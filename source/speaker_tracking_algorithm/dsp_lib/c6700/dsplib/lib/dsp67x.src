!<arch>
<filenames>/    0           1     0     0       3682      `

DSPF_sp_autocor.asm/
DSPF_sp_bitrev_cplx.asm/
DSPF_sp_cfftr4_dif.asm/
DSPF_sp_cfftr2_dit.asm/
DSPF_sp_fftSPxSP.asm/
DSPF_sp_ifftSPxSP.asm/
DSPF_sp_icfftr2_dif.asm/
DSPF_sp_fir_cplx.asm/
DSPF_sp_fir_gen.asm/
DSPF_sp_fir_r2.asm/
DSPF_sp_fircirc.asm/
DSPF_sp_biquad.asm/
DSPF_sp_iirlat.asm/
DSPF_sp_convol.asm/
DSPF_sp_dotp_sqr.asm/
DSPF_sp_dotprod.asm/
DSPF_sp_dotp_cplx.asm/
DSPF_sp_maxval.asm/
DSPF_sp_maxidx.asm/
DSPF_sp_minval.asm/
DSPF_sp_vecrecip.asm/
DSPF_sp_vecsum_sq.asm/
DSPF_sp_w_vec.asm/
DSPF_sp_vecmul.asm/
DSPF_sp_mat_mul.asm/
DSPF_sp_mat_trans.asm/
DSPF_sp_mat_mul_cplx.asm/
DSPF_sp_blk_move.asm/
DSPF_blk_eswap16.asm/
DSPF_blk_eswap32.asm/
DSPF_blk_eswap64.asm/
DSPF_fltoq15.asm/
DSPF_sp_minerr.asm/
DSPF_q15tofl.asm/
DSPF_dp_autocor.asm/
DSPF_dp_bitrev_cplx.asm/
DSPF_dp_cfftr4_dif.asm/
DSPF_dp_cfftr2.asm/
DSPF_dp_icfftr2.asm/
DSPF_dp_fir_cplx.asm/
DSPF_dp_fir_gen.asm/
DSPF_dp_fir_r2.asm/
DSPF_dp_fircirc.asm/
DSPF_dp_biquad.asm/
DSPF_dp_iirlat.asm/
DSPF_dp_convol.asm/
DSPF_dp_dotp_sqr.asm/
DSPF_dp_dotprod.asm/
DSPF_dp_dotp_cplx.asm/
DSPF_dp_maxval.asm/
DSPF_dp_maxidx.asm/
DSPF_dp_minval.asm/
DSPF_dp_vecrecip.asm/
DSPF_dp_vecsum_sq.asm/
DSPF_dp_w_vec.asm/
DSPF_dp_vecmul.asm/
DSPF_dp_mat_mul.asm/
DSPF_dp_mat_trans.asm/
DSPF_dp_mat_mul_cplx.asm/
DSPF_dp_blk_move.asm/
DSPF_sp_autocor.h/
DSPF_sp_autocor.h67/
DSPF_sp_bitrev_cplx.h/
DSPF_sp_bitrev_cplx.h67/
DSPF_sp_cfftr4_dif.h/
DSPF_sp_cfftr4_dif.h67/
DSPF_sp_cfftr2_dit.h/
DSPF_sp_cfftr2_dit.h67/
DSPF_sp_fftSPxSP.h/
DSPF_sp_fftSPxSP.h67/
DSPF_sp_ifftSPxSP.h/
DSPF_sp_ifftSPxSP.h67/
DSPF_sp_icfftr2_dif.h/
DSPF_sp_icfftr2_dif.h67/
DSPF_sp_fir_cplx.h/
DSPF_sp_fir_cplx.h67/
DSPF_sp_fir_gen.h/
DSPF_sp_fir_gen.h67/
DSPF_sp_fir_r2.h/
DSPF_sp_fir_r2.h67/
DSPF_sp_fircirc.h/
DSPF_sp_fircirc.h67/
DSPF_sp_biquad.h/
DSPF_sp_biquad.h67/
DSPF_sp_iirlat.h/
DSPF_sp_iirlat.h67/
DSPF_sp_convol.h/
DSPF_sp_convol.h67/
DSPF_sp_dotp_sqr.h/
DSPF_sp_dotp_sqr.h67/
DSPF_sp_dotprod.h/
DSPF_sp_dotprod.h67/
DSPF_sp_dotp_cplx.h/
DSPF_sp_dotp_cplx.h67/
DSPF_sp_maxval.h/
DSPF_sp_maxval.h67/
DSPF_sp_maxidx.h/
DSPF_sp_maxidx.h67/
DSPF_sp_minval.h/
DSPF_sp_minval.h67/
DSPF_sp_vecrecip.h/
DSPF_sp_vecrecip.h67/
DSPF_sp_vecsum_sq.h/
DSPF_sp_vecsum_sq.h67/
DSPF_sp_w_vec.h67/
DSPF_sp_vecmul.h/
DSPF_sp_vecmul.h67/
DSPF_sp_mat_mul.h/
DSPF_sp_mat_mul.h67/
DSPF_sp_mat_trans.h/
DSPF_sp_mat_trans.h67/
DSPF_sp_mat_mul_cplx.h/
DSPF_sp_mat_mul_cplx.h67/
DSPF_sp_blk_move.h/
DSPF_sp_blk_move.h67/
DSPF_blk_eswap16.h/
DSPF_blk_eswap16.h67/
DSPF_blk_eswap32.h/
DSPF_blk_eswap32.h67/
DSPF_blk_eswap64.h/
DSPF_blk_eswap64.h67/
DSPF_fltoq15.h67/
DSPF_sp_minerr.h/
DSPF_sp_minerr.h67/
DSPF_q15tofl.h67/
DSPF_dp_autocor.h/
DSPF_dp_autocor.h67/
DSPF_dp_bitrev_cplx.h/
DSPF_dp_bitrev_cplx.h67/
DSPF_dp_cfftr4_dif.h/
DSPF_dp_cfftr4_dif.h67/
DSPF_dp_cfftr2.h/
DSPF_dp_cfftr2.h67/
DSPF_dp_icfftr2.h/
DSPF_dp_icfftr2.h67/
DSPF_dp_fir_cplx.h/
DSPF_dp_fir_cplx.h67/
DSPF_dp_fir_gen.h/
DSPF_dp_fir_gen.h67/
DSPF_dp_fir_r2.h/
DSPF_dp_fir_r2.h67/
DSPF_dp_fircirc.h/
DSPF_dp_fircirc.h67/
DSPF_dp_biquad.h/
DSPF_dp_biquad.h67/
DSPF_dp_iirlat.h/
DSPF_dp_iirlat.h67/
DSPF_dp_convol.h/
DSPF_dp_convol.h67/
DSPF_dp_dotp_sqr.h/
DSPF_dp_dotp_sqr.h67/
DSPF_dp_dotprod.h/
DSPF_dp_dotprod.h67/
DSPF_dp_dotp_cplx.h/
DSPF_dp_dotp_cplx.h67/
DSPF_dp_maxval.h/
DSPF_dp_maxval.h67/
DSPF_dp_maxidx.h/
DSPF_dp_maxidx.h67/
DSPF_dp_minval.h/
DSPF_dp_minval.h67/
DSPF_dp_vecrecip.h/
DSPF_dp_vecrecip.h67/
DSPF_dp_vecsum_sq.h/
DSPF_dp_vecsum_sq.h67/
DSPF_dp_w_vec.h67/
DSPF_dp_vecmul.h/
DSPF_dp_vecmul.h67/
DSPF_dp_mat_mul.h/
DSPF_dp_mat_mul.h67/
DSPF_dp_mat_trans.h/
DSPF_dp_mat_trans.h67/
DSPF_dp_mat_mul_cplx.h/
DSPF_dp_mat_mul_cplx.h67/
DSPF_dp_blk_move.h/
DSPF_dp_blk_move.h67/
DSPF_sp_lms.asm/1117057335  0     0     0       31576     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_lms -- Single Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       );                                                                  *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       *
*       input signal and a desired input signal, the filter produces an     *
*       output signal, the final coefficient values, and returns the final  *
*       output error signal.                                                *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled six times to allow update of          *
*          six coefficients in the kernel.                                  *
*       2. The outer loop has been unrolled twice to enable use of LDDW     *
*          for loading the input coefficients.                              *
*       3. LDDW instruction is used to load in the coefficients.            *
*       4. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*       5. The outer loop instructions are scheduled in parallel with       *
*          epilog and prolog wherever possible.                             *
*       6. The 'error' term needs to be computed in the outer loop          *
*          before a new iteration of the inner loop can start. As a         *
*          result the prolog cannot be placed in parallel with epilog       *
*          (after the loop kernel).                                         *
*       7. Pushing and popping variables from the stack does not            *
*          really add any overhead except increase stack size. This         *
*          is because the pops and pushes are done in the delay slots       *
*          of the outer loop instructions.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The inner loop counter must be a multiple of 6 and >=6.          *
*       2. Little endianness is assumed.                                    *
*       3. Extraneous loads are allowed in the program.                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions      *
*       may apply.                                                          *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i,j;                                                        *
*                                                                           *
*           float sum, temp, ae;                                            *
*           temp = 0.0f;                                                    *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0.0f;                                                 *
*               ae = adaptrate * error;                                     *
*                                                                           *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   h[j] = h[j] + (ae * temp);                              *
*                   sum += h[j] * x[i+j];                                   *
*                   temp = x[i + j];                                        *
*               }                                                           *
*                                                                           *
*               r[i] = sum;                                                 *
*               error = desired[i] - sum;                                   *
*               temp = x[i];                                                *
*           }                                                               *
*           /* return the final error */                                    *
*           return error;                                                   *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       (nh + 35) nr + 21                                                   *
*       eg. for nh = 36 and nr = 64                                         *
*       cycles = 4565                                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1376 bytes                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_lms
_DSPF_sp_lms:

* ======================================================================== *
* ======================================================================== *

     STW      .D2T1   A15,       *--B15[17]            ; push A15
||   MV       .L1X    B10,       A0                    ; move nr a-side
||   MVC      .S2     CSR,       B1                    ; disable interrupts
||   B        .S1     no_interrupt


     STW      .D2     B1 ,       *+B15[16]             ; push CSR
||   AND      .L2     B1,        -2,      B1           ; reset GIE bit
||   MV       .S1     B15,       A1                    ; create copy of stk ptr

     STW      .D1     A14,       *+A1[1]               ; push A14
||   STW      .D2     B14,       *+B15[2]              ; push B14
||   MVC      .S2     B1,        CSR

     STW      .D1     A13,       *+A1[3]               ; push A13
||   STW      .D2     B13,       *+B15[4]              ; push B13

     STW      .D1     A12,       *+A1[5]               ; push A12
||   STW      .D2     B12,       *+B15[6]              ; push B12

     STW      .D1     A11,       *+A1[7]               ; push A11
||   STW      .D2     B11,       *+B15[8]              ; push B11

no_interrupt:

     STW      .D1     A10,       *A1[9]                ; push A10 (nh)
||   STW      .D2     B10,       *+B15[10]             ; push B10 (nr)
||   SHL      .S1     A0,        2,       A2

     STW      .D2     B3,        *+B15[11]             ; push return address
||   ADD      .L1     A6,        A2,      A6           ; make 'desired' point to the end
||   MV       .S1     A8,        A9
||   STW      .D1     A0,        *A1[15]


     STW      .D1     A8,        *A1[12]               ; save the value of 'adap rate'
||   MV       .S1X    B8,        A4                    ; move adapt rate
||   MV       .L1     A4,        A8                    ; move address of x
||   ADDAW    .D2     B6,        B10,     B6           ; make 'r' point to the end


* ----------------------------------------------------------------------------
* first the initialization instructions
* ----------------------------------------------------------------------------
     MV       .S2    B4,         B14
||   ZERO     .L2    B13                        ; zero to avoid invalid load
||   MV       .L1    A10,        A2
||   STW      .D2    B6,        *B15[13]        ; save the output array ptr 'r'
||   STW      .D1    A6,        *A1[14]         ; save the 'desired' ptr

oloop:

     MPYSP    .M1    A9,         A4,      A9    ;get the value of adapt*error

     ZERO     .S1    A6
||   ZERO     .D1    A7
||   ZERO     .D2    B4
||   ZERO     .S2    B3
||   MV       .L1X   B14,        A3

;----------------------------------------------------------------------------
; inner loop prolog
;----------------------------------------------------------------------------

     LDDW     .D1T1  *A8++,      A13:A12         ; load x1:x0

     NOP

     LDDW     .D2T1  *B14[1],    A15:A14      ; load h3:h2
||   LDDW     .D1T2  *A8++,      B1:B0        ; load x3:x2
||   MPYSP    .M1X    A9,        B13,     A5  ; multiply current a*e with temp=r0
||   MV       .S2X    A9,        B9           ; outer loop instr.

     LDDW     .D2T1  *B14++[3],  A11:A10      ; load h1:h0
||   LDDW     .D1T2  *A8++,      B13:B12      ; load x5:x4

     NOP

     MPYSP    .M1     A9,        A13,     A10 ;multiply current a*e with x1 = r2
||   MPYSP    .M2X    B9,        A12,     B2  ;multiply current a*e with x0 = r1

     LDDW     .D1     *A8++,     A13:A12      ;load x1:x0
||   LDDW     .D2     *-B14[1],  B11:B10      ; load h5:h4

     MPYSP    .M1X    A9,        B1,      A14   ; multiply current a*e with x3 = r4
||   MPYSP    .M2     B9,        B0,      B2    ; multiply current a*e with x2 = r3
||[A2] SUB    .D1     A2,         6,      A2

     ADDSP    .L1     A5,       A10,      A11    ; find out r0 + h0 = sh0
||   MPYSP    .M2     B9,       B12,      B2     ; multiply current a*e with x4 = r5
||   MV       .S2X    A15,      B5               ; save the value of h3 in h3t
||   LDDW     .D2T1   *B14[1],  A15:A14          ; load h3:h2
||   LDDW     .D1T2   *A8++,    B1:B0            ; load x3:x2
||   MPYSP    .M1X    A9,       B13,      A5     ; multiply current a*e with temp=r0
||   MV       .S1     A13,      A15              ; save value of x1 as x1t


     ADDSP    .L2X    B2,       A11,      B7   ; find out r1 + h1  = sh1
||   LDDW     .D2T1   *B14++[3],A11:A10         ; load h1:h0
||   LDDW     .D1T2   *A8++,    B13:B12         ; load x5:x4

     MV       .S1     A12,      A10              ; save the value of x0 in x0t
||   MV       .S2     B1,       B6               ; save the value of x3 in x3t
||   ADDSP    .L1     A10,      A14,      A0      ; find out r2 + h2 = sh2

     MPYSP    .M1     A9,       A13,      A10     ;multiply current a*e with x1 = r2
||   MPYSP    .M2X    B9,       A12,      B2      ;multiply current a*e with x0 = r1
||   ADDSP    .L1X    A14,      B10,      A13     ; add up r4 + h4 = sh4
||   ADDSP    .L2     B2,       B5,       B8    ; add up r3 + h3 = sh3
||   MV       .D2     B13,      B15              ; save the value of x5 in x5t
||[!A2] B     .S1     skip_kernel


     LDDW     .D1T1   *A8++,    A13:A12           ; load x1:x0
||   LDDW     .D2T2   *-B14[1], B11:B10           ; load h5:h4
||   ADDSP    .L2     B2,       B11,      B8      ; add up r5 + h5 = sh5
||   MPYSP    .M1     A11,      A10,      A0      ; multiply sh0 * x0t = p0
||   MV       .S1     A15,      A4                ; save the value of x1t in x1tt
||   MV       .S2     B0,       B11               ; save the value of x2 in x2t

     MPYSP    .M1X    A9,       B1,       A14     ; multiply current a*e with x3 = r4
||   MPYSP    .M2     B9,       B0,       B2      ; multiply current a*e with x2 = r3
||   MV       .S2     B12,      B10               ; save value of x4 in x4t
||   STW      .D2     B7,       *-B14[11]
||   STW      .D1     A11,      *A3++[6]
||[A2] SUB    .S1     A2,       6,        A2

     ADDSP    .L1     A5,       A10,      A11     ; find out r0 + h0 = sh0
||   MPYSP    .M2     B9,       B12,      B2      ; multiply current a*e with x4 = r5
||   MV       .S2X    A15,      B5                ; save the value of h3 in h3t
||   LDDW     .D2T1   *B14[1],  A15:A14           ; load h3:h2
||   LDDW     .D1T2   *A8++,    B1:B0             ; load x3:x2
||   MPYSP    .M1X    A9,       B13,      A5      ; multiply current a*e with temp=r0
||   MV       .S1     A13,      A15               ; save value of x1 as x1t


     ADDSP    .L2X    B2,       A11,      B7      ; find out r1 + h1  = sh1
||   LDDW     .D2T1   *B14++[3],A11:A10           ; load h1:h0
||   LDDW     .D1T2   *A8++,    B13:B12           ; load x5:x4
||   MPYSP    .M1X    A13,      B10,      A10     ; find sh4 * x4t = p4
||   MPYSP    .M2     B8,       B6,       B5      ; find sh3 * x3t = p3
||   MV       .S2     B8,       B2
||   MV       .S1     A0,       A5

     MV       .S1     A12,      A10               ; save the value of x0 in x0t
||   MV       .S2     B1,       B6                ; save the value of x3 in x3t
||   STW      .D2     B2,       *-B14[15]
||   STW      .D1     A13,      *-A3[2]
||   MPYSP    .M2     B8,       B15,      B5      ; multiply sh5 * x5t = p5
||   MPYSP    .M1X    A5,       B11,      A7      ; multiply sh2 * x2t = p2
||   ADDSP    .L1     A10,      A14,      A0      ; find out r2 + h2 = sh2

;=================PIPED LOOP KERNEL=====================

iloop1:

     MPYSP    .M1     A9,       A13,      A10     ; multiply current a*e with x1 = r2
||   MPYSP    .M2X    B9,       A12,      B2      ; multiply current a*e with x0 = r1
||   ADDSP    .L1X    A14,      B10,      A13     ; add up r4 + h4 = sh4
||   ADDSP    .L2     B2,       B5,       B8      ; add up r3 + h3 = sh3
||   MV       .S2     B13,      B15               ; save the value of x5 in x5t
||   STW      .D1     A5,       *-A3[4]
||   STW      .D2     B8,       *-B14[13]
||[A2] B      .S1     iloop1

     LDDW     .D1     *A8++,    A13:A12           ; load x1:x0
||   LDDW     .D2     *-B14[1], B11:B10           ; load h5:h4
||   ADDSP    .L2     B2,       B11,      B8      ; add up r5 + h5 = sh5
||   MPYSP    .M1     A11,      A10,      A0      ; multiply sh0 * x0t = p0
||   MV       .S1     A15,      A4                ; save the value of x1t in x1tt
||   MV       .S2     B0,       B11               ; save the value of x2 in x2t
||   ADDSP    .L1     A0,       A6,       A6
||   MPYSP    .M2X    B7,       A4,       B10

     MPYSP    .M1X    A9,       B1,       A14     ; multiply current a*e with x3 = r4
||   MPYSP    .M2     B9,       B0,       B2      ; multiply current a*e with x2 = r3
||   MV       .S2     B12,      B10               ; save value of x4 in x4t
||   STW      .D2     B7,       *-B14[11]
||   STW      .D1     A11,      *A3++[6]
||   ADDSP    .L1     A10,      A7,       A7
||   ADDSP    .L2     B4,       B5,       B4
||[A2] SUB    .S1     A2,       6,        A2

     ADDSP    .L1     A5,       A10,      A11     ; find out r0 + h0 = sh0
||   MPYSP    .M2     B9,       B12,      B2      ; multiply current a*e with x4 = r5
||   MV       .S2X    A15,      B5                ; save the value of h3 in h3t
||   LDDW     .D2T1   *B14[1],  A15:A14           ; load h3:h2
||   LDDW     .D1T2   *A8++,    B1:B0             ; load x3:x2
||   MPYSP    .M1X    A9,       B13,      A5      ; multiply current a*e with temp=r0
||   ADDSP    .L2     B5,       B3,       B3
||   MV       .S1     A13,      A15               ; save value of x1 as x1t


     ADDSP    .L2X    B2,       A11,      B7      ; find out r1 + h1  = sh1
||   LDDW     .D2T1   *B14++[3],A11:A10           ; load h1:h0
||   LDDW     .D1T2   *A8++,    B13:B12           ; load x5:x4
||   MPYSP    .M1X    A13,      B10,      A10     ; find sh4 * x4t = p4
||   MPYSP    .M2     B8,       B6,       B5      ; find sh3 * x3t = p3
||   MV       .S2     B8,       B2
||   MV       .S1     A0,       A5
||   ADDSP    .L1     A7,       A6,       A6

     MV       .S1     A12,      A10               ; save the value of x0 in x0t
||   MV       .S2     B1,       B6                ; save the value of x3 in x3t
||   STW      .D2     B2,       *-B14[15]
||   STW      .D1     A13,      *-A3[2]
||   MPYSP    .M2     B8,       B15,      B5      ; multiply sh5 * x5t = p5
||   MPYSP    .M1X    A5,       B11,      A7      ; multiply sh2 * x2t = p2
||   ADDSP    .L2     B4,       B10,      B4
||   ADDSP    .L1     A10,      A14,      A0      ; find out r2 + h2 = sh2

       ;==============================================================
skip_kernel:

     STW      .D1     A5,       *-A3[4]
||   STW      .D2     B8,       *-B14[13]
||   MV       .S2X    A1,       B15

     ADDSP    .L1     A0,       A6,       A6
||   MPYSP    .M2X    B7,       A4,       B10
||   LDW      .D1T2   *A1[14],  B8                 ; desired ptr


     ADDSP    .L1     A10,      A7,       A7
||   ADDSP    .L2     B4,       B5,       B4
||   LDW      .D1T2   *A1[13],  B9                 ; load r
||   LDW      .D2T1   *B15[9],  A2                 ; inner loop ctr

     ADDSP    .L2     B5,       B3,       B3
||   LDW      .D2     *B15[15], B2                 ; outer loop ctr


     ADDSP    .L1     A7,       A6,       A6

     ADDSP    .L2     B4,       B10,      B4
     ;==============================================================
     ; now capture the sums received
     ;==============================================================
     ADDSP    .L1     A6,       A7,       A7

     MV       .S2X    A2,       B5
||   ADDSP    .L2     B4,       B3,       B3

     SUBAW    .D2     B14,      B5,       B14
||   SUBAW    .D1     A8,       A2,       A8

     ADDSP    .L1X    A6,       B4,       A6
||   LDW      .D2T1   *-B8[B2], A10                     ; get the 'desired'

     SUB      .S2     B2,       1,        B1            ; check for end of outer loop

     ADDSP    .L2X    A7,       B3,       B3

     SUBAW    .D2     B14,      12,       B14

     SUBAW    .D1     A8,       12,       A8

     MV       .S1X    B14,      A3

     ADDSP    .L2X    A6,       B3,       B6

     LDW      .D1     *A1[12],  A14                    ; load adaptation rate

     LDDW     .D1T2   *A8++,    B13:B12                ; load x1:x0 in advance
||   MVK      .S2     2,        B0                     ; prolog collapse predicate


  [!B1] B     .S2     outside                          ; to handle an odd value of outer loop ctr


     SUBSP    .L2X    A10,      B6,       B8           ; get the value of error
||   STW      .D2     B6,       *-B9[B2]               ; r[i] = sum
||   SUB      .S2     B2,       1,        B2
||   MV       .S1     A1,       A10
||   SUBSP    .L1X    A10,      B6,       A7           ; get the value of error

     STW      .D2     B2,       *B15[15]

     ZERO     .S1     A4
||   ZERO     .D1     A6

     ZERO     .S2     B4
||   ZERO     .D2     B3


     MPYSP    .M1X    A14,      B8,       A9
||   MPYSP    .M2X    A14,      B8,       B9
||[B1] MVK    .S1     1,        A1                      ; prolog collapse predicate
||[!B1] MV    .L1     A7,       A4
  ;---------------------------------------------------
     NOP

     LDDW     .D1     *A8++,    A13:A12                  ; load x3:x2

     LDDW     .D2T1   *B14++[3],A15:A14                  ; load h1:h0

     LDDW     .D1T2   *A8++,    B7:B6                    ; load x5:x4
||   MPYSP    .M1X    A9,       B13,      A7             ; multiply current a*e with x1 = r1
||   MPYSP    .M2     B9,       B12,      B6             ; multiply current a*e with x0 = r0

     LDDW     .D2T1   *-B14[2], A15:A14                  ; load h3:h2
||   LDDW     .D1T2   *A8++,    B13:B12                  ; load x7:x6

     NOP

;=================PIPED LOOP KERNEL=====================

top:
     MPYSP    .M1     A9,       A12,      A7             ; multiply current a*e with x2 = r2
||   MPYSP    .M2X    B9,       A13,      B8             ; multiply current a*e with x3 = r3
||   MV       .S2     B13,      B1                       ; save the value of x1
||[!B0] ADDSP .L1     A15,      A6,       A6
||[!B0] ADDSP .L2     B1,       B4,       B4
||[!B0] STW   .D2     B15,      *-B14[14]
||[!B0] STW   .D1     A11,      *-A3[7]
||[A2]  B     .S1     top

     LDDW     .D1     *A8++,    A13:A12                  ; load x3:x2
||   LDDW     .D2     *-B14[1], B11:B10                  ; load h5:h4
||   ADDSP    .L2X    B6,       A14,      B6             ; add r0 + h0 = sh0
||   ADDSP    .L1     A7,       A15,      A7             ; add r1 + h1 = sh1
||   MV       .S2     B7,       B5
||   MPYSP    .M1X    A11,      B2,       A0             ; mult sh5 * x6 = p5
||   MPYSP    .M2     B15,      B5,       B15            ; mult sh4 * x4 = p4


     LDDW     .D2T1   *B14++[3],A15:A14                  ; load h1:h0
||   ADDSP    .L1X    A0,       B11,      A11            ; add r5 + h5 = sh5
||   ADDSP    .L2     B15,      B10,      B15            ; add r4 + h4 = sh4
||[!A1] STW   .D1T2   B13,      *-A3[3]
||   MV       .S1     A13,      A5
||   MPYSP    .M1     A7,       A5,       A15            ; multiply sh2 * x3t = p2
||   MPYSP    .M2     B13,      B8,       B1             ; multiply sh3 * s4t = p3
||   MV       .S2     B12,      B2

     LDDW     .D1T2   *A8++,    B7:B6                    ; load x5:x4
||   MPYSP    .M1X    A9,       B13,      A7             ; multiply current a*e with x1 = r1
||   MPYSP    .M2     B9,       B12,      B6             ; multiply current a*e with x0 = r0
||[!A1] ADDSP .L1     A13,      A6,       A6
||[!A1] ADDSP .L2     B15,      B4,       B4
||[!A1] STW   .D2T1   A7,       *-B14[16]
||   SHR      .S1     A1,       1,        A1

     LDDW     .D2T1   *-B14[2], A15:A14                  ; load h3:h2
||   LDDW     .D1T2   *A8++,    B13:B12                  ; load x7:x6
||   ADDSP    .L1     A7,       A14,      A7             ; add up r2 + h2 = sh2
||   ADDSP    .L2X    B8,       A15,      B13            ; add up r3 + h3 = sh3
||   MPYSP    .M1X    A9,       B7,       A0             ; multiply current a*e with x5 = r5
||   MPYSP    .M2     B9,       B6,       B15            ; multiply current a*e with x4 = r4
||   MV       .S2     B6,       B8                       ; save the value of x4 in x4t
||[!A2] MVK   .S1     1,        A1

  [!A1] STW   .D1T2   B6,       *A3++[6]                 ; store sh0
||[!A1] STW   .D2T1   A7,       *-B14[11]                ; store sh1
||   MPYSP    .M2     B6,       B1,       B15            ; mult sh0 * x1t = p0
||   MPYSP    .M1     A7,       A12,      A13            ; mult sh1 * x2 = p1
||[!B0] ADDSP .L1     A0,       A4,       A4
||[!B0] ADDSP .L2     B15,      B3,       B3
||   SHR      .S2     B0,       1,        B0
||[A2]  SUB   .S1     A2,       6,        A2

;============================================================================
     ADDSP    .L1     A15,      A6,       A6
||   ADDSP    .L2     B1,       B4,       B4
||   STW      .D2     B15,      *-B14[14]
||   STW      .D1     A11,      *-A3[1]

     MPYSP    .M1X    A11,      B2,       A0      ; mult sh5 * x6 = p5
||   MPYSP    .M2     B15,      B5,       B15     ; mult sh4 * x4 = p4
||   LDW      .D1T2   *A10[14], B8

     ADDSP    .L1X    A6,       B4,       A6
||   LDW      .D1T2   *A10[15], B2

     LDW      .D1T2   *A10[13], B9

     ADDSP    .L1X    A6,       B4,       A15
||   LDW      .D1     *A10[9],  A2

     ADDSP    .L1     A0,       A4,       A4
||   ADDSP    .L2     B15,      B3,       B3

     NOP

     LDW      .D2T1   *-B8[B2], A3                ; get desired[i]

     ADDSP    .L1     A6,       A15,      A15

     ADDSP    .L2X    A4,       B3,       B3

     SUBAW    .D1     A8,       A2,       A8      ; reset the 'x' pointer
||   MV       .S2X    A2,       B6

     SUB      .S2     B2,       1,        B2

     STW      .D1T2   B2,       *A10[15]
||   ADD      .S2     B2,       1,        B10


     ADDSP    .L1X    A15,      B3,       A4
||   LDW      .D1     *A10[12], A9                  ; load adaptation rate for the next loop
||   MV       .S1     A10,      A1
||   MV       .S2X    A10,      B15

     SUBAW    .D2     B14,      B6,       B14       ; bring back the h ptr

     SUBAW    .D1     A8,       13,       A8        ; advance x by 1 word
||[B2]  B     .S1     oloop

     SUBAW    .D2     B14,      12,       B14

     STW      .D2T1   A4,       *-B9[B10]           ; r[i] = sum
||   LDW      .D1T2   *A8++,    B13
||   SUBSP    .L1     A3,       A4,       A4

outside:

  [!B2] LDW   .D1     *+A1[11],  B3                    ;pop return address
     NOP              2
;=============== outer loop branch occurs here ===========

     LDW      .D1     *+A1[0],   A15                   ; pop A15
||   MV       .S2X    A1,        B15                   ; restore stk ptr

     LDW      .D1     *+A1[1],   A14                   ; pop A14
||   LDW      .D2     *+B15[2],  B14                   ; pop B14

     LDW      .D1     *+A1[3],   A13                   ; pop A13
||   LDW      .D2     *+B15[4],  B13                   ; pop B13

     LDW      .D1     *+A1[5],   A12                   ; pop A12
||   LDW      .D2     *+B15[6],  B12                   ; pop B12

     LDW      .D1     *+A1[7],   A11                   ; pop A11
||   LDW      .D2     *+B15[8],  B11                   ; pop B11

     B        .S2     B3
||   LDW      .D2T2   *B15[16],  B1

     LDW      .D1     *A1[9],    A10                   ; pop A10 (nh)
||   LDW      .D2     *+B15[10], B10                   ; pop B10 (nr)

     ADDAW    .D2     B15,       17,      B15          ; remove space from stack

     NOP              2

     MVC      .S2     B1,        CSR

                .end

* ======================================================================== *
*  End of file: DSPF_sp_lms.asm                                                 *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_autocor/1117057336  1     0     0       20656     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_autocor -- Single Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                    * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        void DSPF_sp_autocor                                                    * 
*                      (                                                    * 
*                          float       *  restrict r,                       * 
*                          const short *  restrict x,                       * 
*                          int            nx,                               * 
*                          int            nr                                * 
*                      )                                                    * 
*             r  = pointer to output array of autocorrelation of length nr  * 
*             x  = pointer to input array of length nx+nr. Input data must  * 
*                  be padded with nr consecutive zeros at the beginning.    * 
*             nx = Length of Autocorrelation vector.                        * 
*             nr = Length of lags.                                          * 
*                                                                           * 
*                                                                           * 
*  DESCRIPTION                                                              * 
*        This routine performs the autocorrelation of the input array inp.  * 
*        It is assumed that the length of the input array, x, is a multiple * 
*        of 2 and the length of the output array, r, is a multiple of 4.    * 
*        The assembly routine computes 4 output samples at a time.          * 
*                                                                           * 
*        It is assumed that input vector x is padded with nr no of zeros in * 
*        the beginning.                                                     * 
*                                                                           * 
*        x is to be aligned on a double word boundary.                      * 
*                                                                           * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*        The inner loop is unrolled twice and the outer loop is unrolled    * 
*        four times.                                                        * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*        1. nx is a multiple of 2 and greater than or equal to 4.           * 
*        2. nr is a multiple of 4 and greater than or equal to 4.           * 
*        3. nx is greater than or equal to nr                               * 
*        4. x  is double word aligned.                                      * 
*                                                                           * 
*  C CODE                                                                   * 
*                                                                           * 
*        void DSPF_sp_autocor(float * r, float * x, int nx, int nr)              * 
*             {                                                             * 
*                                                                           * 
*                       int i,k;                                            * 
*                       float sum;                                          * 
*                       for (i = 0; i < nr; i++)                            * 
*                       {                                                   * 
*                           sum = 0;                                        * 
*                           for (k = nr; k < nx+nr; k++)                    * 
*                           {                                               * 
*                               sum += x[k] * x[k-i];                       * 
*                           }                                               * 
*                           r[i] = sum ;                                    * 
*                       }                                                   * 
*             }                                                             * 
*                                                                           * 
*        This is the C equivalent of the assembly code.  Note that          * 
*        the assembly code is hand optimized and restrictions may apply.    * 
*                                                                           * 
*  NOTES                                                                    * 
*  CYCLES                                                                   * 
*        (nx/2) * nr + (nr/2) * 5 + 10 - (nr * nr)/4 + nr                   * 
*        For nx=64 and nr=64, cycles=1258                                   * 
*        For nx=60 and nr=32, cycles=890                                    * 
*                                                                           * 
*  CODESIZE                                                                 * 
*        512 bytes                                                          * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_autocor
_DSPF_sp_autocor:

* ======================================================================== *
* ======================================================================== *
* ====================== SYMBOLIC REGISTER ASSIGNMENTS =================== *

        .asg    B15,        B_SP           ; stack pointer
        .asg    B11,        B_CSR_store    ; Reg. saving CSR
        .asg    B1,         B_CSR_no_gie   ; Reg. for disabling GIE
        .asg    A3,         A_x            ; x pointer
        .asg    A3,         A_xk_ptr_temp  ; x+k pointer
        .asg    B3,         ret_addr       ; Return address
        .asg    B4,         B_x            ; x pointer
        .asg    B4,         B_xki_ptr_temp ; x+k-i pointer
        .asg    B7,         B_xki_ptr      ; x+k-i pointer
        .asg    A7,         A_xki_ptr      ; x+k-i pointer
        .asg    A0,         A_xk_ptr       ; x+k pointer
        .asg    A6,         A_nx           ; Length of autocorrelation
        .asg    A6,         A_nr_temp      ; Number of lags
        .asg    B6,         B_nr           ; Number of lags
        .asg    B6,         B_nx_temp      ; Length of autocorrelation
        .asg    B6,         B_icntr_temp   ; Inner loop counter
        .asg    A4,         A_r            ; r pointer
        .asg    B2,         B_r            ; r pointer
        .asg    A2,         A_icntr        ; Inner loop counter
        .asg    A1,         A_ocntr        ; Outer loop counter
        .asg    B2,         B_lcntr        ; Counter for checking extraneous loads
        .asg    A9,         A_x_k_1        ; x[k+1]
        .asg    A8,         A_x_k          ; x[k]
        .asg    B1,         B_x_k_i_1      ; x[k-i-1]
        .asg    B0,         B_x_k_i_2      ; x[k-i-2]
        .asg    B9,         B_x_k_i_p1     ; x[k-i+1]
        .asg    B8,         B_x_k_i        ; x[k-i]
        .asg    B7,         B_x_k_i_3      ; x[k-i-3]
        .asg    A5,         A_prod1
        .asg    A5,         A_prod2
        .asg    A5,         A_prod3
        .asg    A5,         A_prod4
        .asg    B5,         B_prod5
        .asg    B5,         B_prod6
        .asg    B5,         B_prod7
        .asg    B5,         B_prod8
        .asg    A6,         A_sum1
        .asg    A6,         A_sum2
        .asg    A6,         A_sum3
        .asg    A6,         A_sum4    
        .asg    B10,        B_sum5    
        .asg    B10,        B_sum6    
        .asg    B10,        B_sum7    
        .asg    B10,        B_sum8 
           
                
; BEGIN BENCHMARK TIMING

           STW   .D2T2 B_CSR_store,     *B_SP--[2]                         ; push B11
||         MV    .L1X  B_x,             A_x                                ; temp = x
||         MVC   .S2   CSR,             B_CSR_store                        ; save CSR
  
           ADDAW .D2   B_x,             B_nr,               B_xki_ptr      ; xki_ptr=x+nr
||         AND   .S2   B_CSR_store,     -2,                 B_CSR_no_gie   ; Disable GIE
||         MV    .L1X  B_nr,            A_nr_temp                          ; A_nr_temp=nr
||         MV    .L2X  A_nx,            B_nx_temp                          ; A_nr_temp=nx

;*-----------------------------------------------------------------------------*

           LDDW  .D2T2 *-B7[1],         B_x_k_i_1:B_x_k_i_2                ; load x[k-i-1]:x[k-i-2]
||         SUB   .L2   B_xki_ptr,       8,                  B_xki_ptr_temp ; xki_ptr_temp = x+nr-2
||         MVC   .S2   B_CSR_no_gie,    CSR                                ; Disable Interrupts 
||         ADDAD .D1   A_x,             A6,                 A_xk_ptr       ; xk_ptr = x+2*nr
||         MV    .L1X  B_xki_ptr,       A_xki_ptr                          ; get xki_ptr 

           LDDW  .D1   *--A_xk_ptr[2],  A_x_k_1:A_x_k                      ; load x[k+1]:x[k]

           LDW   .D2T2 *-B_xki_ptr(12), B_x_k_i_3                          ; load x[k-i-3]
||         SUB   .L1       A_nr_temp,4, A_ocntr                            ; ocntr = nr - 4
||         ADDAW .D1    A_r,            A_nr_temp,          A_r            ; store_ptr = r+nr

           LDDW  .D1T2  *A_xki_ptr,     B_x_k_i_p1:B_x_k_i                 ; x[k-i+1]:x[k-i]
||         SUB   .S1    A_xk_ptr,       16,                 A_xk_ptr_temp  ; xk_ptr_temp=x+2*nr-4 
||         ADD   .L1    A_xk_ptr,       8,                  A_xk_ptr       ; xk_ptr += 2    

           LDDW  .D1T2  *A_xki_ptr++,   B_x_k_i_1:B_x_k_i_2                ; load x[k-i-1]:x[k-i-2]
||         SUB   .L1X   B_nx_temp,      A_nr_temp ,         A_icntr        ; icntr = nx-nr
||         SUB   .L2X   B_nx_temp,      A_nr_temp ,         B_icntr_temp   ; icntr_temp = nx-nr

           LDDW  .D1    *A_xk_ptr++,    A_x_k_1:A_x_k                      ; load x[k+1]:x[k]
||         STW   .D2    B_sum5,         *+B_SP[1]                          ; push B10

           LDW   .D1T2  *-A_xki_ptr(12),B_x_k_i_3                          ; load x[k-i-3]
||         MPYSP .M1X   A_x_k,          B_x_k_i_2,          A_prod3        ; prod3 = x[k] * x[k-i-2]
||         MPYSP .M2X   A_x_k_1,        B_x_k_i_1,          B_prod7        ; prod7 = x[k+1] * x[k-i-1]

           LDDW  .D1T2  *A_xki_ptr,     B_x_k_i_p1:B_x_k_i                 ; load x[k-i+1]:x[k-i]
||         MPYSP .M1X   A_x_k,          B_x_k_i_3,          A_prod4        ; prod4 = x[k] * x[k-i-3]
||         MPYSP .M2X   A_x_k_1,        B_x_k_i_2,          B_prod8        ; prod8 = x[k+1] * x[k-i-2]
||         SHRU  .S2    B_icntr_temp,   1,                  B_lcntr        ; lcntr = icntr_temp/2

LOOP1:      ; OUTER LOOP

  [B_lcntr]LDDW  .D1T2  *A_xki_ptr++,   B_x_k_i_1:B_x_k_i_2                ; load x[k-i-1]:x[k-i-2]
||         MPYSP .M1X   A_x_k,          B_x_k_i_1,          A_prod2        ; prod2 = x[k] * x[k-i-1]
||         MPYSP .M2X   A_x_k_1,        B_x_k_i,            B_prod6        ; prod6 = x[k+1] * x[k-i]
||         B     .S2    LOOP2                        ; Branch to inner loop


  [B_lcntr]LDDW  .D1    *A_xk_ptr++,    A_x_k_1:A_x_k                      ; load x[k+1]:x[k]
||         MPYSP .M1X   A_x_k,          B_x_k_i,            A_prod1        ; prod1 = x[k] * x[k-i]
||         MPYSP .M2X   A_x_k_1,        B_x_k_i_p1,         B_prod5        ; prod5 = x[k-1] * x[k-i+1]
||         ZERO  .L1    A_sum1                                             ; sum1=sum2=sum3=sum4=0 
||         ZERO  .L2    B_sum5                                             ; sum5=sum6=sum7=sum8=0

;*-----------------------------------------------------------------*

LOOP2:                                          

;*-----------------------------------------------------------------*
;*********************** PIPED LOOP KERNEL *************************
;*-----------------------------------------------------------------*

  [B_lcntr]LDW   .D1T2  *-A_xki_ptr(12),B_x_k_i_3                          ; load x[k-i-3]
||         MPYSP .M1X   A_x_k,          B_x_k_i_2,          A_prod3        ; prod3 = x[k] * x[k-i-2]
||         MPYSP .M2X   A_x_k_1,        B_x_k_i_1,          B_prod7        ; prod7 = x[k+1] * x[k-i-1]
||         ADDSP .L1    A_sum3,         A_prod3,            A_sum3         ; sum3 = sum3 + prod3
||         ADDSP .L2    B_sum7,         B_prod7,            B_sum7         ; sum7 = sum7 + prod7

  [B_lcntr]LDDW  .D1T2  *A_xki_ptr,     B_x_k_i_p1:B_x_k_i                 ; load x[k-i+1]:x[k-i]
||         MPYSP .M1X   A_x_k,          B_x_k_i_3,          A_prod4        ; prod4 = x[k] * x[k-i-3]
||         MPYSP .M2X   A_x_k_1,        B_x_k_i_2,          B_prod8        ; prod8 = x[k+1] * x[k-i-2]
||         ADDSP .L1    A_sum4,         A_prod4,            A_sum4         ; sum4 = sum4 + prod4
||         ADDSP .L2    B_sum8,         B_prod8,            B_sum8         ; sum8 = sum8 + prod8
||[B_lcntr]SUB   .S2    B_lcntr,        1,B_lcntr                          ; lcntr = lcntr - 1


  [B_lcntr]LDDW  .D1T2  *A_xki_ptr++,   B_x_k_i_1:B_x_k_i_2                ; load x[k-i-1]:x[k-i-2]
||         MPYSP .M1X   A_x_k,          B_x_k_i_1,          A_prod2        ; prod2 = x[k] * x[k-i-1]
||         MPYSP .M2X   A_x_k_1,        B_x_k_i,            B_prod6        ; prod6 = x[k+1] * x[k-i]
||         ADDSP .L1    A_sum2,         A_prod2,            A_sum2         ; sum2 = sum2 + prod2
||         ADDSP .L2    B_sum6,         B_prod6,            B_sum6         ; sum6 = sum6 + prod6
||[A_icntr]SUB   .S1    A_icntr,        2,                  A_icntr        ; icntr = icntr - 2
||[A_icntr]B     .S2    LOOP2                                              ; Branch to inner loop

  [B_lcntr]LDDW  .D1    *A_xk_ptr++,    A_x_k_1:A_x_k                      ; load x[k+1]:x[k]
||         MPYSP .M1X   A_x_k,          B_x_k_i,            A_prod1        ; prod1 = x[k] * x[k-i]
||         MPYSP .M2X   A_x_k_1,        B_x_k_i_p1,         B_prod5        ; prod5 = x[k-1] * x[k-i+1]
||         ADDSP .L1    A_sum1,         A_prod1,            A_sum1         ; sum1 = sum1 + prod1
||         ADDSP .L2    B_sum5,         B_prod5,            B_sum5         ; sum5 = sum2 + prod2

;*-----------------------------------------------------------------------------*
;******************************* LOOP PROLOG ***********************************
;*-----------------------------------------------------------------------------*

           ADDSP .L1    A_sum3,         B_sum7,             A_sum3         ; sum3 = sum3 + sum7
||         MV    .S1    A_xk_ptr_temp,  A_xk_ptr                           ; xk_ptr = xk_ptr_temp
||[A_ocntr]LDDW  .D2    *B_xki_ptr_temp,B_x_k_i_1:B_x_k_i_2                ; load x[k-i-1]:x[k-i-2]
||         SUB   .D1    A_xk_ptr_temp,  16,                 A_xk_ptr_temp  ; xk_ptr_temp -= 4

           ADDSP .L2X   A_sum4,         B_sum8,             B_sum8         ; sum8 = sum4 + sum8
||[A_ocntr]LDDW  .D1    *A_xk_ptr++,    A_x_k_1:A_x_k                      ; load x[k+1]:x[k]
||[A_ocntr]ADD   .S1X   B_xki_ptr_temp, 8,                  A_xki_ptr      ; xki_ptr = xki_ptr_temp + 2

           ADDSP .L1    A_sum2,         B_sum6,             A_sum2         ; sum2 = sum2 + sum6
||[A_ocntr]B     .S2    LOOP1                                              ; Branch to outer loop
||[A_ocntr]LDW   .D1T2  *-A_xki_ptr(12),B_x_k_i_3                          ; load x[k-i-3]

           ADDSP .L1    A_sum1,         B_sum5,             A_sum1         ; sum1 = sum1 + sum5
||         MV    .S2X   A_r,            B_r                                ; get store_ptr
||         SUB   .S1    A_r,            16,                 A_r            ; store_ptr -= 4
||[A_ocntr]LDDW  .D1T2  *A_xki_ptr,     B_x_k_i_p1:B_x_k_i                 ; load x[k-i+1]:x[k-i]

;*

           STW   .D2T1  A_sum3,         *--B_r[2]                          ; store sum3
||[A_ocntr]LDDW  .D1T2  *A_xki_ptr++,   B_x_k_i_1:B_x_k_i_2                ; load x[k-i-1]:x[k-i-2]
||         ADD   .S2    B_icntr_temp,   4,                  B_icntr_temp   ; icntr_temp += 4

           STW   .D2    B_sum8,         *++B_r[1]                          ; store sum8
||[A_ocntr]LDDW  .D1    *A_xk_ptr++,    A_x_k_1:A_x_k                      ; load x[k+1]:x[k]
||[A_ocntr]MV    .S1X   B_icntr_temp,   A_icntr                            ; icntr = icntr_temp

           STW   .D2T1  A_sum2,         *--B_r[2]                          ; store sum2
||[A_ocntr]LDW   .D1T2  *-A_xki_ptr(12),B_x_k_i_3                          ; load x[k-i-3]
||[A_ocntr]MPYSP .M1X   A_x_k,B_x_k_i_2,A_prod3                            ; prod3 = x[k] * x[k-i-2]
||[A_ocntr]MPYSP .M2X   A_x_k_1,        B_x_k_i_1,          B_prod7        ; prod7 = x[k+1] * x[k-i-1]

           STW   .D2T1  A_sum1,         *-B_r[1]                           ; store sum1
||[A_ocntr]SUB   .L1    A_ocntr,        4,                  A_ocntr        ; ocntr -= 4
||[A_ocntr]LDDW  .D1T2  *A_xki_ptr,     B_x_k_i_p1:B_x_k_i                 ; load x[k-i+1]:x[k-i]
||[A_ocntr]MPYSP .M1X   A_x_k,          B_x_k_i_3,          A_prod4        ; prod4 = x[k] * x[k-i-3]
||[A_ocntr]MPYSP .M2X   A_x_k_1,        B_x_k_i_2,          B_prod8        ; prod8 = x[k+1] * x[k-i-2]
||[A_ocntr]SHRU  .S2    B_icntr_temp,   1,                  B_lcntr        ; lcntr = icntr_temp/2

;**
; BRANCH TO OUTER LOOP OCCURS
; END OF BENCHMARK TIMING
;*------------------------------------------------------------------*

           B     .S2    ret_addr                                           ; Return to the caller
||         LDW   .D2    *+B_SP[1],      B_sum5                             ; pop B10
           LDW   .D2    *++B_SP[2],     B_CSR_store                        ; pop B11
||         MVC   .S2    B_CSR_store,    CSR                                ; Enable Interrupts
           NOP          4

; BRANCH TO CALLING FUNCTION OCCURS

                .end

* ======================================================================== *
*  End of file: DSPF_sp_autocor.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_bitrev_/1117057337  22    0     0       26456     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_bitrev_cplx -- Bit reversal for Single Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*                                                                           * 
*   USAGE                                                                   * 
*                                                                           * 
*      This routine is C Callable and can be called as:                     * 
*                                                                           * 
*      void bitrev_cplx(double *x, short *index, int nx);                   * 
*                                                                           * 
*      x[nx]  : Complex input array to be bit-reversed.                     * 
*               Contains 2*nx floats                                        * 
*      index[]: Array of size ~sqrt(nx) created by the routine              * 
*               bitrev_index to allow the fast implementation of the        * 
*               bit-reversal.                                               * 
*      nx     : Number of elements in array x[]. Must be power of 2.        * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*      This routine performs the bit-reversal of the input array x[],       * 
*      where x[] is an integer array of length nx containing 16-bit         * 
*      complex pairs of data.  This routine requires the index array        * 
*      provided by the program below.  This index should be generated at    * 
*      compile time not by the DSP.                                         * 
*                                                                           * 
*      TI retains all rights, title and interest in this code and only      * 
*      authorizes the use of the bit-reversal code and related table        * 
*      generation code with TMS320-family DSPs manufactured by TI.          * 
*                                                                           * 
*      /* ----------------------------------------------------------- */    * 
*      /*  This routine calculates the index for bit reversal of      */    * 
*      /*  an array of length nx.  The length of the index table is   */    * 
*      /*  2^(2*ceil(k/2)) where nx = 2^k.                            */    * 
*      /*                                                             */    * 
*      /*  In other words, the length of the index table is:          */    * 
*      /*      - for even power of radix: sqrt(nx)                    */    * 
*      /*      - for odd  power of radix: sqrt(2*nx)                  */    * 
*      /* ----------------------------------------------------------- */    * 
*      void bitrev_index(short *index, int nx)                              * 
*      {                                                                    * 
*          int   i, j, k, radix = 2;                                        * 
*          short nbits, nbot, ntop, ndiff, n2, raddiv2;                     * 
*                                                                           * 
*          nbits = 0;                                                       * 
*          i = nx;                                                          * 
*          while (i > 1)                                                    * 
*          {                                                                * 
*              i = i >> 1;                                                  * 
*              nbits++;                                                     * 
*          }                                                                * 
*                                                                           * 
*          raddiv2 = radix >> 1;                                            * 
*          nbot    = nbits >> raddiv2;                                      * 
*          nbot    = nbot << raddiv2 - 1;                                   * 
*          ndiff   = nbits & raddiv2;                                       * 
*          ntop    = nbot + ndiff;                                          * 
*          n2      = 1 << ntop;                                             * 
*                                                                           * 
*          index[0] = 0;                                                    * 
*          for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  * 
*          {                                                                * 
*              index[i] = j - 1;                                            * 
*                                                                           * 
*              for (k = n2/radix; k*(radix-1) < j; k /= radix)              * 
*                  j -= k*(radix-1);                                        * 
*                                                                           * 
*              j += k;                                                      * 
*          }                                                                * 
*          index[n2 - 1] = n2 - 1;                                          * 
*      }                                                                    * 
*                                                                           * 
*    C CODE                                                                 * 
*                                                                           * 
*       void DSPF_sp_bitrev_cplx_cn(double* x, short* index, int n)              * 
*       {                                                                   * 
*            int    i;                                                      * 
*        short  i0, i1, i2, i3;                                             * 
*          short  j0, j1, j2, j3;                                           * 
*          double xi0, xi1, xi2, xi3;                                       * 
*          double xj0, xj1, xj2, xj3;                                       * 
*          short  t;                                                        * 
*          int    a, b, ia, ib, ibs;                                        * 
*          int    mask;                                                     * 
*          int    nbits, nbot, ntop, ndiff, n2, halfn;                      * 
*                                                                           * 
*          nbits = 0;                                                       * 
*          i = n;                                                           * 
*          while (i > 1)                                                    * 
*          {                                                                * 
*             i = i >> 1;                                                   * 
*             nbits++;                                                      * 
*          }                                                                * 
*                                                                           * 
*          nbot    = nbits >> 1;                                            * 
*          ndiff   = nbits & 1;                                             * 
*          ntop    = nbot + ndiff;                                          * 
*          n2       = 1 << ntop;                                            * 
*          mask    = n2 - 1;                                                * 
*          halfn   = n >> 1;                                                * 
*                                                                           * 
*          for (i0 = 0; i0 < halfn; i0 += 2)                                * 
*          {                                                                * 
*              b       = i0 & mask;                                         * 
*              a       = i0 >> nbot;                                        * 
*              if (!b) ia = index[a];                                       * 
*              ib      = index[b];                                          * 
*              ibs     = ib << nbot;                                        * 
*                                                                           * 
*              j0      = ibs + ia;                                          * 
*              t       = i0 < j0;                                           * 
*              xi0     = x[i0];                                             * 
*              xj0     = x[j0];                                             * 
*                                                                           * 
*              if (t)                                                       * 
*              {                                                            * 
*               x[i0] = xj0;                                                * 
*               x[j0] = xi0;                                                * 
*              }                                                            * 
*                                                                           * 
*              i1      = i0 + 1;                                            * 
*              j1      = j0 + halfn;                                        * 
*              xi1     = x[i1];                                             * 
*              xj1     = x[j1];                                             * 
*              x[i1] = xj1;                                                 * 
*              x[j1] = xi1;                                                 * 
*                                                                           * 
*              i3      = i1 + halfn;                                        * 
*              j3      = j1 + 1;                                            * 
*              xi3     = x[i3];                                             * 
*              xj3     = x[j3];                                             * 
*              if (t)                                                       * 
*              {                                                            * 
*               x[i3] = xj3;                                                * 
*               x[j3] = xi3;                                                * 
*              }                                                            * 
*            }                                                              * 
*                                                                           * 
*          }                                                                * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*      1. LDDW is used to load in one complex number at a time (both real   * 
*         and the imaginary parts).                                         * 
*      2. There are 12 stores in 10 cycles but all of them are to locations * 
*         already loaded. No use of the write buffer is made.               * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*      1. nx must be a power of 2.                                          * 
*      2. The table from bitrev_index is already created.                   * 
*      3. LITTLE ENDIAN configuration used.                                 * 
*      4. The array x is actually an array of 2*nx floats. It is assumed to * 
*         be double word aligned.                                           * 
*                                                                           * 
*   NOTES                                                                   * 
*                                                                           * 
*      1. If nx <= 4K one can use the char (8-bit) data type for            * 
*         the "index" variable. This would require changing the LDH when    *  
*         loading index values in the assembly routine to LDB. This would   * 
*         further reduce the size of the Index Table by half its size.      * 
*                                                                           * 
*      2. This code is interrupt tolerant, but not interruptible.           * 
*                                                                           * 
*   CYCLES                                                                  * 
*      (5/2)nx + 26                                                         * 
*                                                                           * 
*      e.g. nx = 256, cycles = 666                                          * 
*                                                                           * 
*   CODESIZE                                                                *
*      608 bytes                                                            * 
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_sp_bitrev_cplx
_DSPF_sp_bitrev_cplx:

* =============== SYMBOLIC REGISTER ASSIGNMENTS =========================== *

      .asg    B15,                SP
      .asg    B4,                 index
      .asg    A9,                 bit_index
      .asg    B11,                ib
      .asg    B11,                ibs
      .asg    A8,                 temp
      .asg    A6,                 n
      .asg    A7,                 nbits
      .asg    A7,                 nbot
      .asg    A0,                 ndiff
      .asg    A4,                 x
      .asg    A10,                ax_copy
      .asg    B10,                bx_copy
      .asg    A0,                 ntop
      .asg    A5,                 mask
      .asg    A4,                 i0
      .asg    A14,                i1
      .asg    A14,                i3
      .asg    A15,                halfn
      .asg    B12,                ia
      .asg    B13,                j0
      .asg    A13,                xi12
      .asg    A12,                xi11
      .asg    A1,                 j1
      .asg    A8,                 j1t
      .asg    B0,                 t
      .asg    B13,                j0t      
      .asg    A3,                 xi32
      .asg    A2,                 xi31
      .asg    A0,                 i0t      
      .asg    B9,                 xj02
      .asg    B8,                 xj01
      .asg    B13,                x2
      .asg    A13,                xj12
      .asg    A12,                xj11
      .asg    A8,                 j3
      .asg    B9,                 xj32
      .asg    B8,                 xj31
      .asg    A1,                 bval
      .asg    A13,                xi02
      .asg    A12,                xi01
      .asg    A8,                 a
      .asg    B13,                xj12temp
      .asg    B2,                 cntr 
      .asg    B14,                x3
      .asg    A0,                 x1
      .asg    B7,                 x_advance
      .asg    A8,                 i3t
      .asg    A0,                 x4
      .asg    B8,                 xi32temp
      .asg    A2,                 ttemp
      .asg    B8,                 x4temp
      .asg    B1,                 nbot_copy
      .asg    B6,                 halfnp1
      .asg    B7,                 i3temp
      .asg    A3,                 x3_copy

* ========================================================================== *

       ; get stack space and push registers
       SUBAW  .D2     SP,         11,       SP        
||     B      .S1     NO_INT                          
              
       STW    .D2T1   A15,        *SP[10]             
||     MV     .S1X    SP,         A1                  
||     MVC    .S2     CSR,        B1                  
     

       STW    .D2T1   A10,        *SP[0]              
||     STW    .D1T2   B10,        *A1[1]              
||     AND    .L2     B1,         -2,       B1        
||     MVC    .S2     CSR,        B5                  
       
       STW    .D2T1   A11,        *SP[2]              
||     STW    .D1T2   B11,        *A1[3]              
||     MVC    .S2     B1,         CSR                 
     
       STW    .D2T1   A12,        *SP[4]              
||     STW    .D1T2   B12,        *A1[5]              
     
       STW    .D2T1   A13,        *SP[6]              
||     STW    .D1T2   B13,        *A1[7]              

NO_INT:     

       STW    .D2T1   A14,        *SP[8]              
||     STW    .D1T2   B14,        *A1[9]              
||     MVK    .S1     31,         temp                
       
       
* ========== PIPED LOOP PROLOG ======================================== *
       
       LDHU   .D2T2   *index,     ib                  ; ib = index[bval]     
||     LMBD   .L1     1,          n,        nbits     ; not yet nbits!
||     SHR    .S1     n,          1,        halfn     ; find halfn     
       
       
       LDHU   .D2T2   *index,     ia                  ; ia = index[a]
||     SUB    .L1     temp,       nbits,    nbits     ; nbits = 31 - pos. of leftmost 1
||     MV     .S1X    index,      bit_index           ; copy index ptr
||     ADD    .L2X    halfn,      1,        halfnp1   ; init constant
 
       
       SHR    .S1     nbits,      1,        nbot      ; find nbot
||     AND    .L1     nbits,      1,        ndiff     ; find ndiff
||     MV     .D1     x,          ax_copy             ; preserve for store
||     MV     .S2X    x,          bx_copy             ; preserve for store
       
       
       ADD    .D1     nbot,       ndiff,    ntop      ; find ntop     
||     MVK    .S1     1,          temp                
                   
       LDDW   .D1T1   *ax_copy,   xi02:xi01           ; x[i0]
||     MV     .S2X    nbot,       nbot_copy           ; copy nbot
||     SHL    .S1     temp,       ntop,     mask      ; find mask
||     ZERO   .L1     i0                              
||     MV     .L2     halfnp1,    i3temp              ; i3 = i0 + halfnp1
       
       SHL    .S2     ib,         B1,       ibs       ; ibs = ib << nbot
||     ADD    .S1     i0,         1,        i1        ; i1=i0 + 1
||     SUB    .L1     mask,       1,        mask      ; find mask
||     LDDW   .D2T1   *bx_copy[i3temp],xi32:xi31      ; load x[i3]     
     
     
       ADD    .D2     ibs,        ia,       j0        ; j0 = ibs + ia
||     LDDW   .D1T1   *ax_copy[i1],xi12:xi11          ; load x[i1] 
||     SHR    .S2     halfn,      1,        cntr      ; init cntr
     
       ADD    .L1X    j0,         halfn,    j1        ; j1 = j0 + halfn
||     CMPLT  .L2X    i0,         j0,       t         ; t=i0<j0
||     SHL    .S2     j0,         3,        j0t       ; for store ptr
||     LDDW   .D2T2   *bx_copy[j0],xj02:xj01          ; loas x[j0] 
||     SHL    .S1     i0,         3,        i0t       ; i0t = i0 * 8

       ADD    .S2     bx_copy,    j0t,      x2        ; x2 = x + j0t
||     LDDW   .D1T1   *ax_copy[j1],xj12:xj11          ; load x[j1] 
||     ADD    .S1     j1,         1,        j3        ; j3=j1+1
||     ADD    .L1     i0,         2,        i0        ; incr i0

* ========== PIPED LOOP KERNEL ======================================== *
          
loop:

       AND    .L1     i0,         mask,     bval      ; bval=i0 & mask    
||     SHL    .S1     j1,         3,        j1t       ; j1t = j1 * 8
||[t]  STW    .D2T1   xi01,       *x2++               ; store x[i0] real
||     LDDW   .D1T2   *ax_copy[j3],xj32:xj31          ; load x[j3] 
    
       LDHU   .D1T2   *bit_index[bval],ib             ; ib = index[bval]
||     SHR    .S1     i0,         nbot,     a         ; a=i0 >> nbot
||[t]  STW    .D2T1   xi02,       *x2                 ; store xi0 imag
||     ADD    .L1     ax_copy,    i0t,      x1        ; init store ptr
||     ADD    .S2X    bx_copy,    j1t,      x3        ; init store ptr
    

  [!bval]LDHU   .D1T2   *bit_index[a],ia              ; if(!b)ia=index[a]    
||     STW    .D2T1   xi11,       *x3++               ; store x[i1] real
    

       STW    .D2T1   xi12,       *x3++               ; store x[i1] imag
||[t]  STW    .D1T2   xj01,       *x1++               ; store x[j0] real
||     ADD    .S2X    x1,         8,        x_advance ; init store ptr
||[cntr]SUB    .L2     cntr,       1,        cntr     ; decr cntr 
    

       SHL    .S1     i3,         3,        i3t       ; for store ptr
||[t]  STW    .D1T2   xj02,       *x1++               ; store x[j0] imag
||     STW    .D2T1   xj11,       *x_advance++        ; store xj1 real 
||     MV     .L2X    xj12,       xj12temp            ; copy x[j1] imag
||[cntr]B      .S2     loop                           ; branch  
    

  [cntr]LDDW   .D1T1   *ax_copy[i0],xi02:xi01         ; load x[i0]
||     STW    .D2T2   xj12temp,   *x_advance          ; store x[j1] imag
||     ADD    .S1     ax_copy,    i3t,      x4        ; init store ptr
||     ADD    .L2X    i0,         halfnp1,  i3temp    ; i3=i0+halfnp1
   

  [cntr]LDDW   .D2T1   *bx_copy[i3temp],xi32:xi31     ; load x[i3]      
||     SHL    .S2     ib,         nbot_copy,ibs       ; ibs = ib << nbot
||     ADD    .S1     i0,         1,        i1        ; i1=i0 + 1
||[t]  STW    .D1T2   xj31,       *x4++               ; store x[j3] real
||     MV     .L2X    xi32,       xi32temp            ; copy x[i3] imag
||     MV     .L1X    x3,         x3_copy             ; copy store ptr
    

       ADD    .S2     ibs,        ia,       j0        ;  j0 = ibs + ia
||[cntr]LDDW   .D1T1   *ax_copy[i1],xi12:xi11         ;  load x[i1]
||     ADD    .S1     i1,         halfn,    i3        ;  i3=i1+halfn
||[t]  STW    .D2T2   xi32temp,   *x3[1]              ; store x[i3] imag
||     MV     .L2X    x4,         x4temp              ; move store ptr
||     MPY    .M1X    t,          1,        ttemp     ; delayed copy
   

       ADD    .L1X    j0,         halfn,    j1        ; j1 = j0 + halfn
||     CMPLT  .L2X    i0,         j0,       t         ; t=i0<j0
||     SHL    .S2     j0,         3,        j0t       ; for store ptr
||[cntr]LDDW   .D2T2   *bx_copy[j0],xj02:xj01         ; load x[j0]  
||     SHL    .S1     i0,         3,        i0t       ; for store ptr
||[t]  STW    .D1T1   xi31,       *x3_copy            ; store x[i3] imag
   

       ADD    .L2     bx_copy,    j0t,      x2        ; x2 = x + j0t
||[cntr]LDDW   .D1T1   *ax_copy[j1],xj12:xj11         ; load x[j1]  
||     ADD    .S1     j1,         1,        j3        ; j3=j1+1
||     ADD    .L1     i0,         2,        i0        ; incr i0
||[ttemp]STW    .D2T2   xj32,       *x4temp           ; store x[j3] imag  
 
* ==== END OF PIPED LOOP KERNEL ======================================= *

       ; restore stack and the stack pointer
       
       MV     .S1X    SP,         A1                  
||     LDW    .D2T1   *SP[10],    A15                 
      
       LDW    .D2T1   *SP[0],     A10                 
||     LDW    .D1T2   *A1[1],     B10                 
       
       LDW    .D2T1   *SP[2],     A11                 
||     LDW    .D1T2   *A1[3],     B11                 
     
       LDW    .D2T1   *SP[4],     A12                 
||     LDW    .D1T2   *A1[5],     B12                 
  
     
       LDW    .D2T1   *SP[6],     A13                 
||     LDW    .D1T2   *A1[7],     B13                 
||     B      .S2     B3                              
     
       LDW    .D2T1   *SP[8],     A14                 
||     LDW    .D1T2   *A1[9],     B14                 
      
       ADDAW  .D2     SP,         11,       SP        
        
       ; restore CSR
       MVC    .S2     B5,         CSR                 
    
       NOP            2                               

                .end

* ======================================================================== *
*  End of file: DSPF_sp_bitrev_cplx.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr4_/1117057338  47    0     0       33022     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                 * 
*                                                                           * 
*   This routine is C Callable and can be called as:                        * 
*                                                                         * 
*   void cfftr4_dif(float* x, float* w, short n)                          * 
*                                                                           * 
*   x is pointer to an array holding the input and output floating        * 
*      point array which contains 'n' complex points                      * 
*   w is pointer to an array holding the coefficient floating point       * 
*      array which contains 3*n/4 complex numbers                         * 
*   n is the number of complex points in x                                * 
*                                                                           * 
*   If the routine is not to be used as a C callable function,            * 
*   then you need to initialize values for all of the parameters          * 
*   passed to the function since these are assumed to be in               * 
*   registers as defined by the calling convention of the                 * 
*   compiler, (refer to the TMS320C6x Optimizing C Compiler               * 
*   User's Guide).                                                        * 
*                                                                           * 
*                                                                           * 
*   DESCRIPTION                                                            * 
*                                                                           * 
*   This routine implements the DIF (decimation in frequency)             * 
*   complex radix 4 FFT with digit-reversed output and normal             * 
*   order input.  The number of points, 'n', must be a power              * 
*   of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                 * 
*   in-place routine in the sense that the output is written              * 
*   over the input.  It is not an in-place routine in the                 * 
*   sense that the input is in normal order and the output is             * 
*   in digit-reversed order.                                              * 
*                                                                           * 
*   There must be n complex points (2*n values), and 3*n/4 complex        * 
*   coefficients (3*n/2 values).                                          * 
*                                                                           * 
*   Each real and imaginary input value is interleaved in the             * 
*   'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers           * 
*   are in normal order.  Each real and imaginary output value            * 
*   is interleaved in the 'x' array and the complex numbers are           * 
*   in digit-reversed  order {rx0, ix0, ...}.  The real and               * 
*   imaginary values of the coefficients are interleaved in the           * 
*   'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers         * 
*   are in normal order.                                                  * 
*                                                                           * 
*   Note that the imaginary coefficients are negated                      * 
*   {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than         * 
*   {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                     * 
*   where d = 2*PI/n.  The value of w(n,k) is usually written             * 
*   w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).              * 
*                                                                           * 
*   The routine can be used to implement an inverse FFT by                * 
*   performing the complex conjugate on the input complex numbers         * 
*   (negating the imaginary value), and dividing the result by n.         * 
*   Another method to use the FFT to perform an inverse FFT, is to        * 
*   swap the real and imaginary values of the input and the result,       * 
*   and divide the result by n.  In either case, the input is still       * 
*   in normal order and the output is still in digit-reversed order.      * 
*                                                                           * 
*   Note that you can not make the radix 4 FFT into an inverse            * 
*   FFT by using the complex conjugate of the coefficients as             * 
*   you can do with the complex radix 2 FFT.                              * 
*                                                                           * 
*   If you label the input locations from 0 to (n-1) (normal order),      * 
*   the digit-reversed locations can be calculated by reversing the       * 
*   order of the bit pairs of the labels.  For example, for a 1024        * 
*   point FFT, the digit reversed location for                            * 
*   617d = 1001101001b = 10 01 10 10 01  is                               * 
*   422d = 0110100110b = 01 10 10 01 10  and visa versa.                  * 
*                                                                           * 
*   TI plans to provide an inverse complex radix 4 FFT with digit-        * 
*   reversed input and normal order output.  With these 2 routines,       * 
*   the digit-reversed output of the FFT can be the input to the          * 
*   inverse FFT without performing digit-reversing on the data.           * 
*                                                                           * 
*   TI also plans to provide a complex digit reverse routine.             * 
*                                                                           * 
*   TECHNIQUES                                                             * 
*                                                                           * 
*   1.  The two inner loops are executed as one loop with                 * 
*       conditional instructions.  The variable 'wcntr' is used           * 
*       to determine when the load pointers and coefficient               * 
*       offsets need to be reset.                                         * 
*   2.  The first 8 cycles of the inner loop prolog are                   * 
*       conditionally scheduled in parallel with the outer loop.          * 
*       This increases the code size by 12 words, but                     * 
*       improves the cycle time.                                          * 
*   3.  A load counter, lcntr, is used so that extraneous loads           * 
*       are not performed.                                                * 
*   4.  If more registers were available, the inner loop could            * 
*       probably be as small as 11 cycles (22 ADDSP/SUBSP                 * 
*       instructions).  The inner loop was extended to 14 cycles          * 
*       to allow more variables to share registers and thus               * 
*       only need 32 registers.                                           * 
*   5.  A local stack is used so that a SP is not needed.                 * 
*   6.  The store variable, scntr, is used to determine when              * 
*       the store pointer needs to be reset.                              * 
*   7.  The variable, n2b, is used as the outer loop counter.             * 
*       We are finished when n2b = 0.                                     * 
*   8.  LDDW instructions are not used so that the real and               * 
*       imaginary values can be loaded to separate register files         * 
*       and so that the load and store pointers can use the               * 
*       same offset, n2.                                                  * 
*   9.  The outer loop resets the inner loop count to 'n' by              * 
*       multiplying 'ie' by 'n2b' which is equivalent to                  * 
*       'ie' multiplied by 'n2' which is always 'n'.  The                 * 
*       product is always the same since the outer loop shifts            * 
*       'n2' to the right by 2 and shifts 'ie' to the left by 2.          * 
*                                                                           * 
*                                                                          * 
*   ASSUMPTIONS                                                            * 
*                                                                           * 
*   1.  Since single assignment of registers is not used,                 * 
*       interrupts should be disabled before this function is             * 
*         called.                                                           * 
*                                                                           * 
*   C CODE                                                                 * 
*   This is the C equivalent for the assembly code.  Note that            * 
*   the assembly code is hand optimized and restrictions may              * 
*   apply.                                                                * 
*                                                                           * 
*   void cfftr4_dif(float* x, float* w, short n)                           * 
*   {                                                                      * 
*       short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;             * 
*       float r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3, si1, si2, si3 * 
*                                                                           * 
*       n2 = n;                                                            * 
*       ie = 1;                                                            * 
*       for(k=n; k>1; k>>=2)                                               * 
*       {                                                                  * 
*          n1 = n2;                                                        * 
*          n2 >>= 2;                                                       * 
*          ia1 = 0;                                                        * 
*          for(j=0; j<n2; j++)                                             * 
*          {                                                               * 
*          ia2 = ia1 + ia1;                                               * 
*                 ia3 = ia1 + ia2;                                          * 
*          co1 = w[ia1*2];                                                * 
*          si1 = w[ia1*2 + 1];                                            * 
*          co2 = w[ia2*2];                                                * 
*          si2 = w[ia2*2 + 1];                                            * 
*          co3 = w[ia3*2];                                                * 
*          si3 = w[ia3*2 + 1];                                            * 
*          ia1 += ie;                                                     * 
*          for(i0=j; i0<n; i0+=n1)                                        * 
*          {                                                              * 
*              i1 = i0 + n2;                                              * 
*              i2 = i1 + n2;                                              * 
*              i3 = i2 + n2;                                              * 
*              r1 = x[i0*2]   + x[i2*2];                                  * 
*              r3 = x[i0*2]   - x[i2*2];                                  * 
*              s1 = x[i0*2+1] + x[i2*2+1];                                * 
*              s3 = x[i0*2+1] - x[i2*2+1];                                * 
*              r2 = x[i1*2]   + x[i3*2];                                  * 
*              r4 = x[i1*2]   - x[i3*2];                                  * 
*              s2 = x[i1*2+1] + x[i3*2+1];                                * 
*              s4 = x[i1*2+1] - x[i3*2+1];                                * 
*              x[i0*2]   = r1 + r2;                                       * 
*              r2        = r1 - r2;                                       * 
*              r1        = r3 - s4;                                       * 
*              r3        = r3 + s4;                                       * 
*              x[i0*2+1] = s1 + s2;                                       * 
*              s2        = s1 - s2;                                       * 
*              s1        = s3 + r4;                                       * 
*              s3        = s3 - r4;                                       * 
*              x[i1*2]   = co1*r3 + si1*s3;                               * 
*              x[i1*2+1] = co1*s3 - si1*r3;                               * 
*              x[i2*2]   = co2*r2 + si2*s2;                               * 
*              x[i2*2+1] = co2*s2 - si2*r2;                               * 
*              x[i3*2]   = co3*r1 + si3*s1;                               * 
*              x[i3*2+1] = co3*s1 - si3*r1;                               * 
*          }                                                              * 
*          }                                                               * 
*          ie <<= 2;                                                       * 
*       }                                                                  * 
*   }                                                                      * 
*                                                                           * 
*   NOTES                                                                   * 
*                                                                           * 
*   CYCLES                                                                  * 
*                                                                           * 
*     (14*n/4 + 23)*log4(n) + 20                                          * 
*                                                                           * 
*   CODESIZE                                                                * 
*       1184 bytes                                                          * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_sp_cfftr4_dif
_DSPF_sp_cfftr4_dif:
       MVC    .S2     IRP,        B0
||     SUBAW  .D2     B15,        20,       B15
||     B      .S1     no_int                          ; disable interrupts       

       STW    .D2     B0,         *B15[0]
||     MVC    .S2     CSR,        B0

       ZERO   .D1     A3                              ; i1 = 0
||     SHR    .S2X    A6,         1,        B0        ; n2b = n >> 1
||     STW    .D2     B0,         *B15[1]
||     AND    .L2     B0,         -1,       B1        ; disable interrupts
||     MV     .S1X    B15,        A9    
       
       MV     .D1     A4,         A5                  ; ptr_y0 = ptr_x0
||     MV     .L1X    B0,         A0                  ; n2 = n2b
||     MV     .L2X    A6,         B2                  ; icntr = n
||     MVC    .S2     B1,         CSR
||     ADD    .D2     B4,         4,        B6        ; ptr_w1 = w + 4

       MV     .L2X    A9,         B9                  ; B9 = A9
||     MVK    .S1     2,          A7                  ; ie = 2
||     SHL    .S2     B2,         3,        B1        ; B1 = B2 << 3
||     STW    .D1     B3,         *A9[2]              ; f push B3

       MV     .L1     A7,         A1                  ; wcntr = ie
||     ADD    .L2X    A4,         4,        B4        ; ptr_x1 = ptr_x0 + 4
||     SUB    .S2     B1,         8,        B7        ; reset = B1 - 8
||     STW    .D1     A10,        *+A9[3]             ; f push A10
||     STW    .D2     B10,        *+B15[4]            ; f push B10

no_int:

       SUB    .L1X    B6,         4,        A6        ; ptr_w0 = ptr_w1 - 4
||     MV     .L2X    A7,         B1                  ; scntr = ie
||     MV     .D2     B4,         B5                  ; ptr_y1 = ptr_x1
||     STW    .D1     A15,        *+A9[5]             ; f push A15
||     MVC    .S2     B15,        IRP                 ; save SP

***************************** Prolog Begins **********************************

       LDW    .D1     *A4++[A0],  A8                  ; load rx0
||     LDW    .D2     *B4++[B0],  B8                  ; load ix0
||     MV     .S1     A9,         A10                 ; f A10 = A9
||     MV     .L2     B15,        B10                 ; f B10 = B9

       LDW    .D1     *A4++[A0],  A15                 ; load rx1
||     LDW    .D2     *B4++[B0],  B15                 ; load ix1

       LDW    .D1     *A4++[A0],  A9                  ; load rx2
||     LDW    .D2     *B4++[B0],  B9                  ; load ix2
||     MV     .L2X    A3,         B3                  ; i1b = i1

       LDW    .D1     *A4++[A0],  B10                 ; load rx3
||     LDW    .D2     *B4++[B0],  A10                 ; load ix3
||     SUB    .S1     A1,         2,        A1        ; if(wcntr) wcntr -= 2

  [!A1]SUB    .S1X    A4,         B7,       A4        ; if(!wcntr) ptr_x0 -= reset
||[!A1]SUB    .S2     B4,         B7,       B4        ; if(!wcntr) ptr_x1 -= reset
||     STW    .D1     A14,        *+A10[6]            ; f push A14
||     STW    .D2     B14,        *+B10[7]            ; f push B14

       STW    .D1     A13,        *+A10[8]            ; f push A13
||     STW    .D2     B13,        *+B10[9]            ; f push B13

       STW    .D1     A12,        *+A10[10]           ; f push A12
||     STW    .D2     B12,        *+B10[11]           ; f push B12

       SUBSP  .L1     A8,         A9,       A9        ; r3 = rx0 - rx2
||     SUBSP  .L2     B8,         B9,       B9        ; s3 = ix0 - ix2
||     STW    .D1     A11,        *+A10[12]           ; f push A11
||     STW    .D2     B11,        *+B10[13]           ; f push B11

oloop:
       SUBSP  .L1X    B15,        A10,      A8        ; s4 = ix1 - ix3
||     SUBSP  .L2X    A15,        B10,      B8        ; r4 = rx1 - rx3

       SUB    .S1X    B2,         4,        A2        ; lcntr = icntr - 4

       ADDSP  .L1     A8,         A9,       A11       ; r1 = rx0 + rx2
||     ADDSP  .L2     B8,         B9,       B11       ; s1 = ix0 + ix2

       LDW    .D1     *++A6[A3],  A10                 ; load co1
||     LDW    .D2     *++B6[B3],  B10                 ; load si1

       LDW    .D1     *++A6[A3],  A13                 ; load co2
||     LDW    .D2     *++B6[B3],  B13                 ; load si2
||     ADDSP  .L1X    A15,        B10,      A12       ; r2 = rx1 + rx3
||     ADDSP  .L2X    B15,        A10,      B12       ; s2 = ix1 + ix3

       LDW    .D1     *+A6[A3],   A12                 ; load co3
||     LDW    .D2     *+B6[B3],   B12                 ; load si3
||     SHL    .S1     A3,         3,        A13       ; tmp = i1 << 3

  [A2] LDW    .D1     *A4++[A0],  A8                  ; @ if(lcntr) load rx0
||[A2] LDW    .D2     *B4++[B0],  B8                  ; @ if(lcntr) load ix0
||     ADDSP  .L1     A9,         A8,       A11       ; r1a = r3 + s4
||     SUBSP  .L2     B9,         B8,       B11       ; s1a = s3 - r4
||     SUB    .S1     A6,         A13,      A6        ; ptr_w0 -= tmp
||     SUB    .S2X    B6,         A13,      B6        ; ptr_w1 -= tmp

  [A2] LDW    .D1     *A4++[A0],  A15                 ; @ if(lcntr) load rx1
||[A2] LDW    .D2     *B4++[B0],  B15                 ; @ if(lcntr) load ix1
||[!A1]ADD    .S1     A3,         A7,       A3        ; if(!wcntr) i1 += ie

  [A2] LDW    .D1     *A4++[A0],  A9                  ; @ if(lcntr) load rx2
||[A2] LDW    .D2     *B4++[B0],  B9                  ; @ if(lcntr) load ix2
||     SUBSP  .L1     A11,        A12,      A11       ; r2a = r1 - r2
||     SUBSP  .L2     B11,        B12,      B11       ; s2a = s1 - s2
||[!A1]MV     .S1     A7,         A1                  ; if(!wcntr) wcntr = ie
||     MV     .S2X    A3,         B3                  ; @ i1b = i1

  [A2] LDW    .D1     *A4++[A0],  B10                 ; @ if(lcntr) load rx3
||[A2] LDW    .D2     *B4++[B0],  A10                 ; @ if(lcntr) load ix3
||     ADDSP  .L1     A11,        A12,      A14       ; ry0 = r1 + r2
||     ADDSP  .L2     B11,        B12,      B14       ; iy0 = s1 + s2
||[A1] SUB    .S1     A1,         2,        A1        ; @ if(wcntr) wcntr -= 2

       SUBSP  .L1     A9,         A8,       A13       ; r3a = r3 - s4
||     ADDSP  .L2     B9,         B8,       B13       ; s3a = s3 + r4
||     MPYSP  .M1     A11,        A10,      A11       ; p0_1 = r1a * co1
||     MPYSP  .M2     B11,        B10,      B11       ; p1_1 = s1a * si1
||[!A1]SUB    .S1X    A4,         B7,       A4        ; @ if(!wcntr) ptr_x0 -= reset
||[!A1]SUB    .S2     B4,         B7,       B4        ; @ if(!wcntr) ptr_x1 -= reset

       MPYSP  .M1X    A11,        B10,      A14       ; p3_1 = r1a * si1
||     MPYSP  .M2X    B11,        A10,      B14       ; p2_1 = s1a * co1

       MPYSP  .M1     A11,        A13,      A11       ; p0_2 = r2a * co2
||     MPYSP  .M2     B11,        B13,      B11       ; p1_2 = s2a * si2

**** Loop Begins ***************************************************************

loop:
       SUBSP  .L1     A8,         A9,       A9        ; @ r3 = rx0 - rx2
||     SUBSP  .L2     B8,         B9,       B9        ; @ s3 = ix0 - ix2
||     MPYSP  .M1X    A11,        B13,      A8        ; p3_2 = r2a * si2
||     MPYSP  .M2X    B11,        A13,      B8        ; p2_2 = s2a * co2
||[!B1]SUB    .S1     A5,         A10,      A5        ; if(!scntr) ptr_y0 -= reset_a
||[!B1]SUB    .S2     B5,         B7,       B5        ; if(!scntr) ptr_y1 -= reset

       SUBSP  .L1X    B15,        A10,      A8        ; @ s4 = ix1 - ix3
||     SUBSP  .L2X    A15,        B10,      B8        ; @ r4 = rx1 - rx3
||     MPYSP  .M1     A13,        A12,      A12       ; p0_3 = r3a * co3
||     MPYSP  .M2     B13,        B12,      B12       ; p1_3 = s3a * si3
||     STW    .D1     A14,        *A5++[A0]           ; store ry0
||     STW    .D2     B14,        *B5++[B0]           ; store iy0

       ADDSP  .L1X    A11,        B11,      A15       ; ry1 = p0_1 + p1_1
||     SUBSP  .L2X    B14,        A14,      B15       ; iy1 = p2_1 - p3_1
||[A2] SUB    .S1     A2,         4,        A2        ; if(lcntr) lcntr -= 4

       ADDSP  .L1     A8,         A9,       A11       ; @ r1 = rx0 + rx2
||     ADDSP  .L2     B8,         B9,       B11       ; @ s1 = ix0 + ix2
||     MPYSP  .M1X    A13,        B12,      A10       ; p3_3 = r3a * si3
||     MPYSP  .M2X    B13,        A12,      B10       ; p2_3 = s3a * co3

       LDW    .D1     *++A6[A3],  A10                 ; @ load co1
||     LDW    .D2     *++B6[B3],  B10                 ; @ load si1
||     ADDSP  .L1X    A11,        B11,      A14       ; ry2 = p0_2 + p1_2
||     SUBSP  .L2X    B8,         A8,       B14       ; iy2 = p2_2 - p3_2

       LDW    .D1     *++A6[A3],  A13                 ; @ load co2
||     LDW    .D2     *++B6[B3],  B13                 ; @ load si2
||     ADDSP  .L1X    A15,        B10,      A12       ; @ r2 = rx1 + rx3
||     ADDSP  .L2X    B15,        A10,      B12       ; @ s2 = ix1 + ix3
||[B2] SUB    .S2     B2,         4,        B2        ; if(icntr) icntr -= 4

       LDW    .D1     *+A6[A3],   A12                 ; @ load co3
||     LDW    .D2     *+B6[B3],   B12                 ; @ load si3
||[!B1]MV     .S2X    A7,         B1                  ; if(!scntr) scntr = ie
||     SHL    .S1     A3,         3,        A13       ; @ tmp = i1 << 3

  [A2] LDW    .D1     *A4++[A0],  A8                  ; @@ if(lcntr) load rx0
||[A2] LDW    .D2     *B4++[B0],  B8                  ; @@ if(lcntr) load ix0
||     ADDSP  .L1     A9,         A8,       A11       ; @ r1a = r3 + s4
||     SUBSP  .L2     B9,         B8,       B11       ; @ s1a = s3 - r4
||     SUB    .S1     A6,         A13,      A6        ; @ ptr_w0 -= tmp
||     SUB    .S2X    B6,         A13,      B6        ; @ ptr_w1 -= tmp

  [A2] LDW    .D1     *A4++[A0],  A15                 ; @@ if(lcntr) load rx1
||[A2] LDW    .D2     *B4++[B0],  B15                 ; @@ if(lcntr) load ix1
||     ADDSP  .L1X    A12,        B12,      A9        ; ry3 = p0_3 + p1_3
||     SUBSP  .L2X    B10,        A10,      B9        ; iy3 = p2_3 - p3_3
||[!A1]ADD    .S1     A3,         A7,       A3        ; @ if(!wcntr) i1 += ie
||[B2] B      .S2     loop                            ; if(icntr) branch to LOOP

  [A2] LDW    .D1     *A4++[A0],  A9                  ; @@ if(lcntr) load rx2
||[A2] LDW    .D2     *B4++[B0],  B9                  ; @@ if(lcntr) load ix2
||     SUBSP  .L1     A11,        A12,      A11       ; @ r2a = r1 - r2
||     SUBSP  .L2     B11,        B12,      B11       ; @ s2a = s1 - s2
||[!A1]MV     .S1     A7,         A1                  ; @ if(!wcntr) wcntr = ie
||     MV     .S2X    A3,         B3                  ; @@ i1b = i1

  [A2] LDW    .D1     *A4++[A0],  B10                 ; @@ if(lcntr) load rx3
||[A2] LDW    .D2     *B4++[B0],  A10                 ; @@ if(lcntr) load ix3
||     ADDSP  .L1     A11,        A12,      A14       ; @ ry0 = r1 + r2
||     ADDSP  .L2     B11,        B12,      B14       ; @ iy0 = s1 + s2
||[A1] SUB    .S1     A1,         2,        A1        ; @@ if(wcntr) wcntr -= 2

       SUBSP  .L1     A9,         A8,       A13       ; @ r3a = r3 - s4
||     ADDSP  .L2     B9,         B8,       B13       ; @ s3a = s3 + r4
||     MPYSP  .M1     A11,        A10,      A11       ; @ p0_1 = r1a * co1
||     MPYSP  .M2     B11,        B10,      B11       ; @ p1_1 = s1a * si1
||     STW    .D1     A15,        *A5++[A0]           ; store ry1
||     STW    .D2     B15,        *B5++[B0]           ; store iy1
||[!A1]SUB    .S1X    A4,         B7,       A4        ; @@ if(!wcntr) ptr_x0 -= reset
||[!A1]SUB    .S2     B4,         B7,       B4        ; @@ if(!wcntr) ptr_x1 -= reset

       MPYSP  .M1X    A11,        B10,      A14       ; @ p3_1 = r1a * si1
||     MPYSP  .M2X    B11,        A10,      B14       ; @ p2_1 = s1a * co1
||     STW    .D1     A14,        *A5++[A0]           ; store ry2
||     STW    .D2     B14,        *B5++[B0]           ; store iy2

       MPYSP  .M1     A11,        A13,      A11       ; @ p0_2 = r2a * co2
||     MPYSP  .M2     B11,        B13,      B11       ; @ p1_2 = s2a * si2
||     STW    .D1     A9,         *A5++[A0]           ; store ry3
||     STW    .D2     B9,         *B5++[B0]           ; store iy3
||[B1] SUB    .S2     B1,         2,        B1        ; if(scntr) scntr -= 2
||     MV     .S1X    B7,         A10                 ; reset_a = reset
**** Loop Ends *****************************************************************
       SHL    .S1     A0,         2,        A3        ; o A3 = n2 << 2
||     SHR    .S2     B0,         2,        B0        ; o n2b >> 2
||     SUB    .D1     A5,         A10,      A5        ; o ptr_y0 -= reset_a
||     SUB    .D2     B5,         B7,       B5        ; o ptr_y1 -= reset

  [B0] SUB    .D1     A5,         A3,       A4        ; o if(n2b)    ptr_x0 = ptr_y0 - A3
||[B0] SUB    .S2X    B5,         A3,       B4        ; o if(n2b)    ptr_x1 = ptr_y1 - A3
||[B0] MV     .S1X    B0,         A0                  ; o if(n2b)    n2 = n2b
||[B0] ZERO   .D2     B3                              ; o if(n2b)    i1b = 0

  [B0] MV     .L1     A4,         A5                  ; o if(n2b)    ptr_y0 = ptr_x0
||[B0] MV     .L2     B4,         B5                  ; o if(n2b)    ptr_y1 = ptr_x1
||[B0] SHL    .S1     A7,         2,        A7        ; o if(n2b)    ie << 2
||[B0] LDW    .D1     *A4++[A0],  A8                  ; p if(n2b)    load rx0
||[B0] LDW    .D2     *B4++[B0],  B8                  ; p if(n2b)    load ix0

  [B0] MV     .S2X    A7,         B1                  ; o if(n2b)    scntr = ie
||[B0] ZERO   .S1     A3                              ; o if(n2b)    i1 = 0
||[B0] MV     .L1     A7,         A1                  ; o if(n2b)    wcntr = ie
||[B0] LDW    .D1     *A4++[A0],  A15                 ; p if(n2b)    load rx1
||[B0] LDW    .D2     *B4++[B0],  B15                 ; p if(n2b)    load ix1

  [B0] MPY    .M2X    A7,         B0,       B2        ; o if(n2b)    icntr = ie * n2b = n
||[B0] B      .S1     oloop                           ; o if(n2b)    branch to OLOOP
||[B0] LDW    .D1     *A4++[A0],  A9                  ; p if(n2b)    load rx2
||[B0] LDW    .D2     *B4++[B0],  B9                  ; p if(n2b)    load ix2
||[!B0]MVC    .S2     IRP,        B15                 ; f if(!n2b)   B6 = ptr_stack

  [B0] LDW    .D1     *A4++[A0],  B10                 ; p if(n2b)    load rx3
||[B0] LDW    .D2     *B4++[B0],  A10                 ; p if(n2b)    load ix3
||[B0] SUB    .S1     A1,         2,        A1        ; p if(wcntr)  wcntr -= 2

  [!B0]LDW    .D2     *B15[2],    B3                  ; f if(!n2b)   pop B3
||[!B0]MV     .L1     B15,        A6                  ; f if(!n2b)   A6 = B6

  [!B0]LDW    .D1     *+A6[5],    A15                 ; f if(!n2b)   pop A15
||[!B0]LDW    .D2     *+B15[1],   B1                  ; f if(!n2b)   pop CSR
||[!A1]SUB    .S1X    A4,         B7,       A4        ; p if(!wcntr) ptr_x0 -= reset
||[!A1]SUB    .S2     B4,         B7,       B4        ; p if(!wcntr) ptr_x1 -= reset

  [!B0]LDW    .D1     *+A6[6],    A14                 ; f if(!n2b)   pop A14
||[!B0]LDW    .D2     *+B15[7],    B14                 ; f if(!n2b)   pop B14

  [B0] SUBSP  .L1     A8,         A9,       A9        ; p if(n2b)    r3 = rx0 - rx2
||[B0] SUBSP  .L2     B8,         B9,       B9        ; p if(n2b)    s3 = ix0 - ix2
||[!B0]LDW    .D1     *+A6[8],    A13                 ; f if(!n2b)   pop A13
||[!B0]LDW    .D2     *+B15[9],    B13                 ; f if(!n2b)   pop B13

* Outer Loop Ends **************************************************************

       LDW    .D1     *+A6[10],    A12                 ; f pop A12
||     LDW    .D2     *+B15[11],   B12                 ; f pop B12

       LDW    .D1     *+A6[12],    A11                 ; f pop A11
||     LDW    .D2     *+B15[13],   B11                 ; f pop B11


       LDW    .D1     *+A6[3],     A10                 ; f pop A10
||     LDW    .D2     *+B15[4],    B10                 ; f pop B10
||     MVC    .S2     B1,          CSR                 ; restore CSR

       LDW    .D2     *B15[0],     B1
||     B      .S2     B3                              ; f return

       NOP            3                                ; f wait for return and LDWs
       
       ADDAW          B15,         20,        B15
       
       MVC    .S2     B1,          IRP

                .end

* ======================================================================== *
*  End of file: DSPF_sp_cfftr4_dif.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr2_/1117057339  71    0     0       32687     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr2_dit -- Single Precision floating point radix-2            *
*      Decimation in Time FFT with complex input                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*           This routine is C-callable and can be called as:                *
*                                                                           *
*           void DSPF_sp_cfftr2_dit(float * x, float * w, short n);              *
*                                                                           *
*           x : Pointer to complex data input                               *
*           w : pointer to complex twiddle factor in Bit reverse order      *
*           N : length of FFT in complex samples, power of 2 such that N>=32*
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs the Decimation-in-Time (DIT) Radix-2 FFT      *
*       of the input array x.                                               *
*       x has N complex floating point numbers arranged as successive       *
*       real and imaginary number pairs. Input array x contains N           *
*       complex points (N*2 elements). The coefficients for the             *
*       FFT are passed to the function in array w which contains            *
*       N/2 complex numbers (N elements) as successive real and             *
*       imaginary number pairs.                                             *
*       The FFT Coefficients w are in N/2 bit-reversed order                *
*       The elements of input array x are in normal order                   *
*       The assembly routine performs 4 output samples (2 real and 2        *
*       imaginary) for a pass through inner loop.                           *
*                                                                           *
*       Note that (bit-reversed) coefficients for higher order FFT (1024    *
*       point) can be used unchanged as coefficients for a lower order      *
*       FFT (512, 256, 128 ... ,2)                                          *
*                                                                           *
*       The routine can be used to implement Inverse-FFT by any ONE of      *
*       the following methods:                                              *
*                                                                           *
*       1.Inputs (x) are replaced by their Complex-conjugate values         *
*         Output values are divided by N                                    *
*       2.FFT Coefficients (w) are replaced by their Complex-conjugates     *
*         Output values are divided by N                                    *
*       3.Swap Real and Imaginary values of input                           *
*       4.Swap Real and Imaginary values of output                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner two loops are combined into one inner loop whose       *
*          loop count is N/2.                                               *
*       2. The prolog has been completely merged with the epilog. But       *
*      this gives rise to a problem which has not been overcome.            *
*      The problem is that the minimum trip count is 32. The safe           *
*      trip count is atleast 16 bound by the size of the epilog.            *
*      In addition because of merging the prolog and the epilog             *
*      a data dependency via memory is caused which forces N to be          *
*      atleast 32.                                                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. N is a integral power of 2 and >=32.                             *
*       2. The FFT Coefficients w are in bit-reversed order                 *
*       3. The elements of input array x are in normal order                *
*       4. The imaginary coefficients of w are negated as {cos(d*0),        *
*          sin(d*0), cos(d*1), sin(d*1) ...} as opposed to the normal       *
*          sequence of {cos(d*0), -sin(d*0), cos(d*1), -sin(d*1) ...}       *
*          where d = 2*PI/N.                                                *
*       5. x and w arrays are double word aligned                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_cfftr2_dit(float* x, float* w, short n)                     *
*       {                                                                   *
*          short n2, ie, ia, i, j, k, m;                                    *
*          float rtemp, itemp, c, s;                                        *
*                                                                           *
*          n2 = n;                                                          *
*          ie = 1;                                                          *
*                                                                           *
*          for(k=n; k > 1; k >>= 1)                                         *
*          {                                                                *
*             n2 >>= 1;                                                     *
*             ia = 0;                                                       *
*             for(j=0; j < ie; j++)                                         *
*             {                                                             *
*                c = w[2*j];                                                *
*                s = w[2*j+1];                                              *
*                for(i=0; i < n2; i++)                                      *
*                {                                                          *
*                   m = ia + n2;                                            *
*                   rtemp     = c * x[2*m]   + s * x[2*m+1];                *
*                   itemp     = c * x[2*m+1] - s * x[2*m];                  *
*                   x[2*m]    = x[2*ia]   - rtemp;                          *
*                   x[2*m+1]  = x[2*ia+1] - itemp;                          *
*                   x[2*ia]   = x[2*ia]   + rtemp;                          *
*                   x[2*ia+1] = x[2*ia+1] + itemp;                          *
*                   ia++;                                                   *
*                }                                                          *
*                ia += n2;                                                  *
*             }                                                             *
*             ie <<= 1;                                                     *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Arrays x (data) and w (coefficients) must reside in                 *
*       different memory banks to avoid memory conflicts.  If Data and      *
*       Coefficents do reside in the same memory bank, add (N/2) + log2(N)  *1
*       cycles to the cycles equation below. The memory bank hits are due t *
*       scheduling of assembly code and also due to extreneous loads        *
*       causing bank hits.                                                  *
*                                                                           *
*       Data and Coefficents must be aligned on an 8 byte boundary.         *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (2*N*log(2)N) + 42                                                  *
*                                                                           *
*       For N=64, Cycles = 810                                              *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*        1248 bytes                                                         *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


                .asg B8, B_x
                .asg A5, A_w
                .asg B7, B_x2mp1
                .asg B6, B_x2m
                .asg A7, A_si
                .asg A6, A_co
                .asg B0, B_lx2mc
                .asg B4, B_8n2
                .asg B13, B_n2
                .asg A13, A_p1
                .asg B11, B_p2
                .asg B3, B_p4
                .asg A15, A_p3
                .asg B2, B_lx2iac
                .asg A3, A_x
                .asg A10, A_8n2
                .asg A12, A_rtemp
                .asg B10, B_itemp
                .asg A1, A_stcnt
                .asg A15, A_x2ias
                .asg B3, B_x2mp1s
                .asg A15, A_x2ms
                .asg B3, B_x2iap1s
                .asg A9, A_x2iap1
                .asg A8, A_x2ia
                .asg B1, B_hafn2
                .asg A2, A_nby2
                .asg A4, A_wbase


        .text
        .global _DSPF_sp_cfftr2_dit
_DSPF_sp_cfftr2_dit:

       ; push all the registers (also CSR, IRP )
       SUBAW  .D2     B15,        16,       B15
||     B      .S1     no_int
||     MVC    .S2     CSR,        B1

       MV     .S1X    B15,        A1
||     STW    .D2T1   A10,        *B15[0]

       STW    .D2T2   B1,         *B15[2]
||     STW    .D1T1   A11,        *A1[1]

       STW    .D2T2   B11,        *B15[4]
||     STW    .D1T1   A12,        *A1[3]
||     AND    .L2     B1,         -2,       B1  ; disable interrupts
||     MVC    .S2     IRP,        B2

       STW    .D2T2   B2,         *B15[6]
||     STW    .D1T1   A13,        *A1[5]
||     MVC    .S2     B1,         CSR

       STW    .D2T2   B13,        *B15[8]
||     STW    .D1T1   A14,        *A1[7]

no_int:

       STW    .D2T2   B14,        *B15[10]
||     STW    .D1T1   A15,        *A1[9]

       STW    .D2T2   B3,         *B15[12]
||     MVC    .S2     B15,        IRP

       ADDAW  .D1     A4,         A6,       A3        ; init x[2m] ptr
||     SHR    .S2X    A6,         1,        B_n2      ; init n2
||     MV     .L1X    B4,         A_w                 ; init w ptr
||     STW    .D2T2   B10,        *B15[13]            ; push b10

       MV     .S2X    A3,         B_x                 ; transfer x[2m] ptr
||     SHL    .S1     A6,         2,        A_8n2     ; keep 8n2 for addr incr
||     SUB    .L2     B_n2,       6,        B15       ; for inner loop cntr
||     STW    .D2T2   B12,        *B15[11]            ; push b12

* ====================== PIPED LOOP PROLOG ======================================= *

       LDDW   .D2     *B_x++,     B_x2mp1:B_x2m       ; load x[2m+1]:x[2m]
||     LDDW   .D1     *A_w++,     A_si:A_co           ; load si:co
||     MV     .S2     B_x,        B5                  ; init x[2m] store ptr

       MV     .L1     A4,         A11                 ; init x[2ia] store ptr
||     SHL    .S2X    A6,         2,        B_8n2     ; copy of 8n2 on b-side
||     MV             B_n2,       B_lx2mc             ; load cntr for x[2m] loads

 [B_lx2mc]SUB .L2     B_lx2mc,    1,        B_lx2mc   ; decr x[2m] load cntr
||     MV     .S1     A4,         A_x                 ; f xx2 = x
||     MV     .S2X    A4,         B14                 ; save base x ptr
||     MV     .D1     A4,         A0                  ; save base x ptr
||     SUB    .L1     A_w,        8,        A_wbase   ; save w base ptr

       MV     .D2     B_n2,       B_lx2iac            ; init x[2ia] load cntr
||     MV     .L1X    B_n2,       A_stcnt             ; init store cntr
||     SHR    .S2     B_n2,       1,        B_hafn2   ; init half of n2

       LDDW   .D2     *B_x++,     B_x2mp1:B_x2m       ; load x[2m+1]:x[2m]

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; p2=co*x[2m+1]

 [B_lx2mc]SUB .S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr
||     MV     .L1X    B15,        A_nby2              ; init loop cntr

       MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; p4=si*x[2m]

       LDDW   .D2     *B_x++,     B_x2mp1:B_x2m       ; load x[2m+1]:x[2m]

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; p2=co*x[2m+1]

  [B_lx2mc]SUB.S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr

       LDDW   .D1     *A_x++,     A_x2iap1:A_x2ia     ; load x[2ia+1]:x[2ia]
||     MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; p4=si*x[2m]
||     ADDSP  .L1     A_p1,       A_p3,     A_rtemp   ; rtemp=p1+p3
||     SUBSP  .L2     B_p2,       B_p4,     B_itemp   ; itemp=p2-p4

       LDDW   .D2     *B_x++,     B_x2mp1:B_x2m       ; load x[2m+1]:x[2m]
||[B_lx2iac]SUB.S2     B_lx2iac,  1,        B_lx2iac  ; decr load cntr

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; p2=co*x[2m+1]

  [B_lx2mc]SUB.S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr

       LDDW   .D1     *A_x++,     A_x2iap1:A_x2ia     ; load x[2ia+1]:x[2ia]
||     MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; p4=si*x[2m]
||     ADDSP  .L1     A_p1,       A_p3,     A_rtemp   ; rtemp=p1+p3
||     SUBSP  .L2     B_p2,       B_p4,     B_itemp   ; itemp=p2-p4

       LDDW   .D2     *B_x++,     B_x2mp1:B_x2m       ; load x[2m+1]:x[2m]
||[B_lx2iac]SUB.S2    B_lx2iac,   1,        B_lx2iac  ; decr load cntr
||     ADDSP  .L1     A_x2ia,     A_rtemp,  A_x2ias   ; x[2ia]=x[2ia]+rtemp
||     SUBSP  .L2X    A_x2iap1,   B_itemp,  B_x2mp1s  ; x[2m+1]=x[2ia+1]-itemp

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; p2=co*x[2m+1]
||     B      .S2     loop

  [B_lx2mc]SUB.S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr
||     SUBSP  .L1     A_x2ia,     A_rtemp,  A_x2ms    ; x[2m]=x[2ia]-rtemp
||     ADDSP  .L2X    A_x2iap1,   B_itemp,  B_x2iap1s ; x[2ia+1]=x[2ia+1]+itemp

* ================== PIPED LOOP KERNEL ======================================== *
loop:

       LDDW   .D1     *A_x++,     A_x2iap1:A_x2ia     ; load x[2ia+1]:x[2ia]
||     MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; p4=si*x[2m]
||[!B_lx2mc]ADD.D2    B_x,        B_8n2,    B_x       ; incr load ptr if required
||     ADDSP  .L1     A_p1,       A_p3,     A_rtemp   ; rtemp=p1+p3
||     SUBSP  .L2     B_p2,       B_p4,     B_itemp   ; itemp=p2-p4
||[!A_stcnt]ADD.S2    B5,         B_8n2,    B5        ; incr store ptr if required
||[!A_stcnt]ADD.S1    A11,        A_8n2,    A11       ; incr store ptr if required

       LDDW   .D2     *B_x++,     B_x2mp1:B_x2m       ; load x[2m+1]:x[2m]
||[!B_lx2mc]LDDW.D1   *A_w++,     A_si:A_co           ; load si:co
||[!B_lx2mc]MPY .M2   1,          B_n2,     B_lx2mc   ; reset load cntr
||[B_lx2iac]SUB .S2   B_lx2iac,   1,        B_lx2iac  ; decr load cntr
||     ADDSP  .L1     A_x2ia,     A_rtemp,  A_x2ias   ; x[2ia]=x[2ia]+rtemp
||     SUBSP  .L2X    A_x2iap1,   B_itemp,  B_x2mp1s  ; x[2m+1]=x[2ia+1]-itemp
||[A_nby2]SUB .S1     A_nby2,     1,        A_nby2    ; decr loop cntr
||[!A_stcnt]MPY.M1X   1,          B_n2,     A_stcnt   ; reset store cntr

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; p2=co*x[2m+1]
||[!B_lx2iac]ADD.S1   A_x,        A_8n2,    A_x       ; incr load ptr if required
||[A_nby2]B   .S2     loop                            ; Branch loop
||     STW    .D1T1   A_x2ias,    *A11++              ; store x[2ia]
||     STW    .D2T2   B_x2mp1s,   *B5[1]              ; store x[2m+1]

  [B_lx2mc]SUB.S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr
||[!B_lx2iac]MPY.M2   1,          B_n2,     B_lx2iac  ; decr load cntr
||     SUBSP  .L1     A_x2ia,     A_rtemp,  A_x2ms    ; x[2m]=x[2ia]-rtemp
||     ADDSP  .L2X    A_x2iap1,   B_itemp,  B_x2iap1s ; x[2ia+1]=x[2ia+1]+itemp
||     STW    .D1     B_x2iap1s,  *A11++              ; store x[2ia+1]
||     STW    .D2     A_x2ms,     *B5++[2]            ; store x[2m]
||[A_stcnt]SUB.S1     A_stcnt,    1,        A_stcnt   ; decr store cntr

* ======================= END OF PIPED LOOP KERNEL ========================== *

       LDDW   .D1     *A_x++,     A_x2iap1:A_x2ia     ; (e) load x[2ia+1]:x[2ia]
||     MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; (e) p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; (e) p4=si*x[2m]
||[!B_lx2mc]ADDAW.D2  B14,        B_n2,     B_x       ; (p) init B_x for outer loop
||     ADDSP  .L1     A_p1,       A_p3,     A_rtemp   ; (e) rtemp=p1+p3
||     SUBSP  .L2     B_p2,       B_p4,     B_itemp   ; (e) itemp=p2-p4
||[!A_stcnt]ADD.S2    B5,         B_8n2,    B5        ; (e) incr store ptr if required
||[!A_stcnt]ADD.S1    A11,        A_8n2,    A11       ; (e) incr store ptr if required

  ; loads are predicated with B_hafn2 so that the last prolog does not
  ; perform invalid loads

  [B_hafn2] LDDW.D2   *B_x++,     B_x2mp1:B_x2m       ; (p) load x[2m+1]:x[2m]
||[!B_lx2mc]LDDW.D1   *A4,        A_si:A_co           ; (p) load si:co
||[!B_lx2mc]MPY .M2   1,          B_hafn2,  B_lx2mc   ; (p) reset load cntr
||[B_lx2iac]SUB .S2   B_lx2iac,   1,        B_lx2iac  ; (p) decr load cntr
||     ADDSP  .L1     A_x2ia,     A_rtemp,  A_x2ias   ; (e) x[2ia]=x[2ia]+rtemp
||     SUBSP  .L2X    A_x2iap1,   B_itemp,  B_x2mp1s  ; (e) x[2m+1]=x[2ia+1]-itemp
||     ADD    .S1     A4,         8,        A_w       ; (p) set w ptr
||[!A_stcnt]MPY.M1X   1,          B_n2,     A_stcnt   ; (p) reset store cntr

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; (e) p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; (e) p2=co*x[2m+1]
||[!B_lx2iac]ADD.S1   A_x,        A_8n2,    A_x       ; (e) incr load ptr if required
||     MV     .S2     B5,         B12                 ; preserve store ptr
||     STW    .D1T1   A_x2ias,    *A11++              ; (e) store x[2ia]
||     STW    .D2T2   B_x2mp1s,   *B5[1]              ; (e) store x[2m+1]

  [B_lx2mc]SUB.S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr
||[!B_lx2iac]MPY.M2   1,          B_n2,     B_lx2iac  ; reset load cntr
||     SUBSP  .L1     A_x2ia,     A_rtemp,  A_x2ms    ; (e) x[2m]=x[2ia]-rtemp
||     ADDSP  .L2X    A_x2iap1,   B_itemp,  B_x2iap1s ; (e) x[2ia+1]=x[2ia+1]+itemp
||     STW    .D1     B_x2iap1s,  *A11++              ; (e) store x[2ia+1]
||     STW    .D2     A_x2ms,     *B12++[2]           ; (e) store x[2m]
||[A_stcnt] SUB.S1    A_stcnt,    1,        A_stcnt   ; (e) decr store cntr
||     MPY    .M1X    B13,       1,        A_nby2     ; is it last outer loop?

       LDDW   .D1     *A_x++,     A_x2iap1:A_x2ia     ; (e) load x[2ia+1]:x[2ia]
||     MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; (e) p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; (e) p4=si*x[2m]
||[!B_lx2mc]ADDAW.D2  B_x,        B_n2,     B_x       ; (p) incr ptr if required
||     ADDSP  .L1     A_p1,       A_p3,     A_rtemp   ; (e) rtemp=p1+p3
||     SUBSP  .L2     B_p2,       B_p4,     B_itemp   ; (e) itemp=p2-p4
||[!A_stcnt]ADD.S2    B12,        B_8n2,    B12       ; (e) incr store ptr if required
||[!A_stcnt]ADD.S1    A11,        A_8n2,    A11       ; (e) incr store ptr if required

  [B_hafn2] LDDW.D2   *B_x++,     B_x2mp1:B_x2m       ; (p) load x[2m+1]:x[2m]
||[!B_lx2mc]LDDW.D1   *A_w++,     A_si:A_co           ; (p) load si:co
||[!B_lx2mc]MPY .M2   1,          B_hafn2,  B_lx2mc   ; (p) reset load cntr
||[B_lx2iac]SUB .S2   B_lx2iac,   1,        B_lx2iac  ; (p) decr load cntr
||     ADDSP  .L1     A_x2ia,     A_rtemp,  A_x2ias   ; (e) x[2ia]=x[2ia]+rtemp
||     SUBSP  .L2X    A_x2iap1,   B_itemp,  B_x2mp1s  ; (e) x[2m+1]=x[2ia+1]-itemp
||[!A_stcnt]MPY.M1X   1,          B_n2,     A_stcnt   ; (e) reset store cntr
||[A_nby2]SUB  .S1    A_nby2,     1,        A_nby2    ; is it last outer loop?

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; (p) p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; (p) p2=co*x[2m+1]
||[!B_lx2iac]ADD.S1   A_x,        A_8n2,    A_x       ; (e) incr load ptr if required
||     MV     .S2     B_8n2,      B9                  ; preserve store ptr
||     STW    .D1T1   A_x2ias,    *A11++              ; (e) store x[2ia]
||     STW    .D2T2   B_x2mp1s,   *B12[1]             ; (e) store x[2m+1]

  [B_lx2mc]SUB.S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr
||[!B_lx2iac]MPY.M2   1,          B_n2,     B_lx2iac  ; reset load cntr
||     SUBSP  .L1     A_x2ia,     A_rtemp,  A_x2ms    ; (e) x[2m]=x[2ia]-rtemp
||     ADDSP  .L2X    A_x2iap1,   B_itemp,  B_x2iap1s ; (e) x[2ia+1]=x[2ia+1]+itemp
||     STW    .D1     B_x2iap1s,  *A11++              ; (e) store x[2ia+1]
||     STW    .D2     A_x2ms,     *B12++[2]           ; (e) store x[2m]
||[A_stcnt] SUB.S1    A_stcnt,    1,        A_stcnt   ; decr store cntr

       LDDW   .D1     *A_x++,     A_x2iap1:A_x2ia     ; (e) load x[2ia+1]:x[2ia]
||     MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; (e) p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; (e) p4=si*x[2m]
||[!B_lx2mc]ADDAW.D2  B_x,        B_n2,     B_x       ; (p) incr ptr if required
||     ADDSP  .L1     A_p1,       A_p3,     A_rtemp   ; (e) rtemp=p1+p3
||     SUBSP  .L2     B_p2,       B_p4,     B_itemp   ; (e) itemp=p2-p4
||[!A_stcnt]ADD.S2    B12,        B9,       B12       ; (e) incr store ptr if required
||[!A_stcnt]ADD.S1    A11,        A_8n2,    A11       ; (e) incr store ptr if required

  [B_hafn2] LDDW.D2   *B_x++,     B_x2mp1:B_x2m       ; (p) load x[2m+1]:x[2m]
||[!B_lx2mc]LDDW.D1   *A_w++,     A_si:A_co           ; (p) load si:co
||[!B_lx2mc]MPY .M2   1,          B_hafn2,  B_lx2mc   ; (p) reset load cntr
||[B_lx2iac]SUB .S2   B_lx2iac,   1,        B_lx2iac  ; (p) decr load cntr
||     ADDSP  .L1     A_x2ia,     A_rtemp,  A_x2ias   ; (e) x[2ia]=x[2ia]+rtemp
||     SUBSP  .L2X    A_x2iap1,   B_itemp,  B_x2mp1s  ; (e) x[2m+1]=x[2ia+1]-itemp
||[!A_stcnt]MPY .M1X  1,          B_n2,     A_stcnt   ; (e) reset store cntr
||     MV             A11,        A14                 ; preserve store ptr

       MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; (p) p2=co*x[2m+1]
||     MV     .S1     A0,         A_x                 ; set the x[2ia] ptr
||     SHR    .S2     B_8n2,      1,        B_8n2     ; set B_8n2 for next
||     STW    .D1T1   A_x2ias,    *A14++              ; (e) store x[2ia]
||     STW    .D2T2   B_x2mp1s,   *B12[1]             ; (e) store x[2m+1]
||     INTSP  .L2     B_hafn2,         B5             ; use L unit in a strange way
||     SUBSP  .L1     A_x2ia,     A_rtemp,  A11       ; (e) x[2m]=x[2ia]-rtemp
||     MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; (p) co*x[2m]

  [B_lx2mc]SUB.S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr
||[!B_lx2iac]MPY.M2   1,          B_hafn2,  B_lx2iac  ; reset load cntr
||     ADDSP  .L2X    A_x2iap1,   B_itemp,  B_x2iap1s ; x[2ia+1]=x[2ia+1]+itemp
||     STW    .D1     B_x2iap1s,  *A14++              ; store x[2ia+1]
||     STW    .D2     A_x2ms,     *B12++[2]           ; store x[2m]
||[A_stcnt]SUB.S1     A_stcnt,    1,        A_stcnt   ; decr store cntr

  [B_hafn2]LDDW.D1    *A_x++,     A_x2iap1:A_x2ia     ; (e) load x[2ia+1]:x[2ia]
||     MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; (p) p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; (p) p4=si*x[2m]
||[!B_lx2mc]ADDAW.D2  B_x,        B_n2,     B_x       ; (p) incr ptr if required
||     ADDSP  .L1     A_p1,       A_p3,     A_rtemp   ; (p) rtemp=p1+p3
||     SUBSP  .L2     B_p2,       B_p4,     B_itemp   ; (p) itemp=p2-p4
||[!A_stcnt]ADD.S2    B12,        B9,       B12       ; (e) incr store ptr if required
||[!A_stcnt]ADD.S1    A14,        A_8n2,    A14       ; (e) incr store ptr if required

  [B_hafn2] LDDW.D2   *B_x++,     B_x2mp1:B_x2m       ; (p) load x[2m+1]:x[2m]
||[!B_lx2mc]LDDW.D1   *A_w++,     A_si:A_co           ; (p) load si:co
||[!B_lx2mc]MPY .M2   1,          B_hafn2,  B_lx2mc   ; (p) reset load cntr
||     ADDSP  .L1     A_x2ia,     A_rtemp,  A_x2ias   ; (p) x[2ia]=x[2ia]-rtemp
||     SUBSP  .L2X    A_x2iap1,   B_itemp,  B_x2mp1s  ; (p) x[2m+1]=x[2ia+1]-itemp
||[B_lx2iac]SUB.S2    B_lx2iac,   1,        B_lx2iac  ; decr load cntr
||[!A_stcnt]SHR.S1    A_8n2,      3,        A_stcnt   ; (e) reset store cntr
||     MPY    .M1X    B_n2,       4,        A15       ; generate incrment

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; p2=co*x[2m+1]
||[A_nby2]B      .S1     loop                         ; Branch next outer loop
||     STW    .D1T1   A_x2ias,    *A14++              ; store x[2ia]
||     STW    .D2T2   B_x2mp1s,   *B12[1]             ; store x[2m+1]
||     SPINT  .L2     B5,         B_n2                ; get B_n2 for next iteration
||     ADD    .S2     B14,        B_8n2,    B5        ; get store ptr
||[A_stcnt]SUB.L1     A_stcnt,    1,        A_stcnt   ; decr store cntr

  [B_lx2mc]SUB.S2     B_lx2mc,    1,        B_lx2mc   ; decr load cntr
||[!B_lx2iac]MPY.M2   1,          B_hafn2,  B_lx2iac  ; reset load cntr
||     SUBSP  .L1     A_x2ia,     A_rtemp,  A_x2ms    ; x[2m]=x[2ia]-rtemp
||     ADDSP  .L2X    A_x2iap1,   B_itemp,  B_x2iap1s ; p itemp3 = t3_1 - itemp1
||     STW    .D1     B_x2iap1s,  *A14++              ; store x[2ia+1]
||     STW    .D2     A11,        *B12++[2]           ; store x[2m]
||[A_nby2]MPY .M1X    B15,        1,        A_nby2    ; set loop counter
||[!B_lx2iac]ADD.S1   A_x,        A15,      A_x       ; incr load ptr

  [B_hafn2] LDDW.D1   *A_x++,     A_x2iap1:A_x2ia     ; (p) load x[2ia+1]:x[2ia]
||     MPYSP  .M1X    A_si,       B_x2mp1,  A_p3      ; (p) p3=si*x[2m+1]
||     MPYSP  .M2X    A_si,       B_x2m,    B_p4      ; (p) p4=si*x[2m]
||[!B_lx2mc]ADDAW.D2  B_x,        B_n2,     B_x       ; (p) incr ptr if required
||     ADDSP  .L1     A_p1,       A_p3,     A_rtemp   ; (p) rtemp=p1+p3
||     SUBSP  .L2     B_p2,       B_p4,     B_itemp   ; (p) itemp=p2-p4
||[!A_stcnt]ADD.S2    B12,        B9,       B12       ; (e) incr store ptr if required
||[!A_stcnt]ADD.S1    A14,        A_8n2,    A14       ; (e) incr store ptr if required

  [B_hafn2] LDDW.D2   *B_x++,     B_x2mp1:B_x2m       ; (p) load x[2m+1]:x[2m]
||[!B_lx2mc]LDDW.D1   *A_w++,     A_si:A_co           ; (p) load si:co
||[!B_lx2mc]MPY .M2   1,          B_hafn2,  B_lx2mc   ; (p) reset load cntr
||[B_lx2iac]SUB .S2   B_lx2iac,   1,        B_lx2iac  ; (p) x[2ia]=x[2ia]-rtemp
||     ADDSP  .L1     A_x2ia,     A_rtemp,  A_x2ias   ; (p) x[2m+1]=x[2ia+1]-itemp
||     SUBSP  .L2X    A_x2iap1,   B_itemp,  B_x2mp1s  ; x[2m+1]=x[2ia+1]-itemp
||     MPY    .M1X    4,          B_n2,     A_8n2     ; set A_8n2
||     MV     .S1     A0,         A11                 ; set load ptr

       MPYSP  .M1X    A_co,       B_x2m,    A_p1      ; p1=co*x[2m]
||     MPYSP  .M2X    A_co,       B_x2mp1,  B_p2      ; p2=co*x[2m+1]
||     SHR    .S2     B_hafn2,    1,        B_hafn2   ; for next outer loop
||     STW    .D1T1   A_x2ias,    *A14++              ; store x[2ia]
||     STW    .D2T2   B_x2mp1s,   *B12[1]             ; store x[2m+1]
||[A_nby2]B      .S1     loop                         ; branch

  [B_lx2mc]SUB .S2    B_lx2mc,    1,        B_lx2mc   ; decr load cntr
||[!B_lx2iac]MPY.M2   1,          B_n2,     B_lx2iac  ; reset load cntr
||     SUBSP  .L1     A_x2ia,     A_rtemp,  A_x2ms    ; x[2m]=x[2ia]-rtemp
||     ADDSP  .L2X    A_x2iap1,   B_itemp,  B_x2iap1s ; x[2ia+1]=x[2ia+1]-itemp
||     STW    .D1     B_x2iap1s,  *A14                ; store x[2ia+1]
||     STW    .D2     A_x2ms,     *B12                ; store x[2m]
||     MPY    .M1     A_stcnt,    0,        A_stcnt   ; reset store count
||[!B_lx2iac]ADD.S1   A_x,        A_8n2,    A_x       ; incr load ptr
****************************************************************************

       MVC    .S2     IRP,        B15

       MV     .S1X    B15,        A1
||     LDW    .D2T2   *B15[12],   B3

       LDW    .D2T1   *B15[0],    A10
||     LDW    .D1T2   *A1[13],    B10

       LDW    .D2T1   *B15[1],    A11
||     LDW    .D1T2   *A1[6],     B2

       LDW    .D2T1   *B15[3],    A12
||     LDW    .D1T2   *A1[2],     B1

       LDW    .D2T1   *B15[5],    A13
||     LDW    .D1T2   *A1[8],     B13

       LDW    .D2T1   *B15[7],    A14
||     LDW    .D1T2   *A1[10],    B14

       LDW    .D2T1   *B15[9],    A15
||     LDW    .D1T2   *A1[4],     B11
||     B      .S2     B3

       MVC    .S2     B2,         IRP
||     LDW    .D1T2   *A1[11],    B12

       NOP            2

       ADDAW          B15,        16,       B15

       MVC    .S2     B1,         CSR

                .end

* ======================================================================== *
*  End of file: DSPF_sp_cfftr2_dit.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fftSPxS/1117057340  95    0     0       57074     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          *
*      forwards FFT with complex input                                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of fft in complex samples, power of 2 such that    *
*                    N >=8 and N<= 16385.                                   *
*       ptr_x  :  Pointer to complex data input.                            *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data.                           *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest fft butterfly used in computation used for       *
*                 decomposing fft into subffts, see notes.                  *
*       offset :  Index in complex samples of sub-fft from start of main    *
*                 fft.                                                      *
*       n_max  :  size of main fft in complex samples.                      *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards fft using a special   *
*       sequece of coefficients generated in the following way:             *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the fft  *
*       producing the frequency domain data in the Y array.                 *
*       As the fft allows every input point to effect every output point    *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main fft of size N to  *
*       be divided into several steps, allowing as much data reuse as       *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           *
*                                                                           *
*       Notice how the 1st fft function is called on the entire 1K data     *
*       set it covers the 1st pass of the fft until the butterfly size is   *
*       256. The following 4 ffts do 256 pt ffts 25% of the size. These     *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the fft the following would be needed :                   *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the fft is calculated by summing these      *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array. In the    *
*       smae way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the FFT, four other calls are required to        *
*       perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 FFTs in         *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the FFT with one function call invocation as shown    *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the fft. This collapses the inner 2 loops in the        *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised FFT uses a redundant sequence of twiddle factors to  *
*          allow a linear access through the data. This linear access       *
*          enables data and instruction level parallelism.                  *
*                                                                           *
*       3. The data produced by the fftSPxSP fft is in normal form, the     *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The fftSPxSP butterfly is bit reversed, i.e. the inner 2 points  *
*          of the butterfly are corssed over, this has the effect of        *
*          making the data come out in bit reversed rather than fftSPxSP    *
*          digit reversed order. This simplifies the last pass of the       *
*          loop. A simple table is used to do the bit reversal out of       *
*          place.                                                           *
*                                                                           *
*              unsigned char brev[64] =                                     *
*              {                                                            *
*                    0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,          *
*                    0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,          *
*                    0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,          *
*                    0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,          *
*                    0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,          *
*                    0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,          *
*                    0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,          *
*                    0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f           *
*              };                                                           *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on double  *
*          word boundares. Real values are stored in even word positions    *
*          and imaginary values in odd positions.                           *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on entry  *
*          to each loop and reanlbed on exit out of the loop.               *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       )                                                                   *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, fft_jmp;                                *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               fft_jmp = stride + (stride>>1);                             *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - fft_jmp);                                  *
*                   if (!predj) x += fft_jmp;                               *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 + xl21;                                       *
*                   yt2 = xl1 + xl20;                                       *
*                   xt2 = xl0 - xl21;                                       *
*                   yt1 = xl1 - xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += fft_jmp;                                       *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of fft */                 *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1472 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_fftSPxSP
_DSPF_sp_fftSPxSP:

* ======================================================================== *
* ======================================================================== *

       SUBAW  .D2    B15,     24      , B15   ; save stack space
       STW    .D2T2  B10,     *B15[1]         ; save b10

       MV     .S1X   B15,     A5              ; copy stack pointer
||     STW    .D2T1  A10,     *B15[6]         ; save a10

       STW    .D2T2  B11,     *B15[2]         ; save b11
||     STW    .D1T1  A11,     *A5[7]          ; save a11

       STW    .D2T2  B12,     *B15[3]         ; save b12
||     STW    .D1T1  A11,     *A5[8]          ; save a11

       STW    .D2T2  B13,     *B15[4]         ; save b13
||     STW    .D1T1  A12,     *A5[9]          ; save a12

       STW    .D2T2  B14,     *B15[5]         ; save b14
||     STW    .D1T1  A13,     *A5[10]         ; save a13
||     MVC    .S2    CSR,     B11             ; get csr

       STW    .D2T1  A14,     *B15[11]        ; store a14
||     STW    .D1T2  B3,      *A5[12]         ; store b3
||     MV     .S1X   B4,      A14             ; move to a_x
||     AND    .L2    B11,     -2,       B12   ; disable interrupt bit

       STW    .D2T1  A15,     *B15[13]        ; save a15
||     STW    .D1T2  B8,      *A5[15]         ; store n_min or radix
||     MV     .S2X   A6,      B14             ; move to b_w2
||     SHR    .S1    A4,      1,        A0    ; get al1

       STW    .D2T2  B4,      *B15[16]        ; store ptr_x
||     STW    .D1T1  A4,      *A5[17]         ; store N
||     SHR    .S2X   A0,      1,        B3    ; get bh2

       STW    .D2T2  B6,      *B15[18]        ; store ptr_y
||     STW    .D1T1  A8,      *A5[19]         ; store brev
||     ADD    .S1X   A0,      B3,       A3    ; get al2
||     MVC    .S2    B12,     CSR             ; disable interrupt

       STW    .D2T1  A10,     *B15[20]        ; store offset
||     STW    .D1T2  B10,     *A5[21]         ; store n_max
||     MVC    .S2    IRP,     B10             ; get irp for storing
||     MV     .S1X   B11,     A11             ; get csr for storing

       STW    .D2T2  B10,     *B15[14]        ; store irp
||     STW    .D1T1  A11,     *A5[22]         ; store original csr
||     ZERO   .S1    A1                       ; j=0
||     MVC    .S2X   A4,      IRP             ; store counter(N) in irp
; end of initialisation

OUT_LOOP:
************************ INNER LOOP PROLOG **********************************

       MV     .S1    A14,     A2              ; move a_x to a_y
||     MV     .S2X   A14,     B2              ; move a_x to b_x

       LDDW   .D2T1  *B2,     A7:A6           ; load x1:x0
||     LDDW   .D1T2  *A14[A3],B7:B6           ; load xl2p1:xl2
||     MV     .S2    B2,      B0              ; move a_x to b_y

       LDDW   .D1T1  *A14[A0],A5:A4           ; load xl1p1:xl1
||     LDDW   .D2T2  *B2[B3], B5:B4           ; load xh2p1:xh2

       NOP

       ADD    .S1    A1,      3,        A1    ; j=j+3

       SUB    .S1    A1,      A3,       A1    ; j=j-fftlmp(al2)
||     ADD    .S2    B14,     0,        B3    ; get initial b_w2

  [!A1]ADDAD  .D1    A14,     A3,       A14   ; a_x=a_x+fftjmp(al2)
||     STW    .D2T1  A14,     *B15[23]        ; store current a_x

       ADDSP  .L1    A6,      A4,       A4    ; axh0=xl1+x0
||     ADDSP  .L2    B4,      B6,       B4    ; bxh20=xh2+xl2

       ADDSP  .L1    A7,      A5,       A5    ; axh1=x1+xl1p1
||     ADDSP  .L2    B5,      B7,       B5    ; bxh21=xh2p1+xl2p1
||     MV     .S2    B3,      B1              ; save b_w in b1

********************** PIPED LOOP KERNEL ***********************************
LOOP:
       SUBSP  .L1    A6,      A4,       A6    ; (1)axl0=x0-xl1
||     SUBSP  .L2    B5,      B7,       B6    ; bxl21=xh2p1-xl2p1
||     SHR    .S2X   A0,      1,        B3    ; bh2=al1/2
||     MV     .S1X   B3,      A6              ; move b_w to a_w
||     MPYSP  .M1    A11,     A9,       A12   ; prod4=xt1*si1
||     MPYSP  .M2    B9,      B11,      B12   ; prod12=si3*xt2
||     ADD    .D1    A14,     8,        A14   ; a_x=a_x+8

       SUBSP  .L1    A7,      A5,       A7    ; (2)axl1=x1-xl1p1
||     SUBSP  .L2    B4,      B6,       B7    ; bxl20=xh2-xl2
||     MV     .S2X   A14,     B2              ; move a_x to b_x
||     ADD    .S1X   A0,      B3,       A3    ; al2=al1+bh2
||     STW    .D2T2  B13,     *B0[1]          ; store xh1pxh21
||[A1] ADD    .D1    A1,      A3,       A1    ; j=j+fftjmp(al2)

       LDDW   .D1T2  *A6[1],  B3:B2           ; (3)load si2:co2
||     STW    .D2T1  A13,     *B0             ; store xh0pxh20
||     ADDSP  .L1X   A12,     B12,      A13   ; sum3=prod5+prod6
||     SUBSP  .L2X   B8,      A8,       B13   ; sum4=prod8+prod7
||     MVC    .S2    IRP,     B8              ; get loop counter to b1

       SUBSP  .L1X   A4,      B4,       A7    ; (4)xt0=axh0-bxh20
||     SUBSP  .L2X   A5,      B5,       B7    ; yt0=axh1-bxh21
||     LDDW   .D1T1  *A6,     A9:A8           ; load si1:co1
||     LDDW   .D2T2  *B1[2],  B9:B8           ; load si3:co3
||     SHL    .S1    A0,      1,        A15   ; al=al1*2
||     SUB    .S2    B8,      4,        B1    ; b1=b1-4

       LDDW   .D2T1  *B2,     A7:A6           ; (5)load x1:x0
||     LDDW   .D1T2  *A14[A3],B7:B6           ; load xl2p1:xl2
||     SUBSP  .L2X   A6,      B6,       B11   ; xt2=axl0-bxl21
||     ADDSP  .L1X   A6,      B6,       A11   ; xt1=axl0+bxl21
||     MVC    .S2    B1,      IRP             ; store updated counter in irp

       LDDW   .D1T1  *A14[A0],A5:A4           ; (6)load xl1p1:xl1
||     LDDW   .D2T2  *B2[B3], B5:B4           ; load xh2p1:xh2
||     SUBSP  .L1X   A7,      B7,       A10   ; yt1=axl1-bxl20
||     ADDSP  .L2X   A7,      B7,       B10   ; yt2=axl1+bxl20
||     SHL    .S2    B3,      1,        B8    ; bl=bh2*2

       ADDSP  .L1    A9,      A11,      A13   ; (7)sum1=prod1+prod2
||     ADDSP  .L2    B9,      B11,      B13   ; sum5=prod9+prod10
||     ADD    .D1    A2,      4,        A11   ; acopy1=a_y+4
||     LDW    .D2T2  *B15[23],B0              ; load 2nd last value of ax
||     SUB    .S2    B1,      4,        B1    ; flag for checking extra loads
||[B1] B      .S1    LOOP                     ; branch to beginning

       ADD    .S1    A1,      3,        A1    ; (8)j=j+3
||     MPYSP  .M1X   B2,      A7,       A12   ; prod5=co2*xt0
||     MPYSP  .M2    B7,      B3,       B12   ; prod6=yt0*si2
||     SHL    .S2X   A1,      3,        B12   ; j*8
||     STW    .D2T1  A13,     *B0[B8]         ; store sum3
||     STW    .D1T2  B13,     *A11[A0]        ; store sum4
||     SUBSP  .L1    A10,     A12,      A13   ; sum2=prod3-prod4
||     SUBSP  .L2    B10,     B12,      B13   ; sum6=prod11-prod12

  [B1] SUB    .S1    A1,      A3,       A1    ; (9)j=j-fftjmp(al2)
||     MPYSP  .M1X   B3,      A7,       A8    ; prod8=si2*xt0
||     MPYSP  .M2    B2,      B7,       B8    ; prod7=co2*yt0
||     ADD    .D2    B14,     B12,      B3    ; b_w2=b_w+j*8
||     SHL    .S2X   A3,      1,        B2    ; bl2=al2*2

  [!A1]ADDAD  .D1    A14,     A3,       A14   ; (10)a_x=a_x+fftjmp(al2)
||     MPYSP  .M1    A8,      A11,      A9    ; prod1=co1*xt1
||     MPYSP  .M2    B8,      B11,      B9    ; prod9=co3*xt2
||     ADDSP  .L1X   A4,      B4,       A13   ; xh0pxh20=axh0+bxh20
||     ADDSP  .L2X   A5,      B5,       B13   ; xh1pxh21=axh1+bxh21
||     ADD    .S2    B0,      4,        B1    ; bycopy3=b_y+4
||     STW    .D2T1  A14,     *B15[23]        ; store current a_x

       ADDSP  .L1    A6,      A4,       A4    ; (11)axh0=xl1+x0
||     ADDSP  .L2    B4,      B6,       B4    ; bxh20=xh2+xl2
||     MPYSP  .M1    A8,      A10,      A10   ; prod3=yt1*co1
||     MPYSP  .M2    B10,     B9,       B11   ; prod10=yt2*si3
||     ADD    .S1    A2,      4,        A8    ; acopy1=a_y+4
||     STW    .D1T1  A13,     *A2[A15]        ; store sum1
||     STW    .D2T2  B13,     *B0[B2]         ; store sum5

       ADDSP  .L1    A7,      A5,       A5    ; (12)axh1=x1+xl1p1
||     ADDSP  .L2    B5,      B7,       B5    ; bxh21=xh2p1+xl2p1
||     MPYSP  .M1    A10,     A9,       A11   ; prod2=si1*yt1
||     MPYSP  .M2    B8,      B10,      B10   ; prod11=co3*yt2
||     STW    .D1T1  A13,     *A8[A15]        ; store sum2
||     STW    .D2T2  B13,     *B1[B2]         ; store sum6
||     MV     .S2    B3,      B1              ; save b_w in b1
||     MV     .S1X   B0,      A2              ; move b_y to a_y
; BRANCH OCCURS HERE

**************************** LOOP EPILOG **********************************
************PARALLEL WITH OUTER LOOP INSTRUCTIONS *************************

       MPYSP  .M1    A11,     A9,       A12   ; prod4=xt1*si1
||     MPYSP  .M2    B9,      B11,      B12   ; prod12=si3*xt2
||     SHR    .S2X   A0,      1,        B3    ; bh2=al1/2
||     LDW    .D2T1  *B15[15],A4              ; load radix or n_min
||     MV     .S1X   B15,     A6              ; move sp for load

       STW    .D2T2  B13,     *B0[1]          ; store xh1pxh21
||     LDW    .D1T1  *A6[16], A14             ; load back initial a_x

       STW    .D2T1  A13,     *B0             ; store xh0pxh20
||     LDW    .D1T2  *A6[17], B4              ; load b_i or N

       SHL    .S1    A0,      1,        A15   ; al=al1*2
||     ADDSP  .L1X   A12,     B12,      A13   ; sum3=prod5+prod6
||     SUBSP  .L2X   B8,      A8,       B13   ; sum4=prod7-prod8

       SHR    .S1    A0,      1,        A5    ; get stride=al1/2
||     LDW    .D2T2  *B15[18],B6              ; load y_ptr

       SHL    .S2    B3,      1,        B8    ; bl=bh2*2
||     CMPGT  .L1    A5,      A4,       A1    ; while(stride > radix)
||     LDW    .D2T1  *B15[19],A5              ; load brev

       ADDSP  .L1    A9,      A11,      A13   ; sum1=prod1+prod2
||     ADDSP  .L2    B9,      B11,      B13   ; sum5=prod9+prod10
||     ADD    .D1    A2,      4,        A11   ; acopy1=a_y+4
||[A1] B      .S1    OUT_LOOP                 ; jump to outer loop
||[!A1]LDW    .D2T2  *B15[22],B5              ; load original csr

       STW    .D2T1  A13,     *B0[B8]         ; store sum3
||     STW    .D1T2  B13,     *A11[A0]        ; store sum4
||     SUBSP  .L1    A10,     A12,      A13   ; sum2=prod3-prod4
||     SUBSP  .L2    B10,     B12,      B13   ; sum6=prod11-prod12
||     MVC    .S2    B4,      IRP             ; move N to irp

       SHL    .S2X   A3,      1,        B2    ; bl2=al2*2
||     SHR    .S1    A0,      2,        A0    ; l1 = l1/4 or stride/4
||     MPY    .M1    A3,      8,        A7    ; get correct fftjmp
||[!A1]LDW    .D1T1  *A6[20], A7              ; load offset
||[!A1]LDW    .D2T2  *B15[21],B7              ; load n_max

       ADD    .D2    B0,      4,        B1    ; bycopy=b_y+4
||     SHR    .S2X   A0,      1,        B3    ; get bh2

       ADD    .S1    A2,      4,        A8    ; acopy1=a_y+4
||     STW    .D1T1  A13,     *A2[A15]        ; store sum1
||     STW    .D2T2  B13,     *B0[B2]         ; store sum5
||     ADD    .S2X   B14,     A7,       B14   ; w= w+fftjmp

       STW    .D1T1  A13,     *A8[A15]        ; store sum2
||     STW    .D2T2  B13,     *B1[B2]         ; store sum6
||     ZERO   .L1    A1                       ; j=0
||     ADD    .S1X   A0,      B3,       A3    ; get al2(fft_jmp)
||[!A1]MVC    .S2    B5,      CSR             ; enable interrupt

;BRANCH TO OUTER LOOP OCCURS HERE

***************************************************************************

       CMPGT  .L1    A4,      4,        A1    ; if(radix <= 4)
||     MV     .D1    A14,     A9              ; move x_ptr to correct place
||     MV     .D2    B6,      B10             ; move the y_ptr
||     MVC    .S2    IRP,     B0              ; initialize counter
||     MV     .S1    A5,      A0              ; move the brev value

  [A1] B      .S2    END                      ; go to end if radix > 4
||       SHR    .S1    A7,      2,        A3    ; j=offset/4
||     NORM   .L2    B7,      B2              ; l0=_norm(n_max)
||       CMPEQ  .L1    A4,      2,        A2    ; flag=(radix==2)

       ADD    .L2X   A9,      8,        B3    ; copy x_ptr
||     CLR    .S1    A3,      6,        31, A8; 1st iteration j0
||     MV     .L1X   B7,      A15             ; move n_max
||     SUB    .D2    B2,      17,       B2    ; l0= l0-17

       SHR    .S2X   A15,     1,        B1    ; n_max = n_max / 2
;||     SUB    .D2    B2,      2,        B2    ; l0-=2 to avoid use of ADDAW
||     SHL    .S1    A15,     2,        A15   ; to get y-ptr copy
||     AND    .L2    B5,      -2,       B5    ; disable interrupt bit

       SUB    .L1X   B1,      1,        A1      ; to incr a-side y-ptr
||     SUB    .D2    B1,      1,        B1    ; to incr b-side y-ptr
||     ADD    .S1    A15,     4,        A15   ; for a-side y-ptr
||     MVC    .S2    B5,      CSR             ; disable interrupt
;INITIALIZATION OF REGISTERS ENDS HERE

*-------------------------PIPED LOOP PROLOG---------------------------------

       LDDW   .D1T1  *A9++[2],A7:A6           ; load x1:x0 (xh1_0:xh0_0)
||     LDDW   .D2T2  *B3++[2],B7:B6           ; load x3:x2 (xh1_1:xh0_1)

       LDDW   .D1T1  *A9++[2],A5:A4           ; load x5:x4 (xl1_0:xl0_0)
||     LDDW   .D2T2  *B3++[2],B5:B4           ; load x7:x6 (xl1_1:xl0_1)

       SHR    .S1    A3,      6,        A8    ; get value of j1
||     LDBU   .D1T2  *A0[A8], B8              ; load k0

       ADD    .S1    A3,      1,        A3    ; increment j
||     LDBU   .D1T2  *A0[A8], B12             ; load value of k1

       NOP

       CLR    .S1    A3,      6,        31, A8; next iteration's j0

  [!A2]ADDSP  .L1    A6,      A4,       A6    ; xh0_0 = x0 + x4
||[!A2]ADDSP  .L2    B6,      B4,       B6    ; xh0_1 = x2 + x6

  [!A2]ADDSP  .L1    A7,      A5,       A7    ; xh1_0 = x1 + x5
||[!A2]ADDSP  .L2    B7,      B5,       B7    ; xh1_1 = x3 + x7
||     SHL    .S2    B8,      6,        B8    ; k0 = k0 << 6

       LDDW   .D1T1  *A9++[2],A7:A6           ; load values of x1:x0 (xh1_0:xh0_0)
||     LDDW   .D2T2  *B3++[2],B7:B6           ; load values of x3:x2 (xh1_1:xh0_1)
||[!A2]SUBSP  .L1    A6,      A4,       A4    ; xl0_0 = x0 - x4
||[!A2]SUBSP  .L2    B7,      B5,       B4    ; xl1_1 = x3 - x7
||     ADD    .S2    B8,      B12,      B8    ; get k0 = k0 + k1

       LDDW   .D1T1  *A9++[2],A5:A4           ; load values of x5:x4
||     LDDW   .D2T2  *B3++[2],B5:B4           ; load values of x7:x6
||[!A2]SUBSP  .L2    B6,      B4,       B5    ; xl0_1 = x2 - x6
||[!A2]SUBSP  .L1    A7,      A5,       A5    ; xl1_0 = x1 - x5

       SHR    .S1    A3,      6,        A8    ; get value of j1
||     LDBU   .D1T2  *A0[A8], B8              ; load value of k0
||     ADDSP  .L2X   A6,      B6,       B11   ; yt0 = xh0_0 + xh0_1
||     SUBSP  .L1X   A6,      B6,       A11   ; yt4 = xh0_0 - xh0_1
||     SHRU   .S2    B8,      B2,       B8    ; k0 = k0 >> l0

       ADD    .S1    A3,      1,        A3    ; increment j
||     LDBU   .D1T2  *A0[A8], B12             ; load value of k1
||     ADDSP  .L2X   A7,      B7,       B12   ; yt1 = xh1_0 + xh1_1
||     SUBSP  .L1X   A7,      B7,       A12   ; yt5 = xh1_0 - xh1_1
||     SHL    .S2    B8,      0x2,      B8

       ADDSP  .L1X   A4,      B4,       A13   ; yt2 = xl0_0 + xl1_1
||     SUBSP  .L2X   A4,      B4,       B13   ; yt6 = xl0_0 - xl1_1
||     ADD    .S2    B10,     B8,       B9    ; get store ptr y

       ADDSP  .L2X   A5,      B5,       B14   ; yt7 = xl1_0 + xl0_1
||     SUBSP  .L1X   A5,      B5,       A14   ; yt3 = xl1_0 - xl0_1
||     CLR    .S1    A3,      6,        31, A8; get the next iteration's j0

*--------------------- PIPED LOOP KERNEL -----------------------------------

loop2:

  [!A2]ADDSP  .L1    A6,      A4,       A6    ; xh0_0 = x0 + x4
||[!A2]ADDSP  .L2    B6,      B4,       B6    ; xh0_0 = x2 + x6
||     ADD    .S1X   B9,      A15,      A10   ; A15 has nmax*4+4
||     STW    .D2T2  B11,     *B9++           ; store yt0
||[B0] SUB    .S2    B0,      4,        B0    ; decrement ctr

  [!A2]ADDSP  .L1    A7,      A5,       A7    ; xh0_0 = x1 + x5
||[!A2]ADDSP  .L2    B7,      B5,       B7    ; xh0_0 = x3 + x7
||     SHL    .S2    B8,      6,        B8    ; k0 = k0 << 6
||     STW    .D2T2  B12,     *B9++[B1]       ; store yt1
||     STW    .D1T1  A12,     *A10++[A1]      ; store yt5

       LDDW   .D1T1  *A9++[2],A7:A6           ; load x1:x0(xh1_0:xh0_0)
||     LDDW   .D2T2  *B3++[2],B7:B6           ; load x3:x2(xh1_1:xh0_1)
||[!A2]SUBSP  .L1    A6,      A4,       A4    ; xl0_0 = x0 - x4
||[!A2]SUBSP  .L2    B7,      B5,       B4    ; xl1_1 = x3 - x7
||     ADD    .S2    B8,      B12,      B8    ; get k0 = k0 + k1
||[B0] B      .S1    loop2

       LDDW   .D1T1  *A9++[2],A5:A4           ; load values of x5:x4
||     LDDW   .D2T2  *B3++[2],B5:B4           ; load values of x7:x6
||[!A2]SUBSP  .L2    B6,      B4,       B5    ; xl0_1 = x2 - x6
||[!A2]SUBSP  .L1    A7,      A5,       A5    ; xl1_0 = x1 - x5
||[A2] MV     .S2X   A14,     B14             ; swap yt3 and yt7
||[A2] MV     .S1X   B14,     A14

       SHR    .S1    A3,      6,        A8    ; get value of j1
||     LDBU   .D1T2  *A0[A8], B8              ; load value of k0
||     ADDSP  .L2X   A6,      B6,       B11   ; yt0 = xh0_0 + xh0_1
||     SUBSP  .L1X   A6,      B6,       A11   ; yt4 = xh0_0 - xh0_1
||     SHRU   .S2    B8,      B2,       B8    ; k0 = k0 >> l0
||     STW    .D2T1  A13,     *B9++           ; store yt2

       ADD    .S1    A3,      1,        A3    ; increment j
||     LDBU   .D1T2  *A0[A8], B12             ; load value of k1
||     ADDSP  .L2X   A7,      B7,       B12   ; yt1 = xh1_0 + xh1_1
||     SUBSP  .L1X   A7,      B7,       A12   ; yt5 = xh1_0 - xh1_1
||     STW    .D2T1  A14,     *B9++[B1]       ; store yt3
||     SHL    .S2    B8,      0x2,      B8

       ADDSP  .L1X   A4,      B4,       A13   ; yt2 = xl0_0 + xl1_1
||     SUBSP  .L2X   A4,      B4,       B13   ; yt6 = xl0_0 - xl1_1
||     ADD    .S2    B10,     B8,       B9    ; get store ptr y
||     STW    .D2T1  A11,     *B9             ; store yt4
||     STW    .D1T2  B13,     *A10++          ; store yt6

       ADDSP  .L2X   A5,      B5,       B14   ; yt7 = xl1_0 + xl0_1
||     SUBSP  .L1X   A5,      B5,       A14   ; yt3 = xl1_0 - xl0_1
||     CLR    .S1    A3,      6,        31, A8; get the next iteration's j0
||     STW    .D1T2  B14,     *A10            ; store yt7

*--------------------- END OF PIPED LOOP KERNEL ----------------------------------------

; POP OUT THE DATA
END:
       MV     .S1X   B15,     A1              ; copy stack pointer
||     LDW    .D2T2  *B15[14],B4              ; load irp into b4

       LDW    .D2T2  *B15[12],B3              ; load b3
||     LDW    .D1T1  *A1[13], A15             ; load a15

       LDW    .D2T2  *B15[1], B10             ; load b10
||     LDW    .D1T1  *A1[6],  A10             ; load a10

       LDW    .D2T2  *B15[2], B11             ; load b11
||     LDW    .D1T1  *A1[7],  A11             ; load a11

       LDW    .D2T2  *B15[3], B12             ; load b12
||     LDW    .D1T1  *A1[9],  A12             ; load a12

       LDW    .D2T2  *B15[4], B13             ; load b13
||     LDW    .D1T1  *A1[10], A13             ; load a13

       LDW    .D1T2  *A1[5],  B14             ; load b14
||     LDW    .D2T1  *B15[22],A1              ; load csr
||     B      .S2    B3                       ; return

       MVC    .S2    B4,      IRP             ; load irp
||     LDW    .D1T1  *A1[11], A14             ; load a14

       ADDAW  .D2    B15,     24,       B15   ; return back stack space

       NOP           2

       MVC    .S2    A1,      CSR             ; enable interrupts
       ;BRANCH TO OUTSIDE OCCURS HERE

                .end

* ======================================================================== *
*  End of file: DSPF_sp_fftSPxSP.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_ifftSPx/1117057342  117   0     0       57486     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         *
*      inverse FFT with complex input                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of ifft in complex samples, power of 2 such that   *
*                 N >=8 and N<= 16385.                                      *
*       ptr_x  :  Pointer to complex data input (normal order).             *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data (normal order).            *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest ifft butterfly used in computation used for      *
*                 decomposing ifft into sub iffts, see notes.               *
*       offset :  Index in complex samples of sub-ifft from start of main   *
*                 ifft.                                                     *
*       n_max  :  size of main ifft in complex samples.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards ifft using a special  *
*       sequence of coefficients generated in the following way:            *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the      *
*       ifft producing the time domain data in the Y array. The output is   *
*       scaled by a scaling factor of 1/N.                                  *
*                                                                           *
*       As the ifft allows every input point to effect every output point   *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main ifft of size N    *
*       to be divided into several steps, allowing as much data reuse as    *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          *
*                                                                           *
*       Notice how the 1st ifft function is called on the entire 1K data    *
*       set it covers the 1st pass of the ifft until the butterfly size is  *
*       256. The following 4 iffts do 256 pt iffts 25% of the size. These   *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the ifft the following would be needed :                  *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the ifft is calculated by summing these     *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple iffts they can share the same table by calling the     *
*       small iffts from further down in the twiddle factor array. In the   *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the IFFT, four other calls are required to       *
*       perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 IFFTs in        *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the IFFT with one function call invocation as shown   *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the ifft. This collapses the inner 2 loops in the       *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised IFFT uses a redundant sequence of twiddle            *
*          factors to allow a linear access through the data. This linear   *
*          access enables data and instruction level parallelism.           *
*                                                                           *
*       3.The data produced by the ifftSPxSP ifft is in normal form, the    *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The ifftSPxSP butterfly is bit reversed, i.e. the inner 2        *
*          points of the butterfly are corssed over, this has the effect    *
*          of making the data come out in bit reversed rather than          *
*          ifftSPxSP digit reversed order. This simplifies the last pass    *
*          of the loop. A simple table is used to do the bit reversal out   *
*          of place.                                                        *
*                                                                           *
*       unsigned char brev[64] =                                            *
*       {                                                                   *
*           0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,                   *
*           0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,                   *
*           0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,                   *
*           0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,                   *
*           0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,                   *
*           0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,                   *
*           0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,                   *
*           0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f                    *
*       };                                                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on         *
*          double word boundares. Real values are stored in even word       *
*          positions and imaginary values in odd positions.                 *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on        *
*          entry to each loop and reanlbed on exit out of the loop.         *
*                                                                           *
*       5. x must be padded with 16 words at the end.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, ifft_jmp;                               *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               ifft_jmp = stride + (stride>>1);                            *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - ifft_jmp);                                 *
*                   if (!predj) x += ifft_jmp;                              *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 - xl21;                                       *
*                   yt2 = xl1 - xl20;                                       *
*                   xt2 = xl0 + xl21;                                       *
*                   yt1 = xl1 + xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 - yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 + xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 - yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 + xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 - yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 + xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += ifft_jmp;                                      *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of ifft */                *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*       1504 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_ifftSPxSP
_DSPF_sp_ifftSPxSP:

* ======================================================================== *
* ======================================================================== *
       SUBAW  .D2    B15,     24      , B15   ; save stack space
       STW    .D2T2  B10,     *B15[1]         ; save b10

       MV     .S1X   B15,     A5              ; copy stack pointer
||     STW    .D2T1  A10,     *B15[6]         ; save a10

       STW    .D2T2  B11,     *B15[2]         ; save b11
||     STW    .D1T1  A11,     *A5[7]          ; save a11

       STW    .D2T2  B12,     *B15[3]         ; save b12
||     STW    .D1T1  A11,     *A5[8]          ; save a11

       STW    .D2T2  B13,     *B15[4]         ; save b13
||     STW    .D1T1  A12,     *A5[9]          ; save a12

       STW    .D2T2  B14,     *B15[5]         ; save b14
||     STW    .D1T1  A13,     *A5[10]         ; save a13
||     MVC    .S2    CSR,     B11             ; get csr

       STW    .D2T1  A14,     *B15[11]        ; store a14
||     STW    .D1T2  B3,      *A5[12]         ; store b3
||     MV     .S1X   B4,      A14             ; move to a_x
||     AND    .L2    B11,     -2,       B12   ; disable interrupt bit

       STW    .D2T1  A15,     *B15[13]        ; save a15
||     STW    .D1T2  B8,      *A5[15]         ; store n_min or radix
||     MV     .S2X   A6,      B14             ; move to b_w2
||     SHR    .S1    A4,      1,        A0    ; get al1

       STW    .D2T2  B4,      *B15[16]        ; store ptr_x
||     STW    .D1T1  A4,      *A5[17]         ; store N
||     SHR    .S2X   A0,      1,        B3    ; get bh2

       STW    .D2T2  B6,      *B15[18]        ; store ptr_y
||     STW    .D1T1  A8,      *A5[19]         ; store brev
||     ADD    .S1X   A0,      B3,       A3    ; get al2
||     MVC    .S2    B12,     CSR             ; disable interrupt

       STW    .D2T1  A10,     *B15[20]        ; store offset
||     STW    .D1T2  B10,     *A5[21]         ; store n_max
||     MVC    .S2    IRP,     B10             ; get irp for storing
||     MV     .S1X   B11,     A11             ; get csr for storing

       STW    .D2T2  B10,     *B15[14]        ; store irp
||     STW    .D1T1  A11,     *A5[22]         ; store original csr
||     ZERO   .S1    A1                       ; j=0
||     MVC    .S2X   A4,      IRP             ; store counter(N) in irp
; end of initialisation

OUT_LOOP:
************************ INNER LOOP PROLOG **********************************

       MV     .S1    A14,     A2              ; move a_x to a_y
||     MV     .S2X   A14,     B2              ; move a_x to b_x

       LDDW   .D2T1  *B2,     A7:A6           ; load x1:x0
||     LDDW   .D1T2  *A14[A3],B7:B6           ; load xl2p1:xl2
||     MV     .S2    B2,      B0              ; move a_x to b_y

       LDDW   .D1T1  *A14[A0],A5:A4           ; load xl1p1:xl1
||     LDDW   .D2T2  *B2[B3], B5:B4           ; load xh2p1:xh2

       NOP

       ADD    .S1    A1,      3,        A1    ; j=j+3

       SUB    .S1    A1,      A3,       A1    ; j=j-fftlmp(al2)
||     ADD    .S2    B14,     0,        B3    ; get initial b_w2

  [!A1]ADDAD  .D1    A14,     A3,       A14   ; a_x=a_x+fftjmp(al2)
||     STW    .D2T1  A14,     *B15[23]        ; store current a_x

       ADDSP  .L1    A6,      A4,       A4    ; axh0=xl1+x0
||     ADDSP  .L2    B4,      B6,       B4    ; bxh20=xh2+xl2

       ADDSP  .L1    A7,      A5,       A5    ; axh1=x1+xl1p1
||     ADDSP  .L2    B5,      B7,       B5    ; bxh21=xh2p1+xl2p1
||     MV     .S2    B3,      B1              ; save b_w in b1

********************** PIPED LOOP KERNEL ***********************************
LOOP:
       SUBSP  .L1    A6,      A4,       A6    ; (1)axl0=x0-xl1
||     SUBSP  .L2    B5,      B7,       B6    ; bxl21=xh2p1-xl2p1
||     SHR    .S2X   A0,      1,        B3    ; bh2=al1/2
||     MV     .S1X   B3,      A6              ; move b_w to a_w
||     MPYSP  .M1    A11,     A9,       A12   ; prod4=xt1*si1
||     MPYSP  .M2    B9,      B11,      B12   ; prod12=si3*xt2
||     ADD    .D1    A14,     8,        A14   ; a_x=a_x+8

       SUBSP  .L1    A7,      A5,       A7    ; (2)axl1=x1-xl1p1
||     SUBSP  .L2    B4,      B6,       B7    ; bxl20=xh2-xl2
||     MV     .S2X   A14,     B2              ; move a_x to b_x
||     ADD    .S1X   A0,      B3,       A3    ; al2=al1+bh2
||     STW    .D2T2  B13,     *B0[1]          ; store xh1pxh21
||[A1] ADD    .D1    A1,      A3,       A1    ; j=j+fftjmp(al2)

       LDDW   .D1T2  *A6[1],  B3:B2           ; (3)load si2:co2
||     STW    .D2T1  A13,     *B0             ; store xh0pxh20
||     SUBSP  .L1X   A12,     B12,      A13   ; sum3=prod5-prod6
||     ADDSP  .L2X   B8,      A8,       B13   ; sum4=prod8+prod7
||     MVC    .S2    IRP,     B8              ; get loop counter to b1

       SUBSP  .L1X   A4,      B4,       A7    ; (4)xt0=axh0-bxh20
||     SUBSP  .L2X   A5,      B5,       B7    ; yt0=axh1-bxh21
||     LDDW   .D1T1  *A6,     A9:A8           ; load si1:co1
||     LDDW   .D2T2  *B1[2],  B9:B8           ; load si3:co3
||     SHL    .S1    A0,      1,        A15   ; al=al1*2
||     SUB    .S2    B8,      4,        B1    ; b1=b1-4

       LDDW   .D2T1  *B2,     A7:A6           ; (5)load x1:x0
||     LDDW   .D1T2  *A14[A3],B7:B6           ; load xl2p1:xl2
||     ADDSP  .L2X   A6,      B6,       B11   ; xt2=axl0+bxl21
||     SUBSP  .L1X   A6,      B6,       A11   ; xt1=axl0-bxl21
||     MVC    .S2    B1,      IRP             ; store updated counter in irp

       LDDW   .D1T1  *A14[A0],A5:A4           ; (6)load xl1p1:xl1
||     LDDW   .D2T2  *B2[B3], B5:B4           ; load xh2p1:xh2
||     ADDSP  .L1X   A7,      B7,       A10   ; yt1=axl1+bxl20
||     SUBSP  .L2X   A7,      B7,       B10   ; yt2=axl1-bxl20
||     SHL    .S2    B3,      1,        B8    ; bl=bh2*2

       SUBSP  .L1    A9,      A11,      A13   ; (7)sum1=prod1-prod2
||     SUBSP  .L2    B9,      B11,      B13   ; sum5=prod9-prod10
||     ADD    .D1    A2,      4,        A11   ; acopy1=a_y+4
||     LDW    .D2T2  *B15[23],B0              ; load 2nd last value of ax
||     SUB    .S2    B1,      4,        B1    ; flag for checking extra loads
||[B1] B      .S1    LOOP                     ; branch to beginning

       ADD    .S1    A1,      3,        A1    ; (8)j=j+3
||     MPYSP  .M1X   B2,      A7,       A12   ; prod5=co2*xt0
||     MPYSP  .M2    B7,      B3,       B12   ; prod6=yt0*si2
||     SHL    .S2X   A1,      3,        B12   ; j*8
||     STW    .D2T1  A13,     *B0[B8]         ; store sum3
||     STW    .D1T2  B13,     *A11[A0]        ; store sum4
||     ADDSP  .L1    A10,     A12,      A13   ; sum2=prod3+prod4
||     ADDSP  .L2    B10,     B12,      B13   ; sum6=prod11+prod12

  [B1] SUB    .S1    A1,      A3,       A1    ; (9)j=j-fftjmp(al2)
||     MPYSP  .M1X   B3,      A7,       A8    ; prod8=si2*xt0
||     MPYSP  .M2    B2,      B7,       B8    ; prod7=co2*yt0
||     ADD    .D2    B14,     B12,      B3    ; b_w2=b_w+j*8
||     SHL    .S2X   A3,      1,        B2    ; bl2=al2*2

  [!A1]ADDAD  .D1    A14,     A3,       A14   ; (10)a_x=a_x+fftjmp(al2)
||     MPYSP  .M1    A8,      A11,      A9    ; prod1=co1*xt1
||     MPYSP  .M2    B8,      B11,      B9    ; prod9=co3*xt2
||     ADDSP  .L1X   A4,      B4,       A13   ; xh0pxh20=axh0+bxh20
||     ADDSP  .L2X   A5,      B5,       B13   ; xh1pxh21=axh1+bxh21
||     ADD    .S2    B0,      4,        B1    ; bycopy3=b_y+4
||     STW    .D2T1  A14,     *B15[23]        ; store current a_x

       ADDSP  .L1    A6,      A4,       A4    ; (11)axh0=xl1+x0
||     ADDSP  .L2    B4,      B6,       B4    ; bxh20=xh2+xl2
||     MPYSP  .M1    A8,      A10,      A10   ; prod3=yt1*co1
||     MPYSP  .M2    B10,     B9,       B11   ; prod10=yt2*si3
||     ADD    .S1    A2,      4,        A8    ; acopy1=a_y+4
||     STW    .D1T1  A13,     *A2[A15]        ; store sum1
||     STW    .D2T2  B13,     *B0[B2]         ; store sum5

       ADDSP  .L1    A7,      A5,       A5    ; (12)axh1=x1+xl1p1
||     ADDSP  .L2    B5,      B7,       B5    ; bxh21=xh2p1+xl2p1
||     MPYSP  .M1    A10,     A9,       A11   ; prod2=si1*yt1
||     MPYSP  .M2    B8,      B10,      B10   ; prod11=co3*yt2
||     STW    .D1T1  A13,     *A8[A15]        ; store sum2
||     STW    .D2T2  B13,     *B1[B2]         ; store sum6
||     MV     .S2    B3,      B1              ; save b_w in b1
||     MV     .S1X   B0,      A2              ; move b_y to a_y
; BRANCH OCCURS HERE

**************************** LOOP EPILOG **********************************
************PARALLEL WITH OUTER LOOP INSTRUCTIONS *************************

       MPYSP  .M1    A11,     A9,       A12   ; prod4=xt1*si1
||     MPYSP  .M2    B9,      B11,      B12   ; prod12=si3*xt2
||     SHR    .S2X   A0,      1,        B3    ; bh2=al1/2
||     LDW    .D2T1  *B15[15],A4              ; load radix or n_min
||     MV     .S1X   B15,     A6              ; move sp for load

       STW    .D2T2  B13,     *B0[1]          ; store xh1pxh21
||     LDW    .D1T1  *A6[16], A14             ; load back initial a_x

       STW    .D2T1  A13,     *B0             ; store xh0pxh20
||     LDW    .D1T2  *A6[17], B4              ; load b_i or N

       SHL    .S1    A0,      1,        A15   ; al=al1*2
||     SUBSP  .L1X   A12,     B12,      A13   ; sum3=prod5-prod6
||     ADDSP  .L2X   B8,      A8,       B13   ; sum4=prod7+prod8

       SHR    .S1    A0,      1,        A5    ; get stride=al1/2
||     LDW    .D2T2  *B15[18],B6              ; load y_ptr

       SHL    .S2    B3,      1,        B8    ; bl=bh2*2
||     CMPGT  .L1    A5,      A4,       A1    ; while(stride > radix)
||     LDW    .D2T1  *B15[19],A5              ; load brev

       SUBSP  .L1    A9,      A11,      A13   ; sum1=prod1-prod2
||     SUBSP  .L2    B9,      B11,      B13   ; sum5=prod9-prod10
||     ADD    .D1    A2,      4,        A11   ; acopy1=a_y+4
||[A1] B      .S1    OUT_LOOP                 ; jump to outer loop
||[!A1]LDW    .D2T2  *B15[22],B5              ; load original csr

       STW    .D2T1  A13,     *B0[B8]         ; store sum3
||     STW    .D1T2  B13,     *A11[A0]        ; store sum4
||     ADDSP  .L1    A10,     A12,      A13   ; sum2=prod3+prod4
||     ADDSP  .L2    B10,     B12,      B13   ; sum6=prod11+prod12
||     MVC    .S2    B4,      IRP             ; move N to irp

       SHL    .S2X   A3,      1,        B2    ; bl2=al2*2
||     SHR    .S1    A0,      2,        A0    ; l1 = l1/4 or stride/4
||     MPY    .M1    A3,      8,        A7    ; get correct fftjmp
||[!A1]LDW    .D1T1  *A6[20], A7              ; load offset
||[!A1]LDW    .D2T2  *B15[21],B7              ; load n_max

       ADD    .D2    B0,      4,        B1    ; bycopy=b_y+4
||     SHR    .S2X   A0,      1,        B3    ; get bh2

       ADD    .S1    A2,      4,        A8    ; acopy1=a_y+4
||     STW    .D1T1  A13,     *A2[A15]        ; store sum1
||     STW    .D2T2  B13,     *B0[B2]         ; store sum5
||     ADD    .S2X   B14,     A7,       B14   ; w= w+fftjmp

       STW    .D1T1  A13,     *A8[A15]        ; store sum2
||     STW    .D2T2  B13,     *B1[B2]         ; store sum6
||     ZERO   .L1    A1                       ; j=0
||     ADD    .S1X   A0,      B3,       A3    ; get al2(fft_jmp)
||[!A1]MVC    .S2    B5,      CSR             ; enable interrupt

;BRANCH TO OUTER LOOP OCCURS HERE

***************************************************************************

       CMPGT  .L1    A4,      4,        A1    ; if(radix <= 4)
||     MV     .D1    A14,     A9              ; move x_ptr to correct place
||     MV     .D2    B6,      B10             ; move the y_ptr
||     MVC    .S2    IRP,     B0              ; initialize counter
||     MV     .S1    A5,      A0              ; move the brev value

  [A1] B      .S2    END                      ; go to end if radix > 4
||     SHR    .S1    A7,      2,        A3    ; j=offset/4
||     NORM   .L2    B7,      B2              ; l0=_norm(n_max)
||     CMPEQ  .L1    A4,      2,        A2    ; flag=(radix==2)

       ADD    .L2X   A9,      8,        B3    ; copy x_ptr
||     CLR    .S1    A3,      6,        31, A8; 1st iteration j0
||     MV     .L1X   B7,      A15             ; move n_max
||     SUB    .D2    B2,      17,       B2    ; l0= l0-17

       SHR    .S2X   A15,     1,        B1    ; n_max = n_max / 2
||     SHL    .S1    A15,     2,        A15   ; to get y-ptr copy
||     AND    .L2    B5,      -2,       B5    ; disable interrupt bit

       SUB    .L1X   B1,      0,        A1    ; to incr a-side y-ptr
||     ADD    .S1    A15,     4,        A15   ; for a-side y-ptr
||     MVC    .S2    B5,      CSR             ; disable interrupt
;INITIALIZATION OF REGISTERS ENDS HERE

*-------------------------PIPED LOOP PROLOG---------------------------------
       LDDW   .D1T1  *A9++[2],A5:A4           ; load x1:x0(xh1_0:xh0_0)
||     LDDW   .D2T2  *B3++[2],B5:B4           ; load x3:x2(xh1_1:xh0_1)

       LDDW   .D1T1  *A9++[2],A7:A6           ; load x5:x4(xl1_0:xl0_0)
||     LDDW   .D2T2  *B3++[2],B7:B6           ; load x7:x6(xl1_1:xl0_1)

       INTSP  .L2    B7, B13                  ; Get n_max

       NOP

       NOP

       CLR    .S1    A3,      6,        31, A8; j0 = (j     ) & 0x3F

  [!A2]ADDSP  .L1    A4,      A6,       A4    ; xh0_0  = x0 + x4
||[!A2]ADDSP  .L2    B4,      B6,       B4    ; xh0_1  = x2 + x6
||     SHR    .S1    A3,      6,        A8    ; j1 = (j >> 6)
||     LDBU   .D1T2  *A0[A8], B11             ; k0 = brev[j0]
||     RCPSP  .S2    B13,     B13             ; Get 1/n_max

  [!A2]ADDSP  .L1    A5,      A7,       A5    ; xh1_0  = x1 + x5
||[!A2]ADDSP  .L2    B5,      B7,       B5    ; xh1_1  = x3 + x7
||     LDBU   .D1    *A0[A8], B4              ; k1 = brev[j1]
||     MV     .S1X   B13,     A13             ; A side 1/n_max

       LDDW   .D1T1  *A9++[2],A5:A4           ; load x1:x0(xh1_0:xh0_0)
||     LDDW   .D2T2  *B3++[2],B5:B4           ; load x3:x2(xh1_1:xh0_1)
||[!A2]SUBSP  .L1    A4,      A6,       A6    ; xl0_0  = x0 - x4
||[!A2]SUBSP  .L2    B7,      B5,       B6    ; xl1_1  = x7 - x3

       LDDW   .D1T1  *A9++[2],A7:A6           ; load x5:x4(xl1_0:xl0_0)
||     LDDW   .D2T2  *B3++[2],B7:B6           ; load x7:x6(xl1_1:xl0_1)
||[!A2]SUBSP  .L1    A5,      A7,       A7    ; xl1_0  = x1 - x5
||[!A2]SUBSP  .L2    B4,      B6,       B7    ; xl0_1  = x2 - x6
||     ADD    .S1    A3,      1,        A3    ; j++

       ADDSP  .L1X   A4,      B4,       A12   ; yt0  = xh0_0 + xh0_1
||     SUBSP  .L2X   A4,      B4,       B12   ; yt4  = xh0_0 - xh0_1

       ADDSP  .L1X   A5,      B5,       A12   ; yt1  = xh1_0 + xh1_1
||     SUBSP  .L2X   A5,      B5,       B12   ; yt5  = xh1_0 - xh1_1
||     SHL    .S2    B11,     6,        B11   ; k0 << 6

       ADDSP  .L1X   A6,      B6,       A12   ; yt2  = xl0_0 + xl1_1
||     SUBSP  .L2X   A6,      B6,       B12   ; yt6  = xl0_0 - xl1_1
||     ADD    .S2    B11,     B4,       B11   ; k = (k0 << 6) +  k1

       CLR    .S1    A3,      6,        31, A8; j0 = (j     ) & 0x3F
||     ADDSP  .L1X   A7,      B7,       A12   ; yt3  = xl1_0 + xl0_1
||     SUBSP  .L2X   A7,      B7,       B12   ; yt7  = xl1_0 - xl0_1
||     SHR    .S2    B11,     B2,       B11   ; k = k >> l0

; ------------------------- BEGINNING OF KERNEL -------------------------

LOOP1:

  [!A2]ADDSP  .L1    A4,      A6,       A4    ; xh0_0  = x0 + x4
||[!A2]ADDSP  .L2    B4,      B6,       B4    ; xh0_1  = x2 + x6
||     SHR    .S1    A3,      6,        A8    ; j1 = (j >> 6)
||     LDBU   .D1T2  *A0[A8], B11             ; k0 = brev[j0]
||     MPYSP  .M1    A12,     A13,      A12   ; yt0/n_max
||     MPYSP  .M2    B12,     B13,      B12   ; yt4/n_max
||     ADDAD  .D2    B10,     B1,       B9    ; y'' = y + n_max

  [!A2]ADDSP  .L1    A5,      A7,       A5    ; xh1_0  = x1 + x5
||[!A2]ADDSP  .L2    B5,      B7,       B5    ; xh1_1  = x3 + x7
||     LDBU   .D1    *A0[A8], B4              ; k1 = brev[j1]
||     MPYSP  .M1    A12,     A13,      A12   ; yt1/n_max
||     MPYSP  .M2    B12,     B13,      B12   ; yt5/n_max
||     SUB    .S2    B0,      4,        B0    ; Update loop ctr
||     ADD    .S1X   B11,     0,        A8    ; k' = k

   [B0]LDDW   .D1T1  *A9++[2],A5:A4           ; load x1:x0(xh1_0:xh0_0)
|| [B0]LDDW   .D2T2  *B3++[2],B5:B4           ; load x3:x2(xh1_1:xh0_1)
||[!A2]SUBSP  .L1    A4,      A6,       A6    ; xl0_0  = x0 - x4
||[!A2]SUBSP  .L2    B7,      B5,       B6    ; xl1_1  = x7 - x3
||     MPYSP  .M1    A12,     A13,      A12   ; yt2/n_max
||     MPYSP  .M2    B12,     B13,      B12   ; yt6/n_max
|| [B0]B      .S2    LOOP1                    ; BRANCH TO LOOP
||     MV     .S1X   B10,     A10             ; y' = y

   [B0]LDDW   .D1T1  *A9++[2],A7:A6           ; load x5:x4(xl1_0:xl0_0)
|| [B0]LDDW   .D2T2  *B3++[2],B7:B6           ; load x7:x6(xl1_1:xl0_1)
||[!A2]SUBSP  .L1    A5,      A7,       A7    ; xl1_0  = x1 - x5
||[!A2]SUBSP  .L2    B4,      B6,       B7    ; xl0_1  = x2 - x6
||     ADD    .S1    A3,      1,        A3    ; j++
||     MPYSP  .M1    A12,     A13,      A12   ; yt3/n_max
||     MPYSP  .M2    B12,     B13,      B12   ; yt7/n_max

       ADDSP  .L1X   A4,      B4,       A12   ; yt0  = xh0_0 + xh0_1
||     SUBSP  .L2X   A4,      B4,       B12   ; yt4  = xh0_0 - xh0_1
||     STW    .D1T1  A12,     *++A10[A8]      ; y0[k] = yt0/n_max
||     STW    .D2T2  B12,     *++B9[B11]      ; y0[k+n_max] = yt4/n_max

       ADDSP  .L1X   A5,      B5,       A12   ; yt1  = xh1_0 + xh1_1
||     SUBSP  .L2X   A5,      B5,       B12   ; yt5  = xh1_0 - xh1_1
||     SHL    .S2    B11,     6,        B11   ; k0 << 6
||     STW    .D1T1  A12,     *+A10[1]        ; y0[k+1] = yt1/n_max
||     STW    .D2T2  B12,     *+B9[1]         ; y0[k+1+n_max] = yt5/n_max

       ADDSP  .L1X   A6,      B6,       A12   ; yt2  = xl0_0 + xl1_1
||     SUBSP  .L2X   A6,      B6,       B12   ; yt6  = xl0_0 - xl1_1
||     ADD    .S2    B11,     B4,       B11   ; k = (k0 << 6) +  k1
||     STW    .D1T1  A12,     *++A10[A1]      ; y0[k+n_max/2] = yt2/n_max
||     STW    .D2T2  B12,     *++B9[B1]       ; y0[k+3*n_max/2] = yt6/n_max

       CLR    .S1    A3,      6,        31, A8; j0 = (j     ) & 0x3F
||     ADDSP  .L1X   A7,      B7,       A12   ; yt3  = xl1_0 + xl0_1
||     SUBSP  .L2X   A7,      B7,       B12   ; yt7  = xl1_0 - xl0_1
||     SHR    .S2    B11,     B2,       B11   ; k = k >> l0
||     STW    .D1T1  A12,     *+A10[1]        ; y0[k+1+n_max/2] = yt3/n_max
||     STW    .D2T2  B12,     *+B9[1]         ; y0[k+1+3*n_max/2] = yt7/n_max

*--------------------- END OF PIPED LOOP KERNEL ----------------------------------------

; POP OUT THE DATA
END:
       MV     .S1X   B15,     A1              ; copy stack pointer
||     LDW    .D2T2  *B15[14],B4              ; load irp into b4

       LDW    .D2T2  *B15[12],B3              ; load b3
||     LDW    .D1T1  *A1[13], A15             ; load a15

       LDW    .D2T2  *B15[1], B10             ; load b10
||     LDW    .D1T1  *A1[6],  A10             ; load a10

       LDW    .D2T2  *B15[2], B11             ; load b11
||     LDW    .D1T1  *A1[7],  A11             ; load a11

       LDW    .D2T2  *B15[3], B12             ; load b12
||     LDW    .D1T1  *A1[9],  A12             ; load a12

       LDW    .D2T2  *B15[4], B13             ; load b13
||     LDW    .D1T1  *A1[10], A13             ; load a13

       LDW    .D1T2  *A1[5],  B14             ; load b14
||     LDW    .D2T1  *B15[22],A1              ; load csr
||     B      .S2    B3                       ; return

       MVC    .S2    B4,      IRP             ; load irp
||     LDW    .D1T1  *A1[11], A14             ; load a14

       ADDAW  .D2    B15,     24,       B15   ; return back stack space

       NOP           2

       MVC    .S2    A1,      CSR             ; enable interrupts
       ;BRANCH TO OUTSIDE OCCURS HERE
                .end

* ======================================================================== *
*  End of file: DSPF_sp_ifftSPxSP.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_icfftr2/1117057343  140   0     0       42151     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSPF_sp_icfftr2_dif(                                            *
*                               float* x,                                   *
*                               float* w,                                   *
*                               short n                                     *
*                              );                                           *
*                                                                           *
*           x : input and output sequences (dim-n)      (input/output)      *
*               x has n complex numbers (2*n SP values).                    *
*               The real and imaginary values are interleaved in memory.    *
*               The input is in Bit reversed order nad output is in Normal  *
*               Order.                                                      *
*           w : FFT coefficients (dim-n/2)              (input)             *
*               w has n/2 complex numbers (n SP values).                    *
*               FFT coeficients must be in bit-reversed order               *
*               The real and imaginary values are interleaved in memory     *
*           n : FFT size                                (input)             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine is used to compute the Inverse, Complex, Radix-2,      *
*       Decimation-in-Frequency Fast Fourier Transform of a single          *
*       precision complex sequence of size n, and a power of 2. The         *
*       routine requires bit-reversed input and bit-reversed coefficents    *
*       (twiddle factors) and produces results that are in normal order.    *
*       Final scaling by 1/N is not done in this function.                  *
*                                                                           *
*       How To Use                                                          *
*                                                                           *
*           void main(void)                                                 *
*           {                                                               *
*               gen_w_r2(w, N);      // Generate coefficient table          *
*               bit_rev(w, N>>1);    // Bit-reverse coefficient table       *
*               cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   *
*                                    // from TI available                   *
*                                    // input in normal order, output in    *
*                                    // order bit-reversed                  *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 *
*                                    // input in bit-reversed order,        *
*                                    // order output in normal              *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               divide(x, N);        // scale inverse FFT output            *
*                                    // result is same as original input    *
*           }                                                               *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. Loading input x as well as coefficient w in double word.         *
*       2. mpy was used to perform a mv.  EX. mpy x, 1, y <=> mv x, y       *
*       3. Because the data loads are 1 itteration ahead of the             *
*          coefficent loads, counter i was copied so that the actual        *
*          count could live longer for the coefficent loads.                *
*       4. 2 Inner loops are callapsed into one loop.                       *
*       5. prolog and epilog are done in parallel with the outermost loop.  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Both input x and coefficient w should be aligned on double word  *
*          boundary.                                                        *
*       2. x should be padded with 4 words.                                 *
*       3. n should be greater than 8.                                      *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions. Note that the assembly code is hand optimized         *
*       and restrictions may apply.                                         *
*                                                                           *
*           void icfftr2_dif(float* x, float* w, short n)                   *
*           {                                                               *
*               short n2, ie, ia, i, j, k, m;                               *
*               float rtemp, itemp, c, s;                                   *
*                                                                           *
*               n2 = 1;                                                     *
*               ie = n;                                                     *
*               for(k=n; k > 1; k >>= 1)                                    *
*               {                                                           *
*                   ie >>= 1;                                               *
*                   ia = 0;                                                 *
*                   for(j=0; j < ie; j++)                                   *
*                   {                                                       *
*                       c = w[2*j];                                         *
*                       s = w[2*j+1];                                       *
*                       for(i=0; i < n2; i++)                               *
*                       {                                                   *
*                           m = ia + n2;                                    *
*                           rtemp     = x[2*ia]   - x[2*m];                 *
*                           x[2*ia]   = x[2*ia]   + x[2*m];                 *
*                           itemp     = x[2*ia+1] - x[2*m+1];               *
*                           x[2*ia+1] = x[2*ia+1] + x[2*m+1];               *
*                           x[2*m]    = c*rtemp   - s*itemp;                *
*                           x[2*m+1]  = c*itemp   + s*rtemp;                *
*                           ia++;                                           *
*                       }                                                   *
*                       ia += n2;                                           *
*                   }                                                       *
*                   n2 <<= 1;                                               *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to generate the coefficient table      *
*       (non-bit reversed).                                                 *
*                                                                           *
*           #include <math.h>                                               *
*           /* generate real and imaginary twiddle                          *
*              table of size n/2 complex numbers */                         *
*                                                                           *
*           gen_w_r2(float* w, int n)                                       *
*           {                                                               *
*               int i;                                                      *
*               float pi = 4.0*atan(1.0);                                   *
*               float e = pi*2.0/n;                                         *
*                                                                           *
*               for(i=0; i < ( n>>1 ); i++)                                 *
*               {                                                           *
*                   w[2*i]   = cos(i*e);                                    *
*                   w[2*i+1] = sin(i*e);                                    *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to bit-reverse the coefficents.        *
*                                                                           *
*           bit_rev(float* x, int n)                                        *
*           {                                                               *
*               int i, j, k;                                                *
*               float rtemp, itemp;                                         *
*                                                                           *
*               j = 0;                                                      *
*               for(i=1; i < (n-1); i++)                                    *
*               {                                                           *
*                   k = n >> 1;                                             *
*                   while(k <= j)                                           *
*                   {                                                       *
*                       j -= k;                                             *
*                       k >>= 1;                                            *
*                   }                                                       *
*                   j += k;                                                 *
*                   if(i < j)                                               *
*                   {                                                       *
*                       rtemp    = x[j*2];                                  *
*                       x[j*2]   = x[i*2];                                  *
*                       x[i*2]   = rtemp;                                   *
*                       itemp    = x[j*2+1];                                *
*                       x[j*2+1] = x[i*2+1];                                *
*                       x[i*2+1] = itemp;                                   *
*                   }                                                       *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to perform the final scaling           *
*       of the IFFT.                                                        *
*                                                                           *
*           /* divide each element of x by n */                             *
*           divide(float* x, int n)                                         *
*           {                                                               *
*               int i;                                                      *
*               float inv = 1.0 / n;                                        *
*                                                                           *
*               for(i=0; i < n; i++)                                        *
*               {                                                           *
*                   x[2*i]   = inv * x[2*i];                                *
*                   x[2*i+1] = inv * x[2*i+1];                              *
*               }                                                           *
*           }                                                               *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       x should be padded with 4 words at the end.                         *
*                                                                           *
*       Since the twiddle table is in bit-reversed order, it turns out      *
*       that the same twiddle table will also work for smaller IFFTs.This   *
*       means that if you need to do both 512 and 1024 point IFFTs in the   *
*       same application, you only need to have the 1024 point twiddle      *
*       table.  The 512 point FFT will use the first half of the 1024       *
*       point twiddle table.                                                *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*        2*n*log2(n) + 37                                                   *
*        eg. IF n = 64, cycles = 805                                        *
*        eg. IF n = 128, cycles = 1829                                      *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*        1600 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *




* ======================================================================== *
* ======================================================================== *

        .asg    B3,  B_RET_ADDR
        .asg    B15, B_SP
        .asg    A2,  A_SP
        .asg    B4,  B_w1
        .asg    B5,  B_wptr
        .asg    B11, B_w
        .asg    B8,  B_w2
        .asg    A3,  A_n2
        .asg    A6,  A_n
        .asg    B7,  B_n1
        .asg    B13, B_n
        .asg    B12, B_k
        .asg    A14, A_sr
        .asg    B14, B_CSR
        .asg    B9,  B_CSR_gie
        .asg    B10, B_x
        .asg    A4,  A_x
        .asg    A4,  A_xptr
        .asg    A10, A_rtemp
        .asg    B4,  B_n2_mul8
        .asg    A1,  A_j
        .asg    A11, A_itemp
        .asg    B0,  B_i
        .asg    A2,  A_i
        .asg    B1,  B_i1
        .asg    B2,  B_i2
        .asg    A5,  A_n2_mul8
        .asg    A0,  A_xtemp
        .asg    B6,  B_xtemp1
        .asg    A9,  A_xm1
        .asg    A8,  A_xm
        .asg    B9,  B_xa1
        .asg    B8,  B_xa
        .asg    A7,  A_s
        .asg    A6,  A_c
        .asg    A15, A_str1
        .asg    A12, A_cr
        .asg    A12, A_ci
        .asg    A13, A_si
        .asg    A13, A_str2
        .asg    B7,  B_str1
        .asg    B7,  B_str2
        .text
        .global _DSPF_sp_icfftr2_dif
_DSPF_sp_icfftr2_dif:

* ======================================================================== *
* ======================================================================== *

; -------------------------------------------------
; INITIALISATION
; -------------------------------------------------
         SUBAW .D2   B_SP,       12,        B_SP     ; Save Stack Space
||       MV    .L1X  B_SP,       A_SP                ; Copy Stack Pointer
||       MV    .L2   B_w1,       B_wptr              ; Copy w pointer
||       MVK   .S1   1,          A_n2                ; n2 = 1
||       SHR   .S2X  A_n,        1,         B_n1     ; n/2

         STW   .D2T1 A_sr,       *B_SP[5]            ; Save Register
||       STW   .D1T2 B_CSR,      *-A_SP[1]           ; Save Register
||       MV    .L1X  B_SP,       A_SP                ; Copy Stack pointer
||       MVC   .S2   CSR,        B_CSR               ; Get CSR
||       MV    .L2   B_w1,       B_w2                ; Copy w pointer

         STW   .D2T1 A_rtemp,    *B_SP[1]            ; Save Register
||       STW   .D1T2 B_x,        *A_SP[7]            ; Save Register
||       AND   .L2   B_CSR,      -2,        B_CSR_gie ; Disable GIE bit
||       MVK   .S2   8,          B_n2_mul8           ; 8*n2
||       SUB   .S1X  B_n1,       6,         A_j      ; j = n/2 - 6

         STW   .D2T1 A_itemp,    *B_SP[2]            ; Save Register
||       STW   .D1T2 B_w,        *A_SP[8]            ; Save Register
||       MVC   .S2   B_CSR_gie,  CSR                 ; Disable Interrupts
||       MV    .L2   B_n2_mul8,  B_i                 ; 8*n2

         STW   .D2T1 A_cr,       *B_SP[3]            ; Save Register
||       STW   .D1T2 B_k,        *A_SP[9]            ; Save Register
||       MV    .S1X  B_n2_mul8,  A_n2_mul8           ; 8*n2
||       MV    .L2   B_n2_mul8,  B_i1                ; i1 = 8 * n2
||       MV    .S2   B_n2_mul8,  B_i2                ; i2 = 8 * n2

         STW   .D2T1 A_si,       *B_SP[4]            ; Save Register
||       STW   .D1T2 B_n,        *A_SP[10]           ; Save Register
||       ADD   .S2X  A_x,        B_n2_mul8, B_xtemp1 ; x_temp1=x+2*n2
||       MV    .L1   A_x,        A_xtemp             ; x_temp=x
||       MV    .L2   B_w2,       B_w                 ; Save a copy of w pointer

; -------------------------------------------------
         LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; load xm1:xm
||       MV    .L2X  A_x,        B_x                 ; Save  a copy of x pointer

         LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; load xa1:xa
||       MV    .L2   B_n1,       B_n                 ; Save n/2
||       MV    .S2   B_n1,       B_k                 ; k = n/2
||       STW   .D2T1 A_str1,     *B_SP[6]            ; Save Register

         SUB   .S2   B_i,        8,         B_i      ; i = i - 8
||       SUB   .S1X  A_n2_mul8,  B_i,       A_i      ; Save i for next cycle

   [!B_i]ADD   .S1   A_x,        A_n2_mul8, A_x      ; x_ptr = x_ptr + 2*n2

   [!B_i]MPY   .M2   B_n2_mul8,  1,         B_i      ; i=8*n2
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; load xm1:xm
; -------------------------------------------------
         LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; load xa1:xa

         ADDSP .L2X  B_xa,       A_xm,      B_str1   ; str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; load sin:cos
||       SUB   .S2   B_i,        8,         B_i      ; i = i - 8
||       SUB   .S1X  A_n2_mul8,  B_i,       A_i      ; Save i for next cycle

         SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; str2 = xm1 + xa1
|| [!B_i]ADD   .S1   A_x,        A_n2_mul8, A_x      ; x_ptr = x_ptr + 2*n2

   [!B_i]MPY   .M2   B_n2_mul8,  1,         B_i      ; i=8*n2
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; itemp = xa1 -xm1
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; load xm1:xm
; ---------
         LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; load xa1:xa

         STW   .D1T2 B_str1,     *A_xtemp++          ; store str1
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; load sin:cos
||       SUB   .S2   B_i,        8,         B_i      ; i = i - 8
||       SUB   .S1X  A_n2_mul8,  B_i,       A_i      ; Save i for next cycle

         STW   .D1T2 B_str2,     *A_xtemp++          ; store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; cr = cos * rtemp
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; str2 = xm1 + xa1
|| [!B_i]ADD   .S1   A_x,        A_n2_mul8, A_x      ; x_ptr = x_ptr + 2*n2

         MPYSP .M1   A_s,        A_itemp,   A_si     ; si = sin * itemp
||       SUB   .S2   B_i1,       8,         B_i1     ; i1= i1-8
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; itemp = xa1 -xm1
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; load xm1:xm
|| [!B_i]MPY   .M2   B_n2_mul8,  1,         B_i      ; i=8*n2
; ---------

         MPYSP .M1   A_s,        A_rtemp,   A_sr     ; sr = sin * rtemp
||[!B_i1]ADD   .S1   A_xtemp,    A_n2_mul8, A_xtemp  ; x_temp = x_temp + 2*n2
||       LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; load xa1:xa

         MPYSP .M1   A_c,        A_itemp,   A_ci     ; ci = cos * itemp
||[!B_i1]MPY   .M2   B_n2_mul8,  1,         B_i1     ; i1=8*n2
||       STW   .D1T2 B_str1,     *A_xtemp++          ; store str1
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; load sin:cos
||       SUB   .S2   B_i,        8,         B_i      ; i = i - 8
||       SUB   .S1X  A_n2_mul8,  B_i,       A_i      ; Save i for next cycle

         STW   .D1T2 B_str2,     *A_xtemp++          ; store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; cr = cos * rtemp
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; str2 = xm1 + xa1
|| [!B_i]ADD   .S1   A_x,        A_n2_mul8, A_x      ; x_ptr = x_ptr + 2*n2

    [A_j]SUB   .S1   A_j,        1,         A_j      ; j = j - 1
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; si = sin * itemp
||       SUB   .S2   B_i1,       8,         B_i1     ; i1= i1-8
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; itemp = xa1 -xm1
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; load xm1:xm
|| [!B_i]MPY   .M2   B_n2_mul8,  1,         B_i      ; i=8*n2
; ---------
         SUBSP .L1   A_cr,       A_si,      A_str1   ; str1 = cr - si
||       MPYSP .M1   A_s,        A_rtemp,   A_sr     ; sr = sin * rtemp
||[!B_i1]ADD   .S1   A_xtemp,    A_n2_mul8, A_xtemp  ;x_temp = x_temp + 2*n2
||       LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; load xa1:xa

         ADDSP .L1   A_ci,       A_sr,      A_str2   ; str2 = ci + sr
||       MPYSP .M1   A_c,        A_itemp,   A_ci     ; ci = cos * itemp
||[!B_i1]MPY   .M2   B_n2_mul8,  1,         B_i1     ; i1=8*n2
||       STW   .D1T2 B_str1,     *A_xtemp++          ; store str1
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; load sin:cos
||       SUB   .S2   B_i,        8,         B_i      ; i = i - 8
||       SUB   .S1X  A_n2_mul8,  B_i,       A_i      ; Save i for next cycle

    [A_j]B     .S2   LOOP                            ; Branch to Inner Loop
||       STW   .D1T2 B_str2,     *A_xtemp++          ; store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; cr = cos * rtemp
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; str2 = xm1 + xa1
|| [!B_i]ADD   .S1   A_x,        A_n2_mul8, A_x      ; x_ptr = x_ptr + 2*n2

    [A_j]SUB   .S1   A_j,        1,         A_j      ; j = j - 1
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; si = sin * itemp
||       SUB   .S2   B_i1,       8,         B_i1     ; i1= i1-8
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; itemp = xa1 -xm1
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; load xm1:xm
|| [!B_i]MPY   .M2   B_n2_mul8,  1,         B_i      ; i=8*n2
; ---------
LOOP:

         STW   .D2T1 A_str1,     *B_xtemp1++         ; Store str1
||       SUB   .S2   B_i2,       8,         B_i2     ; i2 = i2 - 8
||       SUBSP .L1   A_cr,       A_si,      A_str1   ; str1 = cr - si
||       MPYSP .M1   A_s,        A_rtemp,   A_sr     ; sr = sin * rtemp
||[!B_i1]ADD   .S1   A_xtemp,    A_n2_mul8, A_xtemp  ; x_temp = x_temp + 2*n2
||       LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; load xa1:xa

         ADDSP .L1   A_ci,       A_sr,      A_str2   ; str2 = ci + sr
||       MPYSP .M1   A_c,        A_itemp,   A_ci     ; ci = cos * itemp
||[!B_i1]MPY   .M2   B_n2_mul8,  1,         B_i1     ; i1=8*n2
||       STW   .D1T2 B_str1,     *A_xtemp++          ; store str1
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; load sin:cos
||       SUB   .S2   B_i,        8,         B_i      ; i = i - 8
||       SUB   .S1X  A_n2_mul8,  B_i,       A_i      ; Save i for next cycle

         STW   .D2T1 A_str2,     *B_xtemp1++         ; store str2
|| [!B_i2]MPY   .M2   B_n2_mul8,  1,        B_i2     ; i2=8*n2
||  [A_j]B     .S2   LOOP                            ; Branch to Inner Loop
||       STW   .D1T2 B_str2,     *A_xtemp++          ; store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; cr = cos * rtemp
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; str2 = xm1 + xa1
|| [!B_i]ADD   .S1   A_x,        A_n2_mul8, A_x      ; x_ptr = x_ptr + 2*n2

  [!B_i2]ADD   .L2   B_xtemp1,   B_n2_mul8, B_xtemp1 ; x_temp1 = x_temp1 + 2*n2
||  [A_j]SUB   .S1   A_j,        1,         A_j      ; j = j - 1
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; si = sin * itemp
||       SUB   .S2   B_i1,       8, B_i1             ; i1= i1-8
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; itemp = xa1 -xm1
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; load xm1:xm
|| [!B_i]MPY   .M2   B_n2_mul8,  1,         B_i      ; i=8*n2
; -------------------------------------------------
         STW   .D2T1 A_str1,     *B_xtemp1++         ; Store str1
||       SUB   .S2   B_i2,       8,         B_i2     ; i2 = i2 - 8
||       SUBSP .L1   A_cr,       A_si,      A_str1   ; str1 = cr - si
||       MPYSP .M1   A_s,        A_rtemp,   A_sr     ; sr = sin * rtemp
||[!B_i1]ADD   .S1   A_xtemp,    A_n2_mul8, A_xtemp  ; x_temp = x_temp + 2*n2
||       LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; load xa1:xa

         ADDSP .L1   A_ci,       A_sr,      A_str2   ; str2 = ci + sr
||       MPYSP .M1   A_c,        A_itemp,   A_ci     ; ci = cos * itemp
||[!B_i1]MPY   .M2   B_n2_mul8,  1, B_i1             ; i1=8*n2
||       STW   .D1T2 B_str1,     *A_xtemp++          ; store str1
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; load sin:cos
||       SUB   .S2   B_i,        8,         B_i      ; i = i - 8
||       MV    .S1X  B_x,        A_x                 ; x_ptr=x

         STW   .D2T1 A_str2,     *B_xtemp1++         ; store str2
||[!B_i2]MPY   .M2   B_n2_mul8,  1,         B_i2     ; i2=8*n2
||       STW   .D1T2 B_str2,     *A_xtemp++          ; store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; cr = cos * rtemp
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; str2 = xm1 + xa1
||       SHL   .S1   A_n2,       1, A_n2             ; n2=>>1

  [!B_i2]ADD   .L2   B_xtemp1,   B_n2_mul8, B_xtemp1 ; x_temp1 = x_temp1 + 2*n2
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; si = sin * itemp
||       SUB   .S2   B_i1,       8,         B_i1     ; i1= i1-8
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; itemp = xa1 -xm1
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; load xm1:xm
|| [!B_i]MPY   .M2   B_n2_mul8,  2,         B_i      ; i=8*n2
||       SUB   .S1   A_n2_mul8,  8,         A_i      ; In the last it. B_i will be 8
; -------------------------------------------------
; --------------------- EPILOG --------------------
; -------------------------------------------------
         STW   .D2T1 A_str1,     *B_xtemp1++         ; E Store str1
||       SUB   .S2   B_i2,       8,         B_i2     ; E i2 = i2 - 8
||       SUBSP .L1   A_cr,       A_si,      A_str1   ; E str1 = cr - si
||       MPYSP .M1   A_s,        A_rtemp,   A_sr     ; E sr = sin * rtemp
||[!B_i1]ADD   .S1X  A_xtemp,    B_n2_mul8, A_xtemp  ; E x_temp = x_temp + 2*n2
||       LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; P load xa1:xa

         ADDSP .L1   A_ci,       A_sr,      A_str2   ; E str2 = ci + sr
||       MPYSP .M1   A_c,        A_itemp,   A_ci     ; E ci = cos * itemp
||[!B_i1]MPY   .M2   B_n2_mul8,  1,         B_i1     ; E i1=8*n2
||       STW   .D1T2 B_str1,     *A_xtemp++          ; E store str1
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; E str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; E load sin:cos
||       ZERO  .S1   A_i                             ; P i=0 as Initially w should be loaded

         STW   .D2T1 A_str2,     *B_xtemp1++         ; E store str2
||[!B_i2]MPY   .M2   B_n2_mul8,  1,         B_i2     ; E i2=8*n2
||       STW   .D1T2 B_str2,     *A_xtemp++          ; E store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; E cr = cos * rtemp
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; E rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; E str2 = xm1 + xa1

  [!B_i2]ADD   .L2   B_xtemp1,   B_n2_mul8, B_xtemp1 ; E x_temp1 = x_temp1 + 2*n2
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; E si = sin * itemp
||       SUB   .S2   B_i1,       8,         B_i1     ; E i1= i1-8
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; E itemp = xa1 -xm1
||       SHL   .S1   A_n2_mul8,  1,         A_n2_mul8; E N2=N2<<1
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; P load xm1:xm
||       MV    .D2   B_w,        B_wptr              ; load w

; ------------------------------------------------------------

         STW   .D2T1 A_str1,     *B_xtemp1++         ; E  Store str1
||       SUB   .S2   B_i2,       8,         B_i2     ; E i2 = i2 - 8
||       SUBSP .L1   A_cr,       A_si,      A_str1   ; E str1 = cr - si
||       MPYSP .M1   A_s,        A_rtemp,   A_sr     ; E sr = sin * rtemp
||[!B_i1]ADD   .S1X  A_xtemp,    B_n2_mul8, A_xtemp  ; E x_temp = x_temp + 2*n2
||       LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; P load xa1:xa

         ADDSP .L1   A_ci,       A_sr,      A_str2   ; E str2 = ci + sr
||       MPYSP .M1   A_c,        A_itemp,   A_ci     ; E ci = cos * itemp
||[!B_i1]MPY   .M2   B_n2_mul8,  1,         B_i1     ; E i1=8*n2
||       STW   .D1T2 B_str1,     *A_xtemp++          ; E store str1
||       SUB   .S2   B_i,        16,        B_i      ; P i = i - 8
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; P str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; P load sin:cos

         STW   .D2T1 A_str2,     *B_xtemp1++         ; E store str2
||[!B_i2]MPY   .M2   B_n2_mul8,  1,         B_i2     ; E i2=8*n2
||       STW   .D1T2 B_str2,     *A_xtemp++          ; E store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; E cr = cos * rtemp
|| [!B_i]ADD   .S1   A_x,        A_n2_mul8, A_x      ; P x_ptr = x_ptr + 2*n2
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; P rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; P str2 = xm1 + xa1
||       SHR   .S2   B_k,        1,         B_k      ; k =>> 1

  [!B_i2]ADD   .L2   B_xtemp1,   B_n2_mul8, B_xtemp1 ; E x_temp1 = x_temp1 + 2*n2
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; E si = sin * itemp
|| [!B_i]MPY   .M2   B_n2_mul8,  2,         B_i      ; P i=8*n2
||       LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; P load xm1:xm
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; P itemp = xa1 -xm1
||       MV    .D2   B_k,        B_i1                ; Get k

; -----------------------------------------------------------

         STW   .D2T1 A_str1,     *B_xtemp1++         ; E Store str1
||       SUB   .S2   B_i2,       8,         B_i2     ; E i2 = i2 - 8
||       SUBSP .L1   A_cr,       A_si,      A_str1   ; E str1 = cr - si
||       MPYSP .M1   A_s,        A_rtemp,   A_sr     ; E sr = sin * rtemp
||       MV    .S1X  B_x,        A_xtemp             ; E  x_temp=x
|| [B_i1]LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; P load xa1:xa

         ADDSP .L1   A_ci,       A_sr,      A_str2   ; E str2 = ci + sr
||       MPYSP .M1   A_c,        A_itemp,   A_ci     ; E ci = cos * itemp
||       SUB   .D2   B_i,        8,         B_i      ; P i = i - 8
||       SUB   .S1X  A_n2_mul8,  B_i,       A_i      ; P Save i for next cycle
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; P str1 = xm + xa
|| [B_i1]STW   .D1T2 B_str1,     *A_xtemp++          ; P store str1

         STW   .D2T1 A_str2,     *B_xtemp1++         ; E store str2
||[!B_i2]MPY   .M2   B_n2_mul8,  1,         B_i2     ; E i2=8*n2
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; P rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; P str2 = xm1 + xa1
|| [B_i1]STW   .D1T2 B_str2,     *A_xtemp++          ; P store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; P cr = cos * rtemp

  [!B_i2]ADD   .L2   B_xtemp1,   B_n2_mul8, B_xtemp1 ; E x_temp1 = x_temp1 + 2*n2
|| [B_i1]LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; P load xm1:xm
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; P itemp = xa1 -xm1
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; P si = sin * itemp

; ----------------------------------------------------
         STW   .D2T1 A_str1,     *B_xtemp1++         ; E Store str1
||       SUB   .S2   B_i2,       8,         B_i2     ; E i2 = i2 - 8
||       SUBSP .L1   A_cr,       A_si,      A_str1   ; E str1 = cr - si
|| [B_i1]LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; P load xa1:xa
||       MPYSP .M1   A_s,        A_rtemp,   A_sr     ; P sr = sin * rtemp

         ADDSP .L1   A_ci,       A_sr,      A_str2   ; E str2 = ci + sr
||       SUB   .S2   B_i,        8,         B_i      ; P i = i - 8
||       ADDSP .L2X  B_xa,       A_xm,      B_str1   ; P str1 = xm + xa
|| [!A_i]LDDW  .D2T1 *B_wptr++,  A_s:A_c             ; P load sin:cos
|| [B_i1]STW   .D1T2 B_str1,     *A_xtemp++          ; P store str1
||       MPYSP .M1   A_c,        A_itemp,   A_ci     ; P ci = cos * itemp
||       MPY   .M2   B_n2_mul8,  2,         B_i1     ; P  i1=8*n2
||  [B_i1]SUB   .S1X  B_n,       6,         A_j      ; j = n/2 - 6

         STW   .D2T1 A_str2,     *B_xtemp1++         ; E store str2
||[!B_i2]MPY   .M2   B_n2_mul8,  1,         B_i2     ; E i2=8*n2
|| [!B_i]ADD   .S1   A_x,        A_n2_mul8, A_x      ; P x_ptr = x_ptr + 2*n2
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; P rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; P str2 = xm1 + xa1
|| [B_i1]STW   .D1T2 B_str2,     *A_xtemp++          ; P store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; P cr = cos * rtemp
||  [A_j]B     .S2   LOOP                            ; P Branch to Inner Loop

  [!B_i2]ADD   .L2   B_xtemp1,   B_n2_mul8, B_xtemp1 ; E x_temp1 = x_temp1 + 2*n2
|| [!B_i]MPY   .M2   B_n2_mul8,  2,         B_i      ; P i=8*n2
||  [A_j]LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; P load xm1:xm
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; P itemp = xa1 -xm1
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; P si = sin * itemp
||       SUB   .S2   B_i1,       16,        B_i1     ; P i1= i1-16, 16 as last one was removed
||  [A_j]SUB   .S1   A_j,        1,         A_j      ; P j = j - 1
;------------------------------------------------------
         STW   .D2T1 A_str1,     *B_xtemp1++         ; E Store str1
||  [A_j]LDDW  .D1T2 *A_x++,     B_xa1:B_xa          ; P load xa1:xa
||       MPYSP .M1   A_s,        A_rtemp,   A_sr     ; P sr = sin * rtemp
||[!B_i1]ADD   .S1   A_xtemp,    A_n2_mul8, A_xtemp  ; P x_temp = x_temp + 2*n2
||       SUBSP .L1   A_cr,       A_si,      A_str1   ; P str1 = cr - si
||       MPY   .M2   B_n2_mul8,  2,         B_n2_mul8; n2 = n2 << 1

         SUB   .S2   B_i,        8,         B_i      ; P i = i - 8
||       SUB   .S1X  A_n2_mul8,  B_i,       A_i      ; P Save i for next cycle
||       ADDSP .L2X  B_xa, A_xm, B_str1              ; P str1 = xm + xa
||  [A_j]STW   .D1T2 B_str1,     *A_xtemp++          ; P store str1
||       MPYSP .M1   A_c,        A_itemp,   A_ci     ; P ci = cos * itemp
||[!B_i1]MPY   .M2   B_n2_mul8,  2,         B_i1     ; P i1=8*n2
||       ADDSP .L1   A_ci,       A_sr,      A_str2   ; P str2 = ci + sr

         STW   .D2T1 A_str2,     *B_xtemp1++         ; E store str2
||       MPY   .M2   B_n2_mul8,  1,         B_i2     ; E i2=8*n2
||       SUBSP .L1X  B_xa,       A_xm,      A_rtemp  ; P rtemp = xa -xm
||       ADDSP .L2X  B_xa1,      A_xm1,     B_str2   ; P str2 = xm1 + xa1
||  [A_j]STW   .D1T2 B_str2,     *A_xtemp++          ; P store str2
||       MPYSP .M1   A_c,        A_rtemp,   A_cr     ; P cr = cos * rtemp
||  [A_j]B     .S2   LOOP                            ; P Branch to Inner Loop

         ADD   .L2   B_x,        B_n2_mul8, B_xtemp1 ; E  ;x_temp1=x+2*n2
||  [A_j]LDDW  .D1T1 *A_x[A_n2], A_xm1:A_xm          ; P load xm1:xm
||       SUBSP .L1X  B_xa1,      A_xm1,     A_itemp  ; P itemp = xa1 -xm1
||       MPYSP .M1   A_s,        A_itemp,   A_si     ; P si = sin * itemp
||       SUB   .S2   B_i1,       8, B_i1             ; P i1= i1-8
||  [A_j]SUB   .S1   A_j,        1, A_j              ; P j = j - 1
; --------------------------------------------------

         MVC   .S2   B_CSR,      CSR                 ; Enable Interrupt
||       LDW   .D2T1 *B_SP[6],   A_str1              ; Restore register
||       MV    .S1X  B_SP,       A_SP                ; Copy Stack Pointer

         LDW   .D2T1 *B_SP[1],   A_rtemp             ; Restore register
||       LDW   .D1T2 *A_SP[7],   B_x                 ; Restore register

         LDW   .D2T1 *B_SP[2],   A_itemp             ; Restore register
||       LDW   .D1T2 *A_SP[8],   B_w                 ; Restore register

         LDW   .D2T1 *B_SP[3],   A_cr                ; Restore register
||       LDW   .D1T2 *A_SP[9],   B_k                 ; Restore register

         LDW   .D2T1 *B_SP[4],   A_si                ; Restore register
||       LDW   .D1T2 *A_SP[10],  B_n                 ; Restore register
||       B     .S2   B_RET_ADDR

         LDW   .D2T1 *B_SP[5],   A_sr                ; Restore register
||       LDW   .D1T2 *A_SP[11],  B_CSR               ; Restore register

         ADDAW .D2   B_SP,         12,        B_SP     ; Restore Stack Space

         NOP         3

                .end

* ======================================================================== *
*  End of file: DSPF_sp_icfftr2_dif.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fir_cpl/1117057344  165   0     0       21886     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                    * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        void DSPF_sp_fir_cplx(                                                  * 
*                         const float * restrict x,                         * 
*                         const float * restrict h,                         * 
*                         float *       restrict r,                         * 
*                         int   nh,                                         * 
*                         int   nr                                          * 
*                        )                                                  * 
*             x[2*(nr+nh-1)]:Pointer to complex Input array.                * 
*                            The input data pointer x must point to the     * 
*                            (nh)th complex element, i.e. element 2*(nh-1). * 
*             h[2*nh]:       Pointer to complex Coefficient array           * 
*                            (in normal order).                             * 
*             r[2*nr]:       Pointer to complex Output array.               * 
*             nh:            Number of complex coefficients in vector h.    * 
*             nr:            Number of complex output samples to calculate. * 
*                                                                           * 
*  DESCRIPTION                                                              * 
*        This function implements the FIR filter for complex input data.    * 
*        The filter has nr output samples and nh coefficients. Each array   * 
*        consists of an even and odd term with even terms representing the  * 
*        real part and the odd terms the imaginary part of the element.     * 
*        The coefficients are expected in normal order.                     * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*        The outer loop is unrolled twice.                                  * 
*        Outer loop instructions are executed in parallel with inner loop.  * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*        1. nr is a multiple of 2 and greater than or equal to 2.           * 
*        2. nh is greater than or equal to 5.                               * 
*        3. x and h are double word aligned.                                * 
*        4. x points to 2*(nh-1)th input element.                           * 
*                                                                           * 
*  C CODE                                                                   * 
*                                                                           * 
*        void DSPF_sp_fir_cplx_cn(float * x, float * h, float * r,               * 
*                                                  int nh, int nr)          * 
*             {                                                             * 
*                     int i,j;                                              * 
*                     float imag, real;                                     * 
*                     for (i = 0; i < 2*nr; i += 2)                         * 
*                         {                                                 * 
*                         imag = 0;                                         * 
*                         real = 0;                                         * 
*                         for (j = 0; j < 2*nh; j += 2)                     * 
*                             {                                             * 
*                             real += h[j] * x[i-j] - h[j+1] * x[i+1-j];    * 
*                             imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];    * 
*                             }                                             * 
*                         r[i] = real;                                      * 
*                         r[i+1] = imag;                                    * 
*                         }                                                 * 
*             }                                                             * 
*                                                                           * 
*        This is the C equivalent of the assembly code.  Note that          * 
*        the assembly code is hand optimized and restrictions may apply.    * 
*                                                                           * 
*  NOTES                                                                    * 
*  CYCLES                                                                   * 
*        2 * nh * nr + 33                                                   * 
*        For nh=24 and nr=64, cycles=3105                                   * 
*        For nx=32 and nr=64, cycles=4129                                   * 
*                                                                           * 
*  CODESIZE                                                                 * 
*        640 bytes                                                          * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_fir_cplx
_DSPF_sp_fir_cplx:

* ======================================================================== *
* ======================================================================== *

        .asg    B15,       B_SP
        .asg    A0,        A_SP
        .asg    A4,        A_x
        .asg    B4,        B_h
        .asg    A8,        A_h_ptr
        .asg    A5,        A_x_ptr
        .asg    B5,        B_h_ptr
        .asg    A6,        A_r
        .asg    B8,        B_r
        .asg    A8,        A_nr
        .asg    A1,        A_nr1
        .asg    B6,        B_nh
        .asg    B0,        B_ictr
        .asg    A11,       A_x1
        .asg    A10,       A_x0
        .asg    B11,       B_h1
        .asg    B10,       B_h0
        .asg    A13,       A_x3
        .asg    A12,       A_x2
        .asg    A14,       A_h1
        .asg    B13,       B_x3
        .asg    B12,       B_x2
        .asg    A9,        A_prod2
        .asg    B9,        B_prod1
        .asg    B7,        B_real
        .asg    A7,        A_real1
        .asg    B7,        B_imag
        .asg    A7,        A_imag1
        .asg    B7,        B_real2
        .asg    A7,        A_real3
        .asg    B7,        B_imag2
        .asg    A7,        A_imag3
        .asg    A3,        A_zero
        .asg    B12,       B_zero
        .asg    B0,        B_real_t
        .asg    B1,        B_imag_t
        .asg    A0,        A_real3_t
        .asg    A3,        A_imag3_t
        .asg    B1,        B_rstflg
        .asg    A2,        A_ldflg
        .asg    B3,        B_RET
        .asg    B2,        B_CSR_store
        .asg    B1,        B_CSR_tmp
        
        
              SUBAW .D2   B_SP,          20, B_SP           ; Save stack space  
||            MVC   .S2   CSR,           B_CSR_store        ; Get CSR

              MV    .L1X  B_SP,          A_SP               ; Copy stack pointer
||            STW   .D2T1 A_x0,          *+B_SP[1]          ; Save a10
||            MV    .S1   A_x,           A_x_ptr            ; Copy x pointer
||            MV    .S2   B_h,           B_h_ptr            ; Copy h pointer
||            MV    .L2X  A_r,           B_r                ; Copy r pointer

              STW   .D2T1 A_x1,          *+B_SP[2]          ; Save a11
||            STW   .D1T2 B_h0,          *+A_SP[6]          ; Save b10
||            ADD   .S1   A_r,           8,        A_r            ; r = r+8
||            MV    .L1   A_nr,          A_nr1              ; Copy nr
||            AND   .S2   B_CSR_store,   -2,       B_CSR_tmp; Disable GIE bit

              STW   .D2T1 A_x2,          *+B_SP[3]          ; Save a12
||            STW   .D1T2 B_h1,          *+A_SP[7]          ; Save b11
||            MV    .S1X  B_h,           A_h_ptr            ; Copy h pointer

              STW   .D2T1 A_x3,          *+B_SP[4]          ; Save a13
||            STW   .D1T2 B_x2,          *+A_SP[8]          ; Save b12 

              STW   .D2T1 A_h1,          *+B_SP[5]          ; Save a14
||            STW   .D1T2 B_x3,          *+A_SP[9]          ; Save b13
||            MVC   .S2   B_CSR_tmp,     CSR                ; Disable Interrupt

; -----------------------------------------------------------
; ********************** LOOP PROLOG ************************
; -----------------------------------------------------------
              LDDW  .D1T1 *A_x_ptr++,    A_x1:A_x0          ; load x[i-j+1]:x[i-j]
        
              LDDW  .D2T2 *B_h_ptr++,    B_h1:B_h0          ; load h[j+1]:h[j]

              LDDW  .D1T1 *A_x_ptr--[2], A_x3:A_x2          ; load x[i-j+3]:x[i-j+2]
        
              NOP

              LDDW  .D1T1 *A_x_ptr++,    A_x1:A_x0          ; load x[i-j+1]:x[i-j]

              LDDW  .D2T2 *B_h_ptr++,    B_h1:B_h0          ; load h[j+1]:h[j]

              LDDW  .D1T1 *A_x_ptr--[2], A_x3:A_x2          ; load x[i-j+3]:x[i-j+2]
||            MPYSP .M2X  B_h0,          A_x0,     B_prod1  ; h[j] * x[i-j]
||            MPYSP .M1X  B_h1,          A_x1,     A_prod2  ; h[j+1] * x[i+1-j]
        
              MPYSP .M2X  B_h0,          A_x1,     B_prod1  ; h[j] * x[i+1-j]
||            MPYSP .M1X  B_h1,          A_x0,     A_prod2  ; h[j+1] * x[i-j]


              LDDW  .D1T1 *A_x_ptr++,    A_x1:A_x0          ; load x[i-j+1]:x[i-j]
||            MPYSP .M2X  B_h0,          A_x2,     B_prod1  ; h[j] * x[i-j+2]
||            MPYSP .M1X  B_h1,          A_x3,     A_prod2  ; h[j+1] * x[i+1-j+2] 
||            B     .S1   LOOP                              ; Branch to loop 
||            ZERO  .S2   B_real                            ; Initialise Accumulator
||[A_nr1]     SUB   .L1   A_nr1,         2,        A_nr1    ; Update Outer loop ctr

              LDDW  .D2T2 *B_h_ptr++,    B_h1:B_h0          ; load h[j+1]:h[j]
||            MPYSP .M2X  B_h0,          A_x3,     B_prod1  ; h[j] * x[i+1-j+2]
||            MPYSP .M1X  B_h1,          A_x2,     A_prod2  ; h[j+1] * x[i-j+2]
||            SUB   .S2   B_nh,          2,        B_ictr   ; Inner loop counter
||            SUB   .L2   B_nh,          2,        B_rstflg ; Flag for reseting ptrs
||            ZERO  .S1   A_real1                           ; Initialise Accumulator
||[A_nr1]     ADDAD .D1   A_x,           2, A_x             ; x += 2

; ----------------------------------------------------------
; ****************** LOOP KERNEL ***************************
; ----------------------------------------------------------

LOOP:
              LDDW  .D1T1 *A_x_ptr--[2], A_x3:A_x2          ; load x[i-j+3]:x[i-j+2]
||            MPYSP .M2X  B_h0,          A_x0,     B_prod1  ; h[j] * x[i-j]
||            MPYSP .M1X  B_h1,          A_x1,     A_prod2  ; h[j+1] * x[i+1-j]
||            ADDSP .L2   B_real,        B_prod1,  B_real   ; real += (h[j] * x[i-j])
||            ADDSP .L1   A_real1,       A_prod2,  A_real1  ; real1+= (h[j+1] * x[i+1-j])
||[B_rstflg]  SUB   .S2   B_rstflg,      1,        B_rstflg ; Update flag

  [!B_rstflg] LDDW  .D1T2 *-A_x[1],      B_x3:B_x2          ; load x[i-j+1]:x[i-j](duplicate)
||            MPYSP .M2X  B_h0, A_x1,    B_prod1            ; h[j] * x[i+1-j]
||            MPYSP .M1X  B_h1, A_x0,    A_prod2            ; h[j+1] * x[i-j]
||            ADDSP .L2   B_imag,        B_prod1,  B_imag   ; imag += (h[j] * x[i+1-j])
||            ADDSP .L1   A_imag1,       A_prod2,  A_imag1  ; imag1+= (h[j+1] * x[i-j])
||[!B_rstflg] MV    .S2   B_h,           B_h_ptr            ; reset h_ptr
||[!B_rstflg] MV    .S1   A_x,           A_x_ptr            ; reset x_ptr

              LDDW  .D1T1 *A_x_ptr++,    A_x1:A_x0          ; load x[i-j+1]:x[i-j]
||            MPYSP .M2X  B_h0, A_x2,    B_prod1            ; h[j] * x[i-j+2]
||            MPYSP .M1X  B_h1, A_x3,    A_prod2            ; h[j+1] * x[i+1-j+2]
||            ADDSP .L2   B_real2,       B_prod1,  B_real2  ; real2 += (h[j] * x[i-j+2])
||            ADDSP .L1   A_real3,       A_prod2,  A_real3  ; real3 += (h[j+1] * x[i+1-j+2])
||[B_ictr]    SUB   .S2   B_ictr,        1,        B_ictr   ; Update inner loop ctr
||[B_ictr]    B     .S1   LOOP                              ; Branch to inner loop

              LDDW  .D2T2 *B_h_ptr++,    B_h1:B_h0          ; load h[j+1]:h[j]
||[!B_rstflg] LDW   .D1T1 *+A_h_ptr[3],  A_h1               ; h[j+1] forremoving cross path        
||            MPYSP .M2X  B_h0, A_x3,    B_prod1            ; h[j] * x[i+1-j+2]
||            MPYSP .M1X  B_h1, A_x2,    A_prod2            ; h[j+1] * x[i-j+2]
||            ADDSP .L2   B_imag2,       B_prod1,  B_imag2  ; imag2 += (h[j] * x[i+1-j+2])
||            ADDSP .L1   A_imag3,       A_prod2,  A_imag3  ; imag3 += (h[j+1] * x[i-j+2])
||[!B_rstflg] MVK   .S2   3,             B_rstflg           ; For not resetting more than once
||            ZERO  .S1   A_zero                            ; for init. acc. for next iteration

; LOOP ENDS HERE 
; -----------------------------------------------------------
;************** PIPED LOOP EPILOG ****************
; -----------------------------------------------------------

              LDDW  .D1T1 *A_x_ptr--[2], A_x3:A_x2          ; load x[i-j+3]:x[i-j+2]     
||            MPYSP .M2   B_h0,          B_x2,     B_prod1  ; h[j] * x[i-j]
||            MPYSP .M1X  A_h1,          B_x3,     A_prod2  ; h[j+1] * x[i+1-j]
||            SUBSP .L2X  B_real,        A_real1,  B_real   ; real = real - real1        
||            ADDSP .L1   A_prod2,       A_zero,   A_real1  ; real1 = (h[j+1] * x[i+1-j])
||            MV    .D2   B_prod1,       B_real_t           ; real  = (h[j] * x[i-j])

              MPYSP .M2   B_h0,          B_x3,     B_prod1  ; h[j] * x[i+1-j]       
||            MPYSP .M1X  A_h1,          B_x2,     A_prod2  ; h[j+1] * x[i-j]
||            ADDSP .L2X  B_imag,        A_imag1,  B_imag   ; imag = imag + imag1
||            ADDSP .L1   A_prod2,       A_zero,   A_imag1  ; imag1 = (h[j+1] * x[i-j])
||            MV    .D2   B_prod1,       B_imag_t           ; imag  = (h[j] * x[i+1-j])
||            ZERO  .S2   B_zero                            ; for init. acc. for next iteration

              LDDW  .D1T1 *A_x_ptr++,    A_x1:A_x0          ; load x[i-j+1]:x[i-j]
||            MPYSP .M2X  B_h0, A_x2,    B_prod1            ; h[j] * x[i-j+2]
||            MPYSP .M1   A_h1, A_x3,    A_prod2            ; h[j+1] * x[i+1-j+2]
||            SUBSP .L1X  B_real2,       A_real3,  A_real3  ; real2 = real2 - real3
||            ADDSP .L2   B_prod1,       B_zero,   B_real2  ; real2 = (h[j] * x[i-j+2])
||            MV    .S1   A_prod2,       A_real3_t          ; real3 = (h[j+1] * x[i+1-j+2])
||[A_nr1]     B     .S2   LOOP                              ; Branch to inner loop

              LDDW  .D2T2 *B_h_ptr++,    B_h1:B_h0          ; load h[j+1]:h[j]
||            MPYSP .M2X  B_h0, A_x3,    B_prod1            ; h[j] * x[i+1-j+2]
||            MPYSP .M1   A_h1, A_x2,    A_prod2            ; h[j+1] * x[i-j+2]
||            ADDSP .L1X  A_imag3,       B_imag2,  A_imag3  ; imag2 = imag2 + imag3
||            ADDSP .L2   B_prod1,       B_zero,   B_imag2  ; imag2 = (h[j] * x[i+1-j+2])
||            MV    .D1   A_prod2,       A_imag3_t          ; imag3 = (h[j+1] * x[i-j+2])
        
; ------------------------------------------- 

              LDDW  .D1T1 *A_x_ptr--[2], A_x3:A_x2          ; load x[i-j+3]:x[i-j+2] 
||            STW   .D2T2 B_real,        *B_r++             ; Store real
||            MPYSP .M2X  B_h0, A_x0,    B_prod1            ; h[j] * x[i-j]
||            MPYSP .M1X  B_h1, A_x1,    A_prod2            ; h[j+1] * x[i+1-j]
||            ADDSP .L2   B_real_t,      B_prod1,  B_real   ; real += (h[j] * x[i-j])
||            ADDSP .L1   A_real1,       A_prod2,  A_real1  ; real1+= (h[j+1] * x[i+1-j])
||[A_nr1]     SUB   .S1   A_nr1,         2,        A_ldflg  ; Flag for speculative loads

        
              LDDW  .D1T1 *A_x_ptr++,    A_x1:A_x0          ;load x[i-j+1]:x[i-j]
||            STW   .D2T2 B_imag,        *B_r++[3]          ; Store real2
||            MPYSP .M2X  B_h0,          A_x1,     B_prod1  ; h[j] * x[i+1-j]   
||            MPYSP .M1X  B_h1,          A_x0,     A_prod2  ; h[j+1] * x[i-j]
||            ADDSP .L2   B_imag_t,      B_prod1,  B_imag   ; imag += (h[j] * x[i+1-j])
||            ADDSP .L1   A_imag1,       A_prod2,  A_imag1  ; imag1+= (h[j+1] * x[i-j])
||            SUB   .S2   B_nh,          4,        B_rstflg ; Flag for reseting pointers
||[A_ldflg]   ADD   .S1   A_x,           8,        A_x      ; x += 1

              STW   .D1T1 A_real3,       *A_r++             ; Store imag
||            MPYSP .M2X  B_h0,          A_x2,     B_prod1  ; h[j] * x[i-j+2]
||            MPYSP .M1X  B_h1,          A_x3,     A_prod2  ; h[j+1] * x[i+1-j+2]
||            ADDSP .L2   B_real2,       B_prod1,  B_real2  ; real2 += (h[j] * x[i-j+2])
||            ADDSP .L1   A_real3_t,     A_prod2,  A_real3  ; real3 += (h[j+1] * x[i+1-j+2])        
||[A_ldflg]   ADD   .S1   A_x,           8, A_x             ; x += 1
||[A_nr1]     B     .S2   LOOP                              ; Branch to inner loop
        
              LDDW  .D2   *B_h_ptr++,    B_h1:B_h0          ; load h[j+1]:h[j]
||            STW   .D1T1 A_imag3,       *A_r++[3]          ; Store imag2
||            MPYSP .M2X  B_h0,          A_x3,     B_prod1  ; h[j] * x[i+1-j+2]
||            MPYSP .M1X  B_h1,          A_x2,     A_prod2  ; h[j+1] * x[i-j+2]
||            ADDSP .L2   B_imag2,       B_prod1,  B_imag2  ; imag2 += (h[j] * x[i+1-j+2])
||            ADDSP .L1   A_imag3_t,     A_prod2,  A_imag3  ; imag3 += (h[j+1] * x[i-j+2])
||            SUB   .S2   B_nh,          4,        B_ictr   ; Inner loop ctr
||[A_nr1]     SUB   .S1   A_nr1,         2,        A_nr1    ; Update Outer loop ctr

;--------------------------------------------------------    

              LDW   .D2T1 *+B_SP[1],     A_x0               ; Restore a10
||            MV    .S1X  B_SP,          A_SP               ; Copy stack pointer
||            MVC   .S2   B_CSR_store,   CSR                ; Enable Interrupts

              LDW   .D2T1 *+B_SP[2],     A_x1               ; Restore a11    
||            LDW   .D1T2 *+A_SP[6],     B_h0               ; Restore b10   

              LDW   .D2T1 *+B_SP[3],     A_x2               ; Restore a12    
||            LDW   .D1T2 *+A_SP[7],     B_h1               ; Restore b11            

              LDW   .D2T1 *+B_SP[4],     A_x3               ; Restore a13
||            LDW   .D1T2 *+A_SP[8],     B_x2               ; Restore b12            
||            B     .S2   B_RET                             ; Branch to the caller

              LDW   .D2T1 *+B_SP[5],     A_h1               ; Restore a14   
||            LDW   .D1T2 *+A_SP[9],     B_x3               ; Restore b13        


              ADDAW .D2  B_SP,           20,       B_SP     ; Restore stack
        
              NOP   3                

                .end

* ======================================================================== *
*  End of file: DSPF_sp_fir_cplx.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_fir_gen/1117057345  187   0     0       20563     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*    USAGE                                                                  * 
*                                                                           * 
*    This routine is C Callable and can be called as:                       * 
*                                                                           * 
*        void sp_firgen(const float *x, const float *h, float * restrict r, * 
*                   int nh, int nr);                                        * 
*                                                                           * 
*        x : Pointer to array holding the input floating point array        * 
*        h : Pointer to array holding the coefficient floating point        * 
*            array                                                          * 
*        y : Pointer to array holding the output floating point array       * 
*        nh: Number of coefficents                                          * 
*        nr: Number of output values                                        * 
*                                                                           * 
*    DESCRIPTION                                                            * 
*                                                                           * 
*        This routine implements a block FIR filter.  There are "nh"        * 
*        filter coefficients, "nr" output samples, and "nh+nr-1"            * 
*        input samples.    The coefficients need to be placed in the "h"    * 
*        array in reverse order {h(nh-1), ... , h(1), h(0)} and the         * 
*        array "x" starts at x(-nh+1) and ends at x(nr-1).  The             * 
*        routine calculates y(0) through y(nr-1) using the following        * 
*        formula:                                                           * 
*                                                                           * 
*        y(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           * 
*                                                                           * 
*        where n = {0, 1, ... , nr-1}.                                      * 
*    TECHNIQUES                                                             * 
*                                                                           * 
*        1.  LDDW instructions are used to load two SP floating point       * 
*            values simultaneously for the x and h arrays.                  * 
*        2.  The outer loop is unrolled 4 times.                            * 
*        3.  The inner loop is unrolled 2 times and software pipelined.     * 
*        4.  The variables prod1, prod3, prod5, and prod7 share A9.         * 
*            The variables prod0, prod2, prod4, and prod6 share B6.         * 
*            The variables sum1, sum3, sum5, and sum7 share A7.             * 
*            The variables sum0, sum2, sum4, and sum6 share B7.             * 
*            This multiple assignment is possible since the variables       * 
*            are always read just once on the first cycle that they         * 
*            are availble.                                                  * 
*        5.  The first 8 cycles of the inner loop prolog are                * 
*            conditionally scheduled in parallel with the outer loop.       * 
*            This increases the code size by 14 words, but                  * 
*            improves the cycle time.                                       * 
*        6.  A load counter is used so that an epilog is not needed.        * 
*            No extraneous loads are performed.                             * 
*        7.  The variables ptr_h and ptr_x are conditionally reset on       * 
*            the last cycle of the kernel loop when the loop counter        * 
*            reaches zero.  Since the loop counter is zero for the last     * 
*            two iterations, the instructions decrement the pointers        * 
*            by half of the desired value on each iteration.                * 
*                                                                           * 
*    ASSUMPTIONS                                                            * 
*                                                                           * 
*        1.  Little Endian is assumed for LDDW instructions.                * 
*        2.  The number of coefficients must be greater than or equal to 4. * 
*        3.  The number of outputs must be greater than or equal to 4       * 
*        4.  Since single assignment of registers is not used,              * 
*            interrupts should be disabled before this function is          * 
*            called.                                                        * 
*    C CODE                                                                 * 
*        This is the C equivalent for the assembly code.  Note that         * 
*        the assembly code is hand optimized and restrictions may           * 
*        apply.                                                             * 
*                                                                           * 
*        void DSPF_sp_fir_gen(const float *x, const float *h, float * restrict r * 
*                    int nh, int nr)                                        * 
*        {                                                                  * 
*           int i, j;                                                       * 
*           float sum;                                                      * 
*                                                                           * 
*           for(j=0; j < nh; j++)                                           * 
*           {                                                               * 
*              sum = 0;                                                     * 
*              for(i=0; i < nr; i++)                                        * 
*              {                                                            * 
*                  sum += x[i+j] * h[i];                                    * 
*              }                                                            * 
*              r[j] = sum;                                                  * 
*           }                                                               * 
*        }                                                                  * 
*                                                                           * 
*    NOTES                                                                  * 
*                                                                           * 
*        The x, h, and r arrays should be placed on the same double-        * 
*        word boundary (i.e. r, x and h on even double-word boundaries)     * 
*        to prevent internal data memory bank hits.                         * 
*                                                                           * 
*    CYCLES                                                                 * 
*                                                                           * 
*        (4*floor((nh-1)/2)+14)*(ceil(nr/4)) + 8                            * 
*                                                                           * 
*    CODESIZE                                                               * 
*                                                                           * 
*        640 bytes                                                          * 
*                                                                           * 
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ================ SYMBOLIC REGISTER ASSIGNMENTS ========================== *

              .asg A4,             A_x_ptr
              .asg B8,             B_x_ptr
              .asg A8,             A_h_ptr
              .asg A11,            A_fl_one
              .asg B1,             B_x1
              .asg B0,             B_x0
              .asg A5,             A_h1
              .asg A4,             A_h0
              .asg B5,             B_x3
              .asg B4,             B_x2
              .asg A3,             A_x4
              .asg A7,             A_sum1
              .asg A7,             A_sum3
              .asg A7,             A_sum5
              .asg A7,             A_sum7
              .asg B7,             B_sum0
              .asg B7,             B_sum2
              .asg B7,             B_sum4
              .asg B7,             B_sum6
              .asg A9,             A_prod1
              .asg B6,             B_prod0
              .asg A9,             A_prod3
              .asg B6,             B_prod2
              .asg A9,             A_prod5
              .asg B6,             B_prod4
              .asg A9,             A_prod7
              .asg B6,             B_prod6
              .asg B2,             B_icntr
              .asg A1,             A_ldreset
              .asg B1,             B_odd
              .asg A9,             A_sum7temp
              .asg A1,             A_lastouter
              .asg A2,             A_ocntr
              .asg A3,             A_cnteq4
              .asg A3,             A_ldresetcopy
              
*=========================================================================== *  

        .text
        .global _DSPF_sp_fir_gen
_DSPF_sp_fir_gen:

*================= PIPED LOOP PROLOG ======================================= *

       LDDW   .D1     *A_x_ptr++[1],B_x1:B_x0         ; load x1:x0 from memory
||     MV     .L1X    B4,         A_h_ptr             ; h_ptr = h
||     MV     .S1     A8,         A_ocntr             ; copy outer loop cntr 
||     ADD    .L2     B6,         1,        B_icntr   ; make icntr mult of 2
||     STW    .D2T1   A11,        *B15--              ; push A11
||     MVC    .S2     CSR,        B9

       LDDW   .D1     *A_h_ptr++[1],A_h1:A_h0         ; load h1:h0 from memory
||     MV     .L2X    A_x_ptr,    B_x_ptr             ; f ptr_x = x
||     SHR    .S2     B_icntr,    1,        B_icntr   ; f ireset = numH - 4
||     MV     .L1X    B3,         A0                  ; save ret address
||     STW    .D2     B9,         *B15

       LDDW   .D2     *B_x_ptr,   B_x3:B_x2           ; load x3:x2 from memory
||     SUB    .L1     B_icntr,    2,        A_ldreset ; lcntr = ireset
||     MV     .S2     B6,         B3                  ; save inner loop cnt
||     ZERO   .D1     A_fl_one                        ; init constant
||     AND    .L2     B9,         -2,       B9        ; disable interrupts

       LDW    .D2     *+B_x_ptr[2],A_x4               ; load x4 from memory
||     MVKH   .S1     0x3f800000, A_fl_one            ; move float 1
||     MVC    .S2     B9,         CSR

       LDDW   .D2     *B_x_ptr++[1],B_x1:B_x0         ; load x1:x0 from memory
||     SHL    .S2     B_icntr,    3,        B9        ; B9 = (nh) << 3

       LDDW   .D1     *A_h_ptr++[1],A_h1:A_h0         ; load h1:h0 from memory

       LDDW   .D2     *B_x_ptr,   B_x3:B_x2           ; load x3:x2 from memory
||     MPYSP  .M1X    B_x1,       A_h1,     A_prod1   ; prod1 = x1 * h1
||     MPYSP  .M2X    B_x0,       A_h0,     B_prod0   ; prod0 = x0 * h0

       LDW    .D2     *+B_x_ptr[2],A_x4               ; load x4 from memory
||     MPYSP  .M1X    B_x2,       A_h1,     A_prod3   ; prod3 = x2 * h1
||     MPYSP  .M2X    B_x1,       A_h0,     B_prod2   ; prod2 = x1 * h0
||     SUB    .S2     B_icntr,    2,        B_icntr   ; due to epilog

oloop:

  [A_ldreset]LDDW   .D2     *B_x_ptr++[1],B_x1:B_x0   ; load x1:x0 from memory
||     MPYSP  .M1X    B_x3,       A_h1,     A_prod5   ; prod5 = x3 * h1
||     MPYSP  .M2X    B_x2,       A_h0,     B_prod4   ; prod4 = x2 * h0
||[B_icntr]B  .S1     loop                            ; if(icntr) branch to LOOP
||[B_icntr]SUB.S2     B_icntr,    1,        B_icntr   ; decr cntr   

  [A_ldreset]LDDW   .D1     *A_h_ptr++[1],A_h1:A_h0   ; load h1:h0 from memory
||     MPYSP  .M1     A_x4,       A_h1,     A_prod7   ; prod7 = x4 * h1
||     MPYSP  .M2X    B_x3,       A_h0,     B_prod6   ; prod6 = x3 * h0
||     ZERO   .S1     A_sum1                          ; sum1 = 0
||     ZERO   .S2     B_sum0                          ; sum0 = 0

*======================= PIPE LOOP KERNEL ==================================*

loop:

  [A_ldreset]LDDW   .D2     *B_x_ptr,   B_x3:B_x2     ; load x3:x2 from memory
||     MPYSP  .M1X    B_x1,       A_h1,     A_prod1   ; prod1 = x1 * h1
||     MPYSP  .M2X    B_x0,       A_h0,     B_prod0   ; prod0 = x0 * h0
||     ADDSP  .L1     A_sum1,     A_prod1,  A_sum1    ; sum1 = prod1 + sum1
||     ADDSP  .L2     B_sum0,     B_prod0,  B_sum0    ; sum0 = prod0 + sum0

  [A_ldreset]LDW    .D2     *+B_x_ptr[2],A_x4         ; load x4 from memory
||     MPYSP  .M1X    B_x2,       A_h1,     A_prod3   ; prod3 = x2 * h1
||     MPYSP  .M2X    B_x1,       A_h0,     B_prod2   ; prod2 = x1 * h0
||     ADDSP  .L1     A_sum3,     A_prod3,  A_sum3    ; sum3 = prod3 + sum3
||     ADDSP  .L2     B_sum2,     B_prod2,  B_sum2    ; sum2 = prod2 + sum2
||[A_ldreset]SUB.S1   A_ldreset,  1,        A_ldreset ; if(lcntr) lcntr -= 1
||     AND    .S2     B3,         1,        B_odd     ; for odd nh

  [A_ldreset]LDDW   .D2     *B_x_ptr++[1],B_x1:B_x0   ; load x1:x0 from memory
||     MPYSP  .M1X    B_x3,       A_h1,     A_prod5   ; prod5 = x3 * h1
||     MPYSP  .M2X    B_x2,       A_h0,     B_prod4   ; prod4 = x2 * h0
||     ADDSP  .L1     A_sum5,     A_prod5,  A_sum5    ; sum5 = prod5 + sum5
||     ADDSP  .L2     B_sum4,     B_prod4,  B_sum4    ; sum4 = prod4 + sum4
||[B_icntr]B      .S2     loop                        ; if(icntr) branch to LOOP

  [A_ldreset]LDDW   .D1     *A_h_ptr++[1],A_h1:A_h0   ; load h1:h0 from memory
||     MPYSP  .M1     A_x4,       A_h1,     A_prod7   ; prod7 = x4 * h1
||     MPYSP  .M2X    B_x3,       A_h0,     B_prod6   ; prod6 = x3 * h0
||     ADDSP  .L1     A_sum7,     A_prod7,  A_sum7    ; sum7 = prod7 + sum7
||     ADDSP  .L2     B_sum6,     B_prod6,  B_sum6    ; sum6 = prod6 + sum6
||[B_icntr]SUB.D2     B_icntr,    1,        B_icntr   ; if(icntr) icntr -= 1

*============== PIPED LOOP EPILOG =========================================== *

 [!B_odd]ADDSP.L1     A_sum1,     A_prod1,  A_sum1    ; sum1 = prod1 + sum1
||     ADDSP  .L2     B_sum0,     B_prod0,  B7        ; sum0 = prod0 + sum0
||     SUB    .S2     B_x_ptr,    B9,       B_x_ptr   ; restore x_ptr
||     SUB    .S1X    A_h_ptr,    B9,       A_h_ptr   ; restore h_ptr
||[B_odd]MPYSP  .M1   A_sum1,     A_fl_one, A_sum1    ; just copy if odd
||     ADD    .D2     B3,         1,        B_icntr   ; icntr = ireset

 [!B_odd]ADDSP.L1     A_sum3,     A_prod3,  A_sum3    ; sum3 = prod3 + sum3
||     ADDSP  .L2     B_sum2,     B_prod2,  B7        ; sum2 = prod2 + sum2
||[B_odd]MPYSP.M1     A_sum3,     A_fl_one, A_sum3    ; just copy if odd
||     ADD    .D2     B_x_ptr,    16,       B_x_ptr   ; for next iteration
||     SHR    .S2     B_icntr,    1,        B_icntr   ; p icntr = ireset
||     SUB    .D1     A_ocntr,    4,        A_lastouter; is it last outer?
||     SHR    .S1     A_ocntr,    2,        A_cnteq4  ; is it last outer? 

 [!B_odd]ADDSP.L1     A_sum5,     A_prod5,  A_sum5    ; sum5 = prod5 + sum5
||     ADDSP  .L2     B_sum4,     B_prod4,  B7        ; sum4 = prod4 + sum4
||[B_odd]MPYSP.M1     A_sum5,     A_fl_one, A_sum5    ; just copy if odd
||     SUB    .S1X    B_icntr, 2,  A_ldresetcopy      ; init load cntr
||[A_lastouter]MV.D1  A_cnteq4,         A_lastouter   ; decide if last outer

 [!B_odd]ADDSP.L1     A_sum7,     A_prod7,  A_sum7temp; sum7 = prod7 + sum7
||     ADDSP  .L2     B_sum6,     B_prod6,  B7        ; sum6 = prod6 + sum6
||[B_odd]MV   .D1     A_sum7,     A_sum7temp          ; copy if odd
||[A_lastouter]MPYI.M1 A_ldresetcopy,1,     A_ldreset ; for next iteration
||[!A_lastouter]LDW.D2T2 *B15++,  B2                  ; restore CSR

* ============== END OF PIPED LOOP EPILOG =================================== *

  ADDSP       .L1X    B7,      A7,       A7           ; temp1 = sum0 + sum1
||[A_lastouter]LDDW   .D2     *B_x_ptr++[1],B_x1:B_x0 ; load x1:x0 from memory

       ADDSP  .L2X    B7,     A7,       B7            ; temp2 = sum2 + sum3
||[A_lastouter]LDDW   .D1     *A_h_ptr++[1],A_h1:A_h0 ; load h1:h0 from memory
||[!A_lastouter]MV    .S1X    B15,      A3                  

   ADDSP  .L1X    B7,     A7,       A7                ; temp3 = sum4 + sum5
||[A_lastouter]B      .S1     oloop                   ; if(ocntr) branch to OLOOP
||[!A_lastouter]B      .S2X    A0                     ; if(!ocntr) return
||[A_lastouter]LDDW   .D2     *B_x_ptr,   B_x3:B_x2   ; load x3:x2 from memory
||[!A_lastouter]LDW            *A3,        A11                 

       ADDSP  .L2X    B7,     A_sum7temp,B7           ; temp4 = sum6 + sum7
||[A_lastouter]LDW    .D2     *+B_x_ptr[2],A_x4       ; load x4 from memory

       STW    .D1     A7,         *A6++[2]            ; store temp1
||[A_lastouter]LDDW   .D2     *B_x_ptr++[1],B_x1:B_x0 ; load x1:x0 from memory
||     MV     .S2X    A6,         B6                  ; B6 = A6
||[A_ocntr] SUB.S1    A_ocntr,     1,     A_ocntr     ; if(ocntr) ocntr -= 1

  [A_ocntr] STW    .D2     B7,         *+B6[1]        ; store temp2
||[A_lastouter]LDDW.D1     *A_h_ptr++[1],A_h1:A_h0    ; load h1:h0 from memory
||[A_ocntr] SUB    .S1     A_ocntr,    1,     A_ocntr ; if(ocntr) ocntr -= 1
||[!A_lastouter]MVC.S2 B2,       CSR

  [A_ocntr] STW    .D1     A7,         *A6++[1]       ; store temp3
||[A_lastouter]LDDW.D2     *B_x_ptr,   B_x3:B_x2      ; load x3:x2 from memory
||[A_lastouter]MPYSP.M1X   B_x1,    A_h1,   A_prod1   ; prod1 = x1 * h1
||[A_lastouter]MPYSP.M2X   B_x0,    A_h0,   B_prod0   ; prod0 = x0 * h0
||[A_ocntr] SUB.S1         A_ocntr, 1,      A_ocntr   ; if(ocntr) ocntr -= 1

  [A_ocntr] STW.D1         B7,         *A6++[1]       ; store temp4
||[A_ocntr] SUB.S1         A_ocntr, 1,      A_ocntr   ; if(ocntr) ocntr -= 1
||[A_lastouter]LDW.D2     *+B_x_ptr[2],A_x4           ; load x4 from memory
||[A_lastouter]MPYSP.M1X   B_x2,       A_h1,A_prod3   ; prod3 = x2 * h1
||[A_lastouter]MPYSP.M2X   B_x1,       A_h0,B_prod2   ; p prod2 = x1 * h0
||[A_lastouter]SUB.S2      B_icntr,    2,   B_icntr   ; decrement cntr   

* ==================== OUTER LOOP BRANCH ================================ *
                .end

* ======================================================================== *
*  End of file: DSPF_sp_fir_gen.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fir_r2./1117057346  208   0     0       26960     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                    * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        void DSPF_sp_fir_r2(                                                    * 
*                      const float * restrict x,                            * 
*                      const float * restrict h,                            * 
*                      float       * restrict r,                            * 
*                      int   nh,                                            * 
*                      int   nr                                             * 
*                      )                                                    * 
*             x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           * 
*             h[nh]:      Pointer to Coefficient array of size nh.          * 
*                         (in reverse order).                               * 
*             r[nr]:      Pointer to Output array od size nr.               * 
*             nh:         Number of coefficients                            * 
*             nr:         Number of output samples.                         * 
*                                                                           * 
*  DESCRIPTION                                                              * 
*        Computes a real FIR filter (direct-form) using coefficients        * 
*        stored in vector h[]. The real data input is stored in vector      * 
*        x[]. The filter output result is stored in vector r[]. The         * 
*        filter calculates nr output samples using nh coefficients.         * 
*        The coefficients are expected to be in reverse order.              * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*        The outer loop is unrolled four times and inner loop is            * 
*        unrolled twice.                                                    * 
*        Outer loop instructions are executed in parallel with inner loop.  * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*        1. nr is a multiple of 2 and greater than or equal to 2.           * 
*        2. nh is a multiple of 2 and greater than or equal to 8.           * 
*        3. x and h are double word aligned.                                * 
*        4. Coefficients in array h are expected to be in revrse order.     * 
*        5. x and h should be padded with 4 words at the end.               * 
*                                                                           * 
*  C CODE                                                                   * 
*        void DSPF_sp_fir_r2_cn(const float * x, const float * h,                * 
*                                    float *restrict r, int nh, int nr)     * 
*             {                                                             * 
*             int i, j;                                                     * 
*             float sum;                                                    * 
*                                                                           * 
*             for (j = 0; j < nr; j++)                                      * 
*                 {                                                         * 
*                 sum = 0;                                                  * 
*                 for (i = 0; i < nh; i++)                                  * 
*                     sum += x[i + j] * h[i];                               * 
*                 r[j] = sum;                                               * 
*                 }                                                         * 
*             }                                                             * 
*                                                                           * 
*        This is the C equivalent of the assembly code.  Note that          * 
*        the assembly code is hand optimized and restrictions may apply.    * 
*                                                                           * 
*  NOTES                                                                    * 
*  CYCLES                                                                   * 
*        (nh * nr)/2 + 34, if nr multiple of 4                              * 
*        (nh * nr)/2 + 45, if nr not multiple of 4                          *
*        For nh=24 and nr=64, cycles=802                                    * 
*        For nh=30 and nr=50, cycles=795                                    *
*                                                                           * 
*  CODESIZE                                                                 * 
*        928 bytes                                                          * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_fir_r2
_DSPF_sp_fir_r2:

* ======================================================================== *
* ======================================================================== *

               .asg   B15,     B_SP
               .asg   A0,      A_SP
               .asg   A4,      A_x
               .asg   A5,      A_x_ptr
               .asg   B4,      B_h
               .asg   B5,      B_h_ptr 
               .asg   A8,      A_CSR_str
               .asg   B0,      B_CSR_gie
               .asg   A8,      A_nr
               .asg   B2,      B_nr
               .asg   A6,      A_r
               .asg   A6,      A_nh
               .asg   B6,      B_r
               .asg   B6,      B_nh
               .asg   B10,     B_x0
               .asg   B10,     B_x2
               .asg   B10,     B_x20
               .asg   B11,     B_x1
               .asg   B11,     B_x3
               .asg   B11,     B_x31
               .asg   B12,     B_x42
               .asg   B12,     B_x4
               .asg   B12,     B_x_2
               .asg   A10,     A_h0
               .asg   A11,     A_h1
               .asg   A7,      A_prod
               .asg   B7,      B_prod
               .asg   A9,      A_sum
               .asg   B9,      B_sum
               .asg   A2,      A_zero
               .asg   B1,      B_zero
               .asg   A5,      A_zero1
               .asg   B5,      B_zero1
               .asg   B14,     B_prod1
               .asg   A3,      A_prod2
               .asg   A12,     A_prod3
               .asg   A0,      A_prod4
               .asg   A12,     A_x20
               .asg   A12,     A_x0
               .asg   A12,     A_x2
               .asg   A13,     A_x31
               .asg   A13,     A_x1
               .asg   A13,     A_x3
               .asg   A12,     A_sum_4
               .asg   B13,     B_h_1
               .asg   B14,     B_h1
               .asg   A2,      A_ictr
               .asg   A1,      A_RSTflg
               .asg   A1,      A_h_t
               .asg   A1,      A_h_1t
               .asg   B8,      B_MULT4
               .asg   B2,      B_MULflg
               .asg   B0,      B_MULT2
               .asg   B0,      B_STRflg
               .asg   B1,      B_nreq2
               .asg   A5,      A_sum_t
               .asg   B5,      B_sum_t
               .asg   B14,     B_x
               


             LDDW  .D1T2 *A_x,      B_x1:B_x0             ; load x[i+j+1]:x[i+j]
||           SUBAW .D2   B_SP,      11,         B_SP      ; Save stack space
||           AND   .L2X  A_nr,      0x3,        B_MULflg  ; find out multiple of 4
||           MVC   .S2   CSR,       B_CSR_gie             ; Get CSR
||           MV    .L1   A_x,       A_x_ptr               ; Set x_ptr
||           MV    .S1X  B_h,       A_h_t                 ; Set temporary h_ptr

             LDW   .D1T1 *+A_h_t[3],A_h_1t                ; load h[i+3] to remove cross path
||[B_MULflg] SUB   .S1   A_nr,      2,          A_nr      ; make counter multiple of 4
||           MVK   .S2   0,         B_MULT4               ; flag for multiple of 4
||           STW   .D2T2 B_x,       *+B_SP[5]             ; store B14
||           MV    .L2   B_h,       B_h_ptr               ; Set h_ptr
||           MV    .L1X  B_SP,      A_SP                  ; Copy stack pointer
            
             STW   .D2T1 A_h0,      *+B_SP[1]             ; Sore A10
||           STW   .D1T2 B_x20,     *+A_SP[6]             ; Store B10
||[!B_MULflg]MVK   .S2   1,         B_MULT4               ; flag for multiple of 4
||           MV    .L2X  A_nr,      B_nr                  ; copy nr
  
             STW   .D2T1 A_h1,      *+B_SP[2]             ; Store A11
||           STW   .D1T2 B_x31,     *+A_SP[7]             ; Store B11
||           MV    .S1X  B_CSR_gie, A_CSR_str             ; Store CSR  
||           AND   .S2   B_CSR_gie, -2,         B_CSR_gie ; Disable GIE
               
             STW   .D2T1 A_x20,     *+B_SP[3]             ; Store A12
||           STW   .D1T2 B_x42,     *+A_SP[8]             ; Store B12
||           MV    .L1X  B_nh,      A_nh                  ; Change side of nh 
||           MV    .L2X  A_r,       B_r                   ; Change side of r
  
             STW   .D2T1 A_x31,     *+B_SP[4]             ; Store A13
||           STW   .D1T2 B_h_1,     *+A_SP[9]             ; Store B13
||           MVC   .S2   B_CSR_gie, CSR                   ; Disable interrupt
||           ZERO  .L2   B_nreq2                          ; flag for checking if nr=2

; -------------------------------------------------------------
               
             LDDW  .D2T1 *B_h++,    A_h1:A_h0             ; load h[i+1]:h[i]
||[B_nr]     ADDAD .D1   A_x_ptr,   2,          A_x_ptr   ; if nr!=2 update x_ptr
||[!B_nr]    MVK   .S2   1,         B_nreq2               ; Set flag for nr=2
||[!B_nr]    SUB   .L2   1,         B_MULT4,    B_MULT4   ; Invert Mult4 flag if nr=2 

             LDW   .D1T2 *A_x[2],   B_x_2                 ; load x[i+j+2]
||[!B_nr]    MVK   .S2   4,         B_nr                  ; load 4 in counter if NR=2
||           MV    .L2X  A_h_1t,    B_h_1                 ; Get h[i+3]
               
             LDDW  .D1T2 *++A_x,    B_x31:B_x20           ; load x[i+j+3(1)]:x[i+j+2(0)]
||           MV    .L2X  A_x_ptr,   B_x                   ; Set x_ptr for B side         
               
             LDW   .D1T2 *A_x[2],   B_x42                 ; load x[i+j+2(4)]
||           SUB   .S1   A_nh,      2,          A_ictr    ; Set inner loop ctr
||           ZERO  .L1   A_prod                           ; Initialise prod
||           ZERO  .L2   B_prod                           ; Initialise prod
||           B     .S2   ILOOP                            ; Branch to inner loop 
               
             LDDW  .D2T1 *B_h++,    A_h1:A_h0             ; load h[i+1]:h[i]
||           SUB   .S1   A_nh,      2,          A_RSTflg  ; Set reset flag
||           ZERO  .L2   B_sum                            ; Initialise accumulator
||           ZERO  .L1   A_sum                            ; Initialise accumulator 
||           MVK   .S2   0,         B_STRflg              ; Reset store flag

ILOOP:
  [B_STRflg] STW   .D2T1 A_sum_4,   *B_r++                ; Store sum7
||[!A_RSTflg]LDW   .D1T2 *A_x[2],   B_x42                 ; load x[i+j+2(4)]
||           MPYSP .M1X  A_h0,      B_x0,       A_prod    ; h[i] * x[i+j]
||           MPYSP .M2X  A_h1,      B_x1,       B_prod    ; h[i+1] * x[i+j+1] 
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum1 += h[i] * x[i+j]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum2 += h[i+1] * x[i+j+1]
||[!A_RSTflg]MVK   .S1   6,         A_RSTflg              ; Reset reset flag
||           MVK   .S2   0,         B_STRflg              ; Reset store flag

             LDDW  .D1T2 *++A_x,    B_x31:B_x20           ; load x[i+j+3(1)]:x[i+j+2(0)]
||[!A_ictr]  LDDW  .D2T1 *++B_x,    A_x31:A_x20           ; load x[i+j+3(1)]:x[i+j+2(0)]
||           MPYSP .M1X  A_h0,      B_x1,       A_prod    ; h[i] * x[i+j+1]
||           MPYSP .M2X  A_h1,      B_x_2,      B_prod    ; h[i+1] * x[i+j+2]          
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum3 += h[i] * x[i+j+1]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum4 += h[i+1] * x[i+j+2]
||[A_RSTflg] SUB   .S1   A_RSTflg,  2,          A_RSTflg  ; Update reset flag

             LDW   .D1T2 *A_x[2],   B_x42                 ; load x[i+j+2(4)] 
||[!A_RSTflg]MV    .D2   B_h_ptr,   B_h                   ; Set h pointer
||           MPYSP .M1X  A_h0,      B_x2,       A_prod    ; h[i] * x[i+j+2]           
||           MPYSP .M2X  A_h1,      B_x3,       B_prod    ; h[i+1] * x[i+j+3]
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum5 += h[i] * x[i+j+2]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum6 += h[i+1] * x[i+j+3]
||[A_ictr]   B     .S2   ILOOP                            ; Branch to inner loop
||[A_ictr]   SUB   .S1   A_ictr,    2,          A_ictr    ; Update inner loop counter

             LDDW  .D2T1 *B_h++,    A_h1:A_h0             ; load h[i+1]:h[i]
||[!A_RSTflg]LDDW  .D1T2 *A_x_ptr,  B_x1:B_x0             ; load x[i+j+1]:x[i+j+0]               
||           MPYSP .M1X  A_h0,      B_x3,       A_prod    ; h[i] * x[i+j+3]
||           MPYSP .M2X  A_h1,      B_x4,       B_prod    ; h[i+1] * x[i+j+4]
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum7 += h[i] * x[i+j+3]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum8 += h[i+1] * x[i+j+4]
||[!A_RSTflg]MV    .S1   A_x_ptr,   A_x                   ; Set x pointer

; ------------------------------------------------------------

             LDW   .D2T2 *-B_h[1],  B_h1                  ; load h[i+5]
||           MPYSP .M1   A_h0,      A_x0,       A_prod    ; h[i] * x[i+j]
||           MPYSP .M2   B_h_1,     B_x1,       B_prod    ; h[i+1] * x[i+j+1]  
||           ADDSP .L1   A_zero,    A_prod,     A_sum     ; sum1 = h[i] * x[i+j]
||           ADDSP .L2X  A_sum,     B_sum,      B_sum     ; sum2 = sum1 + sum2
||           MV    .S2   B_prod,    B_prod1               ; sum2 = h[i+1] * x[i+j+1]  
||           ADDAD .D1   A_x_ptr,   2,          A_x_ptr   ; Update x_ptr

             LDDW  .D1T2 *++A_x,    B_x31:B_x20           ; load x[i+j+3(1)]:x[i+j+2(0)]
||[B_nr]     SUB   .D2   B_nr,      4,          B_nr      ; Update outer loop counter               
||           MPYSP .M1   A_h0,      A_x1,       A_prod    ; h[i] * x[i+j+1]
||           MPYSP .M2   B_h_1,     B_x_2,      B_prod    ; h[i+1] * x[i+j+2]               
||           ADDSP .L2X  A_zero,    B_prod,     B_sum     ; sum4 = h[i+1] * x[i+j+2]
||           ADDSP .L1X  A_sum,     B_sum,      A_sum     ; sum3 = sum3 + sum4
||           MV    .S1   A_prod,    A_prod2               ; sum3 = h[i] * x[i+j+1]
||[!B_nreq2] ZERO  .S2   B_zero                           ; Zero for pseudo move

             LDW   .D1T2 *A_x[2],   B_x42                 ; load x[i+j+2(4)]
||           MPYSP .M1   A_h0,      A_x2,       A_prod    ; h[i] * x[i+j+2]                
||           MPYSP .M2   B_h_1,     B_x3,       B_prod    ; h[i+1] * x[i+j+3]
||           ADDSP .L2   B_zero,    B_prod,     B_sum     ; sum6 = h[i+1] * x[i+j+3]
||           ADDSP .L1X  A_sum,     B_sum,      A_sum     ; sum5 = sum5 + sum6
||           MV    .S1   A_prod,    A_prod3               ; sum5 = h[i] * x[i+j+2]
||[B_nr]     B     .S2   ILOOP 
||           ADD   .D2   B_MULT4,   B_nr,       B_MULT2   ; If last it.&not mult4 then 0 else 1 

             LDDW  .D2T1 *B_h++,    A_h1:A_h0             ; load h[i+1]:h[i] 
||           MPYSP .M1   A_h0,      A_x3,       A_prod    ; h[i] * x[i+j+3]
||           MPYSP .M2   B_h_1,     B_x4,       B_prod    ; h[i+1] * x[i+j+4]
||           ADDSP .L2   B_zero,    B_prod,     B_sum     ; sum8 = h[i+1] * x[i+j+4]
||           ADDSP .L1X  A_sum,     B_sum,      A_sum_4   ; sum7 = sum7 + sum8
||           MV    .D1   A_prod,    A_prod4               ; sum7 = h[i] * x[i+j+3]
||[!B_MULT2] B     .S1   MULT2 
               
; ------------------------------------------------------------

             STW   .D2T2 B_sum,     *B_r++                ; Store sum2
||           MPYSP .M1X  A_h0,      B_x0,       A_prod    ; h[i] * x[i+j]
||           MPYSP .M2X  A_h1,      B_x1,       B_prod    ; h[i+1] * x[i+j+1]   
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum1 += h[i] * x[i+j]
||           ADDSP .L2   B_prod1,   B_prod,     B_sum     ; sum2 += h[i+1] * x[i+j+1]
||           SUB   .S1   A_nh,      8,          A_ictr    ; Update inner loop ctr

             STW   .D2T1 A_sum,     *B_r++                ; Store sum3       
||           LDDW  .D1T2 *++A_x,    B_x31:B_x20           ; load x[i+j+3(1)]:x[i+j+2(0)]   
||           MPYSP .M1X  A_h0,      B_x1,       A_prod    ; h[i] * x[i+j+1]
||           MPYSP .M2   B_h1,      B_x_2,      B_prod    ; h[i+1] * x[i+j+2]                  
||           ADDSP .L1   A_prod2,   A_prod,     A_sum     ; sum3 += h[i] * x[i+j+1]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum4 += h[i+1] * x[i+j+2]
||           SUB   .S1   A_nh,      8,          A_RSTflg  ; Update reset flag
||           MV    .S2X  A_x_ptr,   B_x                   ; Set x pointer for B side

  [!B_nreq2] STW   .D2T1 A_sum,     *B_r++                ; Store sum5
||           LDW   .D1T2 *A_x[2],   B_x42                 ; load x[i+j+2(4)]
||           MPYSP .M1X  A_h0,      B_x2,       A_prod    ; h[i] * x[i+j+2]               
||           MPYSP .M2X  A_h1,      B_x3,       B_prod    ; h[i+1] * x[i+j+3]
||           ADDSP .L1   A_prod3,   A_prod,     A_sum     ; sum5 += h[i] * x[i+j+2]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum6 += h[i+1] * x[i+j+3]
||[B_nr]     B     .S1   ILOOP                            ; Branch to inner loop
||[!A_RSTflg]MV    .S2   B_h_ptr,   B_h                   ; Set h pointer

             LDDW  .D2T1 *B_h++,    A_h1:A_h0             ; load h[i+1]:h[i]
||[!A_RSTflg]LDDW  .D1T2 *A_x_ptr,  B_x1:B_x0             ; load x[i+j+1]:x[i+j+0]
||           MPYSP .M1X  A_h0,      B_x3,       A_prod    ; h[i] * x[i+j+3]
||           MPYSP .M2X  A_h1,      B_x4,       B_prod    ; h[i+1] * x[i+j+4]
||           ADDSP .L1   A_prod4,   A_prod,     A_sum     ; sum7 += h[i] * x[i+j+3]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum8 += h[i+1] * x[i+j+4]   
||[!A_RSTflg]MV    .S1   A_x_ptr,   A_x                   ; Set x pointer

; -------------------------------------------------------------
  [!B_nreq2] STW   .D2T1 A_sum_4,   *B_r++                ; Store sum2
||           MPYSP .M1X  A_h0,      B_x0,       A_prod    ; h[i] * x[i+j]
||           MPYSP .M2X  A_h1,      B_x1,       B_prod    ; h[i+1] * x[i+j+1]   
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum1 += h[i] * x[i+j]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum2 += h[i+1] * x[i+j+1] 
||[!B_MULT2] B     .S2   LOOP                             ; Jump to inner loop of MULT2         
; -------------------------------------------------------------     
          
END:              
             MVC   .S2X  A_CSR_str, CSR                   ; Enable Interrupts
||           MV    .S1X  B_SP,      A_SP                  ; Copy stach pointer
        
             LDW   .D1T1 *+A_SP[1], A_h0                  ; Load A10   
||           LDW   .D2T2 *+B_SP[6], B_x20                 ; Load B10
               
             LDW   .D1T1 *+A_SP[2], A_h1                  ; Load A11
||           LDW   .D2T2 *+B_SP[7], B_x31                 ; Load B11
                
             LDW   .D1T1 *+A_SP[3], A_x20                 ; Load A12
||           LDW   .D2T2 *+B_SP[8], B_x42                 ; Load B12

             LDW   .D1T1 *+A_SP[4], A_x31                 ; Load A13
||           LDW   .D2T2 *+B_SP[9], B_h_1                 ; Load B13
||           B     .S2   B3                               ; Branch out of the function
        
             LDW   .D2T2 *+B_SP[5], B_x                   ; Load B14
        
             ADDAW .D2   B_SP,      11,         B_SP      ; Restore stack space   
        
             NOP         3                                 
           
; -------------------------------------------------------------           
MULT2:         
  [A_ictr]   LDDW  .D1T2 *++A_x,    B_x1:B_x0             ; load x[i+j+1]:x[i+j+0]
||[A_ictr]   LDDW  .D2T1 *B_h++,    A_h1:A_h0             ; load h[i+1]:h[i]
||           MPYSP .M1X  A_h0,      B_x1,       A_prod    ; h[i] * x[i+j+1]
||           MPYSP .M2X  A_h1,      B_x_2,      B_prod    ; h[i+1] * x[i+j+2] 
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum3 += h[i] * x[i+j+1]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum4 += h[i+1] * x[i+j+2]
||           ZERO  .S1   A_zero1                          ; Zero for pseudo move
||           ZERO  .S2   B_zero1                          ; Zero for pseudo move

  [A_ictr]   LDW   .D1T2 *A_x[2],   B_x_2                 ; load x[i+j+2]                 
||           ADDSP .L1   A_zero1,   A_zero1,    A_sum     ; Zero sum1
||           ADDSP .L2   B_zero1,   B_zero1,    B_sum     ; Zero sum2
||           MPYSP .M1   A_prod,    A_zero1,    A_prod    ; Zero prod1
||           MPYSP .M2   B_prod,    B_zero1,    B_prod    ; Zero prod2
||[A_ictr]   SUB   .S1   A_ictr,    2,          A_ictr    ; Update counter
||[A_ictr]   B     .S2   LOOP                             ; Branch to loop
               
  [A_ictr]   LDDW  .D1T2 *++A_x,    B_x1:B_x0             ; load x[i+j+1]:x[i+j+0]   
||           LDDW  .D2T1 *B_h++,    A_h1:A_h0             ; load h[i+1]:h[i]
||           ADDSP .L1   A_zero1,   A_zero1,    A_sum     ; Zero sum3
||           ADDSP .L2   B_zero1,   B_zero1,    B_sum     ; Zero sum4
||           MPYSP .M1   A_prod,    A_zero1,    A_prod    ; Zero prod3
||           MPYSP .M2   B_prod,    B_zero1,    B_prod    ; Zero prod4
 
; --------------------------------------------------------------


LOOP:
  [A_ictr]   LDW   .D1T2 *A_x[2],   B_x_2                 ; load x[i+j+2]
||           MPYSP .M1X  A_h0,      B_x0,       A_prod    ; h[i] * x[i+j]
||           MPYSP .M2X  A_h1,      B_x1,       B_prod    ; h[i+1] * x[i+j+1]   
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum1 += h[i] * x[i+j]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum2 += h[i+1] * x[i+j+1] 
||[A_ictr]   SUB   .S1   A_ictr,    2,          A_ictr    ; Update counter
||[A_ictr]   B     .S2   LOOP                             ; Branch to loop

  [A_ictr]   LDDW  .D1T2 *++A_x,    B_x1:B_x0             ; load x[i+j+1]:x[i+j+0]   
||[A_ictr]   LDDW  .D2T1 *B_h++,    A_h1:A_h0             ; load h[i+1]:h[i]
||           MPYSP .M1X  A_h0,      B_x1,       A_prod    ; h[i] * x[i+j+1]
||           MPYSP .M2X  A_h1,      B_x_2,      B_prod    ; h[i+1] * x[i+j+2]  
||           ADDSP .L1   A_sum,     A_prod,     A_sum     ; sum3 += h[i] * x[i+j+1]
||           ADDSP .L2   B_sum,     B_prod,     B_sum     ; sum4 += h[i+1] * x[i+j+2]

             ADDSP .L1X  A_sum,     B_sum,      A_sum     ; sum1 = sum1 + sum3
                
             ADDSP .L2X  A_sum,     B_sum,      B_sum     ; sum3 = sum3 + sum4
                
             ADDSP .L1X  A_sum,     B_sum,      A_sum_t   ; sum1'= sum1 + sum2
               
             ADDSP .L2X  A_sum,     B_sum,      B_sum_t   ; sum3'= sum3 + sum4
               
             NOP         2
               
             ADDSP .L1   A_sum,     A_sum_t,    A_sum     ; sum1 = sum1 + sum1'
||           B     .S2   END                              ; branch to end

             ADDSP .L2   B_sum,     B_sum_t,    B_sum     ; sum3 = sum3 + sum3'
               
             NOP         2
               
             STW   .D2T1 A_sum,     *B_r++                ; Store sum1
                
             STW   .D2T2 B_sum,     *B_r++                ; Store sum3
; -----------------------------------------------------------------------------


                .end

* ======================================================================== *
*  End of file: DSPF_sp_fir_r2.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_fircirc/1117057347  228   0     0       18189     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has following C prototype                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        );                                                                 *
*                                                                           *
*       x[]     : Input array (circular buffer of 2^(csize+1) bytes)        *
*                 Must be aligned at 2^(csize+1) byte boundary              *
*       h[nh]   : Filter coefficients array                                 *
*                 Must be double-word aligned                               *
*       r[nr]   : Output array                                              *
*       index   : Offset by which to start reading from the input array     *
*                 Must be multiple of 2                                     *
*       csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         *
*                 Must be 2 <= csize <= 31.                                 *
*       nh      : Number of filter coefficients                             *
*                 Must be multiple of 2 and >= 4                            *
*       nr      : Size of output array                                      *
*                 Must be multiple of 4                                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine implements a circularly addressed FIR filter.          *
*       'nh' is the number of filter coefficients. 'nr' is the number       *
*       of the output samples.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. LDDW instructions are used to load two SP floating point         *
*          values simultaneously for the x and h arrays.                    *
*       2. The outer loop is unrolled 4 times.                              *
*       3. The inner loop is unrolled 2 times.                              *
*       4. The variables prod1, prod3, prod5 and prod7 share A9.            *
*          The variables prod0, prod2, prod4 and prod6 share B6.            *
*          The variables sum1, sum3, sum5 and sum7 share A7.                *
*          The variables sum0, sum2, sum4 and sum6 share B8.                *
*          This multiple assignment is possible since the variables         *
*          are always read just once on the first cycle that they are       *
*          avaliable.                                                       *
*       6. A load counter is used so that an epilog is not needed.  No      *
*          extraneous loads are performed.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The circular input buffer x[] must be aligned at a 2^(csize+1)   *
*          byte boundary. csize must lie in the range 2 <= csize <= 31.     *
*       2. The number of coefficients  (nh) must be a multiple of 2         *
*          and greater than or equal to 4.                                  *
*       3. The number of outputs (nr) must be a multiple of 4 and           *
*          greater than or equal to 4.                                      *
*       4. The 'index' (offset to start reading input array) must be        *
*          mutiple of 2 and less than or equal to (2^(csize-1) - 6)         *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        )                                                                  *
*       {                                                                   *
*           int i, j;                                                       *
*           //Circular Buffer block size = ((2^(csize + 1)) / 4)            *
*           //floating point numbers                                        *
*           int mod = (1 << (csize - 1));                                   *
*           float r0;                                                       *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               r0 = 0;                                                     *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   //Operation "% mod" is equivalent to "& (mod -1)"       *
*                   //r0 += x[(i + j + index) % mod] * h[j];                *
*                   r0 += x[(i + j + index) & (mod - 1)] * h[j];            *
*               }                                                           *
*           r[i] = r0;                                                      *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. This code is LITLLE ENDIAN.                                      *
*       2. This routine disables interupts for its entire duration.         *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (2*nh + 10) nr/4 + 18                                               *
*       eg. for nh = 30, nr=100                                             *
*       cycles = 1768                                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       512 bytes                                                           *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *
        .asg    B15,    SP

        .text
        .global _DSPF_sp_fircirc
_DSPF_sp_fircirc:

* ======================================================================== *
* ======================================================================== *

        STW     .D2     B10,*SP--[1]    ; saving B10 on stack
||      MV      .L1X    B6,A8           ; move index to A8
||      MV      .L2X    A8,B6           ; move csize to B6
||      B       .S1     NO_INT          ; protect from ints

        ADDAW   .D1     A4,A8,A4        ; x += index
||      MVC     .S2     CSR,B10         ; get CSR

*** begin piplining inner loop

        LDDW    .D1     *A4++[1],B1:B0  ; load x1:x0 from mem
||      SUB     .S1     A10,4,A2        ; f ocntr = nr - 4
||      SHL     .S2     B8,1,B9         ; f B9 = (numH) << 1
||      MV      .L1X    B4,A8           ; f ptr_h = h
||      AND     .L2     B10, -2, B0     ; disable GIE

        LDDW    .D1     *A8++[1],A5:A4  ; load h1:h0 from mem
||      MV      .L2X    A4,B7           ; f ptr_x = x
||      SUB     .L1X    B8,4,A0         ; f ireset = numH - 4
||      SHL     .S2     B6,16,B5        ; shift size into BK0
||      MVK     .S1     0x00004000,A5   ; move AMR mode into A5

        LDDW    .D2     *B7,B5:B4       ; load x3:x2 from mem
||      MV      .L2X    A0,B2           ; icntr = ireset
||      MV      .L1     A0,A1           ; ocntr = ireset
||      SUB     .S2     B9,8,B9         ; f xreset = B9 - 8
||      OR      .S1X    B5,A5,A9        ; set AMR value into A9

        LDW     .D2     *+B7[2],A3      ; load x4 from mem
||      MVC     .S2     A9,AMR          ; move A9 into AMR

NO_INT:

        LDDW    .D2     *B7++[1],B1:B0  ; @ load x1:x0 from mem
||      MVC     .S2     B0,CSR          ; disable interrupts

        LDDW    .D1     *A8++[1],A5:A4  ; @ load h1:h0 from mem

        LDDW    .D2     *B7,B5:B4       ; @ load x3:x2 from mem
||      MPYSP   .M1X    B1,A5,A9        ; prod1 = x1 * h1
||      MPYSP   .M2X    B0,A4,B6        ; prod0 = x0 * h0

        LDW     .D2     *+B7[2],A3      ; @ load x4 from mem
||      MPYSP   .M1X    B4,A5,A9        ; prod3 = x1 * h1
||      MPYSP   .M2X    B1,A4,B6        ; prod2 = x0 * h0

OLOOP:
  [A1]  LDDW    .D2     *B7++[1],B1:B0  ; @@ load x1:x0 from mem
||      MPYSP   .M1X    B5,A5,A9        ; prod5 = x3 * h1
||      MPYSP   .M2X    B4,A4,B6        ; prod4 = x2 * h0
||      B       .S1     LOOP            ; if(icntr) branch to LOOP

  [A1]  LDDW    .D1     *A8++[1],A5:A4  ; @@ load h1:h0 from mem
||      MPYSP   .M1     A3,A5,A9        ; prod7 = x4 * h1
||      MPYSP   .M2     B5,A4,B6        ; prod6 = x3 * h0
||      ZERO    .S1     A7              ; sum1 = 0
||      ZERO    .S2     B8              ; sum0 = 0

*****************loop begins*************************
LOOP:

  [A1]  LDDW    .D2     *B7,B5:B4       ; @@ load x3:x2 from mem
||      MPYSP   .M1X    B1,A5,A9        ; @ prod1 = x1 * h1
||      MPYSP   .M2X    B0,A4,B6        ; @ prod0 = x0 * h0
||      ADDSP   .L1     A7,A9,A7        ; sum1 = prod1 + sum1
||      ADDSP   .L2     B8,B6,B8        ; sum0 = prod0 + sum0

  [A1]  LDW     .D2     *+B7[2],A3      ; @@ load x4
||      MPYSP   .M1X    B4,A5,A9        ; @ prod3 = x2 * h1
||      MPYSP   .M2X    B1,A4,B6        ; @ prod2 = x1 * h0
||      ADDSP   .L1     A7,A9,A7        ; sum3 = prod3 + sum3
||      ADDSP   .L2     B8,B6,B8        ; sum2 = prod2 + sum2
||[A1]  SUB     .S1     A1,2,A1         ; if(ocntr) ocntr -= 2

  [A1]  LDDW    .D2     *B7++[1],B1:B0  ; @@@ load x1:x0 from mem
||      MPYSP   .M1X    B5,A5,A9        ; @ prod5 = x3 * h1
||      MPYSP   .M2X    B4,A4,B6        ; @ prod4 = x2 * h0
||      ADDSP   .L1     A7,A9,A7        ; sum5 = prod5 + sum5
||      ADDSP   .L2     B8,B6,B8        ; sum4 = prod4 + sum4
||[B2]  B       .S1     LOOP            ; if(icntr) branch to LOOP

  [A1]  LDDW    .D1     *A8++[1],A5:A4  ; @@@ load h1:h0 from mem
||      MPYSP   .M1     A3,A5,A9        ; @ prod7 = x4 * h1
||      MPYSP   .M2X    B5,A4,B6        ; @ prod6 = x3 * h0
||      ADDSP   .L1     A7,A9,A7        ; sum7 = prod7 + sum7
||      ADDSP   .L2     B8,B6,B8        ; sum6 = prod6 + sum6
||[B2]  SUB     .S2     B2,2,B2         ; if(icntr) icntr -= 2
||[!B2] SUBAB   .D2     B7,B9,B7        ; o if(!icntr) ptr_x -= xreset
||[!B2] SUB     .S1X    A8,B9,A8        ; o if(!icntr) ptr_h -= xreset

******************loop ends**************************

        ADDSP   .L1X    B8,A7,A7        ; o temp1 = sum0 + sum1
||      SUB     .D1     A8,16,A8        ; ptr_h -= 16
||      LDDW    .D2     *B7++[1],B1:B0  ; p load x1:x0 from mem

        ADDSP   .L2X    B8,A7,B8        ; o temp2 = sum2 + sum3
||[A2]  LDDW    .D1     *A8++[1],A5:A4  ; p load h1:h0 from mem
||[!A2] LDW     .D2     *++SP[1],B10    ; restore B10, stack pointer

        ADDSP   .L1X    B8,A7,A7        ; o temp3 = sum4 + sum5
||[A2]  B       .S1     OLOOP           ; o if(ocntr) branch to OLOOP
||[!A2] B       .S2     B3              ; f if(!ocntr) return
||[A2]  LDDW    .D2     *B7,B5:B4       ; p load x3:x2 from mem

        ADDSP   .L2X    B8,A7,B8        ; o temp4 = sum6 + sum7
||[A2]  LDW     .D2     *+B7[2],A3      ; p load x4 from memory
||[!A2] MVC     .S2     B10,CSR         ; enable interrupts

        STW     .D1     A7,*A6++[2]     ; o store temp1
||[A2]  LDDW    .D2     *B7++[1],B1:B0  ; p load x1:x0 from memory
||      MV      .S2X    A6,B6           ; o b6 = a6

        STW     .D2     B8,*+B6[1]      ; o store temp2
||[A2]  LDDW    .D1     *A8++[1],A5:A4  ; p load h1:h0 from memory
||[A2]  MV      .S1     A0,A1           ; p lcntr = ireset
||[A2]  MV      .S2X    A0,B2           ; p icntr = ireset
||[!A2] ZERO    .L2     B6              ; if (!ocntr) A9 = 0

        STW     .D1     A7,*A6++[1]     ; o store temp3
||[A2]  LDDW    .D2     *B7,B5:B4       ; p load x3:x2 from memory
||[A2]  MPYSP   .M1X    B1,A5,A9        ; p prod1 = x1 * h1
||[A2]  MPYSP   .M2X    B0,A4,B6        ; p prod0 = x0 * h0
||[!A2] MVC     .S2     B6,AMR          ; if (!ocntr) move B6 into AMR

        STW     .D1     B8,*A6++[1]     ; o store temp3
||[A2]  SUB     .S1     A2,4,A2         ; o if(ocntr) ocntr -= 4
||[A2]  LDW     .D2     *+B7[2],A3      ; p load x4 from memory
||[A2]  MPYSP   .M1X    B4,A5,A9        ; p prod3 = x2 * h1
||[A2]  MPYSP   .M2X    B1,A4,B6        ; p prod2 = x1 * h0

**************** outer loop ends *********************
                .end

* ======================================================================== *
*  End of file: DSPF_sp_fircirc.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_biquad./1117057348  249   0     0       21424     `
* ============================================================================= *
*                                                                               *
*  TEXAS INSTRUMENTS, INC.                                                      *
*                                                                               *
*  NAME                                                                         *
*      DSPF_sp_biquad: Biquad filter (IIR filter of 2nd order)                       *
*                                                                               *
*  USAGE                                                                        *
*      This routine has following C prototype:                                  *
*                                                                               *
*           void DSPF_sp_biquad (                                                    *
*                         float x[],    Pointer to input samples                *
*                         float b[],    Pointer to Nr coefs b0, b1, b2          *
*                         float a[],    Pointer to Dr coefs a1, a2              *
*                         float delay[] Pointer to filter delays                *
*                         float r[],    Pointer to output samples               *
*                         int   nx      Number of input/output samples          *
*                         )                                                     *
*                                                                               *
*                                                                               *
*                                                                               *
*  DESCRIPTION                                                                  *
*      This routine implements a DF 2 transposed structure of the biquad        *
*      filter. The transfer function of a biquad can be written                 *
*      as:                                                                      *
*                                                                               *
*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)              *
*                       H(Z) =     _________________________________            *
*                                    1 + a(1)z^(-1) + a(2)z^(-2)                *
*                                                                               *
*  C code                                                                       *
*      void DSPF_sp_biquad_cn (float x[],                                            *
*                        float b[],                                             *                  
*                        float a[],                                             *
*                        float delay[],                                         *
*                        int   nx                                               *
*                       )                                                       *
*   {                                                                           *
*           int i;                                                              *
*           float a1, a2, b0, b1, b2, d0, d1, x_i;                              *
*                                                                               *
*           a1 = a[0];                                                          *
*           a2 = a[1];                                                          *
*                                                                               *
*           b0 = b[0];                                                          *
*           b1 = b[1];                                                          *
*           b2 = b[2];                                                          *
*                                                                               *
*           d0 = delay[0];                                                      *
*           d1 = delay[1];                                                      *
*                                                                               *
*           for (i = 0; i < nx; i++)                                            *
*           {                                                                   *
*                       x_i = x[i];                                             *
*                       r[i] = b0 * x_i + d0;                                   *
*                       d0 = b1 * x_i - a1 * r[i] + d1;                         *
*                       d1 = b2 * x_i - a2 * r[i];                              *
*           }                                                                   *
*           delay[0] = d0;                                                      *
*           delay[1] = d1;                                                      *
*  }                                                                            *
*                                                                               *
*   ASSUMPTIONS                                                                 *
*       nx is a multiple of 3                                                   *
*       Source and destination arrays do not overlap.                           *
*                                                                               *
*   TECHNIQUES                                                                  *
*        1.  The loop has been unrolled by 3 times so as to find out 3          *
*            output samples at a time. Thus, the nth, (n+1)th and the (n+2)th   * 
*            output samples are all calculated on the basis of the (n-1)th      *
*            and the (n-2)th output samples. The dependency bound is 12 clocks; *
*            in these many clocks we compute 3 outputs.                         *
*                                                                               *
*        2.  Register sharing has been used to optimize on the use of registers.*
*                                                                               *
*        3.  The prolog has been collapsed by 2 stages and a collapse predicate *
*            has been used.                                                     *
*                                                                               *
*   NOTES                                                                       *
*                                                                               *
*    Unrolling the loop thrice implies that the order of the filter has been    *
*    increased by 2. This is because the output at time instant 'n' is          *
*    dependent on the outputs at instants 'n-3' and 'n-4'. This is              *
*    mathemetically equivalent to multiplying the transfer function's numerator *
*    and denominator by (1 + k1 * z^-1) (1 + k2 * z^-1), where k1 and k2 are    *
*    'a1' and (a2-a1*a1)/a1 respectively. Hence 2 new poles are introduced, one *
*    at -a1 and the other at -(a2-a1*a1)/a1.Thus, use of this function requires *
*    that modulii of a1 and (a2-a1*a1)/a1 be less than 1.                       *
*                                                                               *
*                                                                               *
*   CYCLES                                                                      *
*       4 * nx + 42                                                             *
*       For nx = 60,  cycles = 282                                              *
*       For nx = 90,  cycles = 402.                                             *
*                                                                               *
*   CODESIZE                                                                    *
*       800 bytes                                                               *
*                                                                               *
* ============================================================================= *
*            Copyright (c) 2002 Texas Instruments, Incorporated.                *
*                           All Rights Reserved.                                *
* ============================================================================= *
        .global _DSPF_sp_biquad
         
        .text
        .global _DSPF_sp_biquad
_DSPF_sp_biquad:

     B        .S1     NO_INT                  ; protect from interrupts
||   SUBAW    .D2     B15,       26,      B15 ; create stack space
||   MVC      .S2     CSR,       B1

     ADD      .S1X    B15,       12,       A1 ; make copy of stk ptr
||   STW      .D2T2   B1,        *B15++[2]    ; save current CSR in Stack
||   AND      .L2     B1,        -2,      B1  ; disable GIE bit
      
     ;------------------------------------------------------------------------
     ;preserve address of the delay array
     ;------------------------------------------------------------------------              
     STW      .D2T2   B6,        *B15++[2]    ; preserve delay ptr val
||   STW      .D1T1   A11,       *A1++[2]
||   MV       .S1     A4,        A11          ; addr reg       
||   MV       .S2     B8,        B0           ; loop counter
||   MV       .L1     A8,        A0           ; delay pointer
       
     ;-------------------------------------------------------------------------
     ; load the coefficients from the input arrays
     ;-------------------------------------------------------------------------
     LDW      .D1T2   *A6,       B3           ; a1 (Denom coeff)
||   LDW      .D2T1   *B4,       A9           ; b0 (Numerator coeff)
||   MVC      .S2     B1,        CSR
       
     LDW      .D2T2   *B4[1],    B7           ; b1 (Numerator coeff)
||   LDW      .D1T1   *+A6[1],   A8           ; a2 (Denom coeff)
                
     LDW      .D2T1   *+B4[2],   A4           ; b2 (Numerator coeff)
||   STW      .D1T2   B11,       *A1++[2]                
     
     ;-------------------------------------------------------------------------
     ; some stack pushes are in the delay slots of other instructions
     ;-------------------------------------------------------------------------
NO_INT:
     
     STW      .D2T1   A14,       *B15++[2]
||   STW      .D1T2   B14,       *A1++[2]

         
         
     STW      .D2T2  B3,         *B15++[2]     ; store return address 
||   STW      .D1T1  A15,        *A1++[2]
     
     ;-------------------------------------------------------------------------
     ; the following code evaluates all the required constants for unrolling
     ;   by 3
     ;-------------------------------------------------------------------------
     MPYSP    .M2    B3,        B3,      B1   ; a1 * a1                  
||   MPYSP    .M1X   B3,        A9,      A15  ; a1 * b0
||   STW      .D2T1  A10,       *B15++[2]    
||   STW      .D1T2  B10,       *A1++[2]
       
       
     MPYSP    .M2X   B3,        A8,      B14  ; a1 * a2         
||   MPYSP    .M1    A8,        A9,      A14  ; a2 * b0 
||   STW      .D2T1  A12,       *B15++[2]
||   STW      .D1T2  B12,       *A1++[2]      
       
     MPYSP     .M2   B3,        B7,      B12 ; a1 * b1
||   STW       .D2T1 A13,       *B15++[2]
||   STW       .D1T2 B13,       *A1++[2]
         
     MV        .S1X  B7,        A6           ; move b1 A-side 
||   ADDAW     .D2   B15,       2,       B15                   
         
     SUBSP     .L1   A6,        A15,     A10 ; b1 - a1 * b0
||   MPYSP     .M2   B1,        B3,      B13 ; a1 * a1 * a1
||   MPYSP     .M1X  B1,        A9,      A13 ; a1 * a1 * b0       
||   SUBSP     .L2X  B1,        A8,      B5  ; a1 * a1 - a2 (d1_coef)
         
     STW       .D2T2  B14,       *B15[6]      ; a1 * a2
||   ADDSP     .L2    B14,       B14,     B14 ; 2 * a1 * a2
||   SUBSP     .L1    A4,        A14,     A14 ; b2 - a2 * b0 (for x0_coef)
||   MV        .S2X   A15,       B9           ; move a1 * b0 to its final place
      
     LDW       .D1T2    *+A11[1],   B4        ; load x[i+1] (P)

     LDW       .D1T1    *+A11[2],   A5        ; load x[i+2] (P)
         
     MV        .S1    A10,       A7           ; b1 - a1 * b0  
||   SUBSP     .L1X   A13,       B12,     A3  ; a1 * a1 * b0 - a1 * b1 (for x0_coef)
||   MPYSP     .M2X   B5,        A8,      B8  ; a2 * (a1 * a1 - a2) (d0temp_coef)   
||   STW       .D2T2  B5,        *B15[3]      ; store d1_coef  
||   LDW       .D1T1  *A11++[3], A6           ; load x[i]   (P)
       
     LDW       .D2T1  *B6[1],    A2           ; load initial value of d1
||   SUBSP     .L2    B14,       B13,     B12 ; 2 * a1 * a2 - a1^3 (d0_coef)
||[!B0] B      .S1    skip_kernel    
         
     MVK       .S2    4,         B1
||   ADD       .L2    B0,        6,       B0
||   LDW       .D2T2  *B6,       B12          ; load initial value of d0
       
     STW       .D2T2  B7,        *B15         ; store b1 into the stack 
||   MV        .S1X   B7,        A12                 
         
     ADDSP     .L1    A3,        A14,     A10 ; evaulate x0_coef
||   MV        .S1X   B15,       A1
||   STW       .D2T2  B8,        *B15[1]      ; store d0temp_coef
||   ADD       .S2X    A11,       4,       B14;            (P)   

     MV        .S2X   A9,        B7           ; final place of b0
||   MV        .L2    B7,        B8           ; final place of b1
||   MV        .S1    A4,        A9           ; final place of b2
||   MV        .L1    A6,        A4           ; move x[i]
||   STW       .D1T2  B12,       *A1[2]       ; store d0_coef
                        
;------------------------------------------------------------------------------
; Following code is prolog + loop kernel
;------------------------------------------------------------------------------
     MPYSP     .M2     B7,       B4,      B5  ; b0 * x[i+1]         (P)
||   MPYSP     .M1     A7,       A4,      A6  ; xi_coef1 * x[i]   (P)
||   LDDW      .D2T1    *B15,      A13:A12    ; load d0temp_coeff & b1 (P)
 
     MPYSP     .M1     B7,       A5,      A6  ; b0 * x[i+2]         (P) 
||   MPYSP     .M2     B8,       B4,      B5  ; b1 * x[i+1]        (P)

     MPYSP     .M2      B9,       B4,      B5 ; a1 * b0 * x[i+1]      (P) 
||   MPYSP     .M1      A10,      A4,      A6 ; xi_coef * x[i]    (P) 

     MPYSP     .M2      A9,       B4,      B5 ; b2 * x[i+1]        (P) 
||   MPYSP     .M1      A12,      A5,      A6 ; b1 * x[i+1]       (P) 

     ADDSP     .L1X     B5,       A6,      A15; temp1=b0 * x[i+1] + xi_coef1*x[i] (P)
     
     ADDSP     .L2X     B5,       A6,      B13; b0*x[i+2] + b1*x[i+1] (P)   
     
     SUBSP     .L1X     A6,       B5,      A6 ; a1*b0*x[i+1] + xi_coef*x[i]  (P)  
||   ADD       .S2X     A11,      4,       B14
     
     LDW       .D1T1    *A11++[3],A4          ; load x[i] (P)
||   LDW       .D2T2    *B14++,   B4          ; load x[i+1] (P)      
||   ADDSP     .L2X     B5,       A6,      B5 ; t1 = b2*x[i+1] + xi_coef*x[i] (P)

     LDW       .D2T1    *B14,     A5          ; load x[i+2] (P)
||   MPYSP     .M1      A8,       A15,     A6 ; a2 * temp1 (P)

* =========================== PIPED LOOP KERNEL ================================ *

loop: 
       
     LDW       .D2T2  *B15[2],   B14           ; load d0_coef
||   ADDSP     .L2     B6,       B11,     B14  ; for d0
||   SUBSP     .L1     A3,       A12,     A13  ; for d1
||   MPYSP     .M1     A2,       A13,     A12  ; d1*d1_coeff
||   MPYSP     .M2X    A2,       B2,      B11  ; d1*(a1*a2)
||   SHR       .S2     B1,       1,       B1
       

     ADDSP     .L2X    A6,       B13,     B13  ; temp2
||   LDDW      .D2T1   *B15,     A13:A12       ; load d0temp_coeff & b1
||[!B1] STW.D1T2   B11,          *A0++         ; store r[i]
||   MPYSP     .M1X    B3,       A2,      A1   ; a1 * d1
     

     MPYSP     .M1     A9,       A5,      A14  ; b2 * x[i+2]
||   LDW       .D2T2   *B15[5],  B10           ; load temp2
||   MPYSP     .M2X    B7,       A4,      B2   ; b0*x[i]
||[!B1] SUBSP  .L1X    A14,      B11,     A2   ; r[i+1]
       

     MPYSP     .M2     B7,       B4,      B5  ; b0*x[i+1]
 ||  MPYSP     .M1     A7,       A4,      A6  ; xi_coef1 * x[i]
 ||  SUBSP     .L1X    B5,       A6,      A4  ; t1-a2*(b0*x[i+1]+xi_coef1*x[i])
 ||  LDW       .D2T1   *B15[4],  A1           ; load temp1
 ||  ADDSP     .L2X    B10,      A12,     B11 ; temp2 + d0 * d1_coeff 
     

  [!B1] ADDSP  .L2X    B14,      A12,     B12 ; d0
||   MPYSP     .M1     B7,       A5,      A6  ; mult b0*x[i+2]
||   MPYSP     .M2     B8,       B4,      B5  ; mult b1* x[i+1]
||   LDW       .D2T1   *B15[3],  A13          ; load d1_coeff
     

  [!B1] ADDSP .L1X     A13,      B11,     A2  ; d1
||   MPYSP    .M2      B9,       B4,      B5  ; mult a1b0*x[i+1]
||   MPYSP    .M1      A10,      A4,      A6  ; mult xi_coef* x[i]
||   STW      .D2T1    A15,      *B15[4]      ; store temp1 onto stack
||[ B0]SUB    .S2      B0,       3,       B0  
     

    MPYSP     .M2      A9,       B4,      B5  ; mult b2*x[i+1]
||  MPYSP     .M1      A12,      A5,      A6  ; mult b1* x[i+1]
||  STW       .D2T2    B13,      *B15[5]      ; store temp2
||[!B1] STW   .D1T1    A2,       *A0++        ; store r[i+1]
||[ B0] B     .S2      loop                   ; branch to top 
||  MV        .S1X     B13,      A15          ; transfer temp2 A-side


    ADDSP     .L1X     B5,       A6,      A15 ; b0*x[i+1] + xi_coef1*x[i]
||  MPYSP     .M2      B3,       B13,     B4  ; a1 * temp2
||  MPYSP     .M1      A8,       A15,     A6  ; a2 * temp2
||  LDW       .D2T2    *B15[6],  B2           ; load a1*a2
||  SUBSP     .L2X     B11,      A1,      B11 ; r[i+2]


    ADDSP     .L2X     B5,       A6,      B13 ; b0*x[i+2] + b1*x[i+1]
||  MPYSP     .M1X     B12,      A13,     A12 ; d0 * d0temp_coeff
||  MPYSP     .M2      B12,      B14,     B11 ; d0 * d0_coeff
       

    SUBSP     .L1X     A6,       B5,      A6  ; a1b0*x[i+1] + xi_coef*x[i]  
||  LDW       .D1T1    *-A11[6], A4           ; load x[i] again
||  ADDSP     .L2      B2,       B12,     B11 ; b0*x[i] + d0
||  ADD       .S2X     A11,      4,       B14
   

    LDW       .D1T1    *A11++[3],A4           ; load x[i]                         
||  LDW       .D2T2    *B14++,   B4           ; load x[i+1]                       
||  ADDSP     .L2X     B5,       A6,      B5  ; b2*x[i+1]+ xi_coef*x[i]    
||  MPYSP     .M2      B3,       B12,     B11 ; d0 * a1
||  MPYSP     .M1X     B12,      A13,     A12 ; d0 * d1_coeff
||  ADDSP     .L1      A2,       A1,      A14 ; d1 + temp1
   


    LDW       .D2T1    *B14,     A5           ; load x[i+2]           
||  MPYSP     .M1      A8,       A15,     A6  ; a2*temp1 
||  SUBSP     .L2X     A4,       B4,      B6  ; b2*x[i+1]+xi_coef*x[i]-a2*temp1-a1*temp2 
||  SUBSP     .L1      A14,      A6,      A3  ; b2*x[i+1]+xi_coef*x[i]-a2*(b0*x[i+1]+xi_coef1*x[i])-a1*temp2 
||[!B1] STW   .D1T2    B11,      *A0++        ; store r[i+2]   
     

* ===================END OF PIPED LOOP KERNEL ============================ *
skip_kernel:
    
    ; pop registers from the stack and return to caller
    
    SUB       .S2      B15,      8,       B15
||  LDW       .D2T2    *-B15[10],B3             ; load return address
||  ADD       .S1X     B15,      4,       A1

    LDW      .D2T1     *-B15[12], A6
||  LDW      .D1T2     *-A1[2],   B13
    
    LDW      .D2T1     *-B15[6],  A10
||  LDW      .D1T2     *-A1[17],  B1
    
    LDW      .D1T1     *-A1[5],   A13
    
    LDW      .D2T1     *-B15[4],  A12
||  LDW      .D1T2     *-A1[6],   B10
 
    LDW      .D2T1     *-B15[10], A14
||  LDW      .D1T2     *-A1[12],  B11

    LDW      .D1T1     *-A1[14],  A11
||  LDW      .D2T2     *-B15[7],  B14
||  B        .S2       B3                       ; return to caller
    
    LDW      .D2T2     *-B15[1],  B12     
||  LDW      .D1T1     *-A1[8],   A15
||  MV       .L2X      A6,        B6 

    STW      .D1T2     B12,       *A6
||  STW      .D2T1     A2,        *B6[1]
      
    ADDAW    .D2       B15,       12,     B15  ; restore the stack ptr
   
    MVC      .S2       B1,        CSR          ; restore CSR

    NOP
       
* ============================================================================= *
*  End of file:  DSPF_sp_biquad.asm                                                  *
* ----------------------------------------------------------------------------- *
*            Copyright (c) 2002 Texas Instruments, Incorporated.                *
*                           All Rights Reserved.                                *
* ============================================================================= *
DSPF_sp_iir.asm/1117057349  0     0     0       28987     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iir -- Single Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*                                                                           * 
*    This routine is C callable, and has the following C prototype:         * 
*                                                                           * 
*       void DSPF_sp_iir    (float* restrict r1,                                 * 
*                       const float*    x,                                  * 
*                       float* restrict r2,                                 * 
*                       const float*    h2,                                 * 
*                       const float*    h1,                                 * 
*                       int nr                                              * 
*                      );                                                   * 
*                                                                           * 
*            r1   :  Delay element values (i/p and o/p)                     * 
*            x    :  Pointer to the input array                             * 
*            r2   :  Pointer to the output array                            * 
*            h2   :  Auto-regressive filter coefficients                    * 
*            h1   :  Moving average filter coefficients                     * 
*            nr   :  Number of output samples                               * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*     The IIR performs an auto-regressive moving-average (ARMA)             * 
*     filter with 4 auto-regressive filter coefficients and 5               * 
*     moving-average filter coefficients for nr output samples.             * 
*     The output vector is stored in two locations. This routine            * 
*     is used as a high pass filter in the VSELP vocoder.                   * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*     1. The inner loop is completely unrolled so that two loops            * 
*        become one loop.                                                   * 
*     2. The outer loop is unrolled twice to break the dependency           * 
*        bound of 8 cycles.                                                 * 
*     3. The values of the r1 array are not loaded each time to             * 
*        calculate the value of the 'sum' variable. Instead, the            * 
*        4 values of the r1 array required are maintained in                * 
*        registers so that memory operations are significantly              * 
*        reduced.                                                           * 
*     4. Unrolling by 2 implies calculation of constants before             * 
*        the start of the loop. Due to shortage of registers                * 
*        these constants are stored in the stack and later                  * 
*        retrieved each time they are required.                             * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*     1. The value of 'nr' must be a multiple of 2.                         * 
*     2. Extraneous loads are allowed in the program.                       *
*     3. Modulus(h1[1]) < 1 must be true.                                   *
*                                                                           * 
*   C CODE                                                                  * 
*                                                                           * 
*   This is the C equivalent of the Assembly Code without                   * 
*   restrictions.                                                           * 
*                                                                           * 
*   Note that the assembly code is hand optimized and restrictions          * 
*   may apply.                                                              * 
*                                                                           * 
*   void DSPF_sp_iir (float* restrict r1,                                        * 
*                    const float*    x,                                     * 
*                    float* restrict r2,                                    * 
*                    const float*    h2,                                    * 
*                    const float*    h1,                                    * 
*                    int nr                                                 * 
*                   )                                                       * 
*       {                                                                   * 
*          int i, j;                                                        * 
*          float sum;                                                       * 
*                                                                           * 
*          for (i = 0; i < nr; i++)                                         * 
*          {                                                                * 
*              sum = h2[0] * x[4+i];                                        * 
*                                                                           * 
*              for (j = 1; j <= 4; j++)                                     * 
*                  sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];             * 
*                                                                           * 
*              r1[4+i] = sum;                                               * 
*              r2[i] = r1[4+i];                                             * 
*          }                                                                * 
*      }                                                                    * 
*                                                                           * 
*   NOTES                                                                   * 
*                                                                           * 
*      1. The stack must be placed in L2 to reduce overhead due to          * 
*         external memory access stalls.                                    * 
*                                                                           * 
*   CYCLES                                                                  * 
*      6 * nr + 59                                                          * 
*      eg. for nr = 64, cycles = 443.                                       * 
*                                                                           * 
*   CODESIZE                                                                * 
*                                                                           * 
*      1152 bytes                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ================= SYMBOLIC REGISTER ASSIGNMENTS ========================= *

                .asg B2, B_cntr
                .asg A3, A_xptr
                .asg A8, A_h24
                .asg A6, A_xi
                .asg A9, A_p1
                .asg B8, B_h23
                .asg B6, B_xip1
                .asg B9, B_p2
                .asg A12, A_xip5
                .asg B13, B_k4
                .asg A7, A_h22
                .asg B7, B_h21
                .asg A5, A_xip2
                .asg A9, A_p3
                .asg B13, B_xip4
                .asg B9, B_p4
                .asg A15, A_k0
                .asg A9, A_p11
                .asg A15, A_k1
                .asg B9, B_p21
                .asg A11, A_h20
                .asg B10, B_xip4
                .asg A10, A_p5
                .asg A1, A_k2
                .asg A9, A_p31
                .asg B5, B_xip3
                .asg B13, B_xip3t
                .asg B9, B_p51
                .asg A9, A_p61
                .asg B9, B_p41
                .asg A14, A_s2
                .asg A14, A_s1
                .asg A14, A_h14
                .asg A4, A_yi
                .asg A9, A_p9
                .asg B9, B_p8
                .asg B11, B_yip1
                .asg A14, A_k7
                .asg A15, A_k8
                .asg A9, A_p101
                .asg A9, A_p7
                .asg B9, B_p81
                .asg B13, B_p6
                .asg B12, B_k3
                .asg A14, A_s3
                .asg A15, A_s5
                .asg A10, A_s31
                .asg A10, A_k5
                .asg B9, B_p91
                .asg B13, B_s4
                .asg B9, B_p41
                .asg A10, A_s11
                .asg B4, B_yip3
                .asg B13, B_s51
                .asg B4, B_s91
                .asg B10, B_p71
                .asg A2, A_p71
                .asg A2, A_yip4
                .asg B10, B_k6
                .asg B15, B_SP
                .asg A0, A_h12                
                .asg B1, B_h11
                .asg B12, B_s81
                .asg B13, B_s21
                .asg B13, B_s41
                .asg B13, B_s6
                .asg B3, B_h13
                .asg A14, A_xip4
                .asg A2, A_s2temp
                .asg B11, B_k1
                .asg B10, B_s71
                .asg B0, B_r1ptr
                .asg A13, A_r2ptr
                
* =================================================================== *                
                
        .text
        .global _DSPF_sp_iir
_DSPF_sp_iir:

       SUBAW  .D2     B_SP,        22,       B_SP     ; make stk space  
||     MV     .S2     B8,         B_cntr              ; loop counter
||     MV     .S1X    B4,         A_xptr              ; a3 has x_ptr
||     MV     .L2     A4,         B0                  ; b0 has r1_ptr

          
       LDDW   .D2T2   *B6++,      B5:B4               ; h2[1]:h2[0]
||     LDDW   .D1T1   *A8++,      A5:A4               ; h1[1]:(h1[0]->not reqd)
||     B      .S1     no_int
||     MVC    .S2     CSR,        B7
          
       LDDW   .D2T2   *B6++,      B13:B12             ; h2[3]:h2[2]
||     LDDW   .D1T1   *A8++,      A13:A12             ; h1[3]:h1[2]
||     AND    .L2     B7,         -2,       B9
          
       LDW    .D2T2   *B6++,      B11                 ; h2[4]
||     LDW    .D1T1   *A8++,      A11                 ; h1[4]
||     MV     .S1X    B_SP,        A1
||     MVC    .S2     B9,         CSR
          
       STW    .D2T2   B12,        *B_SP[10]           ; push b12
||     STW    .D1T1   A12,        *A1[12]             ; push a12
       
       STW    .D2T2   B13,        *B_SP[11]           ; push b13
||     STW    .D1T1   A13,        *A1[13]             ; push a13

no_int:
            
       MPYSP  .M1X    A5,         B5,       A8        ; h1[1]*h2[1]
||     MPYSP  .M2X    A5,         B4,       B8        ; h1[1]*h2[0]
||     STW    .D2T2   B11,        *B_SP[15]
||     STW    .D1T1   A11,        *A1[17]
          
       MPYSP  .M1X    A5,         B13,      A8        ; h1[1]*h2[3]
||     MPYSP  .M2X    A5,         B12,      B8        ; h1[1]*h2[2]
||     STW    .D2T2   B10,        *B_SP[14]
||     STW    .D1T1   A10,        *A1[16]
          
       MPYSP  .M2X    A5,         B11,      B10       ; h1[1]*h2[4]
||     MPYSP  .M1     A5,         A5,       A10       ; h1[1]*h1[1]
||     STW    .D2T1   A11,        *B_SP[7]             ; save h1[4]
||     STW    .D1T2   B14,        *A1[22]             ; push B14
          
       MPYSP  .M2X    A5,         B11,      B10       ; h1[1]*h2[4]
||     MPYSP  .M1     A5,         A5,       A10       ; h1[1]*h1[1]
||     STW    .D1T1   A14,        *A1[18]
||     STW    .D2T2   B3,         *B_SP[20]
          
       SUBSP  .L1X    B12,        A8,       A14       ; h2[2] - h1[1]*h2[1]
||     SUBSP  .L2     B5,         B8,       B14       ; h2[1] - h1[1]*h2[0]
||     MPYSP  .M1     A5,         A11,      A8        ; h1[1]*h1[4], k8
||     STW    .D1T1   A15,        *A1[19]
||     STW    .D2T2   B7,         *B_SP[21]

          
       SUBSP  .L2     B13,        B8,       B14       ; h2[3] - h1[1]*h2[2], k2
||     SUBSP  .L1X    B11,        A8,       A14       ; h2[4] - h1[1]*h2[3], k1
            
       MPYSP  .M1     A5,         A12,      A10       ; h1[1]*h1[2]
          
       STW    .D2T2   B10,        *B_SP[0]            ; SP(0)=h1[1]*h2[4], k0
||     SUBSP  .L1     A10,        A12,      A14       ; h1[1]*h1[1]-h1[2]
||     MPYSP  .M1     A5,         A13,      A10       ; h1[1]*h1[3]
          
       STW    .D2T1   A14,        *B_SP[3]            ; k3
||     STW    .D1T2   B14,        *A1[4]              ; k4
          
       STW    .D2T1   A8,         *B_SP[9]            ; k8
||     MV     .S1X    B14,        A1                  ; k2
           
       STW    .D2T1   A14,        *B_SP[1]            ; k1            
||     SUBSP  .L1     A10,        A13,      A14       ; k6=h1[1]*h1[2]-h1[3]
          
       SUBSP  .L1     A10,        A11,      A_k7      ; k7
||     STW    .D2T1   A14,        *B_SP[5]            ; k5
            
       MV     .S1X    B11,        A_h24               ; h2[4]
||     MV     .D2     B13,        B_h23               ; h2[3]          
          
       MV     .S1X    B12,        A_h22               ; h2[2]
||     MV     .S2     B5,         B_h21               ; h2[1]
||     MV     .L2X    A13,        B_h13               ; h1[3]
||     LDDW   .D2T2   *B_r1ptr++,      B11:B10        ; r1[1]:r1[0]
||     LDDW   .D1T1   *A_xptr++,      A5:A4           ; x[1]:x[0]
          
       STW    .D2T1   A14,        *B_SP[6]            ; k6
||     MV     .S1X    B4,         A_h20               ; h2[0]
||     MV     .S2X    A5,         B_h11               ; h1[1]          
||     LDDW   .D1T2   *A_xptr++,      B13:B12         ; x[3]:x[2]
          
       LDDW   .D2T1   *B_SP,       A15:A14            ; k1:k0  
||     LDW    .D1T2   *A_xptr++,      B_xip4          ; x[4]
||     MV     .S1     A12,        A_h12               ; h1[2]
||     MV     .L1X    B_SP,        A10                 
           
       LDW    .D2T2   *B_SP[3],    B12                ; k3
||     MV     .S1     A6,         A_r2ptr             ; a13 has r2_ptr
||     STW    .D1T1   A_k7,        *A10[8]            ; k7          
            
       LDDW   .D2T1   *B_r1ptr++,      A15:A14        ; r1[3]:r1[2]
          
* ===================== PIPED LOOP PROLOG ============================= *          
            
       MPYSP  .M1     A_h24,      A4,       A_p1        ; p1=h2[4]*x[i]
||     MPYSP  .M2X    B_h23,      A5,       B_p2        ; p2=h2[3]*x[i+1]
||     LDW    .D1T1   *A_xptr++[2],         A_xip5      ; x[i+5]          
||     LDW    .D2T2   *B_SP[4],   B_k4                  ; k4
||     MV     .S1X    B10,        A_yi                  ; transfer y[i]
||     MV     .L1     A4,         A_xi                  ; transfer x[i]
          
            
       MPYSP  .M1X    A_h22,      B12,      A_p3        ; p3=h2[2]*x[i+2]
||     MPYSP  .M2     B_h21,      B_xip3t,  B_p4        ; p4=h2[1]*x[i+3]
||     MV     .S2X    A5,         B_xip1                ; transfer x[i+1]
||     MV     .D2     B_xip3t,    B_xip3                ; transfer x[i+3]
          
            
       MPYSP  .M1     A14,        A_xi,     A_p11       ; p11=k0*xi
||     MPYSP  .M2X    A15,        B_xip1,   B_p21       ; p21=k1*x[i+1]
||     MV     .S1X    B12,        A_xip2                ; transfer x[i+2]
          
            
       MPYSP  .M1X    A_h20,      B_xip4,   A_p5        ; p5=h2[0]*x[i+4]
||     MV     .D1     A_xip2,     A_xi                  ; x[i]=x[i+2]
            
            
       MPYSP  .M1     A_xip2,     A_k2,     A_p31       ; p31=x[i+2]*k2
||     MPYSP  .M2     B_xip3,     B_k3,     B_p41       ; p41=x[i+3]*k3
||     ADDSP  .L1X    A_p1,       B_p2,     A_s1        ; s1=p1+p2
||     MV     .S1     A14,        A_yip4                ; transfer y[i+2]
||     MV     .S2X    A15,        B4                    ; transfer y[i+3]
||     MV     .D2     B_xip3,     B_xip1                ; x[i+1]=x[i+3]
          
            
       MPYSP  .M2     B_xip4,     B_k4,     B_p51       ; p51=k4*x[i+4]
||     MPYSP  .M1     A_h20,      A_xip5,   A_p61       ; p61=h2[0]*x[i+5]
||     ADDSP  .L1X    A_p3,       B_p4,     A_s2        ; s2=p3+p4
||     LDW    .D2T1   *B_SP[7],   A_h14                 ; load h1[4]
          
            
       SUBSP  .L1X    B_p21,      A_p11,    A_s11       ; s11=-p11+p21
||     LDDW   .D2T1   *B_SP[4],   A_k8:A_k7             ; k8:k7
          
            
       MV     .S1X    B_xip4,     A_xip2                ; x[i+2]=x[i+4]
            
            
       ADDSP  .L2X    A_p31,      B_p41,    B_s21       ; s21=p31+p41
||     ADDSP  .L1     A_s1,       A_p5,     A_s3        ; s3=s1+p5
||     LDW    .D2T2   *B_SP[1],   B_k1                  ; load k1
          
          
       LDW    .D2T1   *B_SP[0],    A_k0                 ; load k0
||     MV     .S1     A_s2,        A12                 
||     MV     .S2X    A_xip5,      B_xip3               ; x[i+3]=x[i+5]
          

       MPYSP  .M1     A_h14,        A_yi,   A_p9        ; p9=h1[4]*y[i]
||     MPYSP  .M2     B_h13,        B_yip1, B_p8        ; p8=h1[3]*y[i+1]
||     ADDSP  .L1X    B_p51,        A_p61,  A_s31       ; s31=p51+p61
||     LDW    .D1T1   *-A_xptr[1],  A_xip4              ; load x[i+4]
          

       MPYSP  .M1     A_yi,         A_k8,   A_p101      ; p101=k8*y[i]
||     MPYSP  .M2     B_yip1,       A_k7,   B_p91       ; p91=k7*y[i+1]
||     LDW    .D2T2   *B_SP[3],     B_k3                ; load k3
          

       MPYSP  .M1     A_h24,        A_xi,   A_p1        ; p1=h2[4]*x[i]
||     MPYSP  .M2     B_h23,        B_xip1, B_p2        ; p2=h2[3]*x[i+1]
||     LDW    .D1T1   *A_xptr++[2], A_xip5              ; x[i+5]          
||     LDW    .D2T2   *B_SP[4],     B_k4                ; load k4
||     ADDSP  .L1     A_s3,         A12,    A_s5        ; s5=s3+s2
||     ADDSP  .L2X    A_s11,        B_s21,  B_s51       ; s51=s11+s21
            
       MPYSP  .M1     A_h22,        A_xip2, A_p3        ; p3=h2[2]*x[i+2]
||     MPYSP  .M2     B_h21,        B_xip3, B_p4        ; p4=h2[1]*x[i+3]
            
       MPYSP  .M1     A_k0,         A_xi,   A_p11       ; p11=k0*xi
||     MPYSP  .M2     B_k1,         B_xip1, B_p21       ; p21=k1*x[i+1]
||     ADDSP  .L2X    A_p9,         B_p8,   B_s4        ; s4=p8+p9
||     LDW    .D2T2   *B_SP[6],     B_k6                ; load k6
            
       MPYSP  .M1     A_h20,        A_xip4, A_p5        ; p5=h2[0]*x[i+4]
||     MV     .D1     A_xip2,       A_xi                ; x[i]=x[i+2]
||     ADDSP  .L2X    A_p101,       B_p91,  B_s41       ; load s41=p91+p101
            
       MPYSP  .M1     A_xip2,       A_k2,   A_p31       ; p31=x[i+2]*k2
||     MPYSP  .M2     B_xip3,       B_k3,   B_p41       ; p41=x[i+3]*k3
||     ADDSP  .L1X    A_p1,         B_p2,   A_s1        ; s1=p1+p2
||     ADDSP  .L2X    B_s51,        A_s31,  B_s71       ; s71=s31+s51
||     LDW    .D2T1   *B_SP[5],     A_k5                ; load k5
||     MV     .S1     A_xip4,       A_xip2                  
||     MV     .S2     B_xip3,       B_xip1              ; x[i+1]=x[i+3]
          
       MPYSP  .M2X    A_xip4,       B_k4,   B_p51       ; p51=k4*x[i+4]
||     MPYSP  .M1     A_h20,        A_xip5, A_p61       ; p61=h2[0]*x[i+5]
||     ADDSP  .L1X    A_p3,         B_p4,   A_s2        ; s2=p3+p4
||     LDW    .D2T1   *B_SP[7],     A_h14               ; load h1[4]
          
       SUBSP  .L1X    B_p21,        A_p11,  A_s11       ; s11=-p11+p21
||     LDDW   .D2T1   *B_SP[4],     A_k8:A_k7           ; k8:k7
||     SUBSP  .L2X    A_s5,         B_s4,   B_s6        ; s6=s5-s4

       MPYSP  .M1     A_yip4,       A_h12,  A_p7        ; p7=y[i+2]*h1[2]
||     MPYSP  .M2X    A_yip4,       B_k6,   B_p81       ; p81=y[i+2]*k6
||     MV     .S1     A_yip4,       A_yi                ; y[i]=y[i+2]
            
       ADDSP  .L2X    A_p31,        B_p41,  B_s21       ; s21=p31+p41
||     ADDSP  .L1     A_s1,         A_p5,   A_s3        ; s3=s1+p5
||     LDW    .D2T2   *B_SP[1],     B_k1                ; load k1
          
       LDW    .D2     *B_SP[0],     A_k0                ; load k0
||     MV     .S1     A_s2,         A_s2temp                  
||     MPYSP  .M2     B_yip3,       B_h11,  B_p6        ; p6=y[i+3]*h1[1]
||     MPYSP  .M1X    B_yip3,       A_k5,   A_p71       ; p71=y[i+3]*k5
||     ADDSP  .L2     B_s71,        B_s41,  B_s81       ; s81=s41+s71
||     MV     .S2     B_yip3,       B_yip1              ; y[i+1]=y[i+3]
          
       MPYSP  .M1     A_h14,        A_yi,   A_p9        ; p9=h1[4]*y[i]
||     MPYSP  .M2     B_h13,        B_yip1, B_p8        ; p8=h1[3]*y[i+1]
||     ADDSP  .L1X    B_p51,        A_p61,  A_s31       ; s31=p51+p61
||     LDW    .D1T1   *-A_xptr[1],  A_xip4              ; load x[i+4]
||     MV     .S2X    A_xip5,       B_xip3              ; x[i+3]=x[i+5]

* ================= PIPED LOOP KERNEL ================================== *          
loop:          
            
       MPYSP  .M1     A_yi,         A_k8,   A_p101      ; p101=k8*y[i]
||     MPYSP  .M2     B_yip1,       A_k7,   B_p91       ; p91=k7*y[i+1]
||     LDW    .D2T2   *B_SP[3],     B12                 ; load k3
||     SUBSP  .L1X    B_s6,         A_p7,   A15         ; s7=s6-p7
          
       MPYSP  .M1     A_h24,        A_xi,   A_p1        ; p1=h2[4]*x[i]
||     MPYSP  .M2     B_h23,        B_xip1, B_p2        ; p2=h2[3]*x[i+1]
||     LDW    .D1T1   *A_xptr++[2], A_xip5              ; x[i+5]          
||     LDW    .D2T2   *B_SP[4],     B_k4                ; k4
||     ADDSP  .L1     A_s3,         A_s2temp,A_s5       ; s5=s3+s2
||     ADDSP  .L2X    A_s11,        B_s21,  B_s51       ; s51=s11+s21

       MPYSP  .M1     A_h22,        A_xip2, A_p3        ; p3=h2[2]*x[i+2]
||     MPYSP  .M2     B_h21,        B_xip3, B_p4        ; p4=h2[1]*x[i+3]
||     ADDSP  .L2     B_s81,        B_p81,  B_s91       ; s91=s81+p81
||     MV     .S2X    A_p71,        B_p71               ; save p71
          
       MPYSP  .M1     A_k0,         A_xi,   A_p11       ; p11=k0*xi
||     MPYSP  .M2     B_k1,         B_xip1, B_p21       ; p21=k1*x[i+1]
||     ADDSP  .L2X    A_p9,         B_p8,   B_s4        ; s4=p8+p9
||     LDW    .D2T2   *B_SP[6],     B_k6                ; load k6
          
       MPYSP  .M1     A_h20,        A_xip4, A_p5        ; p5=h2[0]*x[i+4]
||     MV     .D1     A_xip2,       A_xi                ; x[i]=x[i+2]
||     ADDSP  .L2X    A_p101,       B_p91,  B_s41       ; load s41=p91+p101
||     SUBSP  .L1X    A15,          B_p6,   A_yip4      ; y[i+4]=s7-p6
||     SUB    .S2     B_cntr,       2,      B_cntr      ; decr cntr        
            
       MPYSP  .M1     A_xip2,       A_k2,   A_p31       ; p31=x[i+2]*k2
||     MPYSP  .M2     B_xip3,       B_k3,   B_p41       ; p41=x[i+3]*k3
||     ADDSP  .L1X    A_p1,         B_p2,   A_s1        ; s1=p1+p2
||     ADDSP  .L2X    B_s51,        A_s31,  B_s71       ; s71=s31+s51
||     LDW    .D2T1   *B_SP[5],     A_k5                ; load k5
||     MV     .S1     A_xip4,       A_xip2              ; x[i+2]=x[i+4]                
||     MV     .S2     B_xip3,       B_xip1              ; x[i+1]=x[i+3]          
          
       MPYSP  .M2X    A_xip4,       B_k4,   B_p51       ; p51=k4*x[i+4]
||     MPYSP  .M1     A_h20,        A_xip5, A_p61       ; p61=h2[0]*x[i+5]
||     ADDSP  .L1X    A_p3,         B_p4,   A_s2        ; s2=p3+p4
||     LDW    .D2T1   *B_SP[7],     A_h14               ; load h1[4]
||     ADDSP  .L2     B_s91,        B_p71,  B_yip3      ; y[i+5]=s91+p71
||[B_cntr] B  .S2     loop                            
          
       SUBSP  .L1X    B_p21,        A_p11,  A_s11       ; s11=-p11+p21
||     LDDW   .D2T1   *B_SP[4],     A_k8:A_k7           ; k8:k7
||     SUBSP  .L2X    A_s5,         B_s4,   B_s6        ; s6=s5-s4
          
       MPYSP  .M1     A_yip4,       A_h12,  A_p7        ; p7=y[i+2]*h1[2]
||     MPYSP  .M2X    A_yip4,       B_k6,   B_p81       ; p81=y[i+2]*k6
||     MV     .S1     A_yip4,       A_yi                ; y[i]=y[i+2]
||     STW    .D2T1   A_yip4,       *B_r1ptr++          ; store in r1 array
                        
       ADDSP  .L2X    A_p31,        B_p41,  B_s21       ; s21=p31+p41
||     ADDSP  .L1     A_s1,         A_p5,   A_s3        ; s3=s1+p5
||     LDW    .D2T2   *B_SP[1],     B_k1                ; load k1
||     STW    .D1T1   A_yip4,       *A_r2ptr++          ; store in r2 array
          
       LDW    .D2T1   *B_SP[0],     A_k0                ; load k0
||     MV     .S1     A_s2,         A_s2temp            ; save s2      
||     MPYSP  .M2     B_yip3,       B_h11,  B_p6        ; p6=y[i+3]*h1[1]
||     MPYSP  .M1X    B_yip3,       A_k5,   A_p71       ; p71=y[i+3]*k5
||     STW    .D1T2   B_yip3,       *A_r2ptr++          ; store into r2    
||     ADDSP  .L2     B_s71,        B_s41,  B_s81       ; s81=s41+s71
||     MV     .S2     B_yip3,       B_yip1              ; y[i+1]=y[i+3]
          
       MPYSP  .M1     A_h14,        A_yi,   A_p9        ; p9=h1[4]*y[i]
||     MPYSP  .M2     B_h13,        B_yip1, B_p8        ; p8=h1[3]*y[i+1]
||     ADDSP  .L1X    B_p51,        A_p61,  A_s31       ; s31=p51+p61
||     LDW    .D1T1   *-A_xptr[1],  A_xip4              ; load x[i+4]
||     STW    .D2     B_yip3,       *B_r1ptr++          ; store into r1        
||     MV     .S2X    A_xip5,       B_xip3              ; x[i+3]=x[i+5]
          
* ========== END OF PIPED LOOP KERNEL ================================= *
       
       MV     .S1X    B_SP,        A1
||     LDDW   .D2T2   *B_SP[10],   B3:B2

       LDDW   .D2T2   *B_SP[5],    B13:B12
||     LDDW   .D1T1   *A1[6],     A13:A12       
  
       LDDW   .D2T2   *B_SP[7],    B11:B10
||     LDDW   .D1T1   *A1[8],     A11:A10       
       
       LDDW   .D2T1   *B_SP[9],    A15:A14
||     LDW    .D1T2   *A1[22],    B14

       ADDAW  .D2     B_SP,        22,       B_SP
       
       B      .S2     B2
       
       MVC    .S2     B3,         CSR
       
       NOP            4

                .end

* ======================================================================== *
*  End of file: DSPF_sp_iir.asm                                                 *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_iirlat./1117057350  269   0     0       26182     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*    USAGE                                                                  * 
*        This routine has following C prototype:                            * 
*                                                                           * 
*             void DSPF_sp_iirlat(                                               * 
*                           float *x,                                       * 
*                           int nx,                                         * 
*                           const float * restrict k,                       * 
*                           int nk,                                         * 
*                           float * restrict b,                             * 
*                           float * r                                       * 
*                           )                                               * 
*          x[nx]   : Input vector                                           * 
*          nx      : Length of input vector.                                * 
*          k[nk]   : Reflection coefficients                                * 
*          nk      : Number of reflection coefficients/lattice stages       * 
*                    Must be multiple of 2 and >=6.                         * 
*          b[nk+1] : Delay line elements from previous call. Should be      * 
*                    initialized to all zeros prior to the first call.      * 
*          r[nx]   : Output vector                                          * 
*                                                                           * 
*      DESCRIPTION                                                          * 
*          This routine implements a real all-pole IIR filter in lattice    * 
*          structure (AR lattice). The filter consists of nk lattice stages * 
*          Each stage requires one reflection coefficient k and one delay   * 
*          element b. The routine takes an input vector x[] and returns the * 
*          filter output in r[]. Prior to the first call of the routine the * 
*          delay elements in b[] should be set to zero. The input data may  * 
*          have to be pre-scaled to avoid overflow or achieve better SNR. T * 
*          reflections coefficients lie in the range -1.0 < k < 1.0. The    * 
*          order of the coefficients is such that k[nk-1] corresponds to th * 
*          first lattice stage after the input and k[0] corresponds to the  * 
*          last stage.                                                      * 
*                                                                           *
*     TECHNIQUES                                                            * 
*          1.  The loop has been unrolled by 4 times.                       * 
*                                                                           * 
*          2.  Register sharing has been used to optimize on the use of regs*
*                                                                           * 
*                                                                           * 
*     ASSUMPTIONS                                                           *
*                                                                           * 
*         1. nk is a multiple of 2 and >=6.                                 *
*         2. Extraneous loads are allowed (80 bytes) before the start of    *
*            array.                                                         * 
*                                                                           * 
*     C CODE                                                                *
*                                                                           * 
*        void DSPF_sp_iirlat(float * x, int nx, const float * restrict k, int nk,* 
*                       float * restrict b, float * r)                      *
*        {                                                                  *
*                                                                           * 
*       float rt;     // output       //                                    *
*       int i, j;                                                           *
*                                                                           *
*       for (j = 0; j < nx; j++)                                            *
*       {                                                                   *
*           rt = x[j];                                                        *
*                                                                           *
*           for (i = nk - 1; i >= 0; i--)                                   *
*           {                                                                *
*               rt = rt - b[i] * k[i];                                        *
*               b[i + 1] = b[i] + rt * k[i];                                *
*           }                                                                *
*                                                                           *
*           b[0] = rt;                                                      *                                
*           r[j] = rt;                                                        *
*       }                                                                   *
*                                                                            * 
*      }                                                                    *
*   NOTES                                                                   * 
*                                                                           * 
*                                                                           * 
*     CYCLES                                                                * 
*         (6*floor((nk-1)/4)+29)* nr + 25                                   *         * 
*         For nk = 10, nr = 100, cycles=4125                                *                                        * 
*                                                                           * 
*     CODESIZE                                                              * 
*         1024 bytes                                                        * 
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ================ SYMBOLIC REGISTER ASSIGNMENTS ========================== *
                   
                   .asg B4, B_bptr
                   .asg A7, A_bi
                   .asg A6, A_bim1
                   
                   .asg A7, A_biag
                   .asg A6, A_bim1ag
                   
                   .asg B7, B_kim2
                   .asg A4, A_kptr
                   .asg B6, B_kim3
                   
                   .asg B7, B_bim2ag
                   .asg B6, B_bim3ag
                   
                   .asg B13, B_bim2
                   .asg B12, B_bim3
                   
                   .asg A15, A_ki
                   .asg A14, A_kim1
                   .asg A15, A_kiag
                   .asg A14, A_kim1ag
                   
                   .asg A8, A_temp1
                   .asg B8, B_p2
                   .asg A9, A_p1
                   .asg B12, B_p3
                   .asg B12, B_s1
                   .asg A10, A_temp2
                   .asg A9, A_temp4
                   .asg B10, B_temp3
                   .asg B11, B_kim2ag
                   .asg B10, B_kim3ag
                   .asg B10, B_rtcopy
                   .asg A13, A_temp1copy
                   .asg A6, A_rt1
                   .asg B12, B_pr2
                   .asg B12, B_rt2
                   .asg B9, B_rt3
                   .asg B9, B_pr3
                   .asg A12, A_rt
                   .asg A0, A_bip1s
                   .asg B9, B_bis
                   .asg B13, B_bim1s
                   .asg A2, A_bim2s
                   .asg B14, B_b_ptr
                   .asg A3, A_k_ptr
                   .asg B1, B_icntr
                   .asg A7,A_pr4
                   .asg A9, A_pr1
                   .asg A9, A_temp2copy
                   .asg B2, B_nolastadd
                   .asg A9, A_bptrcopy
                   .asg A1, A_ocntr
                   .asg A5, A_xptr
                   
* ========================================================================== *                   

        .text
        .global _DSPF_sp_iirlat
_DSPF_sp_iirlat:

       ; push necessary registers into stack
       STW    .D2     B3,         *-B15[2]         ; save ret address   
||     B      .S1     NO_INT                       ; no interrupts   
||     MV     .D1     A4,         A_xptr               ; store x pointer
||     MVC    .S2     CSR,        B1               ; disable interrupts             
||     MV     .L1X    B15,        A4               ; copy stk ptr   

       STW    .D2T1   A15,        *B15--[12]       ; store a15   
||     MV     .S1X    B15,        A2               ; copy stk ptr   
||     SUB            A6,         8,        A_kptr ; store k pointer                                
||     AND    .L2     B1,         -2,       B1     ; disable ints   
||     STW    .D1T2   B1,         *-A4[1]          ; save CSR   

       STW    .D2T1   A10,        *B15[0]          ; store a10   
||     STW    .D1T2   B10,        *-A2[11]         ; store b10   
||     SUB    .L2X    A8,         8,        B_bptr ; save b pointer
||     MVC    .S2     B1,         CSR              ; disable ints   
||     MV     .L1X    B4,         A_ocntr          ; outer loop count

       STW    .D2T1   A11,        *B15[2]          ; store a11   
||     STW    .D1T2   B11,        *-A2[9]          ; store b11   
||     SUB    .L2X    A6,         12,       B5     ; copy of b-ptr       

       STW    .D2T1   A12,        *B15[4]          ; store a12   
||     STW    .D1T2   B12,        *-A2[7]          ; store b12   
||     SUB    .L2     B5,         12,       B5     ; adjust bptr       
     
       STW    .D2T1   A13,        *B15[6]          ; push a13   
||     STW    .D1T2   B13,        *-A2[5]          ; push b13   
||     SHR    .S2     B6,         1,     B_icntr   ; inner loop count              

NO_INT:     

       STW    .D2T1   A14,        *B15[8]          ; push a14
||     STW    .D1T2   B14,        *-A2[3]          ; push b14
||     SHL    .S1X    B_icntr,    3,        A15    ; for b,k ptr init
             
       ADDAW  .D1     A_xptr,     A_ocntr,  A_xptr ; store ptr   
||     ADDAD  .D2     B_bptr,     B_icntr,  B_bptr ; point bptr to last   
||     ADD    .S1     A_kptr,     A15,      A_kptr ; point kptr to last   
             
************ PROLOG BEGINS ******************************

       LDDW   .D2T1   *B_bptr--,  A_bi:A_bim1      ; b[i],b[i-1]   
||     LDDW   .D1T2   *-A_kptr[1],B_kim2:B_kim3    ; k[i-2],k[i-3]   
             
               
       LDDW   .D2T2   *B_bptr--,  B_bim2:B_bim3    ; b[i-2],b[i-3]   
||     LDDW   .D1T1   *A_kptr--[2],A_ki:A_kim1     ; k[i], k[i-1]    
             
               
       ZERO   .S2     B_nolastadd                  ; init cond   
||     MV     .S1X    B_icntr,    A11              ; save inner loop cntr             
               
       LDW    .D1T1   *-A_xptr[A_ocntr],   A_rt    ; load x[j]   

               
       MV     .S2     B8,         B3               ; r pointer preserve
||     ADD    .D1     A_kptr,     16,       A_k_ptr; k pointer preserve
               
       ADD    .D2     B_bptr,     16,       B_b_ptr; b pointer preserve
               
oloop:                              
               
       LDDW   .D2T1   *B_bptr--,  A_bi:A_bim1      ; b[i],b[i-1]   
||     LDDW   .D1T2   *-A_kptr[1],B_kim2:B_kim3    ; k[i-2],k[i-3]   
||     MPYSP  .M1     A_bi,       A_ki,     A_temp1; b[i]*k[i]   
||     MPYSP  .M2     B_kim2,     B_bim2,   B_p2   ; p2=b[i-2]*k[i-2]   
||     SUB    .S1     A_ocntr,    1,        A_ocntr; decr oloop cntr   
               
       LDDW   .D2T2   *B_bptr--,  B_bim2:B_bim3    ; b[i-2],b[i-3]   
||     LDDW   .D1T1   *A_kptr--[2],A_ki:A_kim1     ; k[i],k[i-1]    
||     MPYSP  .M1     A_bim1,     A_kim1,   A_p1   ; p1=b[i-1]*k[i-1]   
||     MPYSP  .M2     B_kim3,     B_bim3,   B_p3   ; p3=k[i-3]*b[i-3]   
               
       NOP            3                               
               
       ADDSP  .L2     B_p2,       B_p3,     B_s1   ; s1=p2+p3   
||     ADDSP  .L1     A_temp1,    A_p1,     A_temp2; temp2=p1+temp1   
             
               
       LDDW   .D2T1   *B_bptr--,  A_bi:A_bim1      ; b[i],b[i-1]   
||     LDDW   .D1T2   *-A_kptr[1],B_kim2:B_kim3    ; k[i-2],k[i-3]   
||     MPYSP  .M1     A_bi,       A_ki,     A_temp1; temp1=b[i]*k[i]   
||     MPYSP  .M2     B_kim2,     B_bim2,   B_p2   ; p2=k[i-2]*b[i-2]   
             
               
       LDDW   .D2T2   *B_bptr--,  B_bim2:B_bim3    ; b[i-2],b[i-3]   
||     LDDW   .D1T1   *A_kptr--[2],A_ki:A_kim1     ; k[i],k[i-1]    
||     MPYSP  .M1     A_bim1,     A_kim1,   A_p1   ; p1=b[i-1]*k[i-1]   
||     MPYSP  .M2     B_kim3,     B_bim3,   B_p3   ; p3=k[i-3]*b[i-3]   
             
       NOP                                                        
             
       ADDSP  .L1X    B_s1,       A_temp2,  A_temp4; temp4=s1+temp2   
||     MV     .S1     A_temp1,    A_temp1copy      ; copy temp1   
||     ADDSP  .L2X    A_temp2,    B_p2,     B_temp3; temp3=p2+temp2   
           
             
       SUB    .S1X    B_icntr,    3,        A2        
||     ADDAD  .D2     B5,         1,        B11       
             
       ADDSP  .L2     B_p2,       B_p3,     B_s1   ; s1=p2+p3   
||     ADDSP  .L1     A_temp1,    A_p1,     A_temp2; temp2=temp1+p1   
||     LDDW   .D1T1   *A_kptr[6], A_ki:A_kim1      ; k[i],k[i-1]   
||     MV     .S2X    A_rt,       B_rtcopy         ; copy rt   
||     LDDW   .D2T2   *B11[B_icntr],B_kim2ag:B_kim3ag; load again   
           
       LDDW   .D2T1   *B_bptr--,  A_bi:A_bim1      ; b[i],b[i-1]   
||     LDDW   .D1T2   *-A_kptr[1],B_kim2:B_kim3    ; k[i-2],k[i-3]   
||     MPYSP  .M1     A_bi,       A_ki,     A_temp1; temp1=b[i]*k[i]   
||     MPYSP  .M2     B_kim2,     B_bim2,   B_p2   ; p2=k[i-2]*b[i-2]   
||     SUBSP  .L1     A_rt,       A_temp1copy,A_rt1; rt1=rt-temp1     
||     SUBSP  .L2X    B_rtcopy,   A_temp2,  B_rt2  ; rt2=rt-temp2   
           
       LDDW   .D2T2   *B_bptr--,  B_bim2:B_bim3    ; load b[i-2],b[i-3]   
||     LDDW   .D1T1   *A_kptr--[2],A_ki:A_kim1     ; k[i],k[i-1]    
||     MPYSP  .M1     A_bim1,     A_kim1,   A_p1   ; p1=b[i-1]*k[i-1]
||     MPYSP  .M2     B_kim3,     B_bim3,   B_p3   ; p3=k[i-3]*k[i-3]   
||     SUBSP  .L1     A_rt,       A_temp4,  A_rt   ; rt=rt-temp4   
||     SUBSP  .L2X    A_rt,       B_temp3,  B_rt3  ; rt3=rt-temp3   
           
       MV     .S1X    B_bptr,     A_bptrcopy       ; copy bptr   
||[!A2]ZERO   .D2     B_nolastadd                     
||[A2] ADD    .S2     B_nolastadd,1,   B_nolastadd ; check for last iter
             
  [B_nolastadd]ADDSP.L1X  B_s1,   A_temp2,  A_temp4; temp4=s1+temp2   
||     MV     .S1     A_temp1,    A_temp1copy      ; copy temp1   
||     ADDSP  .L2X    A_temp2,    B_p2,     B_temp3; temp3=temp2+p2   
||     LDDW   .D2T1   *B_bptr[8], A_biag:A_bim1ag  ; load again   
||     LDDW   .D1T2   *A_bptrcopy[7],B_bim2ag:B_bim3ag; load again   
||[B_icntr]SUB.S2     B_icntr,    1,        B_icntr   ; decr cntr
           
       MPYSP  .M1     A_rt1,      A_ki,     A_pr1  ; pr1=rt1*k[i]   
||     MPYSP  .M2X    A_kim1,     B_rt2,    B_pr2  ; pr2=rt2*k[i-1]   
           
       ADDSP  .L2     B_p2,       B_p3,     B_s1   ; s1=p2+p3   
||     ADDSP  .L1     A_temp1,    A_p1,     A_temp2; temp2=temp1+p1   
||     LDDW   .D1T1   *A_kptr[6], A_kiag:A_kim1ag  ; load again   
||     MV     .S2X    A_rt,       B_rtcopy         ; copy rt   
||     LDDW   .D2T2   *B5[B_icntr],B_kim2ag:B_kim3ag; load again   
||     MPYSP  .M2     B_rt3,      B_kim2ag, B_pr3  ; pr3=rt3*k[i-2]   
||     MPYSP  .M1X    A_rt,       B_kim3ag, A_pr4  ; pr4=rt*k[i-3]   
           
       LDDW   .D2T1   *B_bptr--,  A_bi:A_bim1      ; b[i], b[i-1]   
||     LDDW   .D1T2   *-A_kptr[1],B_kim2:B_kim3    ; k[i-2],k[i-3]   
||     MPYSP  .M1     A_bi,       A_ki,     A_temp1; temp1=b[i]*k[i]   
||     MPYSP  .M2     B_kim2,     B_bim2,   B_p2   ; p2=k[i-2]*b[i-2]   
||     SUBSP  .L1     A_rt,       A_temp1copy,A_rt1; rt1=rt-temp1     
||     SUBSP  .L2X    B_rtcopy,   A_temp2,  B_rt2  ; rt2=rt-temp2   
||     SHR    .S2     B_icntr,    1,    B_nolastadd; check for last iter
||[!B_nolastadd]MV .S1 A_temp2,   A_temp2copy      ; copy temp2   
             
       LDDW   .D2T2   *B_bptr--,  B_bim2:B_bim3    ; b[i-2],b[i-3]   
||     LDDW   .D1T1   *A_kptr--[2],A_ki:A_kim1     ; k[i],k[i-1]    
||     MPYSP  .M1     A_bim1,     A_kim1,   A_p1   ; p1=k[i-1]*b[i-1]   
||     MPYSP  .M2     B_kim3,     B_bim3,   B_p3   ; p3=k[i-3]*b[i-3]   
||[B_nolastadd]SUBSP.L1  A_rt,    A_temp4,  A_rt   ; rt=rt-temp4   
||     SUBSP  .L2X    A_rt,       B_temp3,  B_rt3  ; rt3=rt-temp3   
           
       MV     .S1X    B_bptr,     A_bptrcopy       ; copy bptr   
||     ADDSP  .L1     A_pr1,      A_biag,   A_bip1s; b[i+1]=pr1+b[i]   
||     ADDSP  .L2X    A_bim1,     B_pr2,    B_bis  ; b[i]=b[i-1]+pr2   
||[B_icntr]SUB.S2     B_icntr,    4,    B_nolastadd; last iter check
           
  [B_nolastadd]ADDSP.L1X  B_s1,   A_temp2,  A_temp4; temp4=s1+temp2
||     MV     .S1     A_temp1,    A_temp1copy      ; copy temp1   
||     ADDSP  .L2X    A_temp2,    B_p2,     B_temp3; temp3=p2+temp2   
||     LDDW   .D2T1   *B_bptr[8], A_biag:A_bim1ag  ; load again   
||     LDDW   .D1T2   *A_bptrcopy[7],B_bim2ag:B_bim3ag; load again   
||[B_icntr]SUB.S2     B_icntr,    1,        B_icntr; decr cntr   
           
       MPYSP  .M1     A_rt1,      A_ki,     A_pr1  ; pr1=rt1*k[i]   
||     MPYSP  .M2X    A_kim1,     B_rt2,   B_pr2  ; pr2=k[i-1]*rt2   
||     ADDSP  .L2     B_pr3,      B_bim2ag, B_bim1s; b[i-1]=pr3+b[i-2]   
||     ADDSP  .L1X    B_bim3ag,   A_pr4,    A_bim2s; b[i-2]=pr4+b[i-3]
||[B_icntr]SUB.S2     B_icntr,    1,        B_icntr ; decr cntr  

************** PIPED LOOP KERNEL ***********************           
iloop:

       ADDSP  .L2     B_p2,       B_p3,     B_s1    ; s1=p2+p3  
||     ADDSP  .L1     A_temp1,    A_p1,     A_temp2 ; temp2=p1+temp1  
||     LDDW   .D1T1   *A_kptr[6], A_kiag:A_kim1ag   ; load again  
||     MV     .S2X    A_rt,       B_rtcopy          ; copy rt  
||     LDDW   .D2T2   *B5[B_icntr],B_kim2ag:B_kim3ag; load again   
||     MPYSP  .M2     B_rt3,      B_kim2ag, B_pr3   ; pr3=rt3*k[i-2]  
||     MPYSP  .M1X    A_rt,       B_kim3ag, A_pr4   ; pr4=rt*k[i-3]  
||[B_icntr]B      .S1     iloop                     ; branch      
           
       LDDW   .D2T1   *B_bptr--,  A_bi:A_bim1       ; b[i],b[i-1]  
||     LDDW   .D1T2   *-A_kptr[1],B_kim2:B_kim3     ; k[i-2],k[i-3]  
||     MPYSP  .M1     A_bi,       A_ki,     A_temp1 ; temp1=b[i]*k[i]  
||     MPYSP  .M2     B_kim2,     B_bim2,   B_p2    ; p2=k[i-2]*b[i-2]  
||     SUBSP  .L1     A_rt,       A_temp1copy,A_rt1 ; rt1=rt-temp1
||     SUBSP  .L2X    B_rtcopy,   A_temp2,  B_rt2   ; rt2=rt-temp2  
||[!B_nolastadd]MV.S1 A_temp2,    A_temp2copy       ; copy temp2
||     SHR .S2 B_icntr,    1,     B_nolastadd       ; last iter check
           
       LDDW   .D2T2   *B_bptr--,  B_bim2:B_bim3     ; b[i-2],b[i-3]  
||     LDDW   .D1T1   *A_kptr--[2],A_ki:A_kim1      ; k[i],k[i-1]   
||     MPYSP  .M1     A_bim1,     A_kim1,   A_p1    ; p1=b[i-1]*k[i-1]  
||     MPYSP  .M2     B_kim3,     B_bim3,   B_p3    ; p3=k[i-3]*b[i-3]  
||[B_nolastadd]SUBSP.L1  A_rt,    A_temp4,  A_rt    ; rt=rt-temp4  
||     SUBSP  .L2X    A_rt,       B_temp3,  B_rt3   ; rt3=rt-temp3  
||     MV     .S1X    B_bptr,     A14               ; copy bptr  
           
       MV     .S1X    B_bptr,     A_bptrcopy        ; copy modofied bptr  
||     ADDSP  .L1     A_pr1,      A_biag,   A_bip1s ; b[i+1]=b[i]+pr1  
||     ADDSP  .L2X    A_bim1,     B_pr2,    B_bis   ; b[i]=pr2+b[i-1]  
||     STW    .D2T1   A_bip1s,    *B_bptr[26]       ; store b[i+1]  
||     STW    .D1T2   B_bis,      *A14[23]          ; store b[i]  
||[B_icntr]SUB.S2     B_icntr,    4,    B_nolastadd ; check last add

  [B_nolastadd]ADDSP.L1X  B_s1,   A_temp2,  A_temp4 ; if(cond)temp4=s1+temp2
||     MV     .S1     A_temp1,    A_temp1copy       ; copy temp1  
||     ADDSP  .L2X    A_temp2,    B_p2,     B_temp3 ; temp3=p2+temp2  
||     LDDW   .D2T1   *B_bptr[8], A_biag:A_bim1ag   ; load again   
||   LDDW   .D1T2  *A_bptrcopy[7],B_bim2ag:B_bim3ag ; load again  
||[B_icntr]SUB .S2    B_icntr,    1,        B_icntr ; decr cntr
           
       MPYSP  .M1     A_rt1,     A_ki,     A_pr1    ; pr1=rt1*ki
||     MPYSP  .M2X    A_kim1,     B_rt2,    B_pr2   ; pr2=rt2*k[i-1]  
||     ADDSP  .L2     B_pr3,      B_bim2ag, B_bim1s ; b[i-1]=pr3+b[i-2]  
||     ADDSP  .L1X    B_bim3ag,   A_pr4,    A_bim2s ; b[i-2]=pr4+b[i-3]  
||[B_icntr]SUB.S2     B_icntr,    1,        B_icntr ; decr cntr  
||     STW    .D2T2   B_bim1s,    *B_bptr[24]       ; store b[i-1]  
||     STW    .D1T1   A_bim2s,    *A_bptrcopy[23]   ; store b[i-2]  

*================ PIPED LOOP EPILOG + OUTER LOOP + PROLOG ===================== *
           
       LDDW   .D2T1   *B_b_ptr,   A_bi:A_bim1       ; next iter prolog  
||     LDDW   .D1T2   *-A_k_ptr[1],B_kim2:B_kim3    ; loads for next iter   
||[A_ocntr] B      .S2     oloop                    ; branch next outer loop
             
       LDDW   .D2T2   *-B_b_ptr[1],B_bim2:B_bim3    ; b[i-2],b[i-3]   
||     LDDW   .D1T1   *A_k_ptr,   A_ki:A_kim1       ; k[i],k[i-1]  
||     AND    .S2X    A11,        1,        B_icntr ; if more store then set  

       STW    .D2T1   A_rt,       *B3++             ; r[j]=rt  
||     MV     .S2X    A_rt,       B8                ; copy  
           
       LDW    .D1T1   *-A_xptr[A_ocntr],   A_rt     ; load rt=x[j]           
||     MV     .S1X    B_bptr,     A15               ; copy  
||[B_icntr]STW.D2T2   B8,         *B_bptr[20]       ; if(cond) store b[0]
           
  [B_icntr]STW    .D2T2   B_bis,      *B_bptr[21]   ; if(cond) store b[i]      
||[!B_icntr]STW    .D1T1   A_rt,       *A15[22]     ; if(cond) store b[0]       
||     ZERO.S2     B_nolastadd                      ; zero off cond

       MV     .S2X    A11,        B_icntr           ; init counter  
||     SUB    .S1     A_k_ptr,    16,       A_kptr  ; init pointers  
||     SUB    .L2     B_b_ptr,    16,       B_bptr    
||[B_icntr]STW    .D2T1   A_bip1s,    *B_bptr[22]   ; if(cond)store b[i+1]      
  
* =============== OUTER LOOP BRANCH ============================================ *
           
       ; pop off registers    
       MV     .S1X    B15,        A1                  
||     LDDW   .D2T2   *B15[5],    B3:B2               
      
       LDW    .D2T1   *B15[0],    A10                 
||     LDW    .D1T2   *A1[1],     B10                 
       
       LDW    .D2T1   *B15[2],    A11                 
||     LDW    .D1T2   *A1[3],     B11                 
     
       LDW    .D2T1   *B15[4],    A12                 
||     LDW    .D1T2   *A1[5],     B12                 
     
       LDW    .D2T1   *B15[6],    A13                 
||     LDW    .D1T2   *A1[7],     B13                 
     
       LDW    .D2T1   *B15[8],    A14                 
||     LDW    .D1T2   *A1[9],     B14                 
||     B      .S2     B2                              
      
       LDW    .D2     *B15[12],   A15                 
        
       MVC    .S2     B3,         CSR                 
    
       ADDAW  .D2     B15,        12,       B15       
       
       NOP            2                               

                .end

* ======================================================================== *
*  End of file: DSPF_sp_iirlat.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_convol./1117057351  289   0     0       15981     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_convol -- Single Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*    This routine has the following C prototype:                            *
*                                                                           *
*    void DSPF_sp_convol                                                         *
*          (                                                                *
*                    float *x, //x: Pointer to input samples//              *
*                    float *h, //h: Pointer to impulse response samples//   *
*                    float *r, //r: Pointer to output samples//             *
*                    int   nh, //nh: Number of impulse response samples//   *
*                    int   nr  //nr: Number of output samples//             *
*          )                                                                *
*                                                                           *
*           x = pointer to real input vector of size = nr+nh-1              *
*               a typically contains input data (x) padded with             *
*               consecutive nh - 1  zeros at the beginning and end.         *
*           h = pointer to real input vector of size nh in forward order.   *
*               h typically contains the filter coefs.                      *
*           r = pointer to real output vector of size nr                    *
*           nh= number of elements in vector b. NOTE: nh <= nr  nh is       *
*               typically noted as m in convol formulas. nh must be a       *
*               MULTIPLE of 2                                               *
*           nr= number of elements in vector r. nr must be a MULTIPLE of 4  *
*                                                                           *
*   DESCRIPTION                                                             *
*           This function calculates the full-length convolution of real    *
*           vectors x and h using time-domain techniques. The result is     *
*           placed in real vector r.                                        *
*                                                                           *
*           It is assumed that input vector x is padded with nh-1 no of     *
*           zeros in the beginning and end.                                 *
*                                                                           *
*           It is assumed that the length of the input vector h, nh, is a   *
*           multiple of 2 and the length of the output vector r, nr, is a   *
*           multiple of 4. nh is greater thanor equal to 4 and nr is greate *
*           than or equal to nh. The routine computes 4 output              *
*           samples at a time.                                              *
*                                                                           *
*           x and h are assumed to be aligned on a double word boundary.    *
*                                                                           *
*           If routine is not to be used as a C callable function then      *
*           you need to initialize values for all of the values passed      *
*           as these are assumed to be in registers as defined by the       *
*           calling convention of the compiler, (refer to the C compiler    *
*           reference guide).                                               *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*           1. The inner loop is unrolled twice and the outer loop is       *
*              unrolled four times.                                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*           1. nh is a multiple of 2 and greater than or equal to 4         *
*           2. nr is a multiple of 4                                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*           void DSPF_sp_convol(float *x, float *h, float *r, short nh, short nr *
*           {                                                               *
*                   short   ocntr, icntr;                                   *
*                   float   acc ;                                           *
*                                                                           *
*                   for (ocntr = nr ; ocntr > 0 ; ocntr--)                  *
*                   {                                                       *
*                           acc = 0 ;                                       *
*                                                                           *
*                           for (icntr = nh ; icntr > 0 ; icntr--)          *
*                           {                                               *
*                               acc += x[nr-ocntr+nh-icntr]*h[(icntr-1)];   *
*                           }                                               *
*                           r[nr-ocntr] = acc;                              *
*                   }                                                       *
*                                                                           *
*           }                                                               *
*                                                                           *
*           This is the C equivalent of the assembly code.  Note that       *
*           the assembly code is hand optimized and restrictions may        *
*           apply.                                                          *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*           (nh/2)*nr + (nr/2)*5 + 9                                        *
*           For nh=24 and nr=64, cycles=937                                 *
*           For nh=20 and nr=32, cycles=409                                 *
*                                                                           *
*   CODESIZE                                                                *
*           480 bytes                                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_convol
_DSPF_sp_convol:

* ======================================================================== *
* ======================================================================== *

          SHR    .S2   B6,        1,         B1  ; offset for first load
||        ADD    .L2   B4,        -8,        B2  ; index for load from h

          LDDW   .D1   *A4++,     A1:A0          ; p @ aa1:aa0 = *x++
||        STW    .D2   B10,       *B15--(4)      ; for saving B10
||        B      .S1   NO_INT                    ; protect from ints
||        MV     .L1X  B4,        A6             ; f b_save = h
||        MV     .L2X  A6,        B0             ; f r1 = r

          LDDW   .D2   *+B2[B1],  B9:B8          ; p @ bb1:bb0 = *+h[lcntr]
||        MV     .L1   A4,        A3             ; p a_save = x
||        MV     .L2X  A10,       B5             ; for saving A10
||        ADD    .S2   -2,        B6,        B1  ; f lcntr = nh - 2

          LDDW   .D1   *A3,       A9:A8          ; p @ aa3:aa2 = *a_save
||        ADDAW  .D2   B4,        B1,        B4  ; p h = h + lcntr * 4
||        MVC    .S2   CSR,       B10            ; get CSR

          STW    .D2   B5,        *B15--(4)      ; f Push A10
||          LDW    .D1   *+A3[2],   A10            ; p @ aa4 = *+a_save[2]
||        SUB    .L2   B1,        2,         B1  ; p lcntr = lcntr - 2
||        SUB    .L1X  B4,        8,         A6  ; p b_save = h - 8

          LDDW   .D1   *A3++,     A1:A0          ; p @@ aa1:aa0 = *a_save++
||        AND    .S1X  B10,       -2,        A10 ; Disable GIE

          LDDW   .D1T2 *A6--,     B9:B8          ; p @@ bb1:bb0 = *b_save--
||        MVC    .S2   A10,       CSR            ; Disable Interrupts

NO_INT:
          LDDW   .D1   *A3,       A9:A8          ; p @@ aa3:aa2 = *a_save
||        MPYSP  .M1X  A0,        B9,        A7  ; p prod1 = aa0 * bb1
||        MPYSP  .M2X  A1,        B8,        B7  ; p prod5 = aa1 * bb0
||        ADD    .L1   A4,        8,         A4  ; p x = x + 8
||        SUB    .S1   A8,        4,         A2  ; p ocntr = nr - 4

          LDW    .D1   *+A3[2],   A10            ; p @@ aa4 = *+a_save[2]
||        MPYSP  .M1X  A1,        B9,        A7  ; p prod2 = aa1 * bb1
||        MPYSP  .M2X  A8,        B8,        B7  ; p prod6 = aa2 * bb0

;**
oloop:

  [B1]    LDDW   .D1   *A3++,     A1:A0          ; p @@@ aa1:aa0 = *a_save++
||        MPYSP  .M1X  A8,        B9,        A7  ; p prod3 = aa2 * bb1
||        MPYSP  .M2X  A9,        B8,        B7  ; p prod7 = aa3 * bb0
||        B      .S2   iloop                     ; Branch to inner loop
||        ZERO   .L1   A5                        ; p acc1=acc2=acc3=acc4 = 0
||        ZERO   .L2   B5                        ; p acc5=acc6=acc7=acc8 = 0

  [B1]    LDDW   .D1T2 *A6--,     B9:B8          ; p @@@ bb1:bb0 = *b_save--
||        MPYSP  .M1X  A9,        B9,        A7  ; p prod4 = aa3 * bb1
||        MPYSP  .M2X  A10,       B8,        B7  ; p prod8 = aa4 * bb0
||        SUB    .L2   B6,        4,         B2  ; p icntr = nb - 4

; Kernel Loop Begins

iloop:
  [B1]    LDDW   .D1   *A3,       A9:A8          ; p @@@ aa3:aa2 = *a_save
||        MPYSP  .M1X  A0,        B9,        A7  ; prod1 = aa0 * bb1
||        MPYSP  .M2X  A1,        B8,        B7  ; prod5 = aa1 * bb0
||        ADDSP  .L1   A5,        A7,        A5  ; acc1 = acc1 + prod1
||        ADDSP  .L2   B5,        B7,        B5  ; acc5 = acc5 + prod5

  [B1]    LDW    .D1   *+A3[2],   A10            ; p @@@ aa4 = *+a_save[2]
||        MPYSP  .M1X  A1,        B9,        A7  ; prod2 = aa1 * bb1
||        MPYSP  .M2X  A8,        B8,        B7  ; prod6 = aa2 * bb0
||        ADDSP  .L1   A5,        A7,        A5  ; acc2 = acc2 + prod2
||        ADDSP  .L2   B5,        B7,        B5  ; acc6 = acc6 + prod6
||[B1]    SUB    .S2   B1,        2,         B1  ; lcntr = lcntr - 2


  [B1]    LDDW   .D1   *A3++,     A1:A0          ; p @@@@ aa1:aa0 = *a_save++
||        MPYSP  .M1X  A8,        B9,        A7  ; prod3 = aa2 * bb1
||        MPYSP  .M2X  A9,        B8,        B7  ; prod7 = aa3 * bb0
||        ADDSP  .L1   A5,        A7,        A5  ; acc3 = acc3 + prod3
||        ADDSP  .L2   B5,        B7,        B5  ; acc7 = acc7 + prod7
||[B2]    B      .S2   iloop                     ; branch to inner loop
||[B2]    SUB    .D2   B2,        2,         B2  ; icntr = icntr - 2

  [B1]    LDDW   .D1T2 *A6--,     B9:B8          ; p @@@@ bb1:bb0 = *b_save--
||        MPYSP  .M1X  A9,        B9,        A7  ; prod4 = aa3 * bb1
||        MPYSP  .M2X  A10,       B8,        B7  ; prod8 = aa4 * bb0
||        ADDSP  .L1   A5,        A7,        A5  ; acc4 = acc4 + prod4
||        ADDSP  .L2   B5,        B7,        B5  ; acc8 = acc8 + prod8
||[!B2]   MV     .S1   A4,        A3             ; a_save = x

; Kernel Loop Ends

          ADDSP  .L2X  A5,        B5,        B5  ; o acc5 = acc1 + acc5
||[A2]    LDDW   .D1   *A3++,     A1:A0          ; p @ aa1:aa0 = *a_save++
||[A2]    MV     .S1X  B4,        A6             ; p b_save = h

          ADDSP  .L1X  A5,        B5,        A5  ; o acc2 = acc2 + acc6
||[A2]    LDDW   .D1T2 *A6--,     B9:B8          ; p @ bb1:bb0 = *b_save--
||[A2]    SUB    .S2   B6,        4,         B1  ; p lcntr = nh - 4
||[!A2]   LDW    .D2T1 *++B15(4), A10            ; Pop A10 if last iteration

          ADDSP  .L2X  A5,        B5,        B5  ; o acc7 = acc3 + acc7
||[A2]    B      .S1   oloop                     ; branch to outer loop
||[A2]    LDDW   .D1   *A3,       A9:A8          ; p @ aa3:aa2 = *a_save
||[!A2]   B      .S2   B3                        ; branch out of function
||[!A2]   LDW    .D2   *++B15(4), B10            ; Pop B10

          ADDSP  .L2X  A5,        B5,        B5  ; o acc8 = acc4 + acc8
||[A2]    LDW    .D1   *+A3[2],   A10            ; p @ aa4 = *+a_save[2]
||        ADD    .S1   A4,        8,         A4  ; p x = x + 8
||[!A2]   MVC    .S2   B10,       CSR            ; store previous CSR

          STW    .D2   B5,        *B0++          ; o *r1++ = acc5
||[A2]    LDDW   .D1   *A3++,     A1:A0          ; p @@ aa1:aa0 = *a_save++
||        ADD    .S1   A4,        8,         A4  ; p x = x + 8

          STW    .D2T1 A5,        *B0++          ; o *r1++ = acc2
||[A2]    LDDW   .D1T2 *A6--,     B9:B8          ; p @@ bb1:bb0 = *b_save--

          STW    .D2   B5,        *B0++          ; o *r1++ = acc7
||[A2]    LDDW   .D1   *A3,       A9:A8          ; p @@ aa3:aa2 = *a_save
||[A2]    MPYSP  .M1X  A0,        B9,        A7  ; p prod1 = aa0 * bb1
||[A2]    MPYSP  .M2X  A1,        B8,        B7  ; p prod5 = aa1 * bb0

          STW    .D2   B5,        *B0++          ; o *r1++ = acc8
||[A2]    SUB    .L1   A2,        4,         A2  ; o ocntr = ocntr - 4
||[A2]    LDW    .D1   *+A3[2],   A10            ; p @@ aa4 = *+a_save[2]
||[A2]    MPYSP  .M1X  A1,        B9,        A7  ; p prod2 = aa1 * bb1
||[A2]    MPYSP  .M2X  A8,        B8,        B7  ; p prod6 = aa2 * bb0
    ; Branch to outer loop occures here
                .end

* ======================================================================== *
*  End of file: DSPF_sp_convol.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_dotp_sq/1117057352  309   0     0       12408     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                    * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        void DSPF_sp_dotp_sqr(                                                  * 
*                        float G,                                           * 
*                        const float * x,                                   * 
*                        const float * y,                                   * 
*                        float *  restrict r,                               * 
*                        int   nx                                           * 
*                        )                                                  * 
*             G:      Sum of y-squared initial value.                       * 
*             x[nx]:  Pointer to First input array.                         * 
*             y[nx]:  Pointer to Second input array.                        * 
*             r:      Pointer to Output for Accumulation of x[]*y[].        * 
*             nx:     Length of input vectors.                              * 
*                                                                           * 
*                                                                           * 
*  DESCRIPTION                                                              * 
*        This routine computes the dot product of x[] and y[] arrays,adding * 
*        it to the value in the location pointed to by r. Additionally, it  * 
*        computes the sum of the squares of the terms in the y array,adding *
*        it to the argument G. The final value of G is given as the return  * 
*        value of the function.                                             * 
*                                                                           * 
*                                                                           * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*       Multiple Assignment was used to reduce loop carry path.             * 
*  C CODE                                                                   * 
*                                                                           * 
*        float DSPF_sp_dotp_sqr(float G, const float * x, const float * y,       * 
*                                           float *restrict r, int nx)      * 
*              {                                                            * 
*                                                                           * 
*                         int i;                                            * 
*                                                                           * 
*                         for (i = 0; i < nx; i++)                          * 
*                         {                                                 * 
*                             *r += x[i] * y[i];     /* Compute Dot Product */
*                             G += y[i] * y[i];      /* Compute Square  */  * 
*                         }                                                 * 
*                                                                           * 
*                         return G;                                         * 
*             }                                                             * 
*                                                                           * 
*        This is the C equivalent of the assembly code.  Note that          * 
*        the assembly code is hand optimized and restrictions may apply.    * 
*                                                                           * 
*  NOTES                                                                    * 
*  CYCLES                                                                   * 
*        nx+23                                                              * 
*        For nx=64 cycles=87                                                * 
*        For nx=30 cycles=53                                                * 
*                                                                           * 
*  CODESIZE                                                                 * 
*        288 bytes                                                          * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_dotp_sqr
_DSPF_sp_dotp_sqr:

               .asg  A4,    A_g
               .asg  B6,    B_r
               .asg  A6,    A_y
               .asg  B4,    B_x
               .asg  A8,    A_nx_tmp
               .asg  A1,    A_nx
               .asg  A7,    A_prod1
               .asg  B7,    B_prod2
               .asg  A5,    A_sum5
               .asg  B5,    B_sum1
               .asg  A9,    A_y_i
               .asg  B9,    B_x_i
               .asg  B8,    B_r_reg
               .asg  A9,    A_sum_tmp
               .asg  B9,    B_sum_tmp
               .asg  B3,    B_RET
               .asg  B1,    CSR_store
               .asg  B9,    CSR_temp
               
 
        LDW   .D2T2 *B_r,      B_r_reg             ; load *r       
||      ZERO  .L1   A_sum5                         ; Initialise Accumulator
||      ZERO  .L2   B_sum1                         ; Initialise Accumulator
||      MV    .D1   A_nx_tmp,  A_nx                ; Initialise Counter
||      MVC   .S2   CSR,       CSR_store           ; Get CSR
||      B     .S1   loop                           ; Branch disables interrupt
 
; ---------------------------------------------------------------
; ***********************PROLOG STARTS***************************
; ---------------------------------------------------------------
                            
  [A_nx]LDW   .D2T2 *B_x++,    B_x_i               ; load x[i]
||[A_nx]LDW   .D1T1 *A_y++,    A_y_i               ; load y[i]
||      ZERO  .L1   A_prod1                        ; Initialise prod1
||      ZERO  .L2   B_prod2                        ; Initialise prod2
||[A_nx]B     .S2   loop                           ; Branch to the loop
||[A_nx]SUB   .S1   A_nx,      1,        A_nx      ; Update Counter

  [A_nx]LDW   .D2T2 *B_x++,    B_x_i               ; load x[i]
||[A_nx]LDW   .D1T1 *A_y++,    A_y_i               ; load y[i]
||[A_nx]B     .S2   loop                           ; Branch to the loop
||[A_nx]SUB   .S1   A_nx,      1,        A_nx      ; Update Counter
||      AND   .L2   CSR_store, -2,       CSR_temp  ; Disable GIE bit

  [A_nx]LDW   .D2T2 *B_x++,    B_x_i               ; load x[i]
||[A_nx]LDW   .D1T1 *A_y++,    A_y_i               ; load y[i]
||[A_nx]B     .S1   loop                           ; Branch to the loop
||[A_nx]SUB   .L1   A_nx,      1,        A_nx      ; Update Counter
||      MVC   .S2   CSR_temp,  CSR                 ; Disable Interrupt

  [A_nx]LDW   .D2T2 *B_x++,    B_x_i               ; load x[i]
||[A_nx]LDW   .D1T1 *A_y++,    A_y_i               ; load y[i]
||[A_nx]B     .S2   loop                           ; Branch to the loop
||[A_nx]SUB   .S1   A_nx,      1,        A_nx      ; Update Counter

  [A_nx]LDW   .D2T2 *B_x++,    B_x_i               ; load x[i]
||[A_nx]LDW   .D1T1 *A_y++,    A_y_i               ; load y[i]
||[A_nx]B     .S2   loop                           ; Branch to the loop
||[A_nx]SUB   .S1   A_nx,      1,        A_nx      ; Update Counter
 
; --------------------------------------------------------------------
; ************************** LOOP KERNEL *****************************
; --------------------------------------------------------------------

loop:       
  [A_nx]LDW   .D2T2 *B_x++,    B_x_i               ; load x[i]
||[A_nx]LDW   .D1T1 *A_y++,    A_y_i               ; load y[i]
||      MPYSP .M1   A_y_i,     A_y_i,    A_prod1   ; y[i] * y[i]
||      MPYSP .M2X  B_x_i,     A_y_i,    B_prod2   ; x[i] * y[i]
||      ADDSP .L1   A_sum5,    A_prod1,  A_sum5    ; sum5 += y[i] * y[i]
||      ADDSP .L2   B_sum1,    B_prod2,  B_sum1    ; sum1 += x[i] * y[i]
||[A_nx]SUB   .S1   A_nx,      1,        A_nx      ; Update Counter
||[A_nx]B     .S2   loop                           ; Branch to the loop
     
        ; Branch occurs here     
        
; --------------------------------------------------------------------
; ************************** LOOP EPILOG *****************************
; --------------------------------------------------------------------        
                 
        ADDSP .L1   A_sum5,    A_prod1,  A_sum5    ; sum5 += y[i] * y[i]
||      ADDSP .L2   B_sum1,    B_prod2,  B_sum1    ; sum1 += x[i] * y[i]

        ADDSP .L1   A_sum5,    A_prod1,  A_sum5    ; sum5 += y[i] * y[i]
||      ADDSP .L2   B_sum1,    B_prod2,  B_sum1    ; sum1 += x[i] * y[i]

        ADDSP .L1   A_sum5,    A_prod1,  A_sum5    ; sum5 += y[i] * y[i]
||      ADDSP .L2   B_sum1,    B_prod2,  B_sum1    ; sum1 += x[i] * y[i]

; --------------------------------------------------------------------

        ADDSP .L1   A_g,       A_sum5,   A_g       ; G  += sum5
||      ADDSP .L2   B_r_reg,   B_sum1,   B_r_reg   ; *r += sum1 

        MV          A_sum5,    A_sum_tmp
||      MV          B_sum1,    B_sum_tmp

        ADDSP .L1   A_sum_tmp, A_sum5,   A_sum_tmp ; Accumulate Staggered sums
||      ADDSP .L2   B_sum_tmp, B_sum1,   B_sum_tmp ; Accumulate Staggered sums

        MV          A_sum5,    A_sum_tmp
||      MV          B_sum1,    B_sum_tmp  

        ADDSP .L1   A_g,       A_sum_tmp,A_g       ; Accumulate Staggered sums
||      ADDSP .L2   B_r_reg,   B_sum_tmp,B_r_reg   ; Accumulate Staggered sums

        NOP         2
                
        B     .S2   B_RET                            ; Branch out of the function
                
        ADDSP .L1   A_g,       A_sum_tmp,A_g       ; Accumulate Staggered sums
||      ADDSP .L2   B_r_reg,   B_sum_tmp,B_r_reg   ; Accumulate Staggered sums
 
        NOP         2
        
        MVC   .S2   CSR_store, CSR                 ; Enable Interrupts
                
        STW   .D2T2 B_r_reg,   *B_r                ; Store the result
        
* ======================================================================== *
* ======================================================================== *

                .end

* ======================================================================== *
*  End of file: DSPF_sp_dotp_sqr.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_dotprod/1117057352  331   0     0       13218     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*                                                                           * 
*     This routine is C Callable and can be called as:                      * 
*                                                                           * 
*       float DSPF_sp_dotprod(const float *x, const float *y, const int nx);     * 
*                                                                           * 
*       x     : Pointer to array holding the first floating point vector    * 
*       y     : Pointer to array holding the second floating point vector   * 
*       nx    : Number of values in the x & y vectors                       * 
*                                                                           * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*       This routine calculates the dot product of 2 single precision       * 
*   float vectors.                                                          * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*       1.  LDDW instructions are used to load two SP floating point        * 
*           values at a time for the x and y arrays.                        * 
*       2.  The loop is unrolled once and software pipelined.               * 
*           However, by conditionally adding to the dot product             * 
*           odd numbered array sizes are also permitted.                    * 
*       3.  Since the ADDSP and MPYSP instructions take 4 cycles,           * 
*           A8, B8, A0, and B0 multiplex different variables to save        * 
*           on register usage.                                              * 
*           This multiple assignment is possible since the variables        * 
*           are always read just once on the first cycle that they          * 
*           are available.                                                  * 
*       4.  The loop is primed to reduce the prolog by 4 cycles             * 
*           (14 words) with no increase in cycle time.                      * 
*       5.  The load counter is used as the loop counter which              * 
*           requires a 3 cycle (6 word) epilog to finish the                * 
*           calculations. This does not increase the cycle time.            * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*       1.  Little Endian is assumed for LDDW instructions.                 * 
*       2.  Since single assignment of registers is not used,               * 
*           interrupts should be disabled before this function is           * 
*           called.                                                         * 
*       3.  The arrays x and y should be aligned on opposite (even          * 
*           and odd) double word boundaries to avoid memory bank hits.      * 
*       4.  A memory pad of 4 bytes is required at the end of each          * 
*           array if the number of inputs is odd.                           * 
*                                                                           * 
*   C CODE                                                                  * 
*       This is the C equivalent for the assembly code.  Note that          * 
*       the assembly code is hand optimized and restrictions may            * 
*       apply.                                                              * 
*                                                                           * 
*       float dotp(const float *x, const float *y, const int nx)            * 
*       {                                                                   * 
*          int i;                                                           * 
*          float sum = 0;                                                   * 
*                                                                           * 
*          for (i=0; i < nx; i++)                                           * 
*          {                                                                * 
*             sum += x[i] * y[i];                                           * 
*          }                                                                * 
*          return sum;                                                      * 
*       }                                                                   * 
*                                                                           * 
*   NOTES                                                                   * 
*       1. The arrays x and y should be aligned on opposite (even and odd)  * 
*          double word boundaries to avoid memory bank hits.                * 
*   2. A memory pad of 4 bytes is required at the end of each array         * 
*      if the number of inputs is odd.                                      * 
*                                                                           * 
*   CYCLES                                                                  * 
*                                                                           * 
*      N/2 + 25    with C overhead                                          * 
*      eg. for N=512, cycles=281                                            * 
*                                                                           * 
*   CODESIZE                                                                *
*      256 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_sp_dotprod
_DSPF_sp_dotprod:

* =============== SYMBOLIC REGISTER ASSIGNMENT ============================ *

                .asg A6,            A_cntarg
                .asg A1,            A_cnt
                .asg B2,            B_cntodd
                .asg A4,            A_x
                .asg B4,            B_x
                .asg A7,            A_x1
                .asg A6,            A_x0
                .asg B7,            B_x1
                .asg B6,            B_x0
                .asg A8,            sum0
                .asg B8,            sum1
                .asg A5,            prod0
                .asg B5,            prod1
                .asg A0,            A_sum10
                .asg B0,            B_sum10
                .asg A5,            A_finalh
                .asg B5,            B_finalh
                .asg A4,            A_return
                
**************************** Prolog Begins **********************************
              MV             A_cntarg,  A_cnt                  
||            AND            A_cntarg,  1,    B_cntodd ; is cnt even or odd?

     
              ZERO  .L2     prod1                   ; prod1 = 0
||[A_cnt]     LDDW  .D1     *A_x++,      A_x1:A_x0  ; load x1:x0 from memory
||[A_cnt]     LDDW  .D2     *B_x++,      B_x1:B_x0  ; load y1:y0 from memory
||[A_cnt]     B     .S2     LOOP                    ; branch to loop
||[B_cntodd]  SUB   .S1     A_cnt,       1,    A_cnt        
||[!B_cntodd] SUB   .L1     A_cnt,       2,    A_cnt        

              ZERO  .L1     sum0                    ; sum0 = 0
||            ZERO  .L2     sum1                    ; sum1 = 0
||[A_cnt] LDDW      .D1     *A_x++,      A_x1:A_x0  ; load x1:x0 from memory
||[A_cnt] LDDW      .D2     *B_x++,      B_x1:B_x0  ; load y1:y0 from memory
||[A_cnt] B         .S2     LOOP                    ; branch to loop
||[A_cnt] SUB       .S1     A_cnt,       2,    A_cnt        

  [A_cnt] LDDW   .D1        *A_x++,      A_x1:A_x0  ; load x1:x0 from memory
||[A_cnt] LDDW   .D2        *B_x++,      B_x1:B_x0  ; load y1:y0 from memory
||[A_cnt] B      .S2        LOOP                    ; branch to loop
||[A_cnt] SUB    .S1        A_cnt,         2,  A_cnt        
||        ZERO   .L1        prod0                   ; prod0 = 0
         
  [A_cnt] LDDW   .D1        *A_x++,      A_x1:A_x0  ; load x1:x0 from memory
||[A_cnt] LDDW   .D2        *B_x++,      B_x1:B_x0  ; load y1:y0 from memory
||[A_cnt] B      .S1        LOOP                    ; branch to loop
||[A_cnt] SUB    .L1        A_cnt,         2,  A_cnt        

  [A_cnt] LDDW   .D1        *A_x++,      A_x1:A_x0  ; load x1:x0 from memory
||[A_cnt] LDDW   .D2        *B_x++,      B_x1:B_x0  ; load y1:y0 from memory
||[A_cnt] B      .S2        LOOP                    ; branch to loop
||[A_cnt] SUB    .S1        A_cnt,         2,  A_cnt        

****** Loop Begins *****************************
LOOP:

  [A_cnt] LDDW   .D1        *A_x++,      A_x1:A_x0  ; if(lcntr) load x1:x0 from memory
||[A_cnt] LDDW   .D2        *B_x++,      B_x1:B_x0  ; if(lcntr) load y1:y0 from memory
||     MPYSP     .M1X       A_x0,        B_x0, prod0; prod0 = x0 * y0
||     MPYSP     .M2X       A_x1,        B_x1, prod1; prod1 = x1 * y1
||     ADDSP     .L1        prod0,       sum0, sum0 ; sum0 = prod0 + sum0
||     ADDSP     .L2        prod1,       sum1, sum1 ; sum1 = prod1 + sum1
||[A_cnt] B      .S2        LOOP                    ; if(lcntr) branch to loop
||[A_cnt] SUB    .S1        A_cnt,       2,    A_cnt; if(lcntr) lcntr -= 2

********************** Epilog Begins ****************      
 
       ADDSP  .L1     prod0,         sum0,       sum0; sum0 = prod0 + sum0
||     ADDSP  .L2     prod1,         sum1,       sum1; sum1 = prod1 + sum1

       ADDSP  .L1     prod0,         sum0,       sum0; sum0 = prod0 + sum0
||     ADDSP  .L2     prod1,         sum1,       sum1; sum1 = prod1 + sum1

       ADDSP  .L1     prod0,         sum0,       sum0; sum0 = prod0 + sum0
||[!B_cntodd]ADDSP  .L2     prod1,   sum1,       B9  ; sum1 = prod1 + sum1
||[B_cntodd] MV             sum1,                B9                  

*********************** Epilog Ends  ****************
      
       ADDSP  .L1X    sum0,         sum1,    A_sum10  ; Asum10=sum0 + sum1

       ADDSP  .L2X    sum0,         sum1,    B_sum10  ; Bsum10=sum0 + sum1

       ADDSP  .L1X    sum0,         sum1,    A_sum10  ; Asum10=sum0 + sum1

       ADDSP  .L2X    sum0,         B9,      B_sum10  ; Bsum10=sum0 + sum1

       NOP                                            ; wait for Bsum10

       ADDSP  .L1X    A_sum10,      B_sum10, A_finalh ; A_finalh=Asum10+Bsum10

       NOP                                            ; wait for next Bsum10

       ADDSP  .L2X    A_sum10,      B_sum10, B_finalh ; B_finalh=Asum10+Bsum10

       NOP                                            ; wait for B_finalh

       B      .S2     B3                              ; return from function

       NOP                                            ; wait for B_finalh

       ADDSP  .L1X    A_finalh,     B_finalh, A_return; return A_return

       NOP            3                               ; A_return and branch

                .end

* ======================================================================== *
*  End of file: DSPF_sp_dotprod.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_dotp_cp/1117057353  352   0     0       14511     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_cplx -- Complex single precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*                                                                           * 
*     This routine is C Callable and can be called as:                      * 
*                                                                           * 
*       void DSPF_sp_dotp_cplx(const float *x, const float *y, int n, float *    * 
*                         restrict re, float * restrict im);                * 
*                                                                           * 
*       x     : Pointer to array holding the first floating point vector    * 
*       y     : Pointer to array holding the second floating point vector   * 
*       n     : Number of values in the x & y vectors                       * 
*       re    : Pointer to the location storing the real part of the result * 
*       im    : Pointer to the location storing the imaginary part of       * 
*           the result                                                      * 
*                                                                           * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*       This routine calculates the dot product of 2 single precision       * 
*   complex float vectors. The even numbered locations hold the real parts  * 
*   of the complex numbers while the odd numbered locations contain the     * 
*   imaginary portions.                                                     * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*       1.  LDDW instructions are used to load two SP floating point        * 
*           values at a time for the x and y arrays.                        * 
*                                                                           * 
*       2.  A load counter avoids all extraneous loads.                     * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*       1.  Little Endian is assumed for LDDW instructions.                 * 
*       2.  Since single assignment of registers is not used,               * 
*           interrupts should be disabled before this function is           * 
*           called.                                                         * 
*       3.  Loop counter must be even and > 0.                              * 
*       4.  The x and y arrays must be double word aligned.                 * 
*                                                                           * 
*   C CODE                                                                  * 
*                                                                           * 
*       This is the C equivalent for the assembly code.  Note that          * 
*       the assembly code is hand optimized and restrictions may            * 
*       apply.                                                              * 
*                                                                           * 
*       void DSPF_sp_dotp_cplx_cn(const float* x, const float* y,                * 
*                        int n, float* restrict re,                         * 
*                float* restrict im)                                        * 
*       {                                                                   * 
*                                                                           * 
*           float real=0, imag=0;                                           * 
*           int i=0;                                                        * 
*                                                                           * 
*           for(i=0; i<n; i++)                                              * 
*           {                                                               * 
*               real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  * 
*               imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  * 
*           }                                                               * 
*                                                                           * 
*           *re=real;                                                       * 
*           *im=imag;                                                       * 
*      }                                                                    * 
*                                                                           * 
*   NOTES                                                                   * 
*                                                                           * 
*   1. There are no memory bank hits.                                       * 
*                                                                           * 
*                                                                           * 
*   CYCLES                                                                  * 
*                                                                           * 
*      2*N + 22                                                             * 
*      eg. for N=512, cycles=1046                                           * 
*                                                                           * 
*   CODESIZE                                                                * 
*      384 bytes                                                            * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


              .asg A4, A_x
              .asg B4, B_y
              .asg A7, A_xim
              .asg A6, A_xre
              .asg B7, B_yim
              .asg B6, B_yre
              .asg B2, B_lcntr
              .asg B0, B_cntr
              .asg B1, B_re_ptr
              .asg A0, A_im_ptr
              .asg B9, B_re_acc1
              .asg A9, A_re_acc2
              .asg A5, A_im_acc1
              .asg B5, B_im_acc2
              .asg A8, A_p1
              .asg B8, B_p2
              .asg A8, A_p3
              .asg B8, B_p4
              .asg A2, A_xre_t
              .asg A3, A_xim_t
              .asg A4, A_s1
              .asg A9, A_s2
              .asg B7, B_s3
              .asg A5, A_s4
              .asg A9, A_real
              .asg A9, A_imag
              .asg A1, A_csr
                                  
        .text
        .global _DSPF_sp_dotp_cplx
_DSPF_sp_dotp_cplx:

* ================= PIPE LOOP PROLOG =========================== *

       LDDW       .D1T1    *A_x++,     A_xim:A_xre       ; load xi:xr
||     MV         .S2X     A6,         B_cntr            ; init cntr      
||     MV         .L2      B6,         B_re_ptr          ; keep re store ptr
||     B          .S1      no_int

       ZERO       .D1      A_re_acc2                     ; init sums         
||     ZERO       .L2      B_re_acc1                              
||     ZERO       .L1      A_im_acc1                              
||     LDDW       .D2T2    *B_y++,     B_yim:B_yre       ; load yi:yr         
||[B_cntr] SUB    .S2      B_cntr,     1,        B_lcntr ; set load cntr       
     
  [B_lcntr] LDDW  .D1T1    *A_x++,     A_xim:A_xre       ; load xi:xr        
||     MV         .S1      A8,         A_im_ptr          ; keep im store ptr        
||     MVC        .S2      CSR,        B8
     
       ZERO       .L2      B_im_acc2                     ; init sum         
||[B_lcntr] LDDW  .D2T2    *B_y++,      B_yim:B_yre      ; load yi:yr         
||[B_lcntr] SUB   .S2      B_lcntr,     1,        B_lcntr; decr load cntr
||     MV         .S1X     B8,          A_csr
       
  [B_lcntr] LDDW  .D1T1    *A_x++,     A_xim:A_xre       ; load xi:xr
||     SUB        .S2X     A6,         1,        B_cntr  ; set loop cntr      
||     AND        .L2      B8,         -1,       B8
     
  [B_lcntr] LDDW  .D2T2    *B_y++,     B_yim:B_yre       ; load yi:yr        
||     MV         .S1      A_xim,      A_xim_t           ; live too long       
||[B_lcntr] SUB   .L2      B_lcntr,    1,        B_lcntr ; decr loop cntr       
||     MVC        .S2      B8,         CSR

no_int:
     
       MPYSP      .M1X     A_xim,      B_yim,       A_p1 ; xi*yi       
||     MPYSP      .M2X     A_xre,      B_yre,       B_p2 ; xr*yr       
||     MV         .S1      A_xre,      A_xre_t           ; live too long       
||[B_lcntr] LDDW  .D1T1    *A_x++,     A_xim:A_xre       ; load xi:xr        
||[B_cntr] B      .S2      loop                          ; branch  
     
       MPYSP      .M1X     A_xim_t,    B_yre,    A_p3    ; xi*yr
||     MPYSP      .M2X     A_xre_t,    B_yim,    B_p4    ; xr*yi    
||[B_lcntr] LDDW  .D2T2    *B_y++,     B_yim:B_yre       ; load yi:yr        
||     MV         .S1      A_xim,      A_xim_t           ; live too long       
||[B_cntr] SUB    .S2      B_cntr,     1,        B_cntr  ; decr loop cntr      
||[B_lcntr] SUB   .L2      B_lcntr,    1,        B_lcntr ; decr load cntr       
          
       MPYSP      .M1X     A_xim,      B_yim,    A_p1    ; xi*yi    
||     MPYSP      .M2X     A_xre,      B_yre,    B_p2    ; xr*yr    
||     MV         .S1      A_xre,      A_xre_t           ; live too long       
||[B_lcntr] LDDW  .D1T1    *A_x++,     A_xim:A_xre       ; load xi:xr        
||[B_cntr] B      .S2      loop                          ; branch  
     
       MPYSP      .M1X     A_xim_t,    B_yre,    A_p3    ; xi*yr
||     MPYSP      .M2X     A_xre_t,    B_yim,    B_p4    ; xr*yi    
||[B_lcntr] LDDW  .D2T2    *B_y++,     B_yim:B_yre       ; load yi:yr        
||     MV         .S1      A_xim,      A_xim_t           ; live too long       
||[B_cntr] SUB    .S2      B_cntr,     1,        B_cntr  ; decr loop cntr      
||[B_lcntr] SUB   .L2      B_lcntr,    1,        B_lcntr ; decr load cntr       

* ================== PIPE LOOP KERNEL ========================= *
loop:     

       MPYSP      .M1X    A_xim,       B_yim,       A_p1 ; xi*yi       
||     MPYSP      .M2X    A_xre,       B_yre,       B_p2 ; xr*yr       
||     MV         .S1     A_xre,       A_xre_t           ; live too long       
||[B_lcntr] LDDW  .D1T1   *A_x++,      A_xim:A_xre       ; load xi:xr       
||     ADDSP      .L1     A_re_acc2,   A_p1,   A_re_acc2 ; re_acc2+=p1
||     ADDSP      .L2     B_re_acc1,   B_p2,   B_re_acc1 ; re_acc1+=p2       
||[B_cntr] B      .S2     loop                           ; branch 
||[B_cntr] SUB    .D2     B_cntr,      1,        B_cntr  ; decr loop cntr      
     
       MPYSP      .M1X    A_xim_t,     B_yre,       A_p3 ; xi*yr       
||     MPYSP      .M2X    A_xre_t,     B_yim,       B_p4 ; xr*yi       
||[B_lcntr] LDDW  .D2T2   *B_y++,      B_yim:B_yre       ; load yi:yr        
||     ADDSP      .L1     A_im_acc1,   A_p3,   A_im_acc1 ; im_acc1+=p3
||     ADDSP      .L2     B_im_acc2,   B_p4,   B_im_acc2 ; im_acc2+=p4       
||     MV         .S1     A_xim,       A_xim_t           ; live too long       
||[B_lcntr] SUB   .S2     B_lcntr,     1,        B_lcntr ; decr load cntr       
     
* ============= END OF PIPE LOOP KERNEL ================================= *
       SUBSP      .L1X    B_re_acc1,   A_re_acc2,  A_s1  ; s1=re_acc1-re_acc2
       
       ADDSP      .L2X    A_im_acc1,   B_im_acc2,  B_s3  ; s3=im_acc1-im_acc2    
       
       SUBSP      .L1X    B_re_acc1,   A_re_acc2,  A_s2  ; s2=re_acc1-re_acc2    
       
       ADDSP      .L1X    A_im_acc1,   B_im_acc2,  A_s4  ; s4=im_acc1-im_acc2
       
       NOP                2                               
       
       ADDSP      .L1     A_s1,        A_s2,       A_real  ; s1+s2  
||     B          .S2     B3                              
       
       ADDSP      .L1X    A_s4,        B_s3,       A_imag  ; s3+s4  
       
       NOP                2                               
       
       STW        .D2T1   A_real,      *B_re_ptr           ; store real part        
||     MV         .S2X    A_csr,       B8       

       STW        .D1T1   A_imag,      *A_im_ptr           ; store imag part        
||     MVC        .S2     B8,          CSR       

                .end

* ======================================================================== *
*  End of file: DSPF_sp_dotp_cplx.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_maxval./1117057354  375   0     0       16608     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        float DSPF_sp_maxval(                                                   * 
*                        const float* x,                                    * 
*                        int nx                                             * 
*                       )                                                   * 
*                                                                           * 
*             x :  Pointer to Input array.                                  * 
*             nx:  Number of Inputs in the input Array.                     * 
*             Returns float: Maximum value in the input array               * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*        This routine Finds out the maximum number in the input array.      * 
*                                                                           * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*       The loop is unrolled Six times.                                     * 
*       Six maximums are maintained in each iteration.                      * 
*       One of the maximums are calculated using SUBSP in place of CMPGTSP  * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*       nx should be multiple of 2 and >= 2.                                * 
*       x should be double word aligned.                                    * 
*       NAN( Not a Number in Single Precision format) in the input are      * 
*       disregarded.                                                        * 
*   C CODE                                                                  * 
*       float DSPF_sp_maxval(const float* x, int nx)                             * 
*       {                                                                   * 
*          int i,index;                                                     * 
*          float max;                                                       * 
*          *((int *)&max) = 0xff800000;                                     * 
*                                                                           * 
*          for (i = 0; i < nx; i++)                                         * 
*          if (x[i] > max)                                                  * 
*             {                                                             * 
*             max = x[i];                                                   * 
*             index = i;                                                    * 
*             }                                                             * 
*          printf("%d\n",index);                                            * 
*          return max;                                                      * 
*       }                                                                   * 
*                                                                           * 
*   NOTES                                                                   * 
*       NAN( Not a Number in Single Precision format) in the input are      * 
*       disregarded.                                                        * 
*                                                                           * 
*   CYCLES                                                                  * 
*       3*ceil(nx/6) + 35                                                   * 
*       For nx=60 cycles=65                                                 * 
*       For nx=34 cycles=56                                                 * 
*                                                                           * 
*   CODESIZE                                                                * 
*       448 bytes                                                           * 
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *
* 3*ceil(nx/6) + 35
* nx should be multiple of 2 >= 2 
* no extraneous loads
* x must be word aligned
* NAN's are disregarded
****************************************************************************

           .asg A4,  A_x
           .asg B4,  B_nx 
           .asg A4,  A_RET_VAL
           .asg B5,  B_tmp
           .asg A2,  A_1by6
           .asg A2,  A_tmp
           .asg A1,  A_cst
           .asg B0,  B_nx1
           .asg A3,  A_1
           .asg B0,  B_CSR_gie
           .asg A0,  A_CSR
           .asg B15, B_SP
           .asg A10, A_max6
           .asg B5,  B_max1
           .asg B4,  B_max2
           .asg B4,  B_rem
           .asg A5,  A_rem
           .asg A8,  A_max3
           .asg A9,  A_max4
           .asg B10, B_max5
           .asg B1,  B_flag1
           .asg B1,  B_diff
           .asg B2,  B_flag2
           .asg B2,  B_flag5
           .asg A1,  A_flag3
           .asg A1,  A_flag4
           .asg A1,  A_flag6
           .asg B7,  B_x2
           .asg B6,  B_x1
           .asg A7,  A_x4
           .asg A6,  A_x3
           .asg B9,  B_x6
           .asg B8,  B_x5
           .asg B11, B_mask
           .asg A2,  A_gt3
           .asg A2,  A_ldfg
           .asg B0,  B_gt1
           .asg B1,  B_flag
           .asg A1,  A_flag
           
        .text
        .global _DSPF_sp_maxval
_DSPF_sp_maxval:


           INTSP   .L2   B_nx,       B_tmp               ; Get nx in Floating pt. format
||         MVKL    .S1   0x3E2AAAAB, A_1by6              ; Get 1/6  
||         SUB     .D2   B_SP,       12,       B_SP      ; Save Stack Space  
||         MVC     .S2   CSR,        B_CSR_gie           ; Get CSR

           MVKH    .S1   0x3E2AAAAB, A_1by6              ; Get 1/6
||         STW     .D2   A_max6,     *B_SP               ; Save Register
||         AND     .S2   B_CSR_gie,  -2,       B_CSR_gie ; Disable GIE bit
||         MV      .L1X  B_CSR_gie,  A_CSR               ; Save CSR

           MVKL    .S1   0x3E4CCCCD, A_cst               ; Get 0.2
||         STW     .D2   B_max5,     *B_SP[1]            ; Save Register               

           MVKH    .S1   0x3E4CCCCD, A_cst               ; Get 0.2
||         STW     .D2   B_mask,     *B_SP[2]            ; Save Register                              

           MPYSP   .M1X  A_1by6,     B_tmp,    A_tmp     ; nx/6
||         MVKL    .S2   0x80000000, B_mask              ; load mask
||         MVKL    .S1   0x3F800000, A_1                 ; load 1

           MVKH    .S2   0x80000000, B_mask              ; load mask
||         MVKH    .S1   0x3F800000, A_1                 ; load 1

           NOP           2
                              
           ADDSP   .L1   A_tmp,      A_cst,    A_tmp     ; nx/6 + 0.2
               
           MVKL    .S2   0xff800000, B_x6                ; x6=-INF, To prevent initial moves
               
           MVKH    .S2   0xff800000, B_x6                ; x6=-INF, To prevent initial moves
               
           MV      .S1X  B_x6,       A_max3              ; max3 = -INF
               
           SPINT   .L1   A_tmp,      A_tmp               ; int( nx/6 + 0.2 )
               
           MV      .S1X  B_x6,       A_max4              ; max4 = -INF 
||         MV      .S2   B_x6,       B_max1              ; max1 = -INF

           MV      .L1X  B_x6,       A_max6              ; max6 = -INF
||         MV      .L2   B_x6,       B_max5              ; max5 = -INF

           MVK     .S1   0,          A_flag3             ; Initialise Flag
||         MVK     .S2   0,          B_flag2             ; Initialise Flag

           MPY     .M2X  A_tmp,      6,        B_nx1     ; nx = 6 * int( nx/6 + 0.2 )
||         MVC     .S2   B_CSR_gie,  CSR                 ; Disable Interrupt
               
           ZERO    .L2   B_flag1                         ; Initialise Flag
||         MVK     .S1   1,          A_ldfg              ; Initialise Flag

; ----------------------- LOOP PROLOG ----------------------------
                              
           LDDW    .D1T2 *A_x++,     B_x2:B_x1           ; Load x2:x1
||  [B_nx1]SUB     .D2   B_nx1,      6,        B_nx1     ; nx = nx - 6
||         SUB     .S2   B_nx1,      B_nx,     B_rem     ; Remender after dividing by 6

           LDDW    .D1T1 *A_x++,     A_x4:A_x3           ; Load x4:x3
|| [!B_nx1]MPY     .M1   B_nx1,      A_1,      A_ldfg    ; Get load flag
 
           LDDW    .D1T2 *A_x++,     B_x6:B8             ; Load x6:x5
||  [B_nx1]B       .S2   LOOP                            ; Branch To Loop       
||         MV      .L1X  B_rem,      A_rem               ; Remender after dividing nx by 6
||         MV      .D2   B_x6,       B_max2              ; max2 = -INF 
                      
   [A_ldfg]LDDW    .D1T2 *A_x++,     B_x2:B_x1           ; Load x2:x1
||  [B_nx1]SUB     .D2   B_nx1,      6,        B_nx1     ; nx = nx - 6   

   [A_ldfg]LDDW    .D1T1 *A_x++,     A_x4:A_x3           ; Load x4:x3   
|| [!B_nx1]MPY     .M1   B_nx1,      A_1,      A_ldfg    ; Get load flag                           

; ----------------------------------------------
; ----------------- KERNEL ---------------------
; ----------------------------------------------
LOOP:
   [A_ldfg]LDDW    .D1T2 *A_x++,     B_x6:B8             ; Load x6:x5
||  [B_nx1]B       .S2   LOOP                            ; Branch To Loop        
||         SUBSP   .L2   B_max1,     B_x1,     B_diff    ; Diff = max1 - x1
||         CMPGTSP .S1X  B_x6,       A_max6,   A_flag6   ; if x6 > max6
||[A_flag4]MV      .L1   A_x4,       A_max4              ; max4 = x4
||[B_flag5]MV      .D2   B8,         B_max5              ; max5 = x5
||         MPYSP   .M2X  B_max1,     A_1,      B_max1    ; Save the max1 for next Iteration

   [A_ldfg]LDDW    .D1T2 *A_x++,     B_x2:B_x1           ; Load x2:x1
||  [B_nx1]SUB     .D2   B_nx1,      6,        B_nx1     ; nx = nx - 6   
||         CMPGTSP .S2   B_x2,       B_max2,   B_flag2   ; if x2 > max2
||         CMPGTSP .S1   A_x3,       A_max3,   A_flag3   ; if x3 > max3
||         AND     .L2   B_diff,     B_mask,   B_flag1   ; if x1 > max1 
||[A_flag6]MV      .L1X  B_x6,       A_max6              ; max6 = x6
||         MPYSP   .M2X  B_x1,       A_1,      B_x1      ; Save x1 for next iteratiom
||[!A_ldfg]MPYSP   .M1   A_max3,     A_1,      A_max3    ; Save previous value in last it

   [A_ldfg]LDDW    .D1T1 *A_x++,     A_x4:A_x3           ; Load x4:x3   
||         CMPGTSP .S1   A_x4,       A_max4,   A_flag4   ; if x4 > max4
||         CMPGTSP .S2   B8,         B_max5,   B_flag5   ; if x5 > max5
||[B_flag2]MV      .L2   B_x2,       B_max2              ; max2 = x2
||[A_flag3]MV      .L1   A_x3,       A_max3              ; max3 = x3
||[B_flag1]MV      .D2   B_x1,       B_max1              ; max1 = x1
|| [!B_nx1]MPY     .M1X  B_nx1,      A_1,      A_ldfg    ; Get load flag                

; ------------------------------------------------     

           MPYSP   .M2X  B_max1,     A_1,      B_x1      ; Save the max1 for next Iteration

           AND     .L2   B_diff,     B_mask,   B_flag1   ; if x1 > max1   
||         CMPGT   .L1   A_rem,      3,        A_gt3     ; Check if Remainder is 2

  [B_flag1]MV      .S2   B_x1,       B_max1              ; max1 = x1
||  [A_gt3]ZERO    .D1   A_flag4                         ; Disable move if rem=2
||         CMPGT   .L2X  A_rem,      1,        B_gt1     ; Check if remainder is 6   
           
  [A_flag4]MV      .L1   A_x4,       A_max4              ; max4 = x4               
|| [!A_gt3]CMPGTSP .S1   A_x3,       A_max3,   A_flag3   ; if x3 > max3
||  [B_gt1]ZERO    .S2   B_flag5                         ; Disable move if rem=2 or 4
           
           CMPGTSP .S2   B_x1,       B_max1,   B_flag1   ; if x1 > max1
||[A_flag3]MV      .L1   A_x3,       A_max3              ; max3 = x3
||[B_flag5]MV      .D2   B8,         B_max5              ; max5 = x5
|| [!B_gt1]CMPGTSP .S1X  B_x6,       A_max6,   A_flag6   ; if x6 > max6
||  [B_gt1]ZERO    .D1   A_flag6                         ; Disable move if rem=2 or 4           
          
  [B_flag1]MV      .L2   B_x1,       B_max1              ; max1 = x1  
||[A_flag6]MV      .L1X  B_x6,       A_max6              ; max6 = x6
||         CMPGTSP .S2   B_max2,     B_max5,   B_flag    ; Finding max of max1, max2, max5
||         CMPGTSP .S1   A_max3,     A_max4,   A_flag    ; Finding max of max3, max4, max6
||         LDW     .D2   *B_SP[2],   B_mask              ; Restore Registers        

   [B_flag]MV      .L2   B_max2,     B_max5              ; Finding max of max1, max2, max5
|| [A_flag]MV      .S1   A_max3,     A_max4              ; Finding max of max3, max4, max6
||         LDW     .D2   *B_SP,      A_max6              ; Restore Registers         
||         B       .S2   B3                              ; Branch out of the function
  
           CMPGTSP .S2   B_max1,     B_max5,   B_flag    ; Finding max of max1, max2, max5
||         CMPGTSP .S1   A_max4,     A_max6,   A_flag    ; Finding max of max3, max4, max6   
||         LDW     .D2   *B_SP[1],   B_max5              
  
   [B_flag]MV      .S2   B_max1,     B_max5              ; Finding max of max1, max2, max5
|| [A_flag]MV      .S1   A_max4,     A_max6              ; Finding max of max3, max4, max6
            
           CMPGTSP .S2X  A_max6,     B_max5,   B_flag    ; Finding Maximum
               
   [B_flag]MV      .S1   A_max6,     A_RET_VAL           ; Storing the Maximum
                          
  [!B_flag]MV      .S1X  B_max5,     A_RET_VAL           ; Storing the maximum                
||         ADD     .D2   B_SP,       12,       B_SP      ; Restore Stack Space
||         MVC     .S2X  A_CSR,      CSR                 ; Enable Interrupts                     

* ======================================================================== *
* ======================================================================== *

               .end

* ======================================================================== *
*  End of file: DSPF_sp_maxval.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_maxidx./1117057355  395   0     0       10743     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        int DSPF_sp_maxidx(                                                     * 
*                       const float* x,                                     * 
*                       int nx                                              * 
*                     )                                                     * 
*                                                                           * 
*             x :  Pointer to Input array.                                  * 
*             nx:  Number of Inputs in the input Array.                     * 
*             Returns int: Index of Maximum value                           * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*        This routine Finds out the index of maximum number in the input    * 
*        array.                                                             * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*       The loop is unrolled three times.                                   * 
*       Three maximums are maintained in each iteration.                    * 
*       MPY indtructions are  used for move.                                * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*       nx is a multiple of 3                                               * 
*       nx >= 3, and nx <= 2^16-1.                                          * 
*                                                                           * 
*   C CODE                                                                  * 
*       int DSPF_sp_maxidx(const float* x, int nx)                               * 
*       {                                                                   * 
*          int index, i;                                                    * 
*          float max;                                                       * 
*          *((int *)&max) = 0xff800000;                                     * 
*                                                                           * 
*          for (i = 0; i < nx; i++)                                         * 
*          if (x[i] > max)                                                  * 
*             {                                                             * 
*             max = x[i];                                                   * 
*             index = i;                                                    * 
*             }                                                             * 
*          return index;                                                    * 
*       }                                                                   * 
*                                                                           * 
*   NOTES                                                                   * 
*                                                                           * 
*   CYCLES                                                                  * 
*       formula 2*nx/3 + 13                                                 * 
*       For nx=60 cycles=53                                                 * 
*       For nx=30 cycles=33                                                 * 
*                                                                           * 
*   CODESIZE                                                                * 
*       256 bytes                                                           * 
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

         .asg A8,  A_i
         .asg B4,  B_nx
         .asg B4,  B_x
         .asg B0,  B_nx1
         .asg A4,  A_x
         .asg A4,  A_RET_VAL
         .asg A5,  A_x1
         .asg B5,  B_x2 
         .asg B8,  B_x3
         .asg A9,  A_index3
         .asg A6,  A_index1
         .asg B6,  B_index2
         .asg B9,  B_max3
         .asg A7,  A_max1
         .asg B7,  B_max2
         .asg A1,  A_flag
         .asg B1,  B_flag1
         .asg B0,  B_flag
         .asg B3,  B_RET_ADDR

        .text
        .global _DSPF_sp_maxidx
_DSPF_sp_maxidx:

* ======================================================================== *
* ======================================================================== *

            MV      .S2   B_nx,       B_nx1              ; Get nx
||          ADD     .L2X  A_x,        4,       B_x       ; Copy x pointer

; -------------------------------------------------------------------------
 
     [B_nx1]LDW     .D1T1 *A_x++[2],  A_x1               ; Load x1
||   [B_nx1]LDW     .D2T2 *B_x++[3],  B_x2               ; Load x2
||          MVKL    .S1   0xff800000, A_max1             ; max1 = -INF
||          MVKL    .S2   0xff800000, B_max2             ; max2 = -INF                
||          ZERO    .L1   A_i                            ; i = 0

     [B_nx1]LDW     .D1T2 *A_x++,     B_x3               ; Load x3
||   [B_nx1]SUB     .L2   B_nx1,      3,       B_nx1     ; nx = nx -3
||          MVKH    .S1   0xff800000, A_max1             ; max1 = -INF
||          MVKH    .S2   0xff800000, B_max2             ; max2 = -INF

     [B_nx1]B       .S1   LOOP                           ; Branch To Loop
||   [B_nx1]LDW     .D1T1 *A_x++[2],  A_x1               ; Load x1
||   [B_nx1]LDW     .D2T2 *B_x++[3],  B_x2               ; Load x2
||          MVKL    .S2   0xff800000, B_max3             ; max3 = -INF

     [B_nx1]LDW     .D1T2 *A_x++,     B_x3               ; Load x3
||   [B_nx1]SUB     .L2   B_nx1,      3,       B_nx1     ; nx = nx -3
||          MVKH    .S2   0xff800000, B_max3             ; max3 = -INF     
                                            
     [B_nx1]B       .S1   LOOP                           ; Branch To Loop
||   [B_nx1]LDW     .D1T1 *A_x++[2],  A_x1               ; Load x1
||   [B_nx1]LDW     .D2T2 *B_x++[3],  B_x2               ; Load x2    

            CMPGTSP .S1   A_x1,       A_max1,  A_flag    ; if x1 > max1   
||          CMPGTSP .S2   B_x2,       B_max2,  B_flag1   ; if x2 > max2
||   [B_nx1]LDW     .D1T2 *A_x++,     B_x3               ; Load x3
||   [B_nx1]SUB     .L2   B_nx1,      3,       B_nx1     ; nx = nx -3

; ------------------------------------------------------------------
LOOP:
            CMPGTSP .S2   B_x3,       B_max3,  B_flag1   ; if x3 > max3
||  [A_flag]MV      .L1   A_x1,       A_max1             ; max1 = x1
|| [B_flag1]MV      .L2   B_x2,       B_max2             ; max2 = x2
||  [A_flag]MPY     .M1   A_i,        1,       A_index1  ; index1 = i
|| [B_flag1]MPY     .M2X  A_i,        1,       B_index2  ; index2 = i
||   [B_nx1]B       .S1   LOOP                           ; Branch To Loop
||   [B_nx1]LDW     .D1T1 *A_x++[2],  A_x1               ; Load x1
||   [B_nx1]LDW     .D2T2 *B_x++[3],  B_x2               ; Load x2    

            CMPGTSP .S1   A_x1,       A_max1,  A_flag    ; if x1 > max1   
||          CMPGTSP .S2   B_x2,       B_max2,  B_flag1   ; if x2 > max2
||   [B_nx1]LDW     .D1T2 *A_x++,     B_x3               ; Load x3
||   [B_nx1]SUB     .L2   B_nx1,      3,       B_nx1     ; nx = nx -3    
|| [B_flag1]MPY     .M1   A_i,        1,       A_index3  ; index3 = i
|| [B_flag1]MV      .D2   B_x3,       B_max3             ; max3 = x3
||          ADD     .L1   A_i,        3,       A_i       ; i = i + 3
;-----------------------------------------------------------
 
            B       .S2   B_RET_ADDR                     ; Branch out of the function                 
||          CMPLTSP .S1X  A_max1,     B_max2,  A_flag    ; if max1 < max2

   [!A_flag]CMPLTSP .S2X  A_max1,     B_max3,  B_flag1   ; if max1 < max3 
   
    [A_flag]CMPLTSP .S2   B_max2,     B_max3,  B_flag1   ; if max2 < max3
    
   [B_flag1]ADD     .S1   A_index3,   2,       A_RET_VAL ; Here max3 is maximum
||[!B_flag1]CMPLTSP .S2X  A_max1,     B_max2,  B_flag    ; if max1 < max2

    [B_flag]ADD     .S1X  B_index2,   1,       A_RET_VAL ; Here max2 is maximum
|| [B_flag1]MVK     .S2   1,          B_flag             ; In case max3 is maximum stop other loads

   [!B_flag]MV      .S1   A_index1,   A_RET_VAL          ; Here max1 is maximum
            .end

* ======================================================================== *
*  End of file: DSPF_sp_maxidx.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_minval./1117057356  415   0     0       16429     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*      USAGE                                                                * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        float DSPF_sp_minval(                                                   * 
*                        const float* x,                                    * 
*                        int nx                                             * 
*                       )                                                   * 
*                                                                           * 
*             x :  Pointer to Input array.                                  * 
*             nx:  Number of Inputs in the input Array.                     * 
*             Returns float: Minimum value in the input array               * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*        This routine Finds out the minimum number in the input array.      * 
*                                                                           * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*       The loop is unrolled Six times.                                     * 
*       Six minimums are maintained in each iteration.                      * 
*       One of the minimums are calculated using SUBSP in place of CMPGTSP  * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*       nx should be multiple of 2 and >= 2.                                * 
*       x should be double word aligned.                                    * 
*       NAN( Not a Number in Single Precision format) in the input are      * 
*       disregarded.                                                        * 
*   C CODE                                                                  * 
*       float DSPF_sp_minval(const float* x, int nx)                             * 
*       {                                                                   * 
*          int i,index;                                                     * 
*          float min;                                                       * 
*          *((int *)&min) = 0x7f800000;                                     * 
*                                                                           * 
*          for (i = 0; i < nx; i++)                                         * 
*          if (x[i] < min)                                                  * 
*             {                                                             * 
*             min = x[i];                                                   * 
*             index = i;                                                    * 
*             }                                                             * 
*          printf("\nindex: %d",index);                                     * 
*          return min;                                                      * 
*       }                                                                   * 
*                                                                           * 
*   NOTES                                                                   * 
*       NAN( Not a Number in Single Precision format) in the input are      * 
*       disregarded.                                                        * 
*                                                                           * 
*   CYCLES                                                                  * 
*       3*ceil(nx/6) + 35                                                   * 
*       For nx=60 cycles=65                                                 * 
*       For nx=34 cycles=56                                                 * 
*                                                                           * 
*   CODESIZE                                                                * 
*       448 bytes                                                           * 
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


                
        .text
        .global _DSPF_sp_minval
_DSPF_sp_minval:                

* ======================================================================== *
* ======================================================================== *

           .asg A4,  A_x
           .asg B4,  B_nx 
           .asg A4,  A_RET_VAL
           .asg B5,  B_tmp
           .asg A2,  A_1by6
           .asg A2,  A_tmp
           .asg A1,  A_cst
           .asg B0,  B_nx1
           .asg A3,  A_1
           .asg B0,  B_CSR_gie
           .asg A0,  A_CSR
           .asg B15, B_SP
           .asg A10, A_min6
           .asg B5,  B_min1
           .asg B4,  B_min2
           .asg B4,  B_rem
           .asg A5,  A_rem
           .asg A8,  A_min3
           .asg A9,  A_min4
           .asg B10, B_min5
           .asg B1,  B_flag1
           .asg B1,  B_diff
           .asg B2,  B_flag2
           .asg B2,  B_flag5
           .asg A1,  A_flag3
           .asg A1,  A_flag4
           .asg A1,  A_flag6
           .asg B7,  B_x2
           .asg B6,  B_x1
           .asg A7,  A_x4
           .asg A6,  A_x3
           .asg B9,  B_x6
           .asg B8,  B_x5
           .asg B11, B_mask
           .asg A2,  A_gt3
           .asg A2,  A_ldfg
           .asg B0,  B_gt1
           .asg B1,  B_flag
           .asg A1,  A_flag

* ======================================================================== *
* ======================================================================== *
           

           INTSP   .L2   B_nx,       B_tmp               ; Get nx in Floating pt. format
||         MVKL    .S1   0x3E2AAAAB, A_1by6              ; Get 1/6  
||         SUB     .D2   B_SP,       12,       B_SP      ; Save Stack Space  
||         MVC     .S2   CSR,        B_CSR_gie           ; Get CSR

           MVKH    .S1   0x3E2AAAAB, A_1by6              ; Get 1/6
||         STW     .D2   A_min6,     *B_SP               ; Save Register
||         AND     .S2   B_CSR_gie,  -2,       B_CSR_gie ; Disable GIE bit
||         MV      .L1X  B_CSR_gie,  A_CSR               ; Save CSR

           MVKL    .S1   0x3E4CCCCD, A_cst               ; Get 0.2
||         STW     .D2   B_min5,     *B_SP[1]            ; Save Register               

           MVKH    .S1   0x3E4CCCCD, A_cst               ; Get 0.2
||         STW     .D2   B_mask,     *B_SP[2]            ; Save Register                              

           MPYSP   .M1X  A_1by6,     B_tmp,    A_tmp     ; nx/6
||         MVKL    .S2   0x80000000, B_mask              ; load mask
||         MVKL    .S1   0x3F800000, A_1                 ; load 1

           MVKH    .S2   0x80000000, B_mask              ; load mask
||         MVKH    .S1   0x3F800000, A_1                 ; load 1

           NOP           2
                              
           ADDSP   .L1   A_tmp,      A_cst,    A_tmp     ; nx/6 + 0.2
               
           MVKL    .S2   0x7f800000, B_x6                ; x6=+INF, To prevent initial moves
               
           MVKH    .S2   0x7f800000, B_x6                ; x6=+INF, To prevent initial moves
               
           MV      .S1X  B_x6,       A_min3              ; min3 = +INF
               
           SPINT   .L1   A_tmp,      A_tmp               ; int( nx/6 + 0.2 )
               
           MV      .S1X  B_x6,       A_min4              ; min4 = +INF 
||         MV      .S2   B_x6,       B_min1              ; min1 = +INF

           MV      .L1X  B_x6,       A_min6              ; min6 = +INF
||         MV      .L2   B_x6,       B_min5              ; min5 = +INF

           MVK     .S1   0,          A_flag3             ; Initialise Flag
||         MVK     .S2   0,          B_flag2             ; Initialise Flag

           MPY     .M2X  A_tmp,      6,        B_nx1     ; nx = 6 * int( nx/6 + 0.2 )
||         MVC     .S2   B_CSR_gie,  CSR                 ; Disable Interrupt
               
           ZERO    .L2   B_flag1                         ; Initialise Flag
||         MVK     .S1   1,          A_ldfg              ; Initialise Flag

; ----------------------- LOOP PROLOG ----------------------------
                              
           LDDW    .D1T2 *A_x++,     B_x2:B_x1           ; Load x2:x1
||  [B_nx1]SUB     .D2   B_nx1,      6,        B_nx1     ; nx = nx - 6
||         SUB     .S2   B_nx1,      B_nx,     B_rem     ; Remender after dividing by 6

           LDDW    .D1T1 *A_x++,     A_x4:A_x3           ; Load x4:x3
|| [!B_nx1]MPY     .M1   B_nx1,      A_1,      A_ldfg    ; Get load flag
 
           LDDW    .D1T2 *A_x++,     B_x6:B_x5           ; Load x6:x5
||  [B_nx1]B       .S2   LOOP                            ; Branch To Loop       
||         MV      .L1X  B_rem,      A_rem               ; Remender after dividing nx by 6
||         MV      .D2   B_x6,       B_min2              ; min2 = +INF 
                      
   [A_ldfg]LDDW    .D1T2 *A_x++,     B_x2:B_x1           ; Load x2:x1
||  [B_nx1]SUB     .D2   B_nx1,      6,        B_nx1     ; nx = nx - 6   

   [A_ldfg]LDDW    .D1T1 *A_x++,     A_x4:A_x3           ; Load x4:x3   
|| [!B_nx1]MPY     .M1   B_nx1,      A_1,      A_ldfg    ; Get load flag                           

; ----------------------------------------------
; ----------------- KERNEL ---------------------
; ----------------------------------------------
LOOP:
   [A_ldfg]LDDW    .D1T2 *A_x++,     B_x6:B_x5           ; Load x6:x5
||  [B_nx1]B       .S2   LOOP                            ; Branch To Loop        
||         SUBSP   .L2   B_x1,       B_min1,     B_diff  ; Diff = min1 - x1
||         CMPLTSP .S1X  B_x6,       A_min6,   A_flag6   ; if x6 < min6
||[A_flag4]MV      .L1   A_x4,       A_min4              ; min4 = x4
||[B_flag5]MV      .D2   B8,         B_min5              ; min5 = x5
||         MPYSP   .M2X  B_min1,     A_1,      B_min1    ; Save the min1 for next Iteration

   [A_ldfg]LDDW    .D1T2 *A_x++,     B_x2:B_x1           ; Load x2:x1
||  [B_nx1]SUB     .D2   B_nx1,      6,        B_nx1     ; nx = nx - 6   
||         CMPLTSP .S2   B_x2,       B_min2,   B_flag2   ; if x2 < min2
||         CMPLTSP .S1   A_x3,       A_min3,   A_flag3   ; if x3 < min3
||         AND     .L2   B_diff,     B_mask,   B_flag1   ; if x1 < min1 
||[A_flag6]MV      .L1X  B_x6,       A_min6              ; min6 = x6
||         MPYSP   .M2X  B_x1,       A_1,      B_x1      ; Save x1 for next iteratiom
||[!A_ldfg]MPYSP   .M1   A_min3,     A_1,      A_min3    ; Save previous value in last it

   [A_ldfg]LDDW    .D1T1 *A_x++,     A_x4:A_x3           ; Load x4:x3   
||         CMPLTSP .S1   A_x4,       A_min4,   A_flag4   ; if x4 < min4
||         CMPLTSP .S2   B8,         B_min5,   B_flag5   ; if x5 < min5
||[B_flag2]MV      .L2   B_x2,       B_min2              ; min2 = x2
||[A_flag3]MV      .L1   A_x3,       A_min3              ; min3 = x3
||[B_flag1]MV      .D2   B_x1,       B_min1              ; min1 = x1
|| [!B_nx1]MPY     .M1X  B_nx1,      A_1,      A_ldfg    ; Get load flag                

; ------------------------------------------------     

           MPYSP   .M2X  B_min1,     A_1,      B_x1      ; Save the min1 for next Iteration

           AND     .L2   B_diff,     B_mask,   B_flag1   ; if x1< min1   
||         CMPGT   .L1   A_rem,      3,        A_gt3     ; Check if Remainder is 2

  [B_flag1]MV      .S2   B_x1,       B_min1              ; min1 = x1
||  [A_gt3]ZERO    .D1   A_flag4                         ; Disable move if rem=2
||         CMPGT   .L2X  A_rem,      1,        B_gt1     ; Check if remainder is 6   
           
  [A_flag4]MV      .L1   A_x4,       A_min4              ; min4 = x4               
|| [!A_gt3]CMPLTSP .S1   A_x3,       A_min3,   A_flag3   ; if x3 < min3
||  [B_gt1]ZERO    .S2   B_flag5                         ; Disable move if rem=2 or 4
           
           CMPLTSP .S2   B_x1,       B_min1,   B_flag1   ; if x1 < min1
||[A_flag3]MV      .L1   A_x3,       A_min3              ; min3 = x3
||[B_flag5]MV      .D2   B8,         B_min5              ; min5 = x5
|| [!B_gt1]CMPLTSP .S1X  B_x6,       A_min6,   A_flag6   ; if x6 < min6
||  [B_gt1]ZERO    .D1   A_flag6                         ; Disable move if rem=2 or 4           
          
  [B_flag1]MV      .L2   B_x1,       B_min1              ; min1 = x1  
||[A_flag6]MV      .L1X  B_x6,       A_min6              ; min6 = x6
||         CMPLTSP .S2   B_min2,     B_min5,   B_flag    ; Finding min of min1, min2, min5
||         CMPLTSP .S1   A_min3,     A_min4,   A_flag    ; Finding min of min3, min4, min6
||         LDW     .D2   *B_SP[2],   B_mask              ; Restore Registers        

   [B_flag]MV      .L2   B_min2,     B_min5              ; Finding min of min1, min2, min5
|| [A_flag]MV      .S1   A_min3,     A_min4              ; Finding min of min3, min4, min6
||         LDW     .D2   *B_SP,      A_min6              ; Restore Registers         
||         B       .S2   B3                              ; Branch out of the function
  
           CMPLTSP .S2   B_min1,     B_min5,   B_flag    ; Finding min of min1, min2, min5
||         CMPLTSP .S1   A_min4,     A_min6,   A_flag    ; Finding min of min3, min4, min6   
||         LDW     .D2   *B_SP[1],   B_min5              
  
   [B_flag]MV      .S2   B_min1,     B_min5              ; Finding min of min1, min2, min5
|| [A_flag]MV      .S1   A_min4,     A_min6              ; Finding min of min3, min4, min6
            
           CMPLTSP .S2X  A_min6,     B_min5,   B_flag    ; Finding minimum
               
   [B_flag]MV      .S1   A_min6,     A_RET_VAL           ; Storing the minimum
                          
  [!B_flag]MV      .S1X  B_min5,     A_RET_VAL           ; Storing the minimum                
||         ADD     .D2   B_SP,       12,       B_SP      ; Restore Stack Space
||         MVC     .S2X  A_CSR,      CSR                 ; Enable  Interrupts                     

                .end

* ======================================================================== *
*  End of file: DSPF_sp_minval.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecreci/1117057357  435   0     0       17740     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*                                                                           * 
*       This routine is C callable, and has the following C prototype:      * 
*                                                                           * 
*       float DSPF_sp_vecrecip(const float *x,                                   * 
*                         float * restrict r,                               * 
*                         int n                                             * 
*                        )                                                  * 
*                                                                           * 
*              x        :  Pointer to input array                           * 
*              r        :  Pointer to output array                          * 
*              n        :  Number of elements in array                      * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*       The DSPF_sp_vecrecip module calculates the reciprocal of each element in *h
*       array x and returns the output in array r. It uses 2 iterations     * 
*       of the Newton-Raphson method to improve the accuracy of the output  * 
*       generated by the RCPSP instruction of the C67x. Each iteration      * 
*       doubles the accuracy. The initial output generated by RCPSP is 8 bi *.
*       So after the first iteration it is 16 bits and after the second it  * 
*       the full 23 bits. The formula used is:                              * 
*                                                                           * 
*                r[n+1] = r[n](2 - v*r[n]), n=0,1                           * 
*                                                                           * 
*       where v = the number whose reciprocal is to be found.               * 
*       r[0], the seed value for the algorithm, is given by RCPSP.          * 
*                                                                           * 
*    TECHNIQUES                                                             * 
*                                                                           * 
*       1. The inner loop is unrolled four times to allow calculation of    * 
*          four reciprocals in the kernel. However the stores are executed  * 
*          conditionally to allow 'n' to be any number > 0.                 * 
*                                                                           * 
*       2. Register sharing is used to make optimal use of available        * 
*          registers.                                                       * 
*                                                                           * 
*       3. No extraneous loads occur except for the case when n<=4 where    * 
*          a pad of 16 bytes is required.                                   * 
*                                                                           * 
*       4. There are no alignment requirements.                             * 
*                                                                           * 
*       5. There are no bank conflicts regardless of array alignment.       * 
*                                                                           *
*     C CODE                                                                * 
*       This is the C equivalent of the Assembly Code without               * 
*       restrictions.                                                       * 
*                                                                           * 
*   void DSPF_sp_vecrecip (const float* x, float* restrict r, int n)             *
*       {                                                                   * 
*           int i;                                                          * 
*           for(i = 0; i < n; i++)                                          * 
*               r[i] = 1 / x[i];                                            * 
*       }                                                                   * 
*     NOTES                                                                 * 
*                                                                           * 
*     CYCLES                                                                * 
*                                                                           * 
*          8*floor((n-1)/4) + 53                                            * 
*          eg. for n = 100, cycles = 245                                    * 
*                                                                           * 
*     CODESIZE                                                              * 
*                                                                           * 
*          512 bytes                                                        * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_sp_vecrecip
_DSPF_sp_vecrecip:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *

        .asg            B15,        SP
        .asg            A7,         SP_copy
        .asg            A11,        A_x
        .asg            A15,        A_num
        .asg            A7,         A_rcp1
        .asg            A5,         A_t1
        .asg            A6,         A_t2
        .asg            A5,         A_rcp2
        .asg            A4,         A_rcp3
        .asg            A6,         A_t3
        .asg            A7,         A_t4
        .asg            A6,         A_rcp4
        .asg            A5,         A_rcp5
        .asg            A0,         A_r
        .asg            B14,        B_x
        .asg            B1,         B_num
        .asg            B7,         B_rcp1
        .asg            B5,         B_t1
        .asg            B6,         B_t2
        .asg            B5,         B_rcp2
        .asg            B4,         B_rcp3
        .asg            B6,         B_t3
        .asg            B7,         B_t4
        .asg            B6,         B_rcp4
        .asg            B5,         B_rcp5
        .asg            B2,         B_r
        .asg            A3,         A_num1
        .asg            A8,         A_rcp11
        .asg            A6,         A_t11
        .asg            A12,        A_t21
        .asg            A10,        A_rcp21
        .asg            A9,         A_rcp31
        .asg            A4,         A_t31
        .asg            A6,         A_t41
        .asg            A5,         A_rcp41
        .asg            A5,         A_rcp51
        .asg            B3,         B_num1
        .asg            B8,         B_rcp11
        .asg            B6,         B_t11
        .asg            B11,        B_t21
        .asg            B10,        B_rcp21
        .asg            B9,         B_rcp31
        .asg            B4,         B_t31
        .asg            B6,         B_t41
        .asg            B5,         B_rcp41
        .asg            B5,         B_rcp51
        .asg            A1,         A_n
        .asg            A13,        A_numcopy
        .asg            B12,        B_numcopy
        .asg            A14,        A_num1copy
        .asg            B13,        B_num1copy
        .asg            A2,         A_lcntr
        
* ================ stack pushes ================ *

       STW    .D2     A15,        *SP--[14]
||     B      .S2     NO_INT                          
||     MV     .S1X    SP,         SP_copy  
||     MV     .D1     A6,         A_n               ; fetch loop cntr
       
       STW    .D2T1   A14,        *SP[12]             
||     MVC    .S2     CSR,        B2                ; disable interrupts  
||     STW    .D1T2   B13,        *-SP_copy[3]
||     AND    .S1     A_n,        3,          A_lcntr    ; check if mult of 4
     
       STW    .D2T1   A_lcntr,    *SP[1]              
||     STW    .D1T2   B2,         *-SP_copy[12]
||     AND    .L2     B2,         -2,           B2
||[A_lcntr] SUB    .S1     A_n,        A_lcntr,           A_n  ; make mult of 4
       
       STW    .D1T1   A12,        *-SP_copy[6]              
||     STW    .D2T2   B12,        *SP[10]              
||     MVC    .S2     B2,         CSR
||[A_lcntr] ADD    .S1     A_n,        4,            A_n  
     
       STW    .D2T1   A11,        *SP[5]
||     STW    .D1T2   B11,        *-SP_copy[7]
||     MV     .S1X    B4,         A0                ; pointer to o/p arr
||     ADD    .S2     B4,         8,            B2  ; copy of o/p arr ptr
||     MV     .L1     A4,         A_x               ; pointer to i/p arr.

       STW    .D2T1   A10,        *SP[4]              
||     STW    .D1T2   B14,        *-SP_copy[14]

NO_INT:     

       STW    .D2T1   A13,        *SP[9]              
||     STW    .D1T2   B3,         *-SP_copy[11]
||     ADD    .L2X    A4,         8,            B_x ; copy of i/p ptr

* =========================== PIPE LOOP PROLOG ============================ *

        LDW     .D2T2   *B_x++,     B_num           ; load x0
||      LDW     .D1T1   *A_x++,     A_num           ; load x2            
||      MVK     .S2     8,          B0              ; prolog collapse pred
||      ADD             A_n,         8,         A_n ; due to prolog collapse
||      SUB     .S1     A_n,         4,          A_lcntr ; zero if nx=4

        STW     .D2T2   B10,        *SP[6]          ; use up delay slot

* =========================== PIPE LOOP KERNEL ============================ *
loop:

        ADDSP   .L2     B_rcp1,     B_rcp1,   B_rcp2 ; 2*r[0]
||      ADDSP   .L1     A_rcp1,     A_rcp1,   A_rcp2 ; 2*r[0]          
||      MPYSP   .M1     A_rcp1,     A_t1,     A_t2   ; v*r[1]         
||      MPYSP   .M2     B_rcp1,     B_t1,     B_t2   ; v*r[1]         
|| [A_lcntr] LDW .D2T2   *B_x++[3], B_num1           ; load v
|| [A_lcntr] LDW .D1T1   *A_x++[3], A_num1           ; load v

        SUB     .S1     A_n,        4,          A_n  ; decrement counter           
||      SUBSP   .L1     A_rcp4,     A_t4,       A_rcp5; r[2]=r[1](2-v*r[1])
||      SUBSP   .L2     B_rcp4,     B_t4,       B_rcp5; r[2]=r[1](2-v*r[1])          
||      MPYSP   .M1     A_rcp3,     A_numcopy,  A_t3  ; v*r[0]*r[0]
||      MPYSP   .M2     B_rcp3,     B_numcopy,  B_t3  ; v*r[0]*r[0]          
||      MV      .D1     A_num,      A_numcopy         ; due to live too long
||      MV      .D2     B_num,      B_numcopy         ; due to live too long


  [ A_n]B       .S1     loop                          ; branch          
||      ADDSP   .L2     B_rcp3,     B_rcp3,     B_rcp4; 2*r[1]          
||      ADDSP   .L1     A_rcp3,     A_rcp3,     A_rcp4; 2*r[1]          
||      MPYSP   .M2     B_rcp11,    B_t11,      B_t21 ; v*r[1]          
||      MPYSP   .M1     A_rcp11,    A_t11,      A_t21 ; v*r[1]          
||[!A_n] LDW    .D2T1   *SP[1],     A2                ; load nx mod 4

        SUBSP   .L1     A_rcp41,    A_t41,      A_rcp51 ; final reciprocal
||      SUBSP   .L2     B_rcp41,    B_t41,      B_rcp51 ; final reciprocal        
||      MPYSP   .M1     A_rcp31,    A_num1copy, A_t31   ; v*r[0]*r[0]        
||      MPYSP   .M2     B_rcp31,    B_num1copy, B_t31   ; v*r[0]*r[0]                
||      RCPSP   .S1     A_num,      A_rcp1              ; r[0]        
||      RCPSP   .S2     B_num,      B_rcp1              ; r[0]        
||      MV      .D1     A_num1,     A_num1copy          ; live too long
||      MV      .D2        B_num1,     B_num1copy          ; live too long

        SUBSP   .L2     B_rcp2,     B_t2,       B_rcp3  ; r[1]        
||      SUBSP   .L1     A_rcp2,     A_t2,       A_rcp3  ; r[1]        
||      MPYSP   .M1     A_rcp1,     A_num,      A_t1    ; v*r[0]        
||      MPYSP   .M2     B_rcp1,     B_num,      B_t1    ; v*r[0]        
||      SHR     .S2     B0,         1,          B0      ; prolog collapse   
|| [A_lcntr] SUB     .S1     A_n,        8,          A_lcntr      ; load reset 

  [!B0] STW     .D1T1   A_rcp5,     *A_r++              ; store r[0]     
||[!B0] STW     .D2T2   B_rcp5,     *B_r++              ; store r[2]          
||      ADDSP   .L2     B_rcp31,    B_rcp31,    B_rcp41 ; 2*r[1]        
||      ADDSP   .L1     A_rcp31,    A_rcp31,    A_rcp41 ; 2*r[1]        
||      MPYSP   .M1     A_rcp3,     A_t3,       A_t4    ; v*r[1]        
||      MPYSP   .M2     B_rcp3,     B_t3,       B_t4    ; v*r[1]
||      RCPSP   .S2     B_num1,     B_rcp11             ; r[0]        
||      RCPSP   .S1     A_num1,     A_rcp11             ; r[0]        

        ADDSP   .L2     B_rcp11,    B_rcp11,    B_rcp21 ; 2*r[0]        
||      ADDSP   .L1     A_rcp11,    A_rcp11,    A_rcp21 ; 2*r[0]        
||      MPYSP   .M2     B_rcp11,    B_num1,     B_t11   ; v*r[0]
||      MPYSP   .M1     A_rcp11,    A_num1,     A_t11   ; v*r[0]         
||[A_lcntr]LDW  .D2T2   *B_x++,     B_num               ; v        
||[A_lcntr]LDW  .D1T1   *A_x++,     A_num               ; v        

  [!B0] STW     .D1T1   A_rcp51,    *A_r++[3]           ; store r[1]             
||[!B0] STW     .D2T2   B_rcp51,    *B_r++[3]           ; store r[3]                        
||      MPYSP   .M1     A_rcp31,    A_t31,      A_t41   ; v*r[1]        
||      MPYSP   .M2     B_rcp31,    B_t31,      B_t41   ; v*r[1]        
||      SUBSP   .L1     A_rcp21,    A_t21,      A_rcp31 ; r[1]=r[0](2-v*r[0])        
||      SUBSP   .L2     B_rcp21,    B_t21,      B_rcp31 ; r[0]=r[0](2-v*r[0])        

* =========================== PIPE LOOP EPILOG ============================ *
 [!A2]  MVK     .S1     4,          A2       ; if n mod 4=0 =>4 stores
        
        SUBSP   .L1     A_rcp4,     A_t4,       A_rcp5; r[2]=r[1](2-v*r[1])
||      SUBSP   .L2     B_rcp4,     B_t4,       B_rcp5; r[2]=r[1](2-v*r[1])          

        NOP
        
        SUBSP   .L1     A_rcp41,    A_t41,      A_rcp51 ; final reciprocal
||      SUBSP   .L2     B_rcp41,    B_t41,      B_rcp51 ; final reciprocal        

        NOP
        
        STW     .D1T1   A5,         *A0++                       
||      CMPGT   .L2X    A2,         1,          B0    ; is r[1] there? 
||      CMPGT   .L1     A2,         2,          A1    ; is r[2] there? 

   [A1] STW     .D2T2   B5,         *B2++                       
  
   [B0] STW     .D1T1   A5,         *A0++[3]          ; is r[3] there?           
||      CMPGT   .L2X    A2,         3,          B1
        
   [B1] STW     .D2T2   B5,         *B2++[3]                    

*============== END OF PIPED LOOP EPILOG =============================== *

*============== restore stack A10-A15, B10-B15, SP,CSR ================= *

        MV     .S1X    SP,         A1                  
||      LDDW   .D2T2   *SP[1],     B3:B2
      
        LDDW   .D2T1   *SP[2],     A11:A10                 
||      LDDW   .D1T2   *A1[3],     B11:B10                 
       
        LDDW   .D2T1   *SP[4],     A13:A12                 
||      LDDW   .D1T2   *A1[5],     B13:B12                 
     
        LDW    .D2T1    *SP[12],   A14                 
||      LDW    .D1T2   *A1[0],     B14                 
  
        ADDAW  .D2     SP,         14,       SP      ; restore SP
||      LDW    .D1T1   *A1[14],    A15                         

        B      .S2     B3                              
      
             
        MVC    .S2     B2,         CSR               ; restore CSR  
    
        NOP            4                               

                .end

* ======================================================================== *
*  End of file: DSPF_sp_vecrecip.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_vecsum_/1117057360  457   0     0       12548     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*                                                                           * 
*       This routine is C callable, and has the following C prototype:      * 
*                                                                           * 
*       float DSPF_sp_vecsum_sq(const float *x,                                  * 
*                         int n                                             * 
*                        )                                                  * 
*                                                                           * 
*              x        :  Pointer to first input array                     * 
*              n        :  Number of elements in arrays                     * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*        This routine performs a sum of squares of the elements of the      * 
*    array x and returns the sum.                                           * 
*                                                                           * 
*    TECHNIQUES                                                             * 
*                                                                           * 
*       1. The inner loop is unrolled twice. Hence, 2 registers are used    * 
*      to hold the sum of squares. ADDs are staggered.                      * 
*                                                                           * 
*       2. Extraneous loads occur. A pad of 32 bytes is required at the     * 
*      end of either array.                                                 * 
*                                                                           * 
*                                                                           * 
*    ASSUMPTIONS                                                            * 
*                                                                           * 
*       1. The x array must be double-word aligned.                         * 
*       2. Since loads of 8 floats beyond the arrays occur,                 * 
*          a pad must be provided.                                          * 
*       3. The value of n must be > 0.                                      *
*                                                                           * 
*                                                                           * 
*     C CODE                                                                * 
*      This is the C equivalent of the Assembly Code without                * 
*      restrictions.                                                        * 
*                                                                           * 
*      float DSPF_sp_vecsum_sq_cn(const float *x,int n)                          * 
*      {                                                                    * 
*          int i;                                                           * 
*          float sum=0;                                                     * 
*                                                                           * 
*          for(i=0; i<n; i++)                                               * 
*              sum += x[i]*x[i];                                            * 
*                                                                           * 
*          return sum;                                                      * 
*      }                                                                    * 
*                                                                           * 
*                                                                           * 
*     NOTES                                                                 * 
*                                                                           * 
*     CYCLES                                                                * 
*                                                                           * 
*          floor((n-1)/2) + 26                                              * 
*          eg. for n = 200, cycles = 125                                    * 
*                                                                           * 
*     CODESIZE                                                              * 
*                                                                           * 
*          384 bytes                                                        * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


                    
                    .asg A4, A_x
                    .asg B4, B_x
                    .asg B1, B_cntr
                    .asg A2, A_odd
                    .asg A5, A_x0
                    .asg B5, B_x1
                    .asg A6, A_p1
                    .asg B6, B_p2
                    .asg A7, A_sum1
                    .asg B7, B_sum2
                    .asg A6, A_sum
                    .asg A4, A_ret
                    .asg B9, B_temp
                    .asg B6, B_sum
                    .asg B4, B_part
                    
        .text
        .global _DSPF_sp_vecsum_sq
_DSPF_sp_vecsum_sq:

* ==================== PIPED LOOP PROLOG =================================== *
       ADD   .L2X     A_x,        4,        B_x      ; set load counter
||     SHR   .S2      B4,         1,        B_cntr   ; set loop cntr     
||     ZERO  .D1      A_sum1                         ; init sums     
||     ZERO  .D2      B_sum2                              
||     AND   .L1X     B4,         1,        A_odd    ; is 'n' odd? 
||     B     .S1      no_int   
      
       LDW   .D1T1    *A_x++[2],   A_x0              ; load x0    
||     LDW   .D2T2    *B_x++[2],   B_x1              ; load x1    
||[!A_odd]SUB.L2      B_cntr,      1,       B_cntr   ; adjust cntr     
||     MVC   .S2      CSR,        B8
      
       LDW   .D1T1    *A_x++[2],   A_x0              ; load x0           
||     LDW   .D2T2    *B_x++[2],   B_x1              ; load x1    
||     AND   .S2      B8,          -1,      B9       ; disable inter
      
       LDW   .D1T1    *A_x++[2],   A_x0              ; load x0    
||     LDW   .D2T2    *B_x++[2],   B_x1              ; load x1    
||     MVC   .S2      B9,          CSR
      
       LDW   .D1T1    *A_x++[2],   A_x0              ; load x0    
||     LDW   .D2T2    *B_x++[2],   B_x1              ; load x1    
||[B_cntr] SUB.S2      B_cntr,     1,        B_cntr  ; dec cntr      
||[!B_cntr]B  .S1      skip_kernel                   ; skip if <=2  
      
       LDW    .D1T1   *A_x++[2],   A_x0              ; load x0    
||     LDW    .D2T2   *B_x++[2],   B_x1              ; load x0    
||[B_cntr] B  .S1     loop                           ; branch 
||[B_cntr] SUB.L2     B_cntr,      1,        B_cntr  ; decr cntr      
      
no_int:
      
       LDW    .D1T1   *A_x++[2],   A_x0              ; load x0    
||     LDW    .D2T2   *B_x++[2],   B_x1              ; load x1    
||     MPYSP  .M1     A_x0,        A_x0,       A_p1  ; x0*x0      
||     MPYSP  .M2     B_x1,        B_x1,       B_p2  ; x1*x1      
||[B_cntr] B  .S1     loop                           ; branch 
||[B_cntr] SUB.S2     B_cntr,      1,          B_cntr; decr cntr        
      
       LDW    .D1T1   *A_x++[2],   A_x0              ; load x0    
||     LDW    .D2T2   *B_x++[2],   B_x1              ; load x1    
||     MPYSP  .M1     A_x0,        A_x0,       A_p1  ; x0*x0      
||     MPYSP  .M2     B_x1,        B_x1,       B_p2  ; x1*x1      
||[B_cntr] B  .S1     loop                           ; branch 
||[B_cntr] SUB.S2     B_cntr,      1,          B_cntr; decr cntr        

       LDW    .D1T1   *A_x++[2],   A_x0              ; load x0    
||     LDW    .D2T2   *B_x++[2],   B_x1              ; load x1    
||     MPYSP  .M1     A_x0,        A_x0,       A_p1  ; x0*x0      
||     MPYSP  .M2     B_x1,        B_x1,       B_p2  ; x1*x1      
||[B_cntr] B  .S1     loop                           ; branch 
||[B_cntr] SUB.S2     B_cntr,       1,         B_cntr; decr cntr        
      
       LDW    .D1T1   *A_x++[2],   A_x0              ; load x0    
||     LDW    .D2T2   *B_x++[2],   B_x1              ; load x1    
||     MPYSP  .M1     A_x0,        A_x0,       A_p1  ; x0*x0     
||     MPYSP  .M2     B_x1,        B_x1,       B_p2  ; x1*x1      
||[B_cntr] B  .S1     loop                           ; branch  
||[B_cntr] SUB.S2     B_cntr,      1,          B_cntr; dec cntr        
      
* ========================== PIPED LOOP KERNEL ========================== *      
loop:      
       LDW    .D1T1   *A_x++[2],   A_x0              ; load x0    
||     LDW    .D2T2   *B_x++[2],   B_x1              ; load x1    
||     MPYSP  .M1     A_x0,        A_x0,       A_p1  ; x0*x0      
||     MPYSP  .M2     B_x1,        B_x1,       B_p2  ; x1*x1      
||     ADDSP  .L1     A_p1,        A_sum1,     A_sum1; sum1+=x0*x0       
||     ADDSP  .L2     B_p2,        B_sum2,     B_sum2; sum2+=x1*x1       
||[B_cntr] B  .S1     loop                           ; branch 
||[B_cntr] SUB.S2     B_cntr,      1,          B_cntr; decr cntr        
      
* ======================== PIPED LOOP EPILOG ============================ *      
skip_kernel:
      
       ADDSP   .L1    A_p1,         A_sum1,    A_sum1; sum1+=p1        
||[!A_odd]ADDSP.L2    B_p2,         B_sum2,    B_temp; temp=p2+sum2
||[A_odd] MV   .S2    B_sum2,       B_temp           ; if odd then move   

       ADDSP   .L1X   A_sum1,       B_sum2,    A_sum1; collect stagg sums
        
       ADDSP   .L1X   A_sum1,       B_sum2,    A_sum        
        
       ADDSP   .L2X   A_sum1,       B_sum2,    B_sum2        
        
       ADDSP   .L2X   A_sum1,       B_temp,    B_sum        
        
       NOP                                                        
        
       ADDSP   .L1    A_sum,        A_sum1,    A_ret        
        
       NOP                                                        
        
       ADDSP   .L2    B_sum,        B_sum2,    B_part        
        
       NOP                                                        
        
       B       .S2    B3                              
        
       NOP                                                        
        
       ADDSP          A_ret,        B_part,    A_ret        
        
       NOP            2
       
       MVC     .S2    B8,           CSR                 

                .end

* ======================================================================== *
*  End of file: DSPF_sp_vecsum_sq.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_w_vec.a/1117057361  480   0     0       12605     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*                                                                           * 
*       This routine is C callable, and has the following C prototype:      * 
*                                                                           * 
*         void DSPF_sp_w_vec(const float* x,                                     * 
*                       const float * y,                                    * 
*                       float m,                                            * 
*                       float * restrict r,                                 * 
*                       int     nr                                          * 
*                      )                                                    * 
*                                                                           * 
*              x    :  Pointer to first input array                         * 
*              y    :  Pointer to second input array                        * 
*              m    :  Weight factor                                        * 
*              r    :  Output array pointer                                 * 
*              nr   :  Number of elements in arrays                         * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*      This routine is used to obtain the weighted vector sum.              * 
*      Both the inputs and output are single precision floating             * 
*      point numbers.                                                       * 
*                                                                           * 
*    TECHNIQUES                                                             * 
*                                                                           * 
*       1. The inner loop is unrolled twice.                                * 
*                                                                           * 
*       2. No extraneous loads occur except for odd values of n.            * 
*                                                                           * 
*       3. Write buffer fulls occur unless the array 'r' is in cache.       * 
*                                                                           * 
*                                                                           * 
*    ASSUMPTIONS                                                            * 
*                                                                           * 
*       1. The x and y arrays must be double-word aligned.                  * 
*       2. The value of nr must be > 0.                                     *
*                                                                           * 
*                                                                           * 
*     C CODE                                                                * 
*      This is the C equivalent of the Assembly Code without                * 
*      restrictions.                                                        * 
*                                                                           * 
*      void DSPF_sp_w_vec_cn( const float *    x,                                * 
*                        const float *    y,                                * 
*                        float         m,                                   * 
*                        float *        restrict r,                         * 
*                        int         nr                                     * 
*                     )                                                     * 
*                                                                           * 
*     {                                                                     * 
*         int i;                                                            * 
*         for (i = 0; i < nr; i++)                                          * 
*             r[i] = (m * x[i]) + y[i];                                     * 
*     }                                                                     * 
*                                                                           * 
*                                                                           * 
*                                                                           * 
*     NOTES                                                                 * 
*                                                                           * 
*     CYCLES                                                                * 
*                                                                           * 
*          2*floor((n-1)/2) + 19                                            * 
*          eg. for n = 200, cycles = 219.                                   * 
*                                                                           * 
*     CODESIZE                                                              * 
*                                                                           * 
*          384 bytes                                                        * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_sp_w_vec
_DSPF_sp_w_vec:

              .asg A0, A_m
              .asg A4, A_x
              .asg A7, A_x1
              .asg A6, A_x0
              .asg B9, B_m
              .asg B7, B_y1
              .asg B6, B_y0
              .asg B0, B_lcntr
              .asg A2, A_cntr
              .asg B2, B_odd
              .asg B8, B_p2
              .asg A8, A_p1
              .asg A3, A_s1
              .asg B1, B_s2
              .asg A1, A_lcntr
              .asg A9, A_strptr
              .asg B5, B_strptr
              
* ================= PIPED LOOP PROLOG ============================ *

        LDDW      .D1   *A_x++, A_x1:A_x0       ; load x1:x0
||      ADD       .L2   B6,    4,    B_strptr   ; init store ptr
||      MV        .L1X  B6,    A_strptr         ; init store ptr
||      SHR       .S1   A8,    1,    A_cntr     ; loop counter
||      AND       .S2X  A8,    1,    B_odd      ; is cntr odd?

 [!B_odd]SUB      .L1   A_cntr,1,    A_lcntr    ; init load cntr
||      MV        .L2X  A6,    B_m              ; make copy of wt
||      MV        .S1   A6,    A_m              ; on a and b-sides
||[B_odd]MV       .D1   A_cntr,A_lcntr          ; load cntr
||      B         .S2   no_int                  ; disable interrupts
        
 [A_lcntr]LDDW    .D1T1 *A_x++, A_x1:A_x0        ; load x1:x0
|| [!B_odd]SUB    .L1   A_cntr,    1,    A_cntr  ; due to epilog
||      MVC       .S2   CSR,    B8                  
        
        LDDW      .D2T2 *B4++, B_y1:B_y0        ; load y1:y0
|| [A_lcntr] SUB  .S1   A_lcntr,    1,    A_lcntr; decr x load cntr
||      AND       .L2   B8,   -1,    B8         ; disable interrupts
||      MV        .L1X  B8,    A5               ; save CSR
        
   [A_lcntr] LDDW .D1T1 *A_x++, A_x1:A_x0       ; load cntr
||      MV        .L2X  A_cntr, B_lcntr         ; init y-load cntr  
||      MVC       .S2   B8,     CSR             ; disable interrupts 
        
   [B_lcntr] LDDW .D2T2 *B4++, B_y1:B_y0        ; load y1:y0
||      MPYSP     .M1   A_x0, A_m, A_p1         ; m*x0
||      MPYSP     .M2X  A_x1, B_m, B_p2         ; m*x1
|| [A_lcntr] SUB  .S1   A_lcntr,    1,    A_lcntr; decr x load cntr
        
   [A_lcntr] LDDW .D1T1  *A_x++, A_x1:A_x0      ; load x1:x0 
|| [B_lcntr] SUB  .S2    B_lcntr, 1, B_lcntr    ; decr y load cntr
        
no_int:
        
   [B_lcntr] LDDW .D2T2 *B4++, B_y1:B_y0         ; load y1:y0
||      MPYSP     .M1   A_x0, A_m, A_p1          ; m*x0
||      MPYSP     .M2X  A_x1, B_m, B_p2          ; m*x1
||[!A_cntr] B     .S2   skip_kernel
|| [A_lcntr] SUB  .S1   A_lcntr,    1,    A_lcntr; decr x load cntr
      
   [A_lcntr] LDDW .D1T1  *A_x++, A_x1:A_x0       ; load x1:x0
|| [A_cntr] SUB   .S1    A_cntr, 1, A_cntr       ; decr loop cntr
|| [B_lcntr] SUB  .S2    B_lcntr, 1, B_lcntr     ; decr y-load cntr
        
   [B_lcntr] LDDW .D2T2 *B4++, B_y1:B_y0         ; load y1:y0
||      MPYSP     .M1   A_x0, A_m, A_p1          ; m*x0
||      MPYSP     .M2X  A_x1, B_m, B_p2          ; m*x1
||      ADDSP     .L1X  A_p1, B_y0, A_s1         ; s1=y0+m*x0
||      ADDSP     .L2   B_p2, B_y1, B_s2         ; s2=y1+m*x1
||[A_cntr]  B     .S2   loop                     ; branch
|| [A_lcntr] SUB  .S1   A_lcntr,    1,    A_lcntr; decr x load cntr

  [A_lcntr]  LDDW .D1T1 *A_x++, A_x1:A_x0        ; load x1:x0
||[A_cntr]   SUB  .S1   A_cntr, 1, A_cntr        ; decr loop cntr
|| [B_lcntr] SUB  .S2   B_lcntr, 1, B_lcntr      ; decr y load cntr
        
   [B_lcntr] LDDW .D2T2 *B4++, B_y1:B_y0         ; load y1:y0
||      MPYSP     .M1   A_x0, A_m, A_p1             ; m*x0
||      MPYSP     .M2X  A_x1, B_m, B_p2           ; m*x1
||      ADDSP     .L1X  A_p1, B_y0, A_s1         ; s1=y0+m*x0
||      ADDSP     .L2   B_p2,   B_y1, B_s2         ; s2=y1+m*x1
||[A_cntr]  B     .S2   loop             ; branch
|| [A_lcntr] SUB  .S1   A_lcntr, 1,  A_lcntr     ; decr x load cntr

  [A_lcntr]  LDDW .D1T1  *A_x++, A_x1:A_x0       ; load x1:x0
||[A_cntr]  SUB   .S1    A_cntr, 1, A_cntr       ; decr loop cntr
|| [B_lcntr] SUB  .S2    B_lcntr, 1, B_lcntr     ; decr y load cntr
* ===================== PIPED LOOP KERNEL ============================== *
loop:
        STW       .D1T1 A_s1, *A_strptr++[2]     ; store s1
||[B_lcntr] LDDW  .D2T2 *B4++, B_y1:B_y0         ; load y1:y0
||      MPYSP     .M1   A_x0, A_m, A_p1      ; m*x0
||      MPYSP     .M2X  A_x1, B_m, B_p2      ; m*x1
||      ADDSP     .L1X  A_p1, B_y0, A_s1     ; s1=y0+m*x0
||      ADDSP     .L2   B_p2, B_y1, B_s2     ; s2=y1+m*x1
||[A_cntr]  B     .S2   loop             ; branch
||[A_lcntr]  SUB  .S1   A_lcntr, 1,  A_lcntr      ; decr x load cntr

  [A_lcntr]  LDDW .D1T1 *A_x++, A_x1:A_x0        ; load x1:x0        
||      STW       .D2T2 B_s2, *B_strptr++[2]     ; store s2
||[A_cntr]  SUB   .S1   A_cntr, 1, A_cntr     ; decr loop cntr
||[B_lcntr]  SUB  .S2   B_lcntr, 1, B_lcntr     ; decr y load cntr

* ===================== PIPED LOOP EPILOG ============================== *
skip_kernel:
        
        B         .S2   B3                       ; return
||      STW       .D1T1 A_s1, *A_strptr++[2]     ; store s1

  [!B_odd] STW    .D2T2 B_s2, *B_strptr++[2]     ; store only if even 

        NOP             2
        
        MV        .S2X  A5,     B8
        
        MVC       .S2   B8,     CSR

                .end

* ======================================================================== *
*  End of file: DSPF_sp_w_vec.asm                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecmul./1117057361  499   0     0       9251      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecmul -- Single Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*                                                                           * 
*       This routine is C callable, and has the following C prototype:      * 
*                                                                           * 
*       void DSPF_sp_vecmul   (const float *x,                                   * 
*                         const float *y,                                   * 
*                         float * restrict r,                               * 
*                         int n                                             * 
*                        )                                                  * 
*                                                                           * 
*              x        :  Pointer to first input array                     * 
*              y        :  Pointer to second input array                    * 
*              r        :  Pointer to output array                          * 
*              n        :  Number of elements in arrays                     * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*        This routine performs an element by element floating point         * 
*    multiply of the vectors x[] and y[] and returns the values in r[].     * 
*                                                                           * 
*    TECHNIQUES                                                             * 
*                                                                           * 
*       1. The inner loop is unrolled twice to allow calculation of         * 
*          2 outputs in the kernel. However the stores are executed         * 
*          conditionally to allow 'n' to be any number > 0.                 * 
*                                                                           * 
*       2. No extraneous loads occur except for the case when n is odd      * 
*          where a pad of 4 bytes is required.                              * 
*                                                                           * 
*                                                                           * 
*    ASSUMPTIONS                                                            * 
*                                                                           * 
*       1. The x and y arrays must be double-word aligned.                  * 
*                                                                           * 
*                                                                           * 
*     C CODE                                                                * 
*      This is the C equivalent of the Assembly Code without                * 
*      restrictions.                                                        * 
*                                                                           * 
*      void DSPF_sp_vecmul_cn(const float * x, const float * y,                  *
*                        float * restrict r, int n)                         *
*      {                                                                    *
*          int i;                                                            *
*          for(i = 0; i < n; i++)                                            *
*              r[i] = x[i] * y[i];                                            *
*                                                                            *
*      }                                                                    *
*                                                                           * 
*                                                                           * 
*     NOTES                                                                 * 
*                                                                           * 
*     CYCLES                                                                * 
*                                                                           * 
*          2*floor((n-1)/2) + 18                                            * 
*          eg. for n = 200, cycles =216                                     * 
*                                                                           * 
*     CODESIZE                                                              * 
*                                                                           * 
*          192 bytes                                                        * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



                  .asg A4, A_x
                  .asg B6, B_x
                  .asg A1, A_x1
                  .asg A0, A_x0
                  .asg B5, B_y1
                  .asg B4, B_y0
                  .asg A5, A_p1
                  .asg B8, B_p2
                  .asg B2, B_odd
                  .asg B0, B_cntr
                  .asg A2, A_lcntr
                  .asg A3, A_r
                  .asg B7, B_r
                  .asg B1, B_pred
                  
        .text
        .global _DSPF_sp_vecmul
_DSPF_sp_vecmul:

* ======================= PIPED LOOP PROLOG ======================== *
       SUB    .D1     A6,         8,        A_r     ; set store ptr      
||     MV     .D2     B4,         B_x               ; set y load ptr   
||     MV     .S2     B6,         B4                ; set counter
||     B      .S1     loop                          ; prolog branch  
           
       MVK    .S2     0x4,        B_pred            ; prolog collapse  

       SHR    .S2     B4,         1,        B_cntr  ; init counter  
||     B      .S1     loop                          ; prrolog branch  
||     AND    .L2     B4,         1,        B_odd   ; is cntr odd?  
||     LDDW   .D1T1   *A_x++,     A_x1:A_x0         ; load x1:x0  

       ADD    .L2X    4,          A_r,      B_r     ; set store cntr  
||[!B_odd]SUB .S1X    B_cntr,     1,        A_lcntr ; set load cntr  
||[ B_odd]ADD .S2     B_cntr,     1,        B_cntr  ; adjust cntr  
||[B_odd]MV           B_cntr,     A_lcntr           ; set load cntr  
||     LDDW   .D2T2   *B_x++,     B_y1:B_y0         ; load y1:y0  

* ==================== PIPED LOOP KERNEL================================== *

loop:

  [B_cntr]B      .S1     loop                       ; branch     
||[A_lcntr]LDDW  .D1T1   *A_x++,     A_x1:A_x0      ; load x1:x0     
||     MPYSP     .M1X    B_y0,       A_x0,     A_p1 ; x0*y0     
||     MPYSP     .M2X    B_y1,       A_x1,     B_p2 ; x1*y1     
||[!B_pred]STW   .D2T2   B_p2,       *++B_r(8)      ; store x1*y1  

  [B_pred]SUB    .S2     B_pred,     1,        B_pred; decr prol pred    
||[A_lcntr]SUB   .S1     A_lcntr,    1,        A_lcntr; decr load cntr   
||[!B_pred]STW   .D1T1   A_p1,       *++A_r(8)       ; store x0*y0 
||[B_cntr]SUB    .L2     B_cntr,     1,        B_cntr; decr loop cntr    
||[A_lcntr]LDDW  .D2T2   *B_x++,     B_y1:B_y0       ; load y1:y0    

* =================== END OF PIPED LOOP KERNEL ========================== *

 [!B_odd]STW    .D2T2    B_p2,       *++B_r(8)      ; if even store   
||       B      .S2      B3                         ; return     

       STW      .D1T1    A_p1,       *++A_r(8)      ; store  

       NOP               4                               

                .end

* ======================================================================== *
*  End of file: DSPF_sp_vecmul.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_mat_mul/1117057363  519   0     0       28660     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      14-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                    * 
*      This routine has following C prototype                               * 
*                                                                           * 
*          void DSPF_sp_mat_mul                                                  * 
*          (                                                                * 
*              float *x, int r1, int c1,                                    * 
*              float *y,         int c2,                                    * 
*              float *r,                                                    * 
*          );                                                               * 
*                                                                           * 
*      x[]  : Pointer to r1 by c1 input matrix.                             * 
*      r1   : Number of rows in x.                                          * 
*      c1   : Number of columns in x.  Also number of rows in y.            * 
*      y[]  : Pointer to c1 by c2 input matrix.                             * 
*      c2   : Number of columns in y.                                       * 
*      r[]  : Pointer to r1 by c2 output matrix.                            * 
*                                                                           * 
*  DESCRIPTION                                                              * 
*      This function computes the expression "r = x * y" for the matrices   * 
*      x and y.  The column dimension of x must match the row dimension     * 
*      of y.  The resulting matrix has the same number of rows as x and     * 
*      the same number of columns as y.                                     * 
*                                                                           * 
*      The values stored in the matrices are assumed to be single precision * 
*      floating point values.                                               * 
*                                                                           * 
*      This code is suitable for dense matrices.  No optimizations are      * 
*      made for sparse matrices.                                            * 
*                                                                           * 
*  C CODE                                                                   * 
*      The following is a C description of the algorithm.                   * 
*                                                                           * 
*      void DSPF_sp_mat_mul                                                      * 
*      (                                                                    * 
*          float *x, int r1, int c1,                                        * 
*          float *y,         int c2,                                        * 
*          float *r,                                                        * 
*      )                                                                    * 
*      {                                                                    * 
*          int i, j, k;                                                     * 
*          float sum;                                                       * 
*                                                                           * 
*          /* ---------------------------------------------------- */       * 
*          /*  Multiply each row in x by each column in y.  The    */       * 
*          /*  product of row m in x and column n in y is placed   */       * 
*          /*  in position (m,n) in the result.                    */       * 
*          /* ---------------------------------------------------- */       * 
*          for (i = 0; i < r1; i++)                                         * 
*              for (j = 0; j < c2; j++)                                     * 
*              {                                                            * 
*                  sum = 0;                                                 * 
*                                                                           * 
*                  for (k = 0; k < c1; k++)                                 * 
*                      sum += x[k + i*c1] * y[j + k*c2];                    * 
*                                                                           * 
*                  r[j + i*c2] = sum;                                       * 
*              }                                                            * 
*      }                                                                    * 
*                                                                           * 
*  TECHNIQUES                                                               *
*     All three loops are unrolled two times                                *
*     All the prolog stages of the innermost loop (kLoop) are collapsed     *
*                                                                           *
*  ASSUMPTIONS                                                              * 
*      - The arrays 'x', 'y', and 'r' are stored in distinct arrays.        * 
*        That is, in-place processing is not allowed.                       * 
*      - All r1, c1, c2 are assumed to be > 1                               *
*                                                                           *
*  MEMORY NOTES                                                             *
*      - 5 Floats are always loaded extra from the locations:               *
*          y[c1' * c2'], y[c1' * c2' + 1],                                  *
*          x[r1  * c1'], x[r1' * c1'],     x[2 * c1]                        *
*        where                                                              *
*             r1' = r1 + (r1&1)                                             *
*             c2' = c2 + (c2&1)                                             *
*             c1' = c1 + 1 + 2*(c1&1)                                       *
*      - If (r1&1) means r1 is odd, one extra row of x[] matrix is loaded   *
*      - If (c2&1) means c2 is odd, one extra col of y[] matrix is loaded   *
*                                                                           *
*  CYCLES                                                                   *
*     (0.5 * r1' * c1 * c2') + (6 * c2' * r1') + (4 * r1') + 22             *
*      - where                                                              *
*             r1' = r1 + (r1&1)                                             *
*             c2' = c2 + (c2&1)                                             *
*                                                                           *
*  CODESIZE                                                                 *
*     992 Bytes                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A3,         A_ptr_x
        .asg            A9,         A_x0
        .asg            A8,         A_x1
        .asg            B10,        B_ptr_y
        .asg            B14,         B_c2
        .asg            B1,         B_y0
        .asg            B2,         B_ptr_w
        .asg            B8,         B_y1
        .asg            B3,         B_yc20
        .asg            B11,         B_yc21
        .asg            A14,         A_prod1
        .asg            A7,         A_prod2
        .asg            A0,         A_mac
        .asg            A10,         A_sum
        .asg            B7,         B_prod1
        .asg            B12,         B_prod2
        .asg            B9,         B_mac1
        .asg            B5,         B_sum1
        .asg            A5,         A_ptr_z
        .asg            A13,         A_xc10
        .asg            A9,         A_xc11
        .asg            A0,         A_mac2
        .asg            A10,         A_sum2
        .asg            B11,         B_mac3
        .asg            B5,         B_sum3
        .asg            A1,         A_kCnt

        .asg            A4,         A_x
        .asg            B4,         B_r1
        .asg            A6,         A_c1
        .asg            B6,         B_y
        .asg            A8,         A_c2
        .asg            B8,         B_r
        
        .asg            A11,        i
        .asg            B13,        j
        .asg            A12,        A_c1_odd
        .asg            A12,        A_kLoopCnt
        .asg            A9,         A_index
        .asg            A13,        ptr_r
        
        .asg            B8,         c2_p1
        .asg            B0,         jCnt
        .asg            A2,         iCnt
        .asg            A0,         A_c2_copy
        .asg            A2,         A_pred
        .asg            B0,         B_flag
        .asg            A4,         A_0x80KK
        .asg            A5,         A_0x1
        .asg            B1,         flag_b1
        .asg            B12,        ptr_r_copy
        
; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B2,         B_csr       ; CSR's value
        .asg            B7,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B3,         B_ret       ; Return address
; ========================================================================= ;
        ; Stack frame.  16 words:  A10..A15, B10..B14, B3, CSR, B_r, A_x, pad
        
        .text
        .global _DSPF_sp_mat_mul
_DSPF_sp_mat_mul:

        STW     .D2T2   B14,        *--B_SP[16]            ; Get stk, Save B14
||      B       .S1     NO_INTS                            ;Disable Interrupts during branch

        ADD     .S1X    B_SP,       4,          A_SP       ; Twin Stack Ptr
||      STW     .D2T2   B13,        *+B_SP[2]              ; Save B13

        STW     .D1T1   A15,        *A_SP                  ; Save A15
||      STW     .D2T2   B12,        *+B_SP[4]              ; Save B12

        STW     .D1T1   A14,        *+A_SP[2]              ; Save A14
||      STW     .D2T2   B11,        *+B_SP[6]              ; Save B11
||      MVC     .S2     CSR,        B_csr                  ; Get CSR's state

        STW     .D1T1   A12,        *+A_SP[4]              ; Save A12
||      STW     .D2T2   B10,        *+B_SP[8]              ; Save B10
||      MV      .L2     B_y,        B_ptr_y                ;Initialization of ptr_y
||      AND     .S1     A_c1,       1,          A_c1_odd   ; (c1&1)     
||      AND     .S2     B_csr,      -2,         B_no_gie   ; Clear GIE

        STW     .D1T1   A13,        *+A_SP[6]              ; Save A13
||      STW     .D2T2   B_csr,      *+B_SP[10]             ; Save CSR
||      ADD     .L2     B_ptr_y,    4,          B_ptr_w    ;ptr to 2nd col of Y matrix 
||      MV      .L1     A_c1,       A_index                ;Initialization of index
||      SUB     .S1     A_c1,       A_c1_odd,   A_kLoopCnt ;round c1 to nearest lesser even no.
||      MVC     .S2     B_no_gie,   CSR                    ;Disable Interrrupts

NO_INTS:
        STW     .D1T1   A10,        *+A_SP[8]              ; Save A10
||      STW     .D2T2   B_ret,      *+B_SP[12]             ; Save RET ADDR
||      ZERO    .S1     A_sum                              ;reset A_sum,A_sum2->mapped to same reg
||      SUB     .L1     A_kLoopCnt, 2,          A_kCnt     ;kLoop counter
||      ZERO    .L2     B_sum1                             ;reset B_sum1,B_sum3->mapped to same reg

        STW     .D1T1   A11,        *+A_SP[10]             ; Save A11
||      STW     .D2T2   B_r,        *+B_SP[13]             ; Save B_r
||      MVK     .S1     4,          A_pred                 ;Prolog Collapse Predicate
||      CMPGT   .L2X    A_kLoopCnt, 6,          B_flag     ;if kernel ran > 3 times
||[A_kCnt]B     .S2     ijkLoop

        ZERO    .S1     i                                  ;reset iLoop counter
||      MV      .S2X    A_c2,       B_c2                   ;make a copy of c2 on B-side
||      ZERO    .L2     j                                  ;reset jLoop counter
||      STW     .D2T1   A_x,       *+B_SP[14]              ; Save A_x
||      MV      .L1     A_x,        A_ptr_x                ;Initialization of ptr_x 
||      ADDAW   .D1     A_x,        A_index,    A_ptr_z    ;ptr to 2nd row of X matrix  

        
* =========================== PIPE LOOP KERNEL ============================ *
ijkLoop:
  [!A_pred]ADDSP .L1    A_sum,      A_mac,      A_sum           ;[17,2] 
||      ADDSP   .L2     B_prod1,    B_prod2,    B_mac1          ;[13,3] 
||      MPYSP   .M1X    A_xc10,     B_y0,       A_prod1         ;[ 9,4] 
||      MPYSP   .M2X    A_x1,       B_yc21,     B_prod2         ;[ 9,4] 
||      LDW     .D1T1   *-A_ptr_z[1],           A_xc11          ;[ 5,5] 
||      LDW     .D2T2   *B_ptr_y++[B_c2],       B_y0            ;[ 1,6] 

   [ A_kCnt]SUB   .S1   A_kCnt,     2,          A_kCnt          ;[18,2] 
|| [!A_pred]ADDSP .L2   B_sum1,     B_mac1,     B_sum1          ;[18,2] 
||      ADDSP   .L1     A_prod1,    A_prod2,    A_mac2          ;[14,3] 
||      MPYSP   .M1X    A_xc11,     B_yc20,     A_prod2         ;[10,4] 
||      MPYSP   .M2X    A_xc11,     B_yc21,     B_prod2         ;[10,4] 
||      LDW     .D2T2   *B_ptr_y++[B_c2],       B_yc20          ;[ 2,6] 
||      LDW     .D1T1   *A_ptr_x++, A_x0                        ;[ 2,6] 

   [ A_kCnt]B     .S2   ijkLoop                                   ;[19,2] 
|| [!A_pred]ADDSP .L1   A_sum2,     A_mac2,     A_sum2          ;[19,2] 
||      ADDSP   .L2     B_prod1,    B_prod2,    B_mac3          ;[15,3] 
||      MPYSP   .M2X    A_xc10,     B_y1,       B_prod1         ;[11,4] 
||      MPYSP   .M1X    A_x0,       B_y0,       A_prod1         ;[ 7,5] 
||      LDW     .D2T2   *B_ptr_w++[B_c2],       B_y1            ;[ 3,6] 
||      LDW     .D1T1   *A_ptr_x++, A_x1                        ;[ 3,6] 

   [!A_pred]ADDSP .L2   B_sum3,     B_mac3,     B_sum3          ;[20,2] 
||      ADDSP   .L1     A_prod1,    A_prod2,    A_mac           ;[12,4] 
||      MPYSP   .M2X    A_x0,       B_y1,       B_prod1         ;[ 8,5] 
||      MPYSP   .M1X    A_x1,       B_yc20,     A_prod2         ;[ 8,5] 
||      LDW     .D1T1   *A_ptr_z++[2],          A_xc10          ;[ 4,6] 
||      LDW     .D2T2   *B_ptr_w++[B_c2],       B_yc21          ;[ 4,6] 
|| [A_pred]SUB  .S1     A_pred,     1,          A_pred          ;Prolog Collapse Predicate

* =========================== PIPE LOOP EPILOG ============================ *
   [B_flag]ADDSP .L1    A_sum,      A_mac,      A_sum           ;[17,3] 
||      ADDSP   .L2     B_prod1,    B_prod2,    B_mac1          ;[13,4] 
||      MPYSP   .M1X    A_xc10,     B_y0,       A_prod1         ;[ 9,5] 
||      MPYSP   .M2X    A_x1,       B_yc21,     B_prod2         ;[ 9,5] 
||      LDW     .D1T1   *-A_ptr_z[1],           A_xc11          ;[ 5,6] 
||      SUB     .S1     A_kLoopCnt, 6,          A_kLoopCnt      ;to check if kLoop ran > 2 times
||      LDW     .D2T2   *B_ptr_y,   B_y0                        ;if c1 odd

   [B_flag]ADDSP .L2    B_sum1,     B_mac1,     B_sum1          ;[18,3] 
||      ADDSP   .L1     A_prod1,    A_prod2,    A_mac2          ;[14,4] 
||      MPYSP   .M1X    A_xc11,     B_yc20,     A_prod2         ;[10,5] 
||      MPYSP   .M2X    A_xc11,     B_yc21,     B_prod2         ;[10,5] 
||      MVKL    .S1     0x80000000, A_0x80KK                    ;mask to find sign bit
||      LDW     .D1T1   *A_ptr_x,   A_x0                        ;if c1 odd 

   [B_flag]ADDSP .L1    A_sum2,     A_mac2,     A_sum2          ;[19,3] 
||      ADDSP   .L2     B_prod1,    B_prod2,    B_mac3          ;[15,4] 
||      MPYSP   .M2X    A_xc10,     B_y1,       B_prod1         ;[11,5] 
||      MPYSP   .M1X    A_x0,       B_y0,       A_prod1         ;[ 7,6] 
||      MVKH    .S1     0x80000000, A_0x80KK                    ;mask to find sign bit
||      LDW     .D1T1   *A_ptr_z,   A_xc10                      ;if c1 odd 
||      LDW     .D2T2   *B_ptr_y[1],            B_y1            ;if c1 odd

   [B_flag]ADDSP .L2    B_sum3,     B_mac3,     B_sum3          ;[20,3] 
||      ADDSP   .L1     A_prod1,    A_prod2,    A_mac           ;[12,5] 
||      MPYSP   .M2X    A_x0,       B_y1,       B_prod1         ;[ 8,6] 
||      MPYSP   .M1X    A_x1,       B_yc20,     A_prod2         ;[ 8,6] 
||      AND     .S1     A_0x80KK,   A_kLoopCnt, A_pred          ;if kernel ran > 2 times

   [!A_pred]ADDSP .L1   A_sum,      A_mac,      A_sum           ;[17,4] 
||      ADDSP   .L2     B_prod1,    B_prod2,    B_mac1          ;[13,5] 
||      MPYSP   .M1X    A_xc10,     B_y0,       A_prod1         ;[ 9,6] 
||      MPYSP   .M2X    A_x1,       B_yc21,     B_prod2         ;[ 9,6] 

   [!A_pred]ADDSP .L2   B_sum1,     B_mac1,     B_sum1          ;[18,4] 
||      ADDSP   .L1     A_prod1,    A_prod2,    A_mac2          ;[14,5] 
||      MPYSP   .M1X    A_xc11,     B_yc20,     A_prod2         ;[10,6] 
||      MPYSP   .M2X    A_xc11,     B_yc21,     B_prod2         ;[10,6] 
||      MVK     .S1     0x4,        A_kCnt                      ;(4-c1)

   [!A_pred]ADDSP .L1   A_sum2,     A_mac2,     A_sum2          ;[19,4] 
||      ADDSP   .L2     B_prod1,    B_prod2,    B_mac3          ;[15,5] 
||      MPYSP   .M2X    A_xc10,     B_y1,       B_prod1         ;[11,6] 
||      LDW     .D2T1   *+B_SP[13], ptr_r                       ; Restore B_r
||      MPYSP   .M1X    B_y0,       A_x0,       A_prod1         ;if c1 odd
||      SUB     .S1     A_c1,       A_kCnt,     A_kCnt          ;if c1 == 3 or 2

   [!A_pred]ADDSP .L2   B_sum3,     B_mac3,     B_sum3          ;[20,4] 
||      ADDSP   .L1     A_prod1,    A_prod2,    A_mac           ;[12,6] 
||      MPYSP   .M2X    A_x0,       B_y1,       B_prod1         ;if c1 odd
||      AND     .S1     A_0x80KK,   A_kCnt,     A_kCnt          ;if sign bit set

   [!A_kCnt]ADDSP .L1   A_sum,      A_mac,      A_sum           ;[17,5] 
||      ADDSP   .L2     B_prod1,    B_prod2,    B_mac1          ;[13,6] 
||      MPYSP   .M2X    A_xc10,     B_y1,       B_prod2         ;if c1 odd
||      MPYSP   .M1X    B_y0,       A_xc10,     A_prod2         ;if c1 odd

   [!A_kCnt]ADDSP .L2   B_sum1,     B_mac1,     B_sum1          ;[18,5] 
||      ADDSP   .L1     A_prod1,    A_prod2,    A_mac2          ;[14,6] 
||      MPY     .M1X    i,          B_c2,       A_index         ;i-th row (having c2 elements each)
||      MVKL    .S1     0x3F800000, A_0x1                       ;Constant 1.0

   [!A_kCnt]ADDSP .L1   A_sum2,     A_mac2,     A_sum2          ;[19,5] 
||      ADDSP   .L2     B_prod1,    B_prod2,    B_mac3          ;[15,6] 
||      MVKH    .S1     0x3F800000, A_0x1                       ;Constant 1.0

   [!A_kCnt]ADDSP .L2   B_sum3,     B_mac3,     B_sum3          ;[20,5] 
||      ADD     .S1X    A_index,    j,          A_index         ;i-th row, jth col
||      ADD     .S2     j,          2,          j               ;increment j for next jLoop
||      ADD     .D1     i,          1,          A_pred          ;find (i+1)

        ADDSP   .L1     A_sum,      A_mac,      A_sum           ;[17,6] 
||      SUB     .S2     j,          B_c2,       jCnt            ;if jLoop finished
||      SUB     .S1X    A_pred,     B_r1,       A_pred          ;(i+1)-(r1)

        ADDSP   .L2     B_sum1,     B_mac1,     B_sum1          ;[18,6]
||      AND     .S2X    A_0x80KK,   jCnt,       jCnt            ;if jLoop finished
||      AND     .S1     A_c1,       1,          A_kCnt          ;A_kCnt = is c1 odd

        ADDSP   .L1     A_sum2,     A_mac2,     A_sum2          ;[19,6] 
||      ADDAW   .D1     ptr_r,      A_index,    ptr_r           ;reach [i,j] element of output
||      MV      .S1X    B_c2,       A_c2_copy                   ;make a copy of c2 on A side
||      LDW     .D2T1   *+B_SP[14], A_x                         ; Restore A_x to use in jLoop

        ADDSP   .L2     B_sum3,     B_mac3,     B_sum3          ;[20,6] 
||      AND     .S1     A_0x80KK,   A_pred,     A_pred          ; if (i+1) < r1
  
* ========================================================================= *
* =========================== CODE IN jLoop =============================== *
  [A_kCnt] ADDSP .L1    A_sum,      A_prod1,    A_sum           ;if c1 odd
||[!A_kCnt]MPYSP .M1    A_sum,      A_0x1,      A_sum           ;if c1 not odd
||         ADD   .S2    B_c2,       1,          c2_p1           ;for (i+1)-th row in output
||         MV    .D1    A_0x80KK,   A_prod1                     ;Temporary Move
||[jCnt]   AND   .S1    A_c1,       1,          A_c1_odd
  
  [A_kCnt] ADDSP .L2    B_sum1,     B_prod1,    B_sum1          ;if c1 odd
||[!A_kCnt]MPYSP .M2X   B_sum1,     A_0x1,      B_sum1          ;if c1 not odd
||[jCnt]   MPY   .M1    i,          A_c1,       A_index
||[jCnt]   SUB   .S1    A_c1,       A_c1_odd,   A_kLoopCnt      ;round c1 to nearest lesser even no.
  
  [A_kCnt] ADDSP .L1    A_sum2,     A_prod2,    A_sum2          ;if c1 odd
||[!A_kCnt]MPYSP .M1    A_sum2,     A_0x1,      A_sum2          ;if c1 not odd
||         SUB   .S2    j,          c2_p1,      flag_b1         ;(j+2)-(c2+1)
||[jCnt]   B     .S1    ijkLoop                                   
  
  [A_kCnt] ADDSP .L2    B_sum3,     B_prod2,    B_sum3          ;if c1 odd
||[!A_kCnt]MPYSP .M2X   B_sum3,     A_0x1,      B_sum3          ;if c1 not odd
||[jCnt]   ADDAW .D1    A_x,        A_index,    A_ptr_x         ;ptr to i-th row of X matrix
||[jCnt]   SUB   .S1    A_kLoopCnt, 2,          A_kCnt          ;kLoop counter

           STW   .D1T1  A_sum,      *ptr_r                      ;store at r[i*c2+j]
||         AND   .S2X   A_prod1,    flag_b1,    flag_b1         ;A_prod1=0x80000000, if (j+1) < c2
||[jCnt]   ADD   .L1    A_c1,       A_index,    A_index
||[!jCnt]  ZERO  .S1    A_kCnt 
        
  [flag_b1]STW   .D1T2  B_sum1,     *ptr_r[1]                   ;store at r[i*c2+j+1], when c2 odd
||[jCnt]   ADDAW .D2    B_y,        j,          B_ptr_y         ;ptr to j-th col of Y matrix
||         MV    .S2X   ptr_r,      ptr_r_copy                  ;Temporary Move

  [A_pred] STW   .D1T1  A_sum2,     *ptr_r[A_c2_copy]           ;store at r[(i+1)*c2+j], when r1 odd
||         AND   .S1X   A_pred,     flag_b1,    A_pred          ;
||[jCnt]   ZERO  .L1    A_sum                                   ;reset A_sum,A_sum2->mapped to same reg
||[jCnt]   ADD   .D2    B_ptr_y,    4,          B_ptr_w         ;ptr to (j+1)-th col of Y matrix 
||[A_kCnt] B     .S2    ijkLoop         
  
  [A_pred] STW   .D2T2  B_sum3,     *ptr_r_copy[c2_p1]          ;store at r[(i+1)*c2+j+1], when both c2,r1 odd
||[jCnt]   ZERO  .S2    B_sum1                                  ;reset B_sum1,B_sum3->mapped to same reg
||[jCnt]   CMPGT .L2X   A_kLoopCnt, 6,          B_flag          ;if kernel ran > 3 times
||[jCnt]   ADDAW .D1    A_x,        A_index,    A_ptr_z         ;ptr to (i+1)-th row of X matrix
||[jCnt]   MVK   .S1    4,          A_pred                      ;Prolog Collapse Predicate
||[jCnt]   SUB   .L1    A_kLoopCnt, 2,          A_kCnt          ;kLoop counter

* ========================================================================= *
* =========================== CODE IN iLoop =============================== *
         ADD    .S1     i,          2,          i               ;for next iLoop
        
         CMPLT  .L1     i,          B_r1,       iCnt            ;is iLoop finished
        
   [iCnt]B      .S1     ijkLoop
|| [iCnt]AND    .L1     A_c1,       1,          A_c1_odd
|| [iCnt]MPY    .M1     i,          A_c1,       A_index
   
         ZERO   .S2     j                                       ;reset j for next iLoop start
|| [iCnt]SUB    .S1     A_c1,       A_c1_odd,   A_kLoopCnt      ;round c1 to nearest lesser even no.
||       MV     .L2     B_y,        B_ptr_y
||       ADD    .D2     B_y,        4,          B_ptr_w         ;ptr to 2nd col of Y matrix 
        
   [iCnt]ZERO   .L1     A_sum                                   ;reset A_sum,A_sum2->mapped to same reg
|| [iCnt]ZERO   .D2     B_sum1                                  ;reset B_sum1,B_sum3->mapped to same reg        
|| [iCnt]SUB    .S1     A_kLoopCnt, 2,          A_kCnt          ;kLoop counter
|| [iCnt]CMPGT  .L2X    A_kLoopCnt, 6,          B_flag          ;if kernel ran > 3 times
|| [iCnt]ADDAW  .D1     A_x,        A_index,    A_ptr_x         ;ptr to i-th row of X matrix

   [iCnt]ADD    .D1     A_c1,       A_index,    A_index
||[!iCnt]ZERO    .S1    A_kCnt
   
   [iCnt]ADDAW  .D1     A_x,        A_index,    A_ptr_z         ;ptr to (i+1)-th row of X matrix
||[A_kCnt]B     .S1     ijkLoop

   [iCnt]MVK    .S1     4,          A_pred                      ;Prolog Collapse Predicate
|| [iCnt]SUB    .D1     A_kLoopCnt, 2,          A_kCnt          ;kLoop counter
        
* ========================================================================= *
        LDW     .D2T2   *+B_SP[12], B_ret                   ; Get rtn
||      ADD     .S1X    B_SP,       4,           A_SP       ; Twin Stack Ptr

        LDW     .D2T2   *+B_SP[10], B_csr                   ; Restore CSR
||      LDW     .D1T1   *+A_SP[10], A11                     ; Restore A11

        LDW     .D2T2   *+B_SP[8],  B10                     ; Restore B10
||      LDW     .D1T1   *+A_SP[8],  A10                     ; Restore A10

        LDW     .D2T2   *+B_SP[6],  B11                     ; Restore B11
||      LDW     .D1T1   *+A_SP[6],  A13                     ; Restore A13

        LDW     .D2T2   *+B_SP[4],  B12                     ; Restore B12
||      LDW     .D1T1   *+A_SP[4],  A12                     ; Restore A12

        LDW     .D2T2   *+B_SP[2],  B13                     ; Restore B13
||      LDW     .D1T1   *+A_SP[2],  A14                     ; Restore A14
        
        LDW     .D2T2   *B_SP++[16], B14                    ; Restore B14
||      LDW     .D1T1   *A_SP,      A15                     ; Restore A15
||      MVC     .S2     B_csr,      CSR
        
        B       .S2     B_ret                               ; Return to caller
        NOP             5
* ======================================================================== *
*  End of file: DSPF_sp_mat_mul.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_mat_tra/1117057363  540   0     0       8591      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_trans -- Single Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        void DSPF_sp_mat_trans_cn(                                              * 
*                             const float *restrict x,                      * 
*                             int rows,                                     * 
*                             int cols,                                     * 
*                             float *restrict r)                            * 
*                                                                           * 
*           x[r1*c1]:  Input matrix containing r1*c1 floating point         * 
*                      numbers having r1 rows and c1 columns.               * 
*           rows    :  Number of rows in Matrix x.                          * 
*                      Also Number of columns in matrix y                   * 
*           cols    :  No. of columns in Matrx x.                           * 
*                      Also no. of rows in Matrix y.                        * 
*           y[c1*c2]:  Output matrix containing c1*r1 floating point        * 
*                      numbers having c1 rows and r1 columns.               * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*     This function transposes the input matrix x[] and writes the          * 
*     result to matrix r[].                                                 * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*     The loop is unrolled twice.                                           * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*     rows > 0 and cols > 0                                                 * 
*   C CODE                                                                  * 
*                                                                           * 
*        void DSPF_sp_mat_trans_cn(const float *restrict x, int rows,            * 
*                                            int cols, float *restrict r)   * 
*        {                                                                  * 
*           int i,j;                                                        * 
*                                                                           * 
*           for(i=0; i<cols; i++)                                           * 
*              for(j=0; j<rows; j++)                                        * 
*                 r[i * rows + j] = x[i + cols * j];                        * 
*        }                                                                  * 
*                                                                           * 
*        This is the C equivalent of the assembly code.  Note that          * 
*        the assembly code is hand optimized and restrictions may apply.    * 
*                                                                           * 
*   NOTES                                                                   * 
*                                                                           * 
*   CYCLES                                                                  * 
*       2*rows*cols+7                                                       * 
*       For rows=10 and cols=20, cycles=407                                 * 
*       For rows=15 and cols=20, cycles=607                                 * 
*                                                                           * 
*   CODESIZE                                                                * 
*       128 bytes                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



* ======================================================================== *
* ======================================================================== *

               .asg B4, B_rows
               .asg A6, A_cols 
               .asg A2, A_i   
               .asg A4, A_x   
               .asg A6, A_x_i 
               .asg A7, A_max 
               .asg B3, B_RET_ADDR
               .asg B0, B_j
               .asg B5, B_incr
               .asg A1, A_flag

        .text
        .global _DSPF_sp_mat_trans
_DSPF_sp_mat_trans:

* ======================================================================== *
* ======================================================================== *
  
           MPY   .M1X  B_rows,    A_cols,  A_i    ; i=rows*cols
                
           NOP
                
      [A_i]LDW   .D1T1 *A_x++,    A_x_i           ; load x_i
||    [A_i]SUB   .L1   A_i,       1,       A_i    ; i = i - 1 
||         SUB   .S1X  A_i,       B_rows,  A_max  ; max=(cols-1)*rows               
                
      [A_i]B     .S1   LOOP                       ; Branch to Loop                
||   [!A_i]B     .S2   B_RET_ADDR                 ; Branch out of the function            
                
      [A_i]LDW   .D1T1 *A_x++,    A_x_i           ; load x_i
||    [A_i]SUB   .S1   A_i,       1,       A_i    ; i = i - 1 
||         ZERO  .S2   B_j                        ; j=0
||         ZERO  .L2   B_incr                     ; incr=0               
                
      [A_i]B     .S1   LOOP                       ; Branch to Loop                
||   [!A_i]B     .S2   B_RET_ADDR                 ; Branch out of the function            
                
      [A_i]LDW   .D1T1 *A_x++,             A_x_i  ; load x_i
||    [A_i]SUB   .L1   A_i,       1,       A_i    ; i = i - 1                 
                
LOOP:                
                
           STW   .D2T1 A_x_i,     *B6[B_j]        ; Store x_i
||         CMPLT .L1X  B_j,       A_max,   A_flag ; flag = (j < max)
||    [A_i]B     .S1   LOOP                       ; Branch to Loop
||   [!A_i]B     .S2   B_RET_ADDR                 ; Branch out of the function

      [A_i]LDW   .D1T1 *A_x++,    A_x_i           ; load x_i
||[!A_flag]ADD   .L2   B_incr,    1,       B_incr ; incr = incr + 1
||[!A_flag]ADD   .S2   B_incr,    1,       B_j    ; j = incr
||[A_flag] ADD   .D2   B_j,       B_rows,  B_j    ; j = j +rows                 
||    [A_i]SUB   .S1   A_i,       1,       A_i    ; i = i - 1 
; -----------------------------------
                
                .end

* ======================================================================== *
*  End of file: DSPF_sp_mat_trans.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_mat_mul/1117057364  563   0     0       25683     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul_cplx -- complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        void DSPF_sp_mat_mul_cplx(                                              * 
*                               const float* x,                             * 
*                               int r1,                                     * 
*                               int c1,                                     * 
*                               const float* y,                             * 
*                               int c2,                                     * 
*                               float* restrict r                           * 
*                            )                                              * 
*                                                                           * 
*             x[2*r1*c1]:   Input matrix containing r1*c1 complex           * 
*                           floating point numbers having r1 rows and c1    * 
*                           columns of complex numbers.                     * 
*             r1        :   Number of rows in Matrix x.                     * 
*             c1        :   No. of columns in Matrx x.                      * 
*                           Also no. of rows in Matrix y.                   * 
*             y[2*c1*c2]:   Input matrix containing c1*c2 complex           * 
*                           floating point numbers having c1 rows and c2    * 
*                           columns of complex numbers.                     * 
*             c2        :   No. of columns in Matrix y.                     * 
*             r[2*r1*c2]:   Output matrix of c1*c2 complex floating         * 
*                           point numbers having c1 rows and c2 columns of  * 
*                           complex numbers.                                * 
*                                                                           * 
*                           Complex numbers are stored consecutively with   * 
*                           Real values are stored in even word positions   * 
*                           and imaginary values in odd positions.          * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*         This function computes the expression "r = x * y" for the         * 
*         matrices x and y. The columnar dimension of x must match the row  * 
*         dimension of y. The resulting matrix has the same number of rows  * 
*         as x and the same number of columns as y.                         * 
*                                                                           * 
*         Each element of Matrices are assumed to be complex numbers with   * 
*         Real values are stored in even word positions and imaginary       * 
*         values in odd positions.                                          * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*         Innermost loop is Unrolled twice.                                 * 
*         Two inner loops are collapsed into one loop.                      * 
*         Outermost loop is executed in parallel with innner loops.         * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*         c1 >= 4, and r1,r2>=1                                             * 
*         x should be padded with 6 words                                   * 
*         x and y should be double word aligned                             * 
*   C CODE                                                                  * 
*         void DSPF_sp_mat_mul_cplx_cn(const float* x, int r1, int c1,           * 
*                              const float* y, int c2, float* restrict r)   * 
*         {                                                                 * 
*             float real, imag;                                             * 
*             int i, j, k;                                                  * 
*                                                                           * 
*             for(i = 0; i < r1; i++)                                       * 
*             {                                                             * 
*               for(j = 0; j < c2; j++)                                     * 
*               {                                                           * 
*                 real=0;                                                   * 
*                 imag=0;                                                   * 
*                                                                           * 
*                 for(k = 0; k < c1; k++)                                   * 
*                 {                                                         * 
*                 real += (x[i * 2 * c1 + 2 * k] * y[k * 2 * c2 + 2 * j]    * 
*                 -x[i * 2 * c1 + 2 * k + 1] * y[k * 2 * c2 + 2 * j + 1]);  * 
*                                                                           * 
*                 imag+=(x[i * 2 * c1 + 2 * k] * y[k * 2 * c2 + 2 * j + 1]  * 
*                    + x[i * 2 * c1 + 2 * k + 1] * y[k * 2 * c2 + 2 * j]);  * 
*                 }                                                         * 
*                 r[i * 2 * c2 + 2 * j] = real;                             * 
*                 r[i * 2 * c2 + 2 * j + 1] = imag;                         * 
*               }                                                           * 
*             }                                                             * 
*         }                                                                 * 
*                                                                           * 
*   NOTES                                                                   * 
*         Real values are stored in even word positions and imaginary       * 
*         values in odd positions.                                          * 
*                                                                           * 
*   CYCLES                                                                  * 
*         2*r1*c1*c2' + 33 WHERE c2'=2*ceil(c2/2)                           * 
*         When r1=3, c1=4, c2=4, cycles = 129                               * 
*         When r1=4, c1=4, c2=5, cycles = 225                               * 
*                                                                           * 
*   CODESIZE                                                                * 
*         800 bytes                                                         * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
*


* ======================================================================== *
* ======================================================================== *
                .asg  B15, B_SP
                .asg  B3,  B_RET_ADDR
                .asg  B2,  B_CSR
                .asg  A0,  A_CSR
                .asg  B1,  B_CSR_gie
                .asg  A7,  A_SP
                .asg  A4,  A_x
                .asg  A5,  A_x_ptr
                .asg  B6,  B_y
                .asg  B5,  B_y_ptr
                .asg  A6,  A_c1
                .asg  A8,  A_c2
                .asg  B9,  B_c2
                .asg  B4,  B_8c2
                .asg  B4,  B_r1
                .asg  B0,  B_k
                .asg  B8,  B_r
                .asg  A9,  A_r
                .asg  A11, A_y1
                .asg  A11, A_y3
                .asg  A10, A_y0
                .asg  A10, A_y2
                .asg  B11, B_x1
                .asg  B10, B_x0
                .asg  A12, A_p00
                .asg  A12, A_p02
                .asg  B12, B_p01
                .asg  B12, B_p03
                .asg  A13, A_p11
                .asg  A13, A_p13
                .asg  B13, B_p10
                .asg  B13, B_p12
                .asg  A14, A_s0011
                .asg  A14, A_s0213
                .asg  B14, B_s0110
                .asg  B14, B_s0312
                .asg  A13, A_real1
                .asg  A13, A_real2
                .asg  B13, B_imag1
                .asg  B13, B_imag2
                .asg  A8,  A_zero
                .asg  B3,  B_zero
                .asg  B1,  B_i
                .asg  A1,  A_j
                .asg  A2,  A_row_fg
                .asg  B2,  B_mul_fg
                .asg  B7,  B_multiple
                .asg  A1,  A_temp
                .asg  B15, B_mult
                

        .text
        .global _DSPF_sp_mat_mul_cplx
_DSPF_sp_mat_mul_cplx:

* ======================================================================== *
* ======================================================================== *

             SUBAW .D2   B_SP,       13,        B_SP      ; Save stack space
||           MV    .L1X  B_SP,       A_SP                 ; Copy stack pointer
||           SUB   .L2X  A_c2,       1,         B_c2      ; Index for y
||           AND   .S1   A_c2,       1,         A_temp    ; Checking multiple of 2
||           MVC   .S2   CSR,        B_CSR                ; Get CSR
||           MV    .D1   A_x,        A_x_ptr              ; x_ptr = x
                
             STW   .D2T1 A_y0,       *B_SP[1]             ; Save A_y0
||           STW   .D1T2 B_x0,       *-A_SP[6]            ; Save B_x0
||           MV    .L1X  B_SP,       A_SP                 ; Copy stack pointer 
||           AND   .L2   B_CSR,      -2,        B_CSR_gie ; Disable gie bit
||   [A_temp]ADD   .S1   A_c2,       1,         A_c2      ; Make c2 multiple of 2
||   [A_temp]MVK   .S2   16,         B_multiple           ; Set flag for multiple of 2
                
             STW   .D2T1 A_y1,       *B_SP[2]             ; Save A_y1
||           STW   .D1T2 B_x1,       *A_SP[8]             ; Save B_x1
||           MPY   .M2X  B_r1,       A_c2,      B_i       ; i = r1 * c2
||           MV    .L2   B_y,        B_y_ptr              ; y_ptr=y
||           MVC   .S2   B_CSR_gie,  CSR                  ; Disable Interrupts
||           MV    .L1X  B_CSR,      A_CSR                ; Save CSR

; -------------------------------------------------                
             LDDW  .D1T2 *A_x_ptr++, B_x1:B_x0            ; load x1:x0
||           LDDW  .D2T1 *B_y_ptr++, A_y1:A_y0            ; load y1:y0

             STW   .D2T1 A_p00,      *B_SP[3]             ; Save A_p00
||           STW   .D1T2 B_p01,      *A_SP[9]             ; Save B_p01
||           MPY   .M2   A_c2,       8,         B_8c2     ; 8c2 = 8*C2
||  [!A_temp]MVK   .S2   0,          B_multiple           ; flag for multiple of 2
                
             LDDW  .D2T1 *B_y_ptr++[B_c2], A_y3:A_y2      ; load y3:y2

; -------------------------------------------------                
             STW   .D2T1 A_p11,      *B_SP[4]             ; Save A_p11
||           STW   .D1T2 B_p10,      *A_SP[10]            ; Save B_p10
||           SHR   .S2   B_i,        1, B_i               ; i = r1 * c2/2
||           ADD   .S1   A_c1,       0, A_j               ; j = c1
||           ADD   .L1X  B_r,        4, A_r               ; r1 = r + 4
                
             LDDW  .D1T2 *A_x_ptr++, B_x1:B_x0            ; load x1:x0
||           LDDW  .D2T1 *B_y_ptr++, A_y1:A_y0            ; load y1:y0
                
             MPYSP .M1X  B_x0,       A_y0,      A_p00     ; p00 = x[0] * y[0]                                                                                                                                                                                                                                       
||           MPYSP .M2X  B_x0,       A_y1,      B_p01     ; p01 = x[0] * y[1]
||           STW   .D2T1 A_s0011,    *B_SP[5]             ; Save A_s0011
||           STW   .D1T2 B_s0110,    *A_SP[11]            ; Save B_s0110
||           MV    .L2   B_8c2,      B_k                  ; K=8*C2
||           ADD   .S2   B_y,        B_8c2,     B_y       ; Y=Y+2*C2

             MPYSP .M1X  B_x1,       A_y1,      A_p11     ; p11 = x[1] * y[1]
||           MPYSP .M2X  B_x1,       A_y0,      B_p10     ; p10 = x[1] * y[0]
||           LDDW  .D2T1 *B_y_ptr++[B_c2], A_y3:A_y2      ; load y3:y2
; -------------------------------------------------

             MPYSP .M1X  B_x0,       A_y2,      A_p02     ; p02 = x[0] * y[2]
||           MPYSP .M2X  B_x0,       A_y3,      B_p03     ; p03 = x[0] * y[3]
||           STW   .D1T2 B_RET_ADDR, *A_SP[12]            ; Save Return address
||           ZERO  .S2   B_zero                           ; Set ZERO
||           ZERO  .S1   A_zero                           ; Set ZERO
||           MV    .L2   B_8c2,      B_mult               ; To avoid store, not mult of 2

             MPYSP .M1X  B_x1,       A_y3,      A_p13     ; p13 = x[1] * y[3]
||           MPYSP .M2X  B_x1,       A_y2,      B_p12     ; p12 = x[1] * y[2]
||           LDDW  .D1T2 *A_x_ptr++, B_x1:B_x0            ; load x1:x0
||           LDDW  .D2T1 *B_y_ptr++, A_y1:A_y0            ; load y1:y0

             MPYSP .M1X  B_x0,       A_y0,      A_p00     ; p00 = x[0] * y[0]                                                                                                                                                                                                                                        
||           MPYSP .M2X  B_x0,       A_y1,      B_p01     ; p01 = x[0] * y[1]
                
             MPYSP .M1X  B_x1,       A_y1,      A_p11     ; p11 = x[1] * y[1]
||           MPYSP .M2X  B_x1,       A_y0,      B_p10     ; p10 = x[1] * y[0]
||           SUBSP .L1   A_p00,      A_p11,     A_s0011   ; s0011 = p00 - p11
||           ADDSP .L2   B_p01,      B_p10,     B_s0110   ; s0110 = p01 + p10
||           LDDW  .D2T1 *B_y_ptr++[B_c2], A_y3:A_y2      ; load y3:y2
||      [B_i]SUB   .D1   A_j,        1, A_j               ; SUB J,1,J

; ------------------------------------------------
             MPYSP .M1X  B_x0,       A_y2,      A_p02     ; p02 = x[0] * y[2]
||           MPYSP .M2X  B_x0,       A_y3,      B_p03     ; p03 = x[0] * y[3]
||           ADDSP .L1   A_zero,     A_zero,    A_real1   ; real1 = 0
||           ADDSP .L2   B_zero,     B_zero,    B_imag1   ; imag1 = 0

             MPYSP .M1X  B_x1,       A_y3,      A_p13     ; p13 = x[1] * y[3]
||           MPYSP .M2X  B_x1,       A_y2,      B_p12     ; p12 = x[1] * y[2]
||           SUBSP .L1   A_p02,      A_p13,     A_s0213   ; s0213 = p02 - p13
||           ADDSP .L2   B_p03,      B_p12,     B_s0312   ; s0312 = p03 + p12
||           LDDW  .D1T2 *A_x_ptr++, B_x1:B_x0            ; load x1:x0
||           LDDW  .D2T1 *B_y_ptr++, A_y1:A_y0            ; load y1:y0
||           SUB   .S1   A_j,        3,         A_row_fg  ; Flag for going to next row

             MPYSP .M1X  B_x0,       A_y0,      A_p00     ; p00 = x[0] * y[0]                                                                                                                                                                                                                                        
||           MPYSP .M2X  B_x0,       A_y1,      B_p01     ; p01 = x[0] * y[1]
||      [A_j]B     .S1   LOOP                             ; Branch to loop
||[!A_row_fg]ADD   .D2   B_k,        -16,       B_k       ; k = k -16
||           ADDSP .L1   A_zero,     A_zero,    A_real2   ; real2 = 0
||           ADDSP .L2   B_zero,     B_zero,    B_imag2   ; imag2 = 0
                
             MPYSP .M1X  B_x1,       A_y1,      A_p11     ; p11 = x[1] * y[1]
||           MPYSP .M2X  B_x1,       A_y0,      B_p10     ; p10 = x[1] * y[0]
||           SUBSP .L1   A_p00,      A_p11,     A_s0011   ; s0011 = p00 - p11
||           ADDSP .L2   B_p01,      B_p10,     B_s0110   ; s0110 = p01 + p10
||     [!A_j]ADD   .S1   A_c1,       0,         A_j       ; j = c1
||     [!B_k]MV    .S2   B_8c2,      B_k                  ; k = 8 *c2
||     [!B_k]ADDAD .D1   A_x,        A_c1,      A_x       ; x= x + 2*c1
||           LDDW  .D2T1 *B_y_ptr++[B_c2], A_y3:A_y2      ; load y3:y2

; ---------------------------- KERNEL -------------------------------
LOOP:

             MPYSP .M1X  B_x0,       A_y2,      A_p02     ; p02 = x[0] * y[2]
||           MPYSP .M2X  B_x0,       A_y3,      B_p03     ; p03 = x[0] * y[3]
||           ADDSP .L1   A_real1,    A_s0011,   A_real1   ; real1 = real1 + s0011
||           ADDSP .L2   B_imag1,    B_s0110,   B_imag1   ; imag1 = imag1 + s0110
||      [B_i]SUB   .D1   A_j,        1,         A_j       ; j = j - 1
||[!A_row_fg]MV    .S1   A_x,        A_x_ptr              ; x_ptr = x
||[!A_row_fg]SUB   .S2   B_y,        B_k,       B_y_ptr   ; y_ptr = y - k(8*c2)
||           MV    .D2   B_mult,     B_mul_fg             ; To avoid store, not mult of 2 

             MPYSP .M1X  B_x1,       A_y3,      A_p13     ; p13 = x[1] * y[3]
||           MPYSP .M2X  B_x1,       A_y2,      B_p12     ; p12 = x[1] * y[2]
||      [B_i]LDDW  .D1T2 *A_x_ptr++, B_x1:B_x0            ; load x1:x0
||           LDDW  .D2T1 *B_y_ptr++, A_y1:A_y0            ; load y1:y0
||           SUBSP .L1   A_p02,      A_p13,     A_s0213   ; s0213 = p02 - p13
||           ADDSP .L2   B_p03,      B_p12,     B_s0312   ; s0312 = p03 + p12
||           SUB   .S1   A_j,        3,         A_row_fg  ; Flag for going to next row
||     [!A_j]SUB   .S2   B_i,        1,         B_i       ; i = i - 1

             MPYSP .M1X  B_x0,       A_y0,      A_p00     ; p00 = x[0] * y[0]                                                                                                                                                                                                                                        
||           MPYSP .M2X  B_x0,       A_y1,      B_p01     ; p01 = x[0] * y[1]
||           ADDSP .L1   A_real2,    A_s0213,   A_real2   ; real2 = real2 + s0213
||           ADDSP .L2   B_imag2,    B_s0312,   B_imag2   ; imag2 = imag2 + s0312
||     [!B_i]ZERO  .D1   A_c1                             ; To stop jumping at the end
||      [A_j]B     .S1   LOOP                             ; Branch to loop
||[!A_row_fg]ADD   .S2   B_k,        -16,       B_k       ; k = k - 16
||     [!A_j]SUB   .D2   B_mult,     B_multiple,B_mult    ; To avoid store, not mult of 2
                
             MPYSP .M1X  B_x1,       A_y1,      A_p11     ; p11 = x[1] * y[1]
||           MPYSP .M2X  B_x1,       A_y0,      B_p10     ; p10 = x[1] * y[0]
||           SUBSP .L1   A_p00,      A_p11,     A_s0011   ; s0011 = p00 - p11
||           ADDSP .L2   B_p01,      B_p10,     B_s0110   ; s0110 = p01 + p10
||     [!A_j]ADD   .S1   A_c1,       0,         A_j       ; j = c1
||     [!B_k]MV    .S2   B_8c2,      B_k                  ; k = 8*c2
||     [!B_k]ADDAD .D1   A_x,        A_c1,      A_x       ; x = x + 2*c1
||           LDDW  .D2T1 *B_y_ptr++[B_c2], A_y3:A_y2      ; load y3:y2

; --------------------------------------------------------------------
 
             MPYSP .M1X  B_x0,       A_y2,      A_p02     ; p02 = x[0] * y[2]
||           MPYSP .M2X  B_x0,       A_y3,      B_p03     ; p03 = x[0] * y[3]
||           ADDSP .L1   A_zero,     A_s0011,   A_real1   ; real1 = s0011
||           ADDSP .L2   B_zero,     B_s0110,   B_imag1   ; imag1 = s0110
||           STW   .D2T1 A_real1,    *B_r++[2]            ; store real1
||           STW   .D1T2 B_imag1,    *A_r++[2]            ; store imag1
||[!A_row_fg]MV    .S1   A_x,        A_x_ptr              ; x_ptr = x
||[!A_row_fg]SUB   .S2   B_y,        B_k,       B_y_ptr   ; y_ptr = y - k(8*c2)

             MPYSP .M1X  B_x1,       A_y3,      A_p13     ; p13 = x[1] * y[3]
||           MPYSP .M2X  B_x1,       A_y2,      B_p12     ; p12 = x[1] * y[2]
||      [A_j]LDDW  .D1T2 *A_x_ptr++, B_x1:B_x0            ; load x1:x0
||      [A_j]LDDW  .D2T1 *B_y_ptr++, A_y1:A_y0            ; load y1:y0
||           SUBSP .L1   A_p02,      A_p13,     A_s0213   ; s0213 = p02 - p13
||           ADDSP .L2   B_p03,      B_p12,     B_s0312   ; s0312 = p03 + p12
||           SUB   .S1   A_j,        4, A_row_fg          ; Flag for going to next row
||[!B_mul_fg]MV    .S2   B_8c2,      B_mult               ; To avoid store, not mult of 2

             MPYSP .M1X  B_x0,       A_y0,      A_p00     ; p00 = x[0] * y[0]                                                                                                                                                                                                                                        
||           MPYSP .M2X  B_x0,       A_y1,      B_p01     ; p01 = x[0] * y[1]
||           ADDSP .L1   A_zero,     A_s0213,   A_real2   ; real2 = s0213
||           ADDSP .L2   B_zero,     B_s0312,   B_imag2   ; imag2 = s0312
|| [B_mul_fg]STW   .D2T1 A_real2,    *B_r++[2]            ; store real2
|| [B_mul_fg]STW   .D1T2 B_imag2,    *A_r++[2]            ; store imag2
||      [A_j]B     .S1   LOOP                             ; Branch to loop
||[!A_row_fg]ADD   .S2   B_k,        -16,       B_k       ; k = k - 16
                
             MPYSP .M1X  B_x1,       A_y1,      A_p11     ; p11 = x[1] * y[1]
||           MPYSP .M2X  B_x1,       A_y0,      B_p10     ; p10 = x[1] * y[0]
||           SUBSP .L1   A_p00,      A_p11,     A_s0011   ; s0011 = p00 - p11
||           ADDSP .L2   B_p01,      B_p10,     B_s0110   ; s0110 = p01 + p10
||      [B_i]SUB   .S1   A_j,        1, A_j               ; j = c1
||     [!B_k]MV    .S2   B_8c2,      B_k                  ; k = 8*c2
||     [!B_k]ADDAD .D1   A_x,        A_c1,      A_x       ; x = x + 2*c1
||      [A_j]LDDW  .D2T1 *B_y_ptr++[B_c2], A_y3:A_y2      ; load y3:y2

; ------------------------------------------------------------------- 
             MV    .S2X  A_SP,       B_SP                 ; Copy stack pointer
||           LDW   .D1T2 *A_SP[12],  B_RET_ADDR           ; load return address

             LDW   .D1T1 *A_SP[1],   A_y0                 ; restore A_y0
||           LDW   .D2T2 *B_SP[7],   B_x0                 ; restore B_x0
||           MVC   .S2X  A_CSR, CSR                       ; Enable Interrupt
                
             LDW   .D1T1 *A_SP[2],   A_y1                 ; restore A_y1
||           LDW   .D2T2 *B_SP[8],   B_x1                 ; restore B_x1
                
             LDW   .D1T1 *A_SP[3],   A_p00                ; restore A_p00
||           LDW   .D2T2 *B_SP[9],   B_p01                ; restore B_p01
   
             LDW   .D1T1 *A_SP[4],   A_p11                ; restore A_p11
||           LDW   .D2T2 *B_SP[10],  B_p10                ; restore B_p10
                
             LDW   .D1T1 *A_SP[5],   A_s0011              ; restore A_s0011
||           LDW   .D2T2 *B_SP[11],  B_s0110              ; restore B_s0110                  
||           B     .S2   B_RET_ADDR                       ; Return from function
                
             ADDAW .D2   B_SP,       13,        B_SP      ; Restore stack space

             NOP         4
            .end

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul_cplx.asm                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_blk_mov/1117057365  589   0     0       9498      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_blk_move -- Single Precision Block Move                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_sp_blk_move                                                   *
*                      (                                                    *
*                          const float    *r,                               *
*                          const float *  restrict r,                       *
*                          int            nx,                               *
*                      )                                                    *
*                                                                           *
*        x[nx]:   Pointer to source data to be moved.                       *
*        r[nx]:   Pointer to destination array.                             *
*        nx:        Number of floats to move.                               *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*        This routine moves nx floats from memory location pointed to by x  *
*        to a separate memory location pointed to by r.                     *
*                                                                           *
*                                                                           *
*  TECHNIQUES                                                               *
*       1. The loop is unrolled twice.                                      *
*       2. Cache touching is used to remove the write buffer full problem.  *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*       1. nx is greater than 0.                                            *
*       2. If nx is odd, then x and r should be padded with 1 extra word.   *
*       3. x and r are double word aligned.                                 *
*                                                                           *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       This is the C equivalent of the assembly code. Note that the        *
*       assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*       void DSPF_sp_blk_move(const float * x, float * restrict r, int nx)       *
*       {                                                                   *
*           int i;                                                          *
*           for (i=0;i<nx;i++)                                              *
*           {                                                               *
*               r[i] = x[i];                                                *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*       1. This implementation is little-endian.                            *
*       2. This routine is interrupt-tolerant but not interruptible.        *
*                                                                           *
*                                                                           *
*  CYCLES                                                                   *
*       2*ceil(nx/2)+7                                                      *
*       For nx=64, cycles=71.                                               *
*       For nx=25, cycles=33.                                               *
*                                                                           *
*                                                                           *
*  CODESIZE                                                                 *
*          128 bytes                                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *
        .asg         A6,   A_nx
        .asg         A1,   A_i
        .asg         A2,   A_b
        .asg         B1,   B_mlt
        .asg         A8,   A_temp
        .asg         B4,   B_r
        .asg         A5,   A_r
        .asg         A4,   A_x
        .asg         A9,   A_x1
        .asg         A8,   A_x0
        .asg         B9,   B_x1
        .asg         B7,   B_r1
        .asg         B6,   B_r0
        .asg         B3,   B_RET_ADDR

        .text
        .global _DSPF_sp_blk_move
_DSPF_sp_blk_move:

* ======================================================================== *
* ======================================================================== *

         AND  .S1   A_nx,     0x00000001, A_temp ; Find remainder of Div. by 2
||       AND  .S2X  A_nx,     0x00000001, B_mlt  ; Find remainder of Div. by 2

         ADD  .S1X  B_r,      8,          A_r    ; Set A side r pointer
||       LDDW .D2T2 *B_r,     B_r1:B_r0          ; Dummy Loads To remove Write Buffer Full
||       ADD  .D1   A_nx,     A_temp,     A_i    ; i = 2*ceil(nx/2)

         LDDW .D1T1 *A_x++,   A_x1:A_x0          ; Load x1:x0
||       SUB  .S1   A_i,      2,          A_i    ; i = i - 2
||       SUB  .L2X  A_nx,     B_mlt,      B_mlt  ; i = 2*floor(nx/2)
||       SUB  .L1   A_i,      2,          A_b    ; b = i - 2 - return branch

    [A_i]B    .S1   LOOP                         ; Branch to Loop
||  [A_i]LDDW .D1T2 *A_r++,   B_r1:B_r0          ; Dummy Loads To remove Write Buffer Full
|| [!A_b]B    .S2   B_RET_ADDR                   ; Return from function

    [A_i]LDDW .D1T1 *A_x++,   A_x1:A_x0          ; Load x1:x0
||  [A_i]SUB  .S1   A_i,      2,          A_i    ; i = i - 2
||       SUB  .L1   A_b,      2,          A_b    ; b = b - 2 unconditionally

    [A_i]B    .S1   LOOP                         ; Branch to Loop
||  [A_i]LDDW .D1T2 *A_r++,   B_r1:B_r0          ; Dummy Loads To remove Write Buffer Full
|| [!A_b]B    .S2   B_RET_ADDR                   ; Return from function

    [A_i]LDDW .D1T1 *A_x++,   A_x1:A_x0          ; Load x1:x0
||  [A_i]SUB  .S1   A_i,      2,          A_i    ; i = i - 2
||       SUB  .L1   A_b,      2,          A_b    ; b = b - 2 unconditionally

LOOP:
         STW  .D2T1 A_x0,     *B_r++             ; Store x0
||  [A_i]LDDW .D1T2 *A_r++,   B_r1:B_r0          ; Dummy Loads To remove Write Buffer Full
||       MV   .L2X  A_x1,     B_x1               ; Move x1 to B side
||  [A_i]B    .S1   LOOP                         ; Branch to Loop
|| [!A_b]B    .S2   B_RET_ADDR                   ; Return from function

    [A_i]LDDW .D1T1 *A_x++,   A_x1:A_x0          ; Load x1:x0
||  [A_i]SUB  .S1   A_i,      2,          A_i    ; i = i - 2
||       SUB  .L1   A_b,      2,          A_b    ; b = b - 2 unconditionally
||[B_mlt]STW  .D2T2 B_x1,     *B_r++             ; Store x1
||       SUB  .S2   B_mlt,    2,          B_mlt  ; To avoid extra store
                                                 ; if not multiple of 2
         ; Branch to loop occurs here

                .end

* ======================================================================== *
*  End of file: DSPF_sp_blk_move.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_blk_eswap1/1117057366  611   0     0       14179     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_blk_eswap16                                                   *
*                      (                                                    *
*                          void * restrict x,                               *
*                          void * restrict r,                               *
*                          int             nx,                              *
*                      )                                                    *
*                                                                           *
*        x[nx]:   Pointer to source data.                                   *
*        r[nx]:   Pointer to destination array.                             *
*        nx:      Number of shorts (16-bit values) to endian-swap.          *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*          The date in the x array is endian swapped, meaning that the      *
*       byte-order of the bytest within wach half-word (short) of x is      *
*       reversed in the array r. This routine is used to facilitate moving  *
*       big-endian data to a little-endian system or vice-versa.            *
*                                                                           *
*       When the r pointer is non-NULL, the endian-swap occurs              *
*       out-of-place, similar to a block move. When the r pointer is NULL,  *
*       the endian-swap occurs in-place, allowing the swap to occure        *
*       without using any additional memory.                                *
*                                                                           *
*                                                                           *
*  TECHNIQUES                                                               *
*       1. The loop is unrolled eight times.                                *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*       1. nx is greater than 0 and a multiple of 8.                        *
*       2. If nx is padded with 2 words.                                    *
*       3. x and r are word aligned.                                        *
*       4. Input array x and output array r do not overlap, except in the   *
*       special case where r = NULL so that the operation occurs in-place.  *
*                                                                           *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       This is the C equivalent of the assembly code. Note that the        *
*       assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*       void DSPF_DSPF_blk_eswap16(void restrict x, void restrict r, int nx)     *
*       {                                                                   *
*           int i;                                                          *
*           char_src, _dst;                                                 *
*                                                                           *
*           if (r)                                                          *
*           {                                                               *
*               _src = (char)x;                                             *
*               _dst = (char)r;                                             *
*           }                                                               *
*           else                                                            *
*           {                                                               *
*               _src = (char)x;                                             *
*               _dst = (char)x;                                             *
*           }                                                               *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           {                                                               *
*               char t0, t1;                                                *
*               t0 = _src[i2 + 1];                                          *
*               t1 = _src[i2 + 0];                                          *
*               _dst[i2 + 0] = t0;                                          *
*               _dst[i2 + 1] = t1;                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*       1. This implementation is ENDIAN NEUTRAL.                           *
*       2. This routine is interrupt-tolerant but not interruptible.        *
*                                                                           *
*                                                                           *
*  CYCLES                                                                   *
*       0.625*nx + 12                                                       *
*       For nx=64, cycles=52.                                               *
*       For nx=25, cycles=32.                                               *
*                                                                           *
*                                                                           *
*  CODESIZE                                                                 *
*          256 bytes                                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *
        .asg            A1,         A_i
        .asg            A4,         A_x
        .asg            A5,         A_r
        .asg            A6,         A_nx
        .asg            A6,         A0_b
        .asg            A6,         A0_d
        .asg            A6,         A0_f
        .asg            A6,         A1_d
        .asg            A6,         A1_f
        .asg            A7,         A0_c
        .asg            A7,         A0_e
        .asg            A7,         A1_b
        .asg            A7,         A1_e
        .asg            A8,         A0_a
        .asg            A8,         A1_a
        .asg            A8,         A1_c
        .asg            B0,         B_r1
        .asg            B0,         B_pred
        .asg            B2,         B0_d
        .asg            B3,         B_ret_addr
        .asg            B4,         B_r
        .asg            B5,         B0_a
        .asg            B5,         B0_c
        .asg            B5,         B0_e
        .asg            B5,         B1_d
        .asg            B6,         B_x
        .asg            B7,         B0_b
        .asg            B7,         B0_f
        .asg            B7,         B1_a
        .asg            B7,         B1_c
        .asg            B8,         B1_b
        .asg            B8,         B1_e
        .asg            B8,         B1_f
        .asg            B9,         B_msk

        .text
        .global _DSPF_blk_eswap16
_DSPF_blk_eswap16:

* ======================================================================== *
* ======================================================================== *
* =========================================================================*
* =========================== PIPE LOOP PROLOG ============================*
           B    .S2   loop                        ; Block Interrupts
||         SHR  .S1   A_nx,       3,        A_i      ; i = nx/8
||         ADD  .L2X  A_x,        4,        B_x    ; Move x to B-side
||         MV   .D2   B_r,        B_r1             ; Copy r pointer

           LDW  .D2T1 *B_x[2],    A0_a             ; Load A-side a
||         LDW  .D1T2 *A_x[2],    B0_a             ; Load B-side a
||  [!B_r1]MV   .L2X  A_x,        B_r              ; if(!r) r = x
||         MVKL .S2   0xFF00FF00, B_msk            ; Mask = 0xFF00FF00
;-
           ADD  .L1X  B_r,        4,        A_r    ; Copy r pointer to A-side
||         MVKH .S2   0xFF00FF00, B_msk            ; Mask = 0xFF00FF00

           LDW  .D2T1 *B_x++[4],  A1_a             ; Load A-side a
||         LDW  .D1T2 *A_x++[4],  B1_a             ; Load B-side a

           SUB  .L1   A_i,        1,        A_i    ; i = i - 1

      [A_i]B    .S1   loop                         ; Branch to Loop
||         MVK  .S2   1,          B_pred           ; prolog collapse

* =========================================================================*
; =========================== 1 prolog stage collapsed ====================*
* =========================== PIPE LOOP KERNEL ============================*

loop:
           ADD  .L1   A1_d,       A1_e,     A1_f   ; f = d | e
||         SHL  .S1   A0_a,       8,        A0_c   ; c =  a << 8
||         SHL  .S2   B0_a,       8,        B0_c   ; c =  a << 8
||         AND  .L2   B0_a,       B_msk,    B0_b   ; b =  a & 0xFF00FF00
||    [A_i]LDW  .D2T1 *B_x[2],    A0_a             ; Load A-side a
||    [A_i]LDW  .D1T2 *A_x[2],    B0_a             ; Load B-side a

  [!B_pred]STW  .D1T1 A1_f,       *A_r++[4]        ; Store A-side f
||[!B_pred]STW  .D2T2 B1_f,       *B_r++[4]        ; Store B-side f
||    [A_i]SUB  .S1   A_i,        1,        A_i    ; i = i - 1
||         AND  .L1X  A0_a,       B_msk,    A0_b   ; b =  a & 0xFF00FF00
||         AND  .L2   B0_c,       B_msk,    B0_e   ; e = (a << 8)&0xFF00FF00
||         SHRU .S2   B0_b,       8,        B0_d   ; d = (a & 0xFF00FF00)>>8

           SHL  .S2   B1_a,       8,        B1_c   ; c =  a << 8
||         AND  .L2   B1_a,       B_msk,    B1_b   ; b =  a & 0xFF00FF00
||         AND  .L1X  A0_c,       B_msk,    A0_e   ; e = (a << 8)&0xFF00FF00
||         SHRU .S1   A0_b,       8,        A0_d   ; d = (a & 0xFF00FF00)>>8
||         LDW  .D2T1 *B_x++[4],  A1_a             ; Load A-side a
||         LDW  .D1T2 *A_x++[4],  B1_a             ; Load B-side a

           SHL  .S1   A1_a,       8,        A1_c   ; c =  a << 8
||         AND  .L1X  A1_a,       B_msk,    A1_b   ; b =  a & 0xFF00FF00
||         AND  .L2   B1_c,       B_msk,    B1_e   ; e = (a << 8)&0xFF00FF00
||         SHRU .S2   B1_b,       8,        B1_d   ; d = (a & 0xFF00FF00)>>8
||         ADD  .D1   A0_d,       A0_e,     A0_f   ; f = d | e
||         ADD  .D2   B0_d,       B0_e,     B0_f   ; f = d | e

     [ A_i]B    .S2   loop                         ; Branch to Loop
||         AND  .L1X  A1_c,       B_msk,    A1_e   ; e = (a << 8)&0xFF00FF00
||         SHRU .S1   A1_b,       8,        A1_d   ; d = (a & 0xFF00FF00)>>8
||         ADD  .L2   B1_d,       B1_e,     B1_f   ; f = d | e
||         STW  .D1T1 A0_f,       *A_r[2]          ; Store A-side f
||         STW  .D2T2 B0_f,       *B_r[2]          ; Store B-side f
||         MPY  .M2   B_pred,     0,        B_pred ; prolog collapse

* =========================== PIPE LOOP EPILOG ============================*
; ====================== 1 epilog stage collapsed =========================*

           ADD  .L1   A1_d,       A1_e,     A1_f   ; f = d | e
||         B    .S2   B_ret_addr                   ; return to caller

           STW  .D1T1 A1_f,       *A_r             ; Store A-side f
||         STW  .D2T2 B1_f,       *B_r             ; Store B-side f

           NOP        4

                .end

* ======================================================================== *
*  End of file: DSPF_blk_eswap16.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap3/1117057367  633   0     0       14323     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_blk_eswap32                                                   *
*                      (                                                    *
*                          float * restrict x,                              *
*                          float * restrict r,                              *
*                          int             nx,                              *
*                      )                                                    *
*                                                                           *
*        x[nx]:   Pointer to source data.                                   *
*        r[nx]:   Pointer to destination array.                             *
*        nx:      Number of words (32-bit values) to endian-swap.           *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*       The date in the x array is endian swapped, meaning that the         *
*       byte-order of the bytest within wach word of x is                   *
*       reversed in the array r. This routine is used to facilitate moving  *
*       big-endian data to a little-endian system or vice-versa.            *
*                                                                           *
*       When the r pointer is non-NULL, the endian-swap occurs              *
*       out-of-place, similar to a block move. When the r pointer is NULL,  *
*       the endian-swap occurs in-place, allowing the swap to occure        *
*       without using any additional memory.                                *
*                                                                           *
*                                                                           *
*  TECHNIQUES                                                               *
*       1. The loop is unrolled twice.                                      *
*       2. Multiply instructions are used for shifting left and right.      *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*       1. nx is greater than 0 and a multiple of 2.                        *
*       2. x and r are word aligned.                                        *
*       3. Input array x and output array r do not overlap, except in the   *
*          special case where r = NULL so that the operation occurs in-plac *
*                                                                           *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       This is the C equivalent of the assembly code. Note that the        *
*       assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*       void DSPF_blk_eswap16(void restrict x, void restrict r, int nx)     *
*       {                                                                   *
*           int i;                                                          *
*           char_src, _dst;                                                 *
*                                                                           *
*           if (r)                                                          *
*           {                                                               *
*               _src = (char)x;                                             *
*               _dst = (char)r;                                             *
*           }                                                               *
*           else                                                            *
*           {                                                               *
*               _src = (char)x;                                             *
*               _dst = (char)x;                                             *
*           }                                                               *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           {                                                               *
*               char t0, t1, t2, t3;                                        *
*                                                                           *
*               t0 = _src[i*4 + 3];                                         *
*               t1 = _src[i*4 + 2];                                         *
*               t2 = _src[i*4 + 1];                                         *
*               t3 = _src[i*4 + 0];                                         *
*                                                                           *
*               _dst[i*4 + 0] = t0;                                         *
*               _dst[i*4 + 1] = t1;                                         *
*               _dst[i*4 + 2] = t2;                                         *
*               _dst[i*4 + 3] = t3;                                         *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*       1. This implementation is ENDIAN NEUTRAL.                           *
*       2. This routine is interrupt-tolerant but not interruptible.        *
*                                                                           *
*                                                                           *
*  CYCLES                                                                   *
*       1.5*nx + 14                                                         *
*       For nx=64, cycles=110.                                              *
*       For nx=32, cycles=62.                                               *
*                                                                           *
*                                                                           *
*  CODESIZE                                                                 *
*          224 bytes                                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *
        .asg            A4,     A_x
        .asg            B5,     B_x
        .asg            B4,     B_r
        .asg            A5,     A_r
        .asg            A6,     A_nx
        .asg            A1,     A_cnt
        .asg            B0,     B_a
        .asg            A0,     A_a
        .asg            B9,     B_msk
        .asg            B0,     B_b
        .asg            B1,     B_pred
        .asg            B2,     B_c
        .asg            B2,     B_r1
        .asg            B0,     B_d
        .asg            B2,     B_e
        .asg            B7,     B_f
        .asg            A9,     A_k
        .asg            B8,     B_g
        .asg            B6,     B_h
        .asg            B6,     B_i
        .asg            A6,     A_b
        .asg            A0,     A_c
        .asg            A8,     A_d
        .asg            A2,     A_e
        .asg            A6,     A_f
        .asg            A7,     A_g
        .asg            A3,     A_h
        .asg            A7,     A_i
        .asg            B3,     B_ret_addr


        .text
        .global _DSPF_blk_eswap32
_DSPF_blk_eswap32:

* ======================================================================== *
* ======================================================================== *
* =========================== PIPE LOOP PROLOG =========================== *
           ADD   .L2X  A_x,        4,        B_x    ; Copy x Pointer to B-side
||         SHR   .S1   A_nx,       1,        A_cnt  ; cnt = nx/2

           LDW   .D1T2 *A_x++[2],  B_a              ; Load B-side a
||         LDW   .D2T1 *B_x++[2],  A_a              ; Load A-side a
||         MV    .L2   B_r,        B_r1             ; Copy r Pointer

           B     .S1   loop                         ; Branch to Loop
||         MVK   .S2   0x4000,     B_pred           ; prolog collapse
||  [!B_r1]SUB   .L2   B_x,        12,       B_r    ; if(!r) r = x
;-
           MVKL  .S2   0xFF00FF00, B_msk            ; Mask = 0xFF00FF00
||         MVKL  .S1   0x00018000, A_k              ; K for left shifting by 15
||  [A_cnt]SUB   .L1   A_cnt,      1,        A_cnt  ; cnt = cnt - 1

    [A_cnt]LDW   .D1T2 *A_x++[2],  B_a              ; Load B-side a
||  [A_cnt]LDW   .D2T1 *B_x++[2],  A_a              ; Load A-side a
||         MVKH  .S2   0xFF00FF00, B_msk            ; Mask = 0xFF00FF00
||         MVKH  .S1   0x00018000, A_k              ; K for left shifting by 15
||         ADD   .L1X  B_r,        4,        A_r    ; Copy to A-side r pointer
;-
; ====================== 3 prolog stages collapsed ========================*
* =========================== PIPE LOOP KERNEL ============================*
loop:
           ADDAH .D2   B_g,        B_h,      B_i    ; i = (f << 16)|(f >> 16)
||         ADDAH .D1   A_g,        A_h,      A_i    ; i = (f << 16)|(f >> 16)
||         MPYHU .M1   A_f,        A_k,      A_g    ; g = f >> 16
||  [A_cnt]B     .S2   loop                         ; Branch to Loop
||         MPYU  .M2X  B_f,        A_k,      B_h    ; h = f << 15
||         AND   .S1X  A_c,        B_msk,    A_e    ; e = (a << 8)&0xFF00FF00
||         ADD   .L2   B_d,        B_e,      B_f    ; f = d | e
||  [A_cnt]SUB   .L1   A_cnt,      1,        A_cnt  ; cnt = cnt - 1

  [!B_pred]STW   .D2T2 B_i,        *B_r++[2]        ; Store B-side i
||[!B_pred]STW   .D1T1 A_i,        *A_r++[2]        ; Store A-side i
||         MPYU  .M1   A_f,        A_k,      A_h    ; h = f << 15
||         AND   .L1X  A_a,        B_msk,    A_b    ; b =  a & 0xFF00FF00
||         SHL   .S1   A_a,        8,        A_c    ; c =  a << 8
||         AND   .L2   B_a,        B_msk,    B_b    ; b =  a & 0xFF00FF00
||         SHL   .S2   B_a,        8,        B_c    ; c =  a << 8
|| [B_pred]MPY   .M2   B_pred,     2,        B_pred ; prolog collapse

           ADD   .L1   A_d,        A_e,      A_f    ; f = d | e
||         MPYHU .M2X  B_f,        A_k,      B_g    ; g = f >> 16
||         SHRU  .S1   A_b,        8,        A_d    ; d = (a & 0xFF00FF00)>>8
||         SHRU  .S2   B_b,        8,        B_d    ; d = (a & 0xFF00FF00)>>8
||         AND   .L2   B_c,        B_msk,    B_e    ; e = (a << 8)&0xFF00FF00
||  [A_cnt]LDW   .D1T2 *A_x++[2],  B_a              ; Load B-side a
||  [A_cnt]LDW   .D2T1 *B_x++[2],  A_a              ; Load A-side a

* =========================== PIPE LOOP EPILOG ============================*
; ======================= 3 epilog stages collapsed =======================*

           ADDAH .D2   B_g,        B_h,      B_i    ; i = (f << 16)|(f >> 16)
||         ADDAH .D1   A_g,        A_h,      A_i    ; i = (f << 16)|(f >> 16)
||         MPYHU .M1   A_f,        A_k,      A_g    ; g = f >> 16
||         MPYU  .M2X  B_f,        A_k,      B_h    ; h = f << 15
||         B     .S2   B_ret_addr                   ; Return from function

  [!B_pred]STW   .D2T2 B_i,        *B_r++[2]        ; Store B-side i
||[!B_pred]STW   .D1T1 A_i,        *A_r++[2]        ; Store A-side i
||         MPYU  .M1   A_f,        A_k,      A_h    ; h = f << 15
;-
           NOP         2

           ADDAH .D2   B_g,        B_h,      B_i    ; i = (f << 16)|(f >> 16)
||         ADDAH .D1   A_g,        A_h,      A_i    ; i = (f << 16)|(f >> 16)

           STW   .D2T2 B_i,        *B_r             ; Store B-side i
||         STW   .D1T1 A_i,        *A_r             ; Store A-side i

                .end

* ======================================================================== *
*  End of file: DSPF_blk_eswap32.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap6/1117057368  655   0     0       14827     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_blk_eswap64                                                   *
*                      (                                                    *
*                          double * restrict x,                             *
*                          double * restrict r,                             *
*                          int             nx,                              *
*                      )                                                    *
*                                                                           *
*        x[nx]:   Pointer to source data.                                   *
*        r[nx]:   Pointer to destination array.                             *
*        nx:      Number of double words (64-bit values) to endian-swap.    *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*       The date in the x array is endian swapped, meaning that the         *
*       byte-order of the bytes within each double word of x is             *
*       reversed in the array r. This routine is used to facilitate moving  *
*       big-endian data to a little-endian system or vice-versa.            *
*                                                                           *
*       When the r pointer is non-NULL, the endian-swap occurs              *
*       out-of-place, similar to a block move. When the r pointer is NULL,  *
*       the endian-swap occurs in-place, allowing the swap to occure        *
*       without using any additional memory.                                *
*                                                                           *
*                                                                           *
*  TECHNIQUES                                                               *
*       1. Multiply instructions are used for shifting left and right.      *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*       1. nx is greater than 0.                                            *
*       2. x and r are word aligned.                                        *
*       3. Input array x and output array r do not overlap, except in the   *
*          special case where r = NULL so that the operation occurs in-plac *
*                                                                           *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       This is the C equivalent of the assembly code. Note that the        *
*       assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*       void DSPF_blk_eswap16(void restrict x, void restrict r, int nx)     *
*       {                                                                   *
*           int i;                                                          *
*           char_src, _dst;                                                 *
*                                                                           *
*           if (r)                                                          *
*           {                                                               *
*               _src = (char)x;                                             *
*               _dst = (char)r;                                             *
*           }                                                               *
*           else                                                            *
*           {                                                               *
*               _src = (char)x;                                             *
*               _dst = (char)x;                                             *
*           }                                                               *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           {                                                               *
*               char t0, t1, t2, t3, t4, t5, t6, t7;                        *
*                                                                           *
*               t0 = _src[i8 + 7];                                          *
*               t1 = _src[i8 + 6];                                          *
*               t2 = _src[i8 + 5];                                          *
*               t3 = _src[i8 + 4];                                          *
*               t4 = _src[i8 + 3];                                          *
*               t5 = _src[i8 + 2];                                          *
*               t6 = _src[i8 + 1];                                          *
*               t7 = _src[i8 + 0];                                          *
*                                                                           *
*                                                                           *
*               _dst[i8 + 0] = t0;                                          *
*               _dst[i8 + 1] = t1;                                          *
*               _dst[i8 + 2] = t2;                                          *
*               _dst[i8 + 3] = t3;                                          *
*               _dst[i8 + 4] = t4;                                          *
*               _dst[i8 + 5] = t5;                                          *
*               _dst[i8 + 6] = t6;                                          *
*               _dst[i8 + 7] = t7;                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*       1. This implementation is ENDIAN NEUTRAL.                           *
*       2. This routine is interrupt-tolerant but not interruptible.        *
*                                                                           *
*                                                                           *
*  CYCLES                                                                   *
*       3*nx + 14                                                           *
*       For nx=64, cycles=206.                                              *
*       For nx=25, cycles=110.                                              *
*                                                                           *
*                                                                           *
*  CODESIZE                                                                 *
*          224 bytes                                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *
        .asg            A4,     A_x
        .asg            B5,     B_x
        .asg            B4,     B_r
        .asg            A5,     A_r
        .asg            A6,     A_nx
        .asg            A1,     A_cnt
        .asg            B0,     B_a
        .asg            A0,     A_a
        .asg            B9,     B_msk
        .asg            B0,     B_b
        .asg            B1,     B_pred
        .asg            B2,     B_c
        .asg            B0,     B_d
        .asg            B2,     B_e
        .asg            B2,     B_r1
        .asg            B7,     B_f
        .asg            A9,     A_k
        .asg            B8,     B_g
        .asg            B6,     B_h
        .asg            B6,     B_i
        .asg            A6,     A_b
        .asg            A0,     A_c
        .asg            A8,     A_d
        .asg            A2,     A_e
        .asg            A6,     A_f
        .asg            A7,     A_g
        .asg            A3,     A_h
        .asg            A7,     A_i
        .asg            B3,     B_ret_addr


        .text
        .global _DSPF_blk_eswap64
_DSPF_blk_eswap64:

* ======================================================================== *
* ======================================================================== *
* =========================== PIPE LOOP PROLOG =========================== *

           ADD   .L2X  A_x,        4,       B_x    ; Copy x pointer to B-side
||         MV    .L1   A_nx,       A_cnt           ; Get Loop counter

           LDW   .D1T2 *A_x++[2],  B_a             ; Load B-side a
||         LDW   .D2T1 *B_x++[2],  A_a             ; Load A-side a
||         MV    .L2   B_r,        B_r1            ; Get r pointer

           B     .S1   loop                        ; Branch to Loop
||         MVK   .S2   0x4000,     B_pred          ; prolog collapse
||  [!B_r1]SUB   .L2   B_x,        12,      B_r    ; if(!r) x = r
;-
           MVKL  .S2   0xFF00FF00, B_msk           ; Mask = 0xFF00FF00
||         MVKL  .S1   0x00018000, A_k             ; K for left shifting by 15
||  [A_cnt]SUB   .L1   A_cnt,      1,       A_cnt  ; cnt = cnt - 1

    [A_cnt]LDW   .D1T2 *A_x++[2],  B_a             ; Load B-side a
||  [A_cnt]LDW   .D2T1 *B_x++[2],  A_a             ; Load A-side a
||         MVKH  .S2   0xFF00FF00, B_msk           ; Mask = 0xFF00FF00
||         MVKH  .S1   0x00018000, A_k             ; K for left shifting by 15
||         ADD   .L1X  B_r,        4,       A_r    ; Copy r pointer to A-side
;-
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================*
loop:
           ADDAH .D2   B_g,        B_h,     B_i    ; i = (f << 16)|(f >> 16)
||         ADDAH .D1   A_g,        A_h,     A_i    ; i = (f << 16)|(f >> 16)
||         MPYHU .M1   A_f,        A_k,     A_g    ; g = f >> 16
||  [A_cnt]B     .S2   loop                        ; Branch to Loop
||         MPYU  .M2X  B_f,        A_k,     B_h    ; h = f << 15
||         AND   .S1X  A_c,        B_msk,   A_e    ; e = (a << 8)&0xFF00FF00
||         ADD   .L2   B_d,        B_e,     B_f    ; f = d | e
||  [A_cnt]SUB   .L1   A_cnt,      1,       A_cnt  ; cnt = cnt - 1

  [!B_pred]STW   .D1T2 B_i,        *A_r++[2]       ; Store B-side i
||[!B_pred]STW   .D2T1 A_i,        *B_r++[2]       ; Store A-side i
||         MPYU  .M1   A_f,        A_k,     A_h    ; h = f << 15
||         AND   .L1X  A_a,        B_msk,   A_b    ; b =  a & 0xFF00FF00
||         SHL   .S1   A_a,        8,       A_c    ; c =  a << 8
||         AND   .L2   B_a,        B_msk,   B_b    ; b =  a & 0xFF00FF00
||         SHL   .S2   B_a,        8,       B_c    ; c =  a << 8
|| [B_pred]MPY   .M2   B_pred,     2,       B_pred ; prolog collapse

           ADD   .L1   A_d,        A_e,     A_f    ; f = d | e
||         MPYHU .M2X  B_f,        A_k,     B_g    ; g = f >> 16
||         SHRU  .S1   A_b,        8,       A_d    ; d = (a & 0xFF00FF00)>>8
||         SHRU  .S2   B_b,        8,       B_d    ; d = (a & 0xFF00FF00)>>8
||         AND   .L2   B_c,        B_msk,   B_e    ; e = (a << 8)&0xFF00FF00
||  [A_cnt]LDW   .D1T2 *A_x++[2],  B_a             ; Load B-side a
||  [A_cnt]LDW   .D2T1 *B_x++[2],  A_a             ; Load A-side a

* =========================== PIPE LOOP EPILOG ============================*
; ===== 3 epilog stages collapsed
           ADDAH .D2   B_g,        B_h,     B_i    ; i = (f << 16)|(f >> 16)
||         ADDAH .D1   A_g,        A_h,     A_i    ; i = (f << 16)|(f >> 16)
||         MPYHU .M1   A_f,        A_k,     A_g    ; g = f >> 16
||         MPYU  .M2X  B_f,        A_k,     B_h    ; h = f << 15
||         B     .S2   B_ret_addr                  ; Return from Function

  [!B_pred]STW   .D1T2 B_i,        *A_r++[2]       ; Store B-side i
||[!B_pred]STW   .D2T1 A_i,        *B_r++[2]       ; Store A-side i
||         MPYU  .M1   A_f,        A_k,     A_h    ; h = f << 15
;-
           NOP         2

           ADDAH .D2   B_g,        B_h,     B_i    ; i = (f << 16)|(f >> 16)
||         ADDAH .D1   A_g,        A_h,     A_i    ; i = (f << 16)|(f >> 16)

           STW   .D1T2 B_i,        *A_r            ; Store B-side i
||         STW   .D2T1 A_i,        *B_r            ; Store A-side i
;-

                .end

* ======================================================================== *
*  End of file: DSPF_blk_eswap64.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_fltoq15.as/1117057369  677   0     0       12302     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*      This routine is C-callable and can be called as:                     * 
*                                                                           * 
*      void DSPF_fltoq15                                                         * 
*      (                                                                    * 
*          const float* restrict x,                                         * 
*          short*       restrict r,                                         * 
*          int         nx                                                   * 
*      );                                                                   * 
*                                                                           * 
*      x[nx] :  Input array contaning values of type float                  * 
*      r[nx] :  Output array contains Q15 equivalents of x[nx]              * 
*      nx    :  Number of elements in both arrays                           * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*      Convert the IEEE floating point numbers stored in vector x[] into    * 
*      Q.15 format numbers stored in vector r[]. Results will be rounded    * 
*      towards negative infinity. All values that exceed the size limit     * 
*      will be saturated to 0x7fff if value is positive and 0x8000 if       * 
*      value is negative.                                                   * 
*                                                                           * 
*   C CODE                                                                  * 
*      void DSPF_fltoq15                                                         * 
*      (                                                                    * 
*          const float* restrict x,                                         * 
*          short*       restrict r,                                         * 
*          int         nx                                                   * 
*      )                                                                    * 
*      {                                                                    * 
*          int i, a;                                                        * 
*                                                                           * 
*          for(i = 0; i < nx; i++)                                          * 
*          {                                                                * 
*              a = floor(32768 * x[i]);                                     * 
*                                                                           * 
*              // saturate to 16-bit //                                     * 
*              if (a>32767)  a =  32767;                                    * 
*              if (a<-32768) a = -32768;                                    * 
*                                                                           * 
*              r[i] = (short) a;                                            * 
*          }                                                                * 
*      }                                                                    * 
*   TECHNIQUES                                                              * 
*                                                                            * 
*      1. SSHL has been used to saturate the output of the instr SPINT      * 
*      2. There are no write buffer fulls because one STH occurs per cycle. * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*      1. None                                                              * 
*                                                                           * 
*   NOTES                                                                   * 
*      1. This code is interrupt-tolerant but not interruptible.            * 
*      2. This implementation is ENDIAN NEUTRAL.                            * 
*   CYCLES                                                                  * 
*                                                                           * 
*     N + 17                                                                * 
*     eg. N=512, cycles = 529                                               * 
*                                                                           * 
*   CODESIZE                                                                * 
*      384 bytes                                                            * 
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_fltoq15
_DSPF_fltoq15:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            A6,         A_x0
        .asg            A3,         A_num1
        .asg            A7,         A_p0
        .asg            A5,         A_t0
        .asg            B6,         B_t2
        .asg            B7,         B_temp
        .asg            B5,         B_t3
        .asg            B4,         B_r
        .asg            B0,         B_nx
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDW     .D1T1   *A_x++,     A_x0           ; load float
||      MV      .L2X     A6,        B_nx           ; move cntr to cond reg
||      ZERO    .L1      A_num1                    ; init 2^15
||      MVC     .S2     CSR,        B9             ; disable interrupts
||      B       .S1     NO_INT                       

 [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float
||      MVKH    .S1     0x47000000, A_num1
||[!B_nx]B      .S2     B3
||      AND     .L2     B9,         -2,         B8

 [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float
||     MVC     .S2      B8,        CSR

 [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float
||      MVK     .S2     1,          B_temp

 [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float


 [B_nx] MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

NO_INT:

        MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

        MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

        MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

        SPINT   .L1     A_p0,       A_t0             ; convert to integer
||       MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

        SPINT   .L1     A_p0,       A_t0             ; convert to integer
||       MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float
||[ B_nx]SUB    .L2     B_nx,       1,          B_nx ; decr cntr

        SPINT   .L1     A_p0,       A_t0             ; convert to integer
||       MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float
||[ B_nx]SUB    .L2     B_nx,       1,          B_nx ; decr cntr
||[ B_nx]B      .S1     loop                                    

  [ B_nx]B      .S1     loop                                    
||[ B_nx]SUB    .L2     B_nx,       1,          B_nx ; decr cntr
||     SPINT   .L1     A_p0,       A_t0             ; convert to integer
||       MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

        SSHL    .S2X    A_t0,       16,         B_t2 ; sat if necessary           
||[ B_nx]B      .S1     loop                                    
||[ B_nx]SUB    .L2     B_nx,       1,          B_nx ; decr cntr
||     SPINT   .L1     A_p0,       A_t0             ; convert to integer
||       MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

        MPYHLU  .M2     B_t2,       B_temp,     B_t3 ; tx upper 16 to lower
||      SSHL    .S2X    A_t0,       16,         B_t2 ; sat if necessary
||[ B_nx]B      .S1     loop                                    
||[ B_nx]SUB    .L2     B_nx,       1,          B_nx ; decr cntr
||     SPINT   .L1     A_p0,       A_t0             ; convert to integer
||       MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

        MPYHLU  .M2     B_t2,       B_temp,     B_t3 ; tx upper 16 to lower
||      SSHL    .S2X    A_t0,       16,         B_t2 ; sat if necessary
||[ B_nx]B      .S1     loop                                    
||[ B_nx]SUB    .L2     B_nx,       1,          B_nx ; decr cntr
||     SPINT   .L1     A_p0,       A_t0             ; convert to integer
||       MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

* =========================== PIPE LOOP KERNEL ============================ *
loop:
        STH     .D2T2   B_t3,       *B_r++                      
||      MPYHLU  .M2     B_t2,       B_temp,     B_t3 ; tx upper 16 to lower
||      SSHL    .S2X    A_t0,       16,         B_t2 ; sat if necessary
||[ B_nx]B      .S1     loop                                    
||[ B_nx]SUB    .L2     B_nx,       1,          B_nx ; decr cntr
||     SPINT   .L1     A_p0,       A_t0             ; convert to integer
||       MPYSP   .M1     A_x0,       A_num1,     A_p0 ; mult. by 2^15
|| [B_nx] LDW     .D1T1   *A_x++,     A_x0           ; load float

* ======================== END OF PIPED LOOP KERNEL ======================= * 
        B       .S2     B3
        NOP             4
        MVC     .S2     B9,         CSR
                .end

* ======================================================================== *
*  End of file: DSPF_fltoq15.asm                                                *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_minerr./1117057369  695   0     0       22991     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minerr -- Searching for a pair of numbers producing maximum      *
*      dot product                                                         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*        This routine has the following C prototype:                        * 
*                                                                           * 
*        float DSPF_sp_minerr(const float* GSP0_TABLE, const float* errCoefs,    * 
*                                               int *restrict max_index)    * 
*                                                                           * 
*           GSP0_TABLE[256*9]: GSP0 terms array.                            * 
*           errCoefs[9]:       Array of error coefficients.                 * 
*                              Must be Double word aligned.                 * 
*           max_index:         Index to GSP0_TABLE[max_index], the first    * 
*                              element of the 9-element vector that         * 
*                              resulted in the maximum dot product.         * 
*           return float       Maximum dot product result.                  * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*        Performs a dot product on 256 pairs of 9 element vectors and       * 
*        searches for the pair of vectors which produces the maximum dot    * 
*        product result. This is a large part of the VSELP vocoder          * 
*        codebook search.                                                   * 
*                                                                           * 
*        The function stores the index to the first element of the          * 
*        9-element vector that resulted in the maximum dot product in the   * 
*        memory loaction Pointed by max_index. The maximum dot product      * 
*        value is returned by the function.                                 * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*       The inner loop is totally unrolled.                                 * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*       errCoefs must be Double word aligned.                               * 
*                                                                           * 
*   C CODE                                                                  * 
*                                                                           * 
*         float DSPF_sp_minerr(const float* GSP0_TABLE, const float* errCoefs,   * 
*                                                int *restrict max_index)   * 
*         {                                                                 * 
*                                                                           * 
*                    float val, maxVal = -50;                               * 
*                    int i, j;                                              * 
*                                                                           * 
*                    for (i = 0; i < GSP0_NUM; i++)                         * 
*                        {                                                  * 
*                        for (val = 0, j = 0; j < GSP0_TERMS; j++)          * 
*                           val += GSP0_TABLE[i*GSP0_TERMS+j]*errCoefs[j];  * 
*                        if (val > maxVal)                                  * 
*                           {                                               * 
*                           maxVal = val;                                   * 
*                           *max_index = i*GSP0_TERMS;                      * 
*                           }                                               * 
*                        }                                                  * 
*                    return (maxVal);                                       * 
*         }                                                                 * 
*                                                                           * 
*   NOTES                                                                   * 
*         errCoefs must be Double word aligned                              * 
*                                                                           * 
*   CYCLES                                                                  * 
*         1189                                                              * 
*                                                                           * 
*   CODESIZE                                                                * 
*           736 bytes                                                       * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



* ======================================================================== *
* ======================================================================== *

       .asg A4,  A_GSP0_TABLE
       .asg B5,  B_GSP0_TABLE
       .asg A4,  RET_VALUE
       .asg B6,  B_errCoefs
       .asg B4,  B_errCoefs1
       .asg A5,  A_errCoefs
       .asg B4,  B_CSR
       .asg B0,  B_CSR_gie
       .asg A6,  A_max_index1
       .asg A15, A_max_index
       .asg B3,  B_RET_ADDR
       .asg B6,  B_g       
       .asg B7,  B_g0
       .asg B7,  B_g1       
       .asg B7,  B_g2
       .asg B7,  B_g3       
       .asg B7,  B_g4
       .asg B7,  B_g6
       .asg B7,  B_g8
       
       .asg A6,  A_g  
       .asg A7,  A_g0     
       .asg A7,  A_g1
       .asg A7,  A_g2
       .asg A7,  A_g3
       .asg A7,  A_g5
       .asg A7,  A_g7
       
       .asg A12, A_e0
       .asg B11, B_e1
       .asg B10, B_e2
       .asg A13, A_e3
       .asg B12, B_e4
       .asg A14, A_e5
       .asg B13, B_e6
       .asg A11, A_e7
       .asg B14, B_e8
       .asg B11, B_e3
       .asg A13, A_e1
       .asg B13, B_e5
       .asg A10, A_e6
       
       .asg A6,  A_m
       .asg A8,  A_m0
       .asg A8,  A_m2
       .asg A8,  A_m3
       .asg A8,  A_m5
       .asg A8,  A_m7
       .asg B8,  B_m1
       .asg B8,  B_m2
       .asg B8,  B_m4
       .asg B8,  B_m6
       .asg B8,  B_m8
       
       .asg B0,  B_m01
       .asg B0,  B_m23
       .asg B0,  B_m801
       .asg B6,  B_m45
       .asg B6,  B_m2345
       .asg B6,  B_m67
       .asg B1,  B_m67801
       .asg B1,  B_sum
       .asg A9,  A_m12
       .asg A9,  A_m34
       .asg A9,  A_m012
       .asg A10, A_m56
       .asg A10, A_m3456
       .asg A10, A_m78
       .asg A5,  A_m01278
       .asg A5,  A_sum
       
       .asg B15, B_SP
       .asg A9,  A_SP
       .asg A6,  A_SP1
       .asg B9,  B_maxval
       .asg A0,  A_index
       .asg A1,  A_i
       .asg B1,  B_flag
       .asg B0,  B_flag1
       .asg B2,  B_ldfg
       .asg A2,  A_pred
       .asg A7,  A_cst
       

        .text
        .global _DSPF_sp_minerr
_DSPF_sp_minerr:

* ======================================================================== *
* ======================================================================== *
           SUBAW   .D2   B_SP,               12,          B_SP         ; Save Stack Space
||         MV      .L1X  B_SP,               A_SP                      ; Copy Stack Pointer
||         MVK     .S2   20,                 B_GSP0_TABLE              ; For copying table pointer
||         MV      .L2   B_errCoefs1,        B_errCoefs                ; Copy errCoefs Pointer
                
           STW     .D2T2 B_e1,               *B_SP[1]                  ; Save Register
||         STW     .D1T1 A_m78,              *-A_SP[6]                 ; Save Register
||         MV      .L1X  B_SP,               A_SP                      ; Copy Stack Pointer
||         ADD     .L2X  A_GSP0_TABLE,       B_GSP0_TABLE,B_GSP0_TABLE ; Copy Table Pointer
||         MVC     .S2   CSR,                B_CSR                     ; Get CSR
                
           STW     .D2T2 B_e2,               *B_SP[2]                  ; Save Register
||         STW     .D1T1 A_e7,               *A_SP[7]                  ; Save Register
||         MV      .L1X  B_errCoefs,         A_errCoefs                ; Copy errCoefs Pointer
||         MVK     .S1   258,                A_i                       ; i = 258 (GSP0_NUM+2)
||         AND     .S2   B_CSR,              -2,          B_CSR_gie    ; Disable gie bit

           STW     .D2T2 B_e4,               *B_SP[3]                  ; Save Register
||         STW     .D1T1 A_e0,               *A_SP[8]                  ; Save Register    
||         MVKL    .S2   0xFF800000,         B_maxval                  ; maxval = -INF
||         MVK     .S1   4,                  A_pred                    ; Predicate for Prolog collapse

           STW     .D2T2 B_e6,               *B_SP[4]                  ; Save Register
||         STW     .D1T1 A_e3,               *A_SP[9]                  ; Save Register                                                
||         MVKH    .S2   0xFF800000,         B_maxval                  ; maxval = -INF

           STW     .D2T2 B_e8,               *B_SP[5]                  ; Save Register
||         STW     .D1T1 A_e5,               *A_SP[10]                 ; Save Register
||         MVC     .S2   B_CSR_gie,          CSR                       ; Disable Interrupt

           STW     .D1T1 A_max_index,        *A_SP[11]                 ; Save Register
||         MV      .L1   A_max_index1,       A_max_index               ; Get Max_index Pointer
||         LDW     .D2T2 *B_errCoefs[8],     B_e8                      ; load err8

; ----------------------------------------------------------------
           LDDW    .D2T1 *B_errCoefs,        A_e1:A_e0                 ; load err1:err0
||         LDDW    .D1T2 *A_errCoefs[1],     B_e3:B_e2                 ; load err3:err2                
||         MVK     .S2   256,                B_ldfg                    ; To prevent Extra loads
||         ZERO    .L2   B_flag1                                       ; Initiailse flag
                                
; ----------------------- LOOP PROLOG ----------------------------

           LDDW    .D1T1 *A_GSP0_TABLE++[1], A_g1:A_g                  ; load g1:g0
||         LDDW    .D2T2 *B_errCoefs[2],     B_e5:B_e4                 ; load err5:err4
||         ZERO    .S2   B_flag                                        ; Initialise flag

           LDDW    .D1T2 *A_GSP0_TABLE++[1], B_g3:B_g                  ; load g3:g2
||         LDDW    .D2T1 *B_errCoefs[3],     A_e7:A_e6                 ; load err7:err6
 
           LDW     .D1T2 *A_GSP0_TABLE++[2], B_g4                      ; load g4
||         LDW     .D2T1 *B_GSP0_TABLE++[2], A_g5                      ; load g5

           LDW     .D1T2 *A_GSP0_TABLE++[2], B_g6                      ; load g6
||         LDW     .D2T1 *B_GSP0_TABLE++[2], A_g7                      ; load g7

           LDW     .D1T2 *A_GSP0_TABLE++[2], B_g8                      ; load g8
||         LDW     .D2T1 *B_GSP0_TABLE++[2], A_g0                      ; load g0
||         MV      .S2X  A_e1,               B_e1                      ; get err1
||         MV      .S1X  B_e3,               A_e3                      ; get err3
 
           LDW     .D1T2 *A_GSP0_TABLE++[2], B_g1                      ; load g1
||         LDW     .D2T1 *B_GSP0_TABLE++[2], A_g2                      ; load g2
||         MPYSP   .M1   A_g,                A_e0,        A_m0         ; m0 = g0 * err0
||         MPYSP   .M2X  A_g1,               B_e1,        B_m1         ; m1 = g1 * err1
||         MV      .S1X  B_e5,               A_e5                      ; get err5

           LDW     .D1T1 *A_GSP0_TABLE++[2], A_g3                      ; load g3
||         LDW     .D2T2 *B_GSP0_TABLE++[2], B_g4                      ; load g4
||         MPYSP   .M2   B_g,                B_e2,        B_m2         ; m2 = g2 * err2
||         MPYSP   .M1X  B_g3,               A_e3,        A_m3         ; m3 = g3 * err3
||         MV      .S2X  A_e6,               B_e6                      ; get err6

LOOP:

   [B_ldfg]LDW     .D1T1 *A_GSP0_TABLE++[2], A_g5                      ; load g5
|| [B_ldfg]LDW     .D2T2 *B_GSP0_TABLE++[2], B_g6                      ; load g6  
||         MPYSP   .M2   B_g4,               B_e4,        B_m4         ; m4 = g4 * err4
||         MPYSP   .M1   A_g5,               A_e5,        A_m5         ; m5 = g5 * err5
||         ADDSP   .L1X  A_m5,               B_m6,        A_m56        ; m56 = m5 + m6             
 
   [B_ldfg]LDW     .D1T1 *A_GSP0_TABLE++[2], A_g7                      ; load g7 
|| [B_ldfg]LDW     .D2T2 *B_GSP0_TABLE++[2], B_g8                      ; load g8
||         MPYSP   .M2   B_g6,               B_e6,        B_m6         ; m6 = g6 * err6
||         MPYSP   .M1   A_g7,               A_e7,        A_m7         ; m7 = g7 * err7
||         ADDSP   .L1X  A_m7,               B_m8,        A_m78        ; m78 = m7 + m8  
||         ADDSP   .L2   B_m67,              B_m801,      B_m67801     ; m67801 = m67 + m801
||    [A_i]SUB     .S1   A_i,                2,           A_i          ; i = i - 1
|| [B_ldfg]SUB     .S2   B_ldfg,             2,           B_ldfg       ; Update flag to prvent extra loads

   [B_ldfg]LDW     .D1T1 *A_GSP0_TABLE++[2], A_g0                      ; load g0
|| [B_ldfg]LDW     .D2T2 *B_GSP0_TABLE++[2], B_g1                      ; load g1
||         MPYSP   .M2   B_g8,               B_e8,        B_m8         ; m8 = g8 * err8
||         MPYSP   .M1   A_g0,               A_e0,        A_m          ; m0 = g0 * err0
||         ADDSP   .L2X  A_m0,               B_m1,        B_m01        ; m01 = m0 + m1
||         ADDSP   .L1   A_m,                A_m12,       A_m012       ; m012 = m0 + m12
||         CMPGTSP .S2   B_sum,              B_maxval,    B_flag1      ; if sum > maxval

   [B_ldfg]LDW     .D1T2 *A_GSP0_TABLE++[2], B_g2                      ; load g2
|| [B_ldfg]LDW     .D2T1 *B_GSP0_TABLE++[2], A_g3                      ; load g3
||         MPYSP   .M2   B_g1,               B_e1,        B_m1         ; m1 = g1 * err1
||         MPYSP   .M1X  A_g2,               B_e2,        A_m2         ; m2 = g2 * err2
||         ADDSP   .L2X  A_m3,               B_m2,        B_m23        ; m23 = m2 + m3
||[!A_pred]ADDSP   .L1   A_m3456,            A_m01278,    A_sum        ; sum = m4567 + m01278
||    [A_i]B       .S1   LOOP                                          ; Branch To Loop
|| [A_pred]ZERO    .S2   B_flag1                                       ; For Collapsing Prolog
 
   [B_ldfg]LDW     .D1T2 *A_GSP0_TABLE++[2], B_g4                      ; load g4
|| [B_ldfg]LDW     .D2T1 *B_GSP0_TABLE++[2], A_g5                      ; load g5
||         MPYSP   .M1   A_g3,               A_e3,        A_m3         ; m3 = g3 * err3
||         MPYSP   .M2   B_g4,               B_e4,        B_m4         ; m4 = g4 * err4
||         ADDSP   .L2X  A_m5,               B_m4,        B_m45        ; m45 = m4 + m5
||         ADDSP   .L1   A_m34,              A_m56,       A_m3456      ; m3456 = m34 + m56
||[B_flag1]MV      .S2   B_sum,              B_maxval                  ; maxval = sum
||[B_flag1]MV      .S1   A_i,                A_index                   ; index = i

   [B_ldfg]LDW     .D1T2 *A_GSP0_TABLE++[2], B_g6                      ; load g6
|| [B_ldfg]LDW     .D2T1 *B_GSP0_TABLE++[2], A_g7                      ; load g7
||         MPYSP   .M1   A_g5,               A_e5,        A_m5         ; m5 = g5 * err5
||         MPYSP   .M2   B_g6,               B_e6,        B_m6         ; m6 = g6 * err6
||         ADDSP   .L2X  A_m7,               B_m6,        B_m67        ; m67 = m6 + m7

   [B_ldfg]LDW     .D1T2 *A_GSP0_TABLE++[2], B_g8                      ; load g8
|| [B_ldfg]LDW     .D2T1 *B_GSP0_TABLE++[2], A_g0                      ; load g0
||         MPYSP   .M1   A_g7,               A_e7,        A_m7         ; m7 = g7 * err7
||         MPYSP   .M2   B_g8,               B_e8,        B_m8         ; m8 = g8 * err8
||         ADDSP   .L2   B_m01,              B_m8,        B_m801       ; m801 = m8 + m01
||         ADDSP   .L1   A_m012,             A_m78,       A_m01278     ; m01278 = m012 + m78
|| [A_pred]MV      .S1X  B_maxval,           A_sum                     ; For Collapsing Prolog

   [B_ldfg]LDW     .D1T2 *A_GSP0_TABLE++[2], B_g1                      ; load g1
|| [B_ldfg]LDW     .D2T1 *B_GSP0_TABLE++[2], A_g2                      ; load g2
||         MPYSP   .M1   A_g0,               A_e0,        A_m0         ; m0 = g0 * err0
||         MPYSP   .M2   B_g1,               B_e1,        B_m1         ; m1 = g1 * err1
||         ADDSP   .L1X  A_m2,               B_m1,        A_m12        ; m12 = m1 + m2
||         ADDSP   .L2   B_m2345,            B_m67801,    B_sum        ; sum = m2345 + m67801
||         CMPGTSP .S2X  A_sum,              B_maxval,    B_flag       ; if sum > maxval
|| [A_pred]SUB     .S1   A_pred,             2,           A_pred       ; For Collapsing Prolog

   [B_ldfg]LDW     .D1T1 *A_GSP0_TABLE++[2], A_g3                      ; load g3
|| [B_ldfg]LDW     .D2T2 *B_GSP0_TABLE++[2], B_g4                      ; load g4
||         MPYSP   .M2   B_g2,               B_e2,        B_m2         ; m2 = g2 * err2
||         MPYSP   .M1   A_g3,               A_e3,        A_m3         ; m3 = g3 * err3
||         ADDSP   .L2   B_m23,              B_m45,       B_m2345      ; m2345 = m23 + m45
||         ADDSP   .L1X  A_m3,               B_m4,        A_m34        ; m34 = m3 + m4
|| [B_flag]MV      .S2X  A_sum,              B_maxval                  ; maxval = sum
|| [B_flag]SUB     .S1   A_i,                1,           A_index      ; index = i - 1

; ---------------------------------------------------------------- 

           MV      .S1X  B_SP,               A_SP1                     ; E Copy Stack Pointer
||         LDW     .D2T1 *B_SP[10],          A_e5                      ; Restore Register
                
           ADDSP   .L1   A_m3456,            A_m01278,    A_sum        ; E sum = m4567 + m01278
||         LDW     .D2T2 *B_SP[1],           B_e1                      ; Restore Register                  
||         LDW     .D1T1 *A_SP1[7],          A_e7                      ; Restore Register                 
||         MVK     .S1   252,                A_cst                     ; Load constant 253               

           CMPGTSP .S2   B_sum, B_maxval,    B_flag1                   ; E if sum > maxval
||         LDW     .D2T2 *B_SP[2],           B_e2                      ; Restore Register   
||         LDW     .D1T1 *A_SP1[6],          A_m78                     ; Restore Register   
||         MPY     .M1   A_index,            9,           A_index      ; index = index * 9

  [B_flag1]MV      .L2   B_sum,              B_maxval                  ; E maxval = sum
||         LDW     .D2T2 *B_SP[3],           B_e4                      ; Restore Register   
||         LDW     .D1T1 *A_SP1[8],          A_e0                      ; Restore Register   
||         MPY     .M1   A_cst,              9,           A_cst        ; cst = 9 * 252
 
  [B_flag1]MVK     .S1   -18,                A_index                   ; E index = i(Here -18)
||         LDW     .D2T2 *B_SP[4],           B_e6                      ; Restore Register   
||         LDW     .D1T1 *A_SP1[9],          A_e3                      ; Restore Register   
||         B       .S2   B_RET_ADDR                                    ; Branch out of the function

           LDW     .D2T2 *B_SP[5],           B_e8                      ; Restore Register   
||         LDW     .D1T1 *A_SP1[11],         A_max_index               ; Restore Register                   
||         CMPGTSP .S2X  A_sum,              B_maxval,    B_flag       ; E if sum > maxval

   [B_flag]MV      .L2X  A_sum,              B_maxval                  ; E index = i(Here -18)
|| [B_flag]MVK     .S1   -27,                A_index                   ; E index = i(Here -27)
||         ADDAW   .D2   B_SP,               12,          B_SP         ; Restore Stack space

; ---------------------------------------------------------------------------------
 
           SUB     .L1   A_cst,              A_index,     A_index      ; index = 252*9 - index
  
           STW     .D1T1 A_index,            *A_max_index              ; Store Maximum Index               
||         MV      .L1X  B_maxval,           RET_VALUE                 ; Load return value
 
           MVC     .S2   B_CSR,              CSR                       ; Enable Interrupt
  
                .end

* ======================================================================== *
*  End of file: DSPF_sp_minerr.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_q15tofl.as/1117057370  715   0     0       14146     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       *
*      format                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Nov-2002                                                         *
*                                                                          *
*   USAGE                                                                   * 
*                                                                           * 
*     This routine is C Callable and can be called as:                      * 
*                                                                           * 
*       float DSPF_q15tofl(short *x, float *r, int nx);                          * 
*                                                                           * 
*       x     : Input array containing shorts in Q15 format                 * 
*       r     : Output array containing equivalent floats                   * 
*       nx    : Number of values in the x vector                            * 
*                                                                           * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*                                                                           * 
*       This routine converts data in the Q15 format into IEEE Single Prec. *
*       floating point.                                                     * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*                                                                           * 
*       1.  LDDW instructions are used to load four short values at a time. * 
*       2.  The loop is unrolled four times and software pipelined.         * 
*           However, by conditionally storing any array sizes               * 
*           are permitted.                                                  * 
*       3.  To avoid write buffer fulls on the 671x the output array is     * 
*           brought into cache inside the kernel. Thus, the store happens   * 
*           to addresses already in L1D. Thus, no use of the write buffer   * 
*           is made.                                                        * 
*       4.  Extraneous loads are allowed in the program.                    *
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*                                                                           * 
*       1. The array x must be double word-aligned.                         * 
*       2. The value of nx is > 0.                                          *
*                                                                           * 
*   C CODE                                                                  * 
*                                                                           * 
*       This is the C equivalent for the assembly code.  Note that          * 
*       the assembly code is hand optimized and restrictions may            * 
*       apply.                                                              * 
*                                                                           * 
*   void DSPF_q15tofl_cn(short *x, float *r, int nx)                             * 
*      {                                                                    * 
*       int i;                                                              * 
*       for (i=0;i<nx;i++)                                                  * 
*            r[i]=(float)x[i]/0x8000;                                       * 
*      }                                                                    * 
*                                                                           * 
*                                                                           * 
*   NOTES                                                                   * 
*      1. No write buffer fulls occur because of cache touching.            * 
*                                                                           * 
*   CYCLES                                                                  * 
*                                                                           * 
*      3*floor((N-1)/4) + 20                                                * 
*      eg. for N = 512, cycles = 401                                        *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     448 bytes                                                             *
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* =============== SYMBOLIC REGISTER ASSIGNMENTS =========================== *

                .asg A4, A_x
                .asg A7, A_hi
                .asg A6, A_lo
                .asg A8, A_loshort
                .asg B8, B_hishort
                .asg A9, A_lofloat
                .asg B6, B_hifloat
                .asg A1, A_2rm15
                .asg B2, B_2rm15
                .asg A8, A_float0
                .asg A0, A_float2
                .asg B0, B_float1
                .asg B0, B_float3
                .asg B4, B_r
                .asg A5, A_r
                .asg B9, B_rtouch
                .asg B7, B_extreg
                .asg A3, A_cntmod4
                .asg A2, A_icntr
                .asg B5, B_dummyload

* ========================================================================= *                

        .text
        .global _DSPF_q15tofl
_DSPF_q15tofl:
           
* ================ PIPE LOOP PROLOG ======================================= *
           
       LDDW   .D1T1   *A_x++,     A_hi:A_lo     ; load 4 shorts      
||     MV     .L1X    B_r,        A_r           ; copy store ptr      
||     ADD    .S1     A6 ,        3,        A_icntr  ; round off cntr
||     ZERO   .D2     B_2rm15                   ; init 2^-15 to reg      
           
       MVKH   .S2     0X38000000, B_2rm15       ; load 2^-15      
||     ADD    .L2     B_r,        4,        B_r ; advance store ptr      
||     MV     .D2     B_r,        B_rtouch      ; init touch ptr      
||     SHR    .S1     A_icntr,   2,    A_icntr  ; cntr /= 4      
||     AND    .L1     A6,         3,        A1  ; how many store remain?      
                    

  [A_icntr] SUB .D1 A_icntr,      1,   A_icntr  ; due to epilog      
||[!A1]MVK    .S1     4,          A_cntmod4     ; if mult of 4 move 4             
           
           
       LDDW   .D1T1   *A_x++,     A_hi:A_lo     ; load 4 shorts      
||     MVK    .S2     16,         B_extreg      ; for EXT instr            
||[A1] MV     .S1     A1,         A_cntmod4     ; init cnt mod 4             
||     MV     .L1X    B_2rm15,    A_2rm15       ; copy 2^-15      
           
       NOP                                                        
           
       EXT    .S1     A_lo, 16,   16,  A_loshort; extract bits 0-15
           
       LDDW   .D1T1   *A_x++,     A_hi:A_lo     ; load 4 shorts      
||     INTSP  .L1     A_loshort,  A_lofloat     ; convert x0 to float       
||     EXT    .S2X    A_lo, B_extreg,  B_hishort; extract bits 16-31 
||     EXT    .S1     A_hi, 16,   16,  A_loshort; extract bits 0-15
         
           
       INTSP  .L1     A_loshort,  A_lofloat     ; convert x2 to float      
||     INTSP  .L2     B_hishort,  B_hifloat     ; convert x1 to float
||     EXT    .S2X    A_hi, B_extreg, B_hishort ; extract bits 16-31 
         
           
       EXT    .S1     A_lo, 16,   16,  A_loshort; extract bits 0-15
||     INTSP  .L2     B_hishort,  B_hifloat     ; convert x3 to float      
||     LDW    .D2T2   *B_rtouch++[4],B_dummyload; touch r-data         
||[!A_icntr]B      .S2     skip_kernel          ; branch if cnt <=4      
         
           
       LDDW   .D1T1   *A_x++,     A_hi:A_lo     ; load 4 shorts             
||     INTSP  .L1     A_loshort,  A_lofloat     ; convert x0 to float
||     EXT    .S2X    A_lo,   B_extreg, B_hishort; extract bits 16-31 
||     EXT    .S1     A_hi, 16,   16, A_loshort ; extract bits 0-15
         
       INTSP  .L1     A_loshort,  A_lofloat     ; convert x2 to float      
||     INTSP  .L2     B_hishort,  B_hifloat     ; convert x1 to float      
||     EXT    .S2X    A_hi,  B_extreg, B_hishort; extract bits 16-31 
||     MPYSP  .M1     A_lofloat, A_2rm15,A_float0; divide by 2^15  
||[A_icntr] SUB    .D1  A_icntr, 1,    A_icntr   ; decr cntr     
         
           
       EXT    .S1     A_lo,  16,  16,  A_loshort   ; extract bits 0-15
||     INTSP  .L2     B_hishort,  B_hifloat        ; convert x3 to float   
||     MPYSP  .M1     A_lofloat,  A_2rm15, A_float2; divide by 2^15  
||     MPYSP  .M2     B_hifloat,  B_2rm15, B_float1; divide by 2^15    
||[A_icntr] B      .S2     loop                    ; brnch        
||     LDW    .D2T2   *B_rtouch++[4],B_dummyload   ; touch memory      

           
       LDDW   .D1T1   *A_x++,     A_hi:A_lo          ; load 4 shorts              
||     INTSP  .L1     A_loshort,  A_lofloat          ; convert x0 to float 
||     EXT    .S2X    A_lo,       B_extreg, B_hishort; extract bits 16-31  
||     EXT    .S1     A_hi, 16,   16,     A_loshort  ; extract bits 0-15
||     MPYSP  .M2     B_hifloat,  B_2rm15,  B_float3 ; divide by 2^15 
         
          
       INTSP  .L1     A_loshort,  A_lofloat          ; convert x2 to float 
||     INTSP  .L2     B_hishort,  B_hifloat          ; convert x1 to float 
||     EXT    .S2X    A_hi,       B_extreg, B_hishort; extract bits 16-31  
||     MPYSP  .M1     A_lofloat,  A_2rm15,  A_float0 ; divide by 2^15     
||[A_icntr] SUB .D1   A_icntr,    1,        A_icntr  ; decr cntr               

*================ PIPE LOOP KERNEL ====================================== *
loop:                  
          
       EXT    .S1     A_lo,       16, 16,  A_loshort ; extract bits 0-15   
||     INTSP  .L2     B_hishort,  B_hifloat          ; convert x3 to float 
||     MPYSP  .M1     A_lofloat,  A_2rm15,  A_float2 ; divide by 2^15      
||     MPYSP  .M2     B_hifloat,  B_2rm15,  B_float1 ; divide by 2^15       
||     STW    .D1T1   A_float0,   *A_r++[2]          ; store x0         
||[A_icntr] B      .S2     loop                      ; brnch               
||     LDW    .D2T2   *B_rtouch++[4],B_dummyload     ; touch memory    
         
          
       LDDW   .D1T1   *A_x++,     A_hi:A_lo          ; load 4 shorts       
||     INTSP  .L1     A_loshort,  A_lofloat          ; convert x0 to float 
||     EXT    .S2X    A_lo,       B_extreg, B_hishort; extract bits 16-31  
||     EXT    .S1     A_hi,       16, 16,   A_loshort; extract bits 0-15
||     MPYSP  .M2     B_hifloat,  B_2rm15,  B_float3 ; divide by 2^15        
||     STW    .D2T2   B_float1,   *B_r++[2]          ; store x1 
         
          
       INTSP  .L1     A_loshort,  A_lofloat          ; convert x2 to float 
||     INTSP  .L2     B_hishort,  B_hifloat          ; convert x1 to float 
||     EXT    .S2X    A_hi,       B_extreg, B_hishort; extract bits 16-31  
||     MPYSP  .M1     A_lofloat,  A_2rm15,  A_float0 ; divide by 2^15       
||     STW    .D1T1   A_float2,   *A_r++[2]          ; store x2
||     STW    .D2T2   B_float3,   *B_r++[2]          ; store x3 
||[A_icntr] SUB .S1   A_icntr,    1,        A_icntr  ; decr cntr             

*=========================== PIPE LOOP EPILOG ============================ *

skip_kernel:

       STW    .D1T1   A_float0,   *A_r++[2]          ; remaining stores 
||     SUB    .S1     A_cntmod4,         1,        A2        
||     B      .S2     B3                             ; return 
         
  [A2] STW    .D2T2   B_float1,   *B_r++[2]          ; conditional stores 
||[A2] SUB    .D1     A2,         1,        A2        
||     SHR    .S1     A_cntmod4,         2,        A1        

  [A2] STW    .D1T1   A_float2,   *A_r++[2]           
||[A1] STW    .D2T2   B_float3,   *B_r++[2]           

       NOP            3                               
       
       .end

* ======================================================================== *
*  End of file: DSPF_q15tofl.asm                                                *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_lms.asm/1117057371  0     0     0       21890     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_lms -- Double Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C callable, and has the following C prototype:       *
*                                                                           *
*      double DSPF_dp_lms (double *x,                                            *
*                     double *h,                                             *
*                     double *desired,                                      *
*                     double *r,                                            *
*                     double adaptrate,                                     *
*                     double error,                                         *
*                     int nh,                                               *
*                     int nr                                                *
*                     )                                                     *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  *
*      signal and a desired input signal, the filter produces an output     *
*      signal, the final coefficient values and returns the final output    *
*      error signal.                                                        *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*    1. The inner loop is unrolled Two times to allow update of             *
*       two coefficients in the kernel.                                     *
*                                                                           *
*    2. The 'error' term needs to be computed in the outer loop             *
*       before a new iteration of the inner loop can start. As a            *
*       result the prolog cannot be placed in parallel with epilog          *
*       (after the loop kernel).                                            *
*                                                                           *
*   3. Register sharing is used to make optimal use of available            *
*       registers.                                                          *
*                                                                           *
*    ASSUMPTIONS                                                            *
*    1. The inner loop counter must be a multiple of 2 and >=2.             *
*    2. Little endianness is assumed.                                       *
*    3. Extraneous loads are allowed in the program.                        *
*    4. The coefficient array is assumed to be in reverse order,            *
*       i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    This is the C equivalent of the Assembly Code without                  *
*    restrictions.                                                          *
*                                                                           *
*    Note that the assembly code is hand optimized and restrictions         *
*    may apply.                                                             *
*                                                                           *
*    double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou *e
*         int nr, double error)                                             *
*    {                                                                      *
*        int i,j;                                                           *
*        double sum;                                                        *
*                                                                           *
*        for (i = 0; i < nr; i++)                                           *
*        {                                                                  *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*            h[j] = h[j] + (ar*error*x[i+j-1]);                             *
*         }                                                                 *
*                                                                           *
*        sum = 0.0f;                                                        *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*           sum += h[j] * x[i+j];                                           *
*         }                                                                 *
*        y[i] = sum;                                                        *
*        error = d[i] - sum;                                                *
*       }                                                                   *
*       return error;                                                       *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
*  CYCLES                                                                   *
*     (4*nh + 47) nr + 27                                                   *
*     eg. for nh = 24 and nr = 36                                           *
*     cycles = 5175                                                         *
*                                                                           *
*  CODESIZE                                                                 *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_lms
_DSPF_dp_lms:

        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1     A4,             A3                  ;Pointer for Array x
 ||     MV          .L2     B4,             B3                  ;Pointer for Array h
 ||     MV          .S2X    A10,            B2                  ;Setting Inner Loop Counter

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     MV          .L1X    B8,             A4                  ;Loading 'error' in A5:A4
 ||     MVC         .S2     CSR,            B7                  ;Get CSR

        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable the interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     MV          .S1X    B9,             A5                  ;Loading 'error' in A5:A4

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MV          .L1     A10,            A14                 ;A14<--nh

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]

        STW         .D2     B3,             *B15--[02]          ;Pushing *H and *X into stack
 ||     STW         .D1     A3,             *A15--[02]

        STW         .D2     B6,             *B15--[02]          ;Pushing *R and *D into stack
 ||     STW         .D1     A6,             *A15--[02]
 ||     MV          .L2X    A8,             B8

        STW         .D2     B8,             *B15--[02]          ;Pushing ar into stack
 ||     STW         .D1     A9,             *A15--[02]
 ||     MV          .S1X    B10,            A2                  ;Setting OuterLoop Counter
 ||     MV          .L2X    A9,             B9

        MV          .L1X    B15,            A15                 ;A15<-- Stack Pointer
 ||     MV          .L2X    A8,             B8
**************************** BEGIN OF PROLOG ***************************************
oLoop:

        MPYDP       .M1X    A5:A4,          B9:B8,      A5:A4   ;A5:A4<--error*ar

        MV          .L2X    A14,            B2                  ;Set Inner Loop Counter

        ZERO        .L1     A10                                 ;Clear A11:A10
 ||     ZERO        .S1     A11

        ZERO        .L1     A12                                 ;Clear A13:A12

        LDDW        .D1     *-A3[01],       A1:A0               ;Load x[i+j-1]

        ZERO        .L1     A13

        NOP         2

        LDDW        .D1     *A3++[02],      A1:A0               ;Load x[i+j+1-1]

        MPYDP       .M1     A5:A4,          A1:A0,      A7:A6   ;A7:A6<-- error*ar*x[i+j-1]
 ||     SUB         .S2     B2,             02,         B2      ;Decrement Inner Loop Counter

        NOP         2

        LDDW        .D1     *-A3[01],       A1:A0               ;Load x[i+j-1]

        MPYDP       .M1     A5:A4,          A1:A0,      A9:A8   ;A9:A8<-- error*ar*x[i+j+1-1]
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;Load h[j]

        NOP         2

        LDDW        .D1     *A3++[02],      A1:A0               ;Load x[i+j+1-1]

        MPYDP       .M1     A5:A4,          A1:A0,      A7:A6   ;A7:A6<-- error*ar*x[i+j-1]
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;Load h[j+1]
 ||     SUB         .S2     B2,             02,         B2      ;Decrement Inner Loop Counter

        ADDDP       .L2X    B1:B0,          A7:A6,      B7:B6   ;h[j]+=error*ar*x[i+j-1]
        LDDW        .D1     *-A3[04],       B5:B4               ;Load x[i+j](2nd time)

        LDDW        .D1     *-A3[01],       A1:A0               ;Load x[i+j-1]

        MPYDP       .M1     A5:A4,          A1:A0,      A9:A8   ;A9:A8<-- error*ar*x[i+j+1-1]
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;Load h[j]

        ADDDP       .L2X    B1:B0,          A9:A8,      B9:B8   ;h[j+1]+=error*ar*x[i+j+1-1]

        LDDW        .D1     *-A3[03],       B11:B10             ;Load x[i+j+1](2nd time)

        LDDW        .D1     *A3++[02],      A1:A0               ;Load x[i+j+1-1]
 ||     MPYDP       .M2     B5:B4,          B7:B6,      B13:B12 ;P1=h[j]*x[i+j]
 ||     STW         .D2     B6,             *-B3[06]            ;Storing Updated h[j] 32LSB'S

        MPYDP       .M1     A5:A4,          A1:A0,      A7:A6   ;A7:A6<-- error*ar*x[i+j-1]
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;Load h[j+1]
 ||     SUB         .S2     B2,             02,         B2      ;Decrement Inner Loop Counter

        ADDDP       .L2X    B1:B0,          A7:A6,      B7:B6   ;h[j]+=error*ar*x[i+j-1]
 ||     STW         .D2     B7,             *-B3[07]            ;Storing Updated h[j] 32MSB'S
        LDDW        .D1     *-A3[04],       B5:B4               ;Load x[i+j](2nd time)

        LDDW        .D1     *-A3[01],       A1:A0               ;Load x[i+j-1]
 ||     MPYDP       .M2     B11:B10,        B9:B8,      B15:B14 ;P2=h[j+1]*x[i+j+1]
 ||     STW         .D2     B8,             *-B3[06]            ;Storing Updated h[j+1] 32LSB'S

        MPYDP       .M1     A5:A4,          A1:A0,      A9:A8   ;A9:A8<-- error*ar*x[i+j+1-1]
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;Load h[j]

***************************BEGIN OF KERNEL**************************************
iLoop:

        ADDDP       .L2X    B1:B0,      A9:A8,      B9:B8       ;h[j+1]+=error*ar*x[i+j+1-1]
 ||     STW         .D2     B9,         *-B3[07]                ;Storing Updated h[j+1] 32MSB'S

        LDDW        .D1     *-A3[03],       B11:B10             ;Load x[i+j+1](2nd time)

        LDDW        .D1     *A3++[02],      A1:A0               ;Load x[i+j+1-1]
 ||     MPYDP       .M2     B5:B4,          B7:B6,      B13:B12 ;P1=h[j]*x[i+j]
 ||[B2] B           iLoop
 ||     STW         .D2     B6,             *-B3[06]            ;Storing Updated h[j] 32LSB'S

   [B2] MPYDP       .M1     A5:A4,          A1:A0,      A7:A6   ;A7:A6<-- error*ar*x[i+j-1]
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;Load h[j+1]
 ||     ADDDP       .L1     A11:A10,        B13:B12,    A11:A10 ;S1+=P1
 ||[B2] SUB         .S2     B2,             02,         B2      ;Decrement innerLoop Counter
 ||[!B2]LDW         .D1     *+A15[05],      A6                  ;Loading Pointer for X

        ADDDP       .L2X    B1:B0,          A7:A6,      B7:B6   ;h[j]+=error*ar*x[i+j-1]
 ||     STW         .D2     B7,             *-B3[07]            ;Storing Updated h[j] 32MSB'S

        LDDW        .D1     *-A3[04],       B5:B4               ;Load x[0](2nd time)

        LDDW        .D1     *-A3[01],       A1:A0               ;Load x[i+j-1]
 ||     MPYDP       .M2     B11:B10,        B9:B8,      B15:B14 ;P2=h[j+1]*x[i+j+1]
 ||     STW         .D2     B8,             *-B3[06]            ;Storing Updated h[j+1] 32LSB'S

        MPYDP       .M1     A5:A4,          A1:A0,      A9:A8   ;A9:A8<-- error*ar*x[i+j+1-1]
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;Load h[j]
 ||     ADDDP       .L1     A13:A12,        B15:B14,    A13:A12 ;S2+=P2

**************************END OF KERNEL**************************************
*****************************************************************************
*****************************************************************************
************************START OF EPILOG**************************************

        ADDDP       .L2X    B1:B0,          A9:A8,      B9:B8   ;h[j+1]+=error*ar*x[i+j+1-1]
 ||     STW         .D2     B9,             *-B3[07]            ;Storing Updated h[j+1] 32MSB'S

        LDDW        .D1     *-A3[03],       B11:B10             ;Load x[i+j+1](2nd time)
        MPYDP       .M2     B5:B4,          B7:B6,      B13:B12 ;P1=h[j]*x[i+j]
 ||     STW         .D2     B6,             *-B3[06]            ;Storing Updated h[j] 32LSB'S
 ||     ADDAD       .D1     A6,             01,         A6      ;Updating Pointer For x[i]

        ADDDP       .L1     A11:A10,        B13:B12,    A11:A10 ;S1+=P1
 ||     STW         .D2     B7,             *-B3[05]            ;Storing Updated h[j] 32MSB'S

 ||     STW         .D1     A6,             *+A15[05]           ;Storing Updated Index for X
 ||     MV          .S1     A6,             A3                  ;Setting X Pointer

   [A2] SUB         .S1     A2,             01,         A2      ;Decrement the outer Loop Counter

        NOP         1

        MPYDP       .M2     B11:B10,        B9:B8,      B15:B14 ;P2=h[j+1]*x[i+j+1]
 ||     STW         .D2     B8,             *-B3[04]            ;Storing Updated h[j+1] 32LSB'S

        ADDDP       .L1     A13:A12,        B15:B14,    A13:A12 ;S2+=P2
 ||     STW         .D2     B9,             *-B3[03]            ;Storing Updated h[j+1] 32MSB'S

        LDW         .D1     *+A15[04],      B6                  ;Loading Pointer for Y

        LDW         .D1     *+A15[03],      B7                  ;Loading Pointer for D

        NOP         1

        ADDDP       .L1     A11:A10,        B13:B12,    A11:A10 ;S1+=P1

        NOP         1

        LDW         .D1     *+A15[02],      B8                  ;Loading ar

        LDW         .D1     *+A15[01],      B9                  ;Loading ar

        ADDDP       .L1     A13:A12,        B15:B14,    A13:A12 ;S2+=P2
************************END OF EPILOG**************************************
***************************************************************************
***************************************************************************
******************START OF OUTER LOOP INSRUCTIONS**************************
        LDDW        .D2     *B7,        A7:A6                   ;Loading d[i]

        ADDAD       .D2     B7,         1,      B7              ;Incrementing Pointer for d[i]

        STW         .D1     B7,         *+A15[03]               ;Storing Incremented d[i]

        NOP         2

        ADDDP       .L1     A11:A10,    A13:A12,        A11:A10 ;SUM=S1+S2

        NOP         5

    [A2]B           .S1     oLoop
 ||     SUBDP       .L1     A7:A6,      A11:A10,        A5:A4   ;error=d[i]-SUM

        LDW         .D1     *+A15[06],      B3                  ;Loading Pointer for H

        NOP         1

        STW         .D2     A10,        *B6++[01]               ;Storing r[i] 32 LSB'S

        STW         .D2     A11,        *B6++[01]               ;Storing r[i] 32 MSB'S

        STW         .D1     B6,         *+A15[04]               ;Storing *r
****************OUTER LOOP BRANCH OCCURS HERE********************************
        ADDAW       .D1     A15,    05,     A15                 ;Set Twin Sp's

        ADD         .L2     A15,    04,     B15;
 ||     LDW         .D2     *+B15[11],      B7                  ;Restoring CSR

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable the Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;
                .end

* ======================================================================== *
*  End of file: DSPF_dp_lms.asm                                                 *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_autocor/1117057372  733   0     0       18567     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_autocor -- double Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*                                                                           *
*       r  = Pointer to output array of autocorrelation of length nr        *
*       x  = Pointer to input array of length nx+nr. Input data must        *
*            be padded with nr consecutive zeros at the beginning.          *
*       nx = Length of autocorrelation vector.                              *
*       nr = Length of lags.                                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs the autocorrelation of the input array x.     *
*       is assumed that the length of the input array, x, is a              *
*       multiple of 2 and the length of the output array, r, is a           *
*       multiple of 4. The assembly routine computes 4 output samples       *
*       at a time. It is assumed that input vector x is padded with nr      *
*       no of zeros in the beginning.                                       *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice and the outer loop is unrolled  *
*       four times.                                                         *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 2 and greater than or equal to 4.            *
*       2. nr is a multiple of 4 and greater than or equal to 4.            *
*       3. nx is greater than or equal to nr                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*       {                                                                   *
*           int i,k;                                                        *
*           double sum;                                                     *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (k = nr; k < nx+nr; k++)                                *
*                   sum += x[k] * x[k-i];                                   *
*               r[i] = sum ;                                                *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*       interruptible.                                                      *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       2*nx*nr + 5/2*nr + 32                                               *
*       For nx=32 and nr=64, cycles=4258                                    *
*       For nx=24 and nr=32, cycles=1648                                    *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       576 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSPF_dp_autocor
_DSPF_dp_autocor:


        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     ADD         .L2X    B6,             A6,         B1      ;nx+nr

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     MVC         .S2     CSR,            B7

        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable Interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1,Twin SP's
 ||     ADDAD       .D2     B4,             B1,         B4      ;Set Pointer to x[nx+nr]
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     MV          .L1     B4,             A14                 ;Pointer for x[k-i]
 ||     MV          .L2     B4,             B14                 ;Pointer for x[k]

        LDDW        .D1     *--A14[01],     A1:A0               ;p-Load x[k-i]
 ||     LDDW        .D2     *--B14[01],     B3:B2               ;p-Load x[k]
 ||     MV          .L1     A4,             A7                  ;Pointer for r[i]
 ||     MV          .S1     B4,             A4                  ;Pointer for x[k-i]

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MV          .L2     B6,             B0                  ;Set Outerloop Counter nr
 ||     MV          .S2     A6,             B1                  ;Set Innerloop Counter nr

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]

        LDDW        .D1     *--A14[01],     A3:A2               ;p-Load x[k-1-i]
 ||     LDDW        .D2     *--B14[01],     B5:B4               ;p-Load x[k-1]

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]

        LDDW        .D1     *-A14[01],      A5:A4               ;p-Load x[k-2-i]

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]
 ||     MPYDP       .M1X    A1:A0,          B3:B2,      A7:A6   ;p-P11=x[k-i]*x[k]

        STW         .D2     B4,             *B15--[02]          ;Pushing address of h[i]into stack
 ||     STW         .D1     A4,             *A15--[02]          ;Pushing address of x[i]into stack

        LDDW        .D1     *-A14[02],      A1:A0               ;p-Load x[k-3-i]

        STW         .D2     A6,             *B15--[01]          ;Pushing nx into stack
 ||     MV          .L1     A7,             A15                 ;Pointer for r[i]
 ||     MPYDP       .M2X    B3:B2,          A3:A2,      B7:B6   ;p-P12=h[k-1-i]*x[k]

        ZERO        .L1     A10
 ||     ZERO        .S1     A11
 ||     ZERO        .L2     B10
 ||     ZERO        .S2     B11

        MPYDP       .M1X    A5:A4,          B3:B2,      A9:A8   ;P13=k[k-2-i]*x[k]

        ZERO        .L1     A12
 ||     ZERO        .S1     A13
 ||     ZERO        .L2     B12
 ||     ZERO        .S2     B13

        MPYDP       .M2X    B3:B2,          A1:A0,      B9:B8   ;P14=x[k-3-i]*x[k]

        LDDW        .D1     *-A14[03],      A3:A2               ;Load x[k-4-i]
 ||     SUB         .L2     B1,             02,         B1      ;Decrement Innerloop Counter

************************************************************************************
*********************************BEGIN OF KERNEL************************************
************************************************************************************
loop:

        MPYDP       .M1X    A3:A2,          B5:B4,      A7:A6   ;P21=x[k-1-i]*x[k-1]
 ||[!B1]LDW         .D2     *+B15[02],      A14                 ;o-Load x[k-i] Pointer

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P11
 ||[!B1]LDW         .D2     *+B15[03],      B14                 ;o-Load x[k] Pointer

        MPYDP       .M2X    B5:B4,          A5:A4,      B7:B6   ;P22=x[k-2-i]*x[k-1]

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P12
 ||[B1] LDDW        .D1     *--A14[01],     A1:A0               ;Load x[k-i]
 ||[B1] LDDW        .D2     *--B14[01],     B3:B2               ;Load x[k]

        MPYDP       .M1X    A1:A0,          B5:B4,      A9:A8   ;P23=x[k-3-i]*x[k-1]

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P13
 ||[B1] LDDW        .D1     *--A14[01],     A3:A2               ;Load x[k-1-i]
 ||[B1] LDDW        .D2     *--B14[01],     B5:B4               ;Load x[k-1]

        MPYDP       .M2X    B5:B4,          A3:A2,      B9:B8   ;P24=x[k-4-i]*x[k-1]
 ||[!B1]SUBAW       .D1     A14,            8,          A14     ;o-Update x[k-i] Pointer

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P14
 ||[B1] LDDW        .D1     *-A14[01],      A5:A4               ;Load x[k-2-i]

   [B1] MPYDP       .M1X    A1:A0,          B3:B2,      A7:A6   ;P11=x[k-i]*x[k]
 ||[!B1]STW         .D2     A14,            *+B15[02]           ;o-Store Updated Pointer of x[k-i]

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P21
 ||[B1] LDDW        .D1     *-A14[02],      A1:A0               ;Load x[k-3-i]

   [B1] B           .S1     loop
 ||[B1] MPYDP       .M2X    B3:B2,          A3:A2,      B7:B6   ;P12=x[k-1-i]*x[k]
 ||[!B1]LDDW        .D1     *--A14[01],     A1:A0               ;p-Load x[k-i]
 ||[!B1]LDDW        .D2     *--B14[01],     B3:B2               ;p-Load x[k]

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P22
 ||[!B1]LDW         .D2     *+B15[01],      B1                  ;o-Load nx

   [B1] MPYDP       .M1X    A5:A4,          B3:B2,      A9:A8   ;P13=x[k-2-i]*x[k]
 ||[!B1]LDDW        .D1     *--A14[01],     A3:A2               ;p-Load x[k-1-i]
 ||[!B1]LDDW        .D2     *--B14[01],     B5:B4               ;p-Load x[k-1]

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P23

   [B1] MPYDP       .M2X    B3:B2,          A1:A0,      B9:B8   ;P14=x[k-3-i]*x[k]
 ||[!B1]LDDW        .D1     *-A14[01],      A5:A4               ;p-Load x[k-2-i]

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P24
 ||[B1] LDDW        .D1     *-A14[03],      A3:A2               ;Load x[k-4-i]
 ||[B1] SUB         .S2     B1,             02,         B1      ;Decrement Innerloop Counter

************************************************************************************
***********************************END OF KERNEL************************************
************************************************************************************

        STW         .D1     A10,            *A15++[1]           ;o-Store r1
 ||[B0] SUB         .S2     B0,             04,         B0      ;o-Decrement Outerloop Counter
 ||     ZERO        .S1     A10
 ||[B0] MPYDP       .M1X    A1:A0,          B3:B2,      A7:A6   ;p-P11=x[k-i]*x[k]

   [B0] LDDW        .D1     *-A14[02],      A1:A0               ;p-Load x[k-i-3]

        STW         .D1     A11,            *A15++[1]           ;o-Store r1
 ||     ZERO        .S1     A11
 ||[B0] MPYDP       .M2X    B3:B2,          A3:A2,      B7:B6   ;p-P12=x[k-i-1]*x[k]

        STW         .D1     B10,            *A15++[1]           ;o-Store r2
 ||     ZERO        .S2     B10

   [B0] B           .S1     loop
 ||     STW         .D1     B11,            *A15++[1]           ;o-Store r2
 ||     ZERO        .S2     B11
 ||[B0] MPYDP       .M1X    A5:A4,          B3:B2,      A9:A8   ;p-P13=x[k-i-2]*x[k]

        STW         .D1     A12,            *A15++[1]           ;o-Store r3
 ||     ZERO        .S1     A12

        STW         .D1     A13,            *A15++[1]           ;o-Store r3
 ||[B0] MPYDP       .M2X    B3:B2,          A1:A0,      B9:B8   ;p-P14=x[k-i-3]*x[k]
 ||     ZERO        .S1     A13
 ||[!B0]ADD         .S2     B15,            12,         B15     ;Restore SP


        STW         .D1     B12,            *A15++[1]           ;o-Store r4
 ||     ZERO        .S2     B12

        STW         .D1     B13,            *A15++[1]           ;o-Store r4
 ||     ZERO        .S2     B13

   [B0] LDDW        .D1     *-A14[03],      A3:A2               ;p-Load x[k-i-4]
 ||[B0] SUB         .S2     B1,             02,         B1      ;p-Decrement Innerloop
 ||[!B0]SUB         .S1     B15,            4,          A15     ;Twin SP
 ||[!B0]LDW         .D2     *+B15[11],      B7                  ;Restore CSR

************************************************************************************
***************************OUTERLOOP BRANCH OCCURS HERE*****************************
************************************************************************************

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;
                .end

* ======================================================================== *
*  End of file: DSPF_dp_autocor.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_bitrev_/1117057373  754   0     0       27762     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C Callable and can be called as:                     *
*                                                                           *
*      void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                *
*                                                                           *
*      x      : Complex input array to be bit-reversed.                     *
*               Contains 2*nx doubles                                       *
*      index  : Array of size ~sqrt(nx) created by the routine              *
*               bitrev_index to allow the fast implementation of the        *
*               bit-reversal.                                               *
*      nx     : Number of elements in array x[]. Must be power of 2.        *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine performs the bit-reversal of the input array x[],       *
*      where x[] is a double array of length 2*nx containing Double         *
*      precision floating point complex pairs of data. This routine         *
*      requires the index array provided by the program below.              *
*      This index should be generated at compile time not by the DSP.       *
*                                                                           *
*      TI retains all rights, title and interest in this code and only      *
*      authorizes the use of the bit-reversal code and related table        *
*      generation code with TMS320-family DSPs manufactured by TI.          *
*                                                                           *
*      /* ----------------------------------------------------------- */    *
*      /*  This routine calculates the index for bit reversal of      */    *
*      /*  an array of length nx.  The length of the index table is   */    *
*      /*  2^(2*ceil(k/2)) where nx = 2^k.                            */    *
*      /*                                                             */    *
*      /*  In other words, the length of the index table is:          */    *
*      /*      - for even power of radix: sqrt(nx)                    */    *
*      /*      - for odd  power of radix: sqrt(2*nx)                  */    *
*      /* ----------------------------------------------------------- */    *
*      void bitrev_index(short *index, int nx)                              *
*      {                                                                    *
*          int   i, j, k, radix = 2;                                        *
*          short nbits, nbot, ntop, ndiff, n2, raddiv2;                     *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*              i = i >> 1;                                                  *
*              nbits++;                                                     *
*          }                                                                *
*                                                                           *
*          raddiv2 = radix >> 1;                                            *
*          nbot    = nbits >> raddiv2;                                      *
*          nbot    = nbot << raddiv2 - 1;                                   *
*          ndiff   = nbits & raddiv2;                                       *
*          ntop    = nbot + ndiff;                                          *
*          n2      = 1 << ntop;                                             *
*                                                                           *
*          index[0] = 0;                                                    *
*          for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  *
*          {                                                                *
*              index[i] = j - 1;                                            *
*                                                                           *
*              for (k = n2/radix; k*(radix-1) < j; k /= radix)              *
*                  j -= k*(radix-1);                                        *
*                                                                           *
*              j += k;                                                      *
*          }                                                                *
*          index[n2 - 1] = n2 - 1;                                          *
*      }                                                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*      1. nx must be a power of 2.                                          *
*      2. The table from bitrev_index is already created.                   *
*      3. The array x is actually an array of 2*nx doubles.                 *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                *
*       {                                                                   *
*          int    i;                                                        *
*          short  i0, i1, i2;                                               *
*          short  j0, j1, j2;                                               *
*          double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       *
*          double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       *
*          short  t;                                                        *
*          int    a, b, ia, ib, ibs;                                        *
*          int    mask;                                                     *
*          int    nbits, nbot, ntop, ndiff, n2, halfn;                      *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*             i = i >> 1;                                                   *
*             nbits++;                                                      *
*          }                                                                *
*                                                                           *
*          nbot    = nbits >> 1;                                            *
*          ndiff   = nbits & 1;                                             *
*          ntop    = nbot + ndiff;                                          *
*          n2       = 1 << ntop;                                            *
*          mask    = n2 - 1;                                                *
*          halfn   = nx >> 1;                                               *
*                                                                           *
*          for (i0 = 0; i0 < halfn; i0 += 2)                                *
*          {                                                                *
*              b       = i0 & mask;                                         *
*              a       = i0 >> nbot;                                        *
*              if (!b) ia = index[a];                                       *
*              ib      = index[b];                                          *
*              ibs     = ib << nbot;                                        *
*                                                                           *
*              j0      = ibs + ia;                                          *
*              t       = i0 < j0;                                           *
*              xi0r     = x[2*i0];                                          *
*              xi0i     = x[2*i0+1];                                        *
*              xj0r     = x[2*j0];                                          *
*              xj0i     = x[2*j0+1];                                           *
*              if (t)                                                       *
*              {                                                            *
*                 x[2*i0]   = xj0r;                                         *
*                 x[2*i0+1] = xj0i;                                         *
*                 x[2*j0]   = xi0r;                                         *
*                 x[2*j0+1] = xi0i;                                         *
*               }                                                           *
*                                                                           *
*              i1      = i0 + 1;                                            *
*              j1      = j0 + halfn;                                        *
*              xi1r    = x[2*i1];                                           *
*              xi1i    = x[2*i1+1];                                         *
*              xj1r    = x[2*j1];                                           *
*              xj1i    = x[2*j1+1];                                         *
*                                                                           *
*              x[2*i1]   = xj1r;                                            *
*              x[2*i1+1] = xj1i;                                            *
*              x[2*j1]   = xi1r;                                            *
*              x[2*j1+1] = xi1i;                                            *
*                                                                           *
*              i2      = i1 + halfn;                                        *
*              j2      = j1 + 1;                                            *
*                                                                           *
*              xi2r    = x[2*i2];                                           *
*              xi2i    = x[2*i2+1];                                         *
*              xj2r    = x[2*j2];                                           *
*              xj2i    = x[2*j2+1];                                         *
*              if (t)                                                       *
*              {                                                            *
*              x[2*i2]   = xj2r;                                            *
*              x[2*i2+1] = xj2i;                                            *
*              x[2*j2]   = xi2r;                                            *
*              x[2*j2+1] = xi2i;                                            *
*              }                                                            *
*            }                                                              *
*                                                                           *
*          }                                                                *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1. The index table can be generated using the bitrev_index           *
*         function provided in the dsplib\support\fft directory.            *
*      2. If nx <= 4K one can use the char (8-bit) data type for            *
*         the "index" variable. This would require changing the LDH when    *
*         loading index values in the assembly routine to LDB. This would   *
*         further reduce the size of the Index Table by half its size.      *
*                                                                           *
*      3. Endian: LITTLE ENDIAN configuration used.                         *
*                                                                           *
*      4. Interruptibility: This code is interrupt tolerant, but not        *
*         interruptible.                                                    *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      5*nx + 33                                                            *
*      e.g. nx = 128, cycles = 673                                          *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      736 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_bitrev_cplx
_DSPF_dp_bitrev_cplx:

        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     LMBD        .L1     1,              A6,         A5      ;To find log(n) base 2
 ||     MVK         .S1     31,             A7

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     SUB         .S1     A7,             A5,         A5      ;nbits
 ||     MVC         .S2     CSR,            B7                  ;Get CSR

        STW         .D2     B7,             *B15--[01]          ;Store the CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable Interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     SHR         .S2X    A5,             1,          B5      ;nbot

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     AND         .L2X    A5,             1,          B6      ;ndiff
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     ADD         .L2     B6,             B5,         B7      ;ntop
 ||     MVK         .S1     1,              A7

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]
 ||     SHL         .S2     A7,             B7,         B3      ;n2
 ||     ZERO        .L1     A0                                  ;ioc

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]
 ||     SUB         .L2     B3,             1,          B2      ;mask
 ||     SHR         .S1     A6,             1,          A3      ;halfn1
 ||     SHR         .S2     A0,             B5,         B3      ;a=i0>>nbot

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]
 ||     MV          .L1     A4,             A14                 ;x_l1
 ||     ADD         .L2     A4,             8,          B14     ;x_l2
 ||     MPY         .M1     A3,             2,          A6      ;halfn

        AND         .L2     A0,             B2,         B1      ;b=i0&mask
 ||     ZERO        .L1     A4

   [B1] LDHU        .D2     *B4[B3],        A4                  ;ia
 ||     ADD         .L1     A3,             4,          A3

        LDHU        .D2     *B4[B1],        A5                  ;ib
 ||     MV          .L1     A6,             A10                 ;halfn

        ADD         .L1     A0,             A0,         A11     ;i0
 ||     ADD         .S1     A0,             2,          A0      ;ioc+=2(for Next iteration)

        AND         .L2     A0,             B2,         B1      ;b=i0&mask(for Next iteration)

        SHR         .S2     A0,             B5,         B3      ;a=i0>>nbot(for Next iteration)

        NOP         1

        SHL         .S2     A5,             B5,         B10     ;ibs

        ADD         .S2     B10,            A4,         B11     ;j0

        ADD         .L2     B11,            B11,        B11     ;j0

        MV          .L2     A11,            B12                 ;i_t
 ||     MV          .L1     B11,            A12                 ;j_t
************************************************************************************
*****************************BEGIN OF KERNEL****************************************
************************************************************************************
loop:

        LDDW        .D1     *+A14[A11],     A7:A6               ;x[i0] Realpart
 ||     LDDW        .D2     *+B14[B12],     B7:B6               ;x[i0] Imagpart
 ||     ADD         .L1     A11,            2,          A13     ;i1=i0+1
 ||     ADD         .L2     B11,            A10,        B13     ;j1=j0+halfn

        LDDW        .D1     *+A14[A12],     A9:A8               ;x[j0] Realpart
 ||     LDDW        .D2     *+B14[B11],     B9:B8               ;x[j0] Imagpart
 ||     MV          .L1     B13,            A12                 ;j1_t
 ||     MV          .L2     A13,            B12                 ;i1_t

   [!B1]LDHU        .D2     *B4[B3],        A4                  ;ia
 ||     MPY         .M1     A11,            2,          A11
 ||     MPY         .M2     B11,            2,          B11
 ||     CMPLT       .L1     A11,            B11,        A2      ;t

        LDHU        .D2     *B4[B1],        A5                  ;ib
 ||     ADD         .L1     A0,             2,          A0      ;Increment loop Counter

        LDDW        .D1     *+A14[A12],     A9:A8               ;x[j1] Realpart
 ||     LDDW        .D2     *+B14[B13],     B9:B8               ;x[j1] Imagpart

        LDDW        .D1     *+A14[A13],     A7:A6               ;x[i1] Realpart
 ||     LDDW        .D2     *+B14[B12],     B7:B6               ;x[i1] Imagpart
 ||     MV          .L1     B11,            A12                 ;j0_t
 ||     MV          .L2     A11,            B12                 ;i0_t

   [A2] STW         .D1     A8,             *+A14[A11]          ;store x[j0] real part
 ||[A2] STW         .D2     B8,             *+B14[B12]          ;store x[j0] Imag part
 ||[A2] ADD         .L1     A11,            1,          A11
 ||[A2] ADD         .L2     A11,            1,          B12

   [A2] STW         .D1     A9,             *+A14[A11]          ;store x[j0] real part
 ||[A2] STW         .D2     B9,             *+B14[B12]          ;store x[j0] Imag part
 ||     ADD         .L1     A13,            A10,        A15     ;i2
 ||     ADD         .L2     B13,            2,          B0      ;j2

   [A2] STW         .D1     A6,             *+A14[A12]          ;store x[i0] real part
 ||[A2] STW         .D2     B6,             *+B14[B11]          ;store x[i0] Imag part
 ||[A2] ADD         .L1     B11,            1,          A12
 ||[A2] ADD         .L2     B11,            1,          B11
 ||     ADD         .S1     A0,             2,          A11

   [A2] STW         .D1     A7,             *+A14[A12]          ;store x[i0] real part
 ||[A2] STW         .D2     B7,             *+B14[B11]          ;store x[i0] Imag part
 ||     MV          .L1     B0,             A12                 ;j2_t
 ||     MV          .L2     A15,            B12                 ;i2_t
 ||     MPY         .M1     A13,            2,          A13
 ||     MPY         .M2     B13,            2,          B13

        LDDW        .D1     *+A14[A12],     A9:A8               ;x[j2] Realpart
 ||     LDDW        .D2     *+B14[B0],      B9:B8               ;x[j2] Imagpart
 ||     AND         .S2     A0,             B2,         B1      ;b=i0&mask(for Next iteration)

        LDDW        .D1     *+A14[A15],     A7:A6               ;x[i2] Realpart
 ||     LDDW        .D2     *+B14[B12],     B7:B6               ;x[i2] Imagpart
 ||     MV          .L1     B13,            A12                 ;j1_t
 ||     MV          .L2     A13,            B12                 ;i1_t

        STW         .D1     A8,             *+A14[A13]          ;store x[j1] real part
 ||     STW         .D2     B8,             *+B14[B12]          ;store x[j1] Imag part
 ||     ADD         .L1     A13,            1,          A13
 ||     ADD         .L2     A13,            1,          B12

        STW         .D1     A9,             *+A14[A13]          ;store x[j1] real part
 ||     STW         .D2     B9,             *+B14[B12]          ;store x[j1] Imag part
 ||     MPY         .M1     A15,            2,          A15
 ||     MPY         .M2     B0,             2,          B0
 ||     SHR         .S2     A0,             B5,         B3      ;a=i0>>nbot
 ||     CMPEQ       .L1     A0,             A3,         A1      ;Check the loop Condition

    [!A1]B          .S1     loop
 ||     STW         .D1     A6,             *+A14[A12]          ;store x[i1] real part
 ||     STW         .D2     B6,             *+B14[B13]          ;store x[i1] Imag part
 ||     ADD         .L1     B13,            1,          A12
 ||     ADD         .L2     B13,            1,          B13
 ||     SHL         .S2     A5,             B5,         B10     ;ibs

        STW         .D1     A7,             *+A14[A12]          ;store x[i1] real part
 ||     STW         .D2     B7,             *+B14[B13]          ;store x[i1] Imag part
 ||     MV          .L1     B0,             A12                 ;j2_t
 ||     MV          .L2     A15,            B12                 ;i2_t

   [A2] STW         .D1     A8,             *+A14[A15]          ;store x[j2] real part
 ||[A2] STW         .D2     B8,             *+B14[B12]          ;store x[j2] Imag part
 ||[A2] ADD         .L1     A15,            1,          A15
 ||[A2] ADD         .L2     A15,            1,          B12

   [A2] STW         .D1     A9,             *+A14[A15]          ;store x[j2] real part
 ||[A2] STW         .D2     B9,             *+B14[B12]          ;store x[j2] Imag part
 ||     ADD         .S2     B10,            A4,         B11     ;j0
 ||     ADD         .S1     A0,             A0,         A11

   [A2] STW         .D1     A6,             *+A14[A12]          ;store x[i2] real part
 ||[A2] STW         .D2     B6,             *+B14[B0]           ;store x[i2] Imag part
 ||[A2] ADD         .L1     B0,             1,          A12
 ||[A2] ADD         .L2     B0,             1,          B0
 ||     SUB         .S1     A11,            4,          A11
 ||     ADD         .S2     B11,            B11,        B11

   [A2] STW         .D1     A7,             *+A14[A12]          ;store x[i2] real part
 ||[A2] STW         .D2     B7,             *+B14[B0]           ;store x[i2] Imag part
 ||     MV          .L2     A11,            B12                 ;i0_t
 ||     MV          .L1     B11,            A12                 ;j0_t
****************************************************************************************
*******************************END OF LOOP**********************************************
****************************************************************************************

        SUB         .L1     B15,            04,         A15     ;Twin stack Pointer
 ||     LDW         .D2     *+B15[11],      B7                  ;Restore CSR

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12

        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable the interrupts

        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;


                .end

* ======================================================================== *
*  End of file: DSPF_dp_bitrev_cplx.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_cfftr4_/1117057374  779   0     0       35430     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      *
*      Frequency radix-4 FFT with complex input                            *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*   This routine is C Callable and can be called as:                        *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*                                                                           *
*   x : Pointer to an array holding the input and output floating           *
*       point array which contains 'n' complex points                       *
*   w : Pointer to an array holding the coefficient floating point          *
*       array which contains 3*n/4 complex numbers                          *
*   n : Number of complex points in x                                       *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*   This routine implements the DIF (decimation in frequency)               *
*   complex radix 4 FFT with digit-reversed output and normal               *
*   order input.  The number of points, 'n', must be a power                *
*   of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   *
*   in-place routine in the sense that the output is written                *
*   over the input.  It is not an in-place routine in the                   *
*   sense that the input is in normal order and the output is               *
*   in digit-reversed order.                                                *
*                                                                           *
*   There must be n complex points (2*n values), and 3*n/4 complex          *
*   coefficients (3*n/2 values).                                            *
*                                                                           *
*   Each real and imaginary input value is interleaved in the               *
*   'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             *
*   are in normal order.  Each real and imaginary output value              *
*   is interleaved in the 'x' array and the complex numbers are             *
*   in digit-reversed  order {rx0, ix0, ...}.  The real and                 *
*   imaginary values of the coefficients are interleaved in the             *
*   'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           *
*   are in normal order.                                                    *
*                                                                           *
*   Note that the imaginary coefficients are negated                        *
*   {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           *
*   {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       *
*   where d = 2*PI/n.  The value of w(n,k) is usually written               *
*   w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                *
*                                                                           *
*   The routine can be used to implement an inverse FFT by                  *
*   performing the complex conjugate on the input complex numbers           *
*   (negating the imaginary value), and dividing the result by n.           *
*   Another method to use the FFT to perform an inverse FFT, is to          *
*   swap the real and imaginary values of the input and the result,         *
*   and divide the result by n.  In either case, the input is still         *
*   in normal order and the output is still in digit-reversed order.        *
*                                                                           *
*   Note that you can not make the radix 4 FFT into an inverse              *
*   FFT by using the complex conjugate of the coefficients as               *
*   you can do with the complex radix 2 FFT.                                *
*                                                                           *
*   If you label the input locations from 0 to (n-1) (normal order),        *
*   the digit-reversed locations can be calculated by reversing the         *
*   order of the bit pairs of the labels.  For example, for a 1024          *
*   point FFT, the digit reversed location for                              *
*   617d = 1001101001b = 10 01 10 10 01  is                                 *
*   422d = 0110100110b = 01 10 10 01 10  and visa versa.                    *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*   1.  All the three loops are executed as one loop with                   *
*       conditional instructions.                                           *
*   2.  The outer loop counter is used as load counterto prevent            *
*       extraneous loads.                                                   *
*   3.  If more registers were available, the inner loop could              *
*       probably be as small as 28 cycles,but the loop was extended         *
*       to 56 cycles to allow more variables to share registers.            *
*   4.  The pointer for X and W are maintianed  on both register sides      *
*       to avoid crosspath Conflicts.                                       *
*   5.  Variable tctr is used as innerloop Counter.                          *
*   6.  The variable, K, is used as the outer loop counter.We are           *
*       finished when n2b = 0.                                              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*   1.  There are no special alignment requirements.                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent for the assembly code.  Note that              *
*   the assembly code is hand optimized and restrictions may                *
*   apply.                                                                  *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*   {                                                                       *
*       short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              *
*       double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               *
*       double si1, si2, si3;                                               *
*       n2 = n;                                                             *
*       ie = 1;                                                             *
*       for(k=n; k>1; k>>=2)                                                *
*       {                                                                   *
*          n1 = n2;                                                         *
*          n2 >>= 2;                                                        *
*          ia1 = 0;                                                         *
*          for(j=0; j<n2; j++)                                              *
*          {                                                                *
*              ia2 = ia1 + ia1;                                             *
*              ia3 = ia1 + ia2;                                             *
*              co1 = w[ia1*2];                                              *
*              si1 = w[ia1*2 + 1];                                          *
*              co2 = w[ia2*2];                                              *
*              si2 = w[ia2*2 + 1];                                          *
*              co3 = w[ia3*2];                                              *
*              si3 = w[ia3*2 + 1];                                          *
*              ia1 += ie;                                                   *
*              for(i0=j; i0<n; i0+=n1)                                      *
*              {                                                            *
*                  i1 = i0 + n2;                                            *
*                  i2 = i1 + n2;                                            *
*                  i3 = i2 + n2;                                            *
*                  r1 = x[i0*2]   + x[i2*2];                                *
*                  r3 = x[i0*2]   - x[i2*2];                                *
*                  s1 = x[i0*2+1] + x[i2*2+1];                              *
*                  s3 = x[i0*2+1] - x[i2*2+1];                              *
*                  r2 = x[i1*2]   + x[i3*2];                                *
*                  r4 = x[i1*2]   - x[i3*2];                                *
*                  s2 = x[i1*2+1] + x[i3*2+1];                              *
*                  s4 = x[i1*2+1] - x[i3*2+1];                              *
*                  x[i0*2]   = r1 + r2;                                     *
*                  r2        = r1 - r2;                                     *
*                  r1        = r3 - s4;                                     *
*                  r3        = r3 + s4;                                     *
*                  x[i0*2+1] = s1 + s2;                                     *
*                  s2        = s1 - s2;                                     *
*                  s1        = s3 + r4;                                     *
*                  s3        = s3 - r4;                                     *
*                  x[i1*2]   = co1*r3 + si1*s3;                             *
*                  x[i1*2+1] = co1*s3 - si1*r3;                             *
*                  x[i2*2]   = co2*r2 + si2*s2;                             *
*                  x[i2*2+1] = co2*s2 - si2*r2;                             *
*                  x[i3*2]   = co3*r1 + si3*s1;                             *
*                  x[i3*2+1] = co3*s1 - si3*r1;                             *
*             }                                                             *
*          }                                                                *
*          ie <<= 2;                                                        *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. The twiddle factor array w can be generated by the tw_r4fft       *
*         function provided in dsplib\support\fft\tw_r4fft.c. The exe       *
*         file for this function, dsplib\bin\tw_r4fft.exe, can be           *
*         used dump the twiddle factor array into a file.                   *
*      2. The function bit_rev in dsplib\support\fft can be used to         *
*         bit-reverse the output array to convert it into normal order.     *
*      3. Endian: This code is LITTLE  ENDIAN.                              *
*      4. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     14*n*log4(n) + 46                                                     *
*     eg. if n = 256, cycles = 14382.                                       *
*                                                                           *
*   CODESIZE                                                                *
*       1344 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_cfftr4_dif
_DSPF_dp_cfftr4_dif:

        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L2     A6,             B5                  ;n2
 ||     MVK         .S1     1,              A5                  ;ie
 ||     MVC         .S2     CSR,            B7                  ;get the CSR

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     SHR         .S2     B5,             2,          B6      ;tctr

        STW         .D2     B7,             *B15--[01]          ;Store the CSR
 ||     AND         .L2     -2,             B7,         B7      ;Disable the Interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     MV          .L2     B6,             B0                  ;kloop counter
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     MV          .L1     B5,             A6                  ;n1

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     SHR         .S2     B5,             2,          B5      ;n2>>=2
 ||     ZERO        .L1     A7                                  ;ia1
 ||     MV          .S1     A5,             A2                  ;i=ie
 ||     MV          .L2     B4,             B13                 ;Pointer for w

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]
 ||     SHL         .S2     A7,             1,          B7      ;ia2
 ||     MV          .L1     A4,             A12                 ;Pointer for x
 ||     ADD         .S1     B4,             8,          A13     ;t_w

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]
 ||     ADD         .L1     A7,             B7,         A8      ;ia3
 ||     ADD         .L2     A4,             8,          B12     ;t_x

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]
 ||     ADD         .L1     A7,             A5,         A9      ;t_ia1
 ||     ZERO        .S1     A10                                 ;t_i0

        STW         .D2     B5,             *B15--[02]          ;Pushing n2 and ie into stack
 ||     STW         .D1     A5,             *A15--[02]
 ||     ADD         .L1     A10,            B5,         A3      ;i1=i0+n2
 ||     MV          .S2     A9,             B9

        STW         .D2     B6,             *B15--[02]          ;Pushing tctr and n1 into stack
 ||     STW         .D1     A6,             *A15--[02]
 ||     ADD         .L2     A3,             B5,         B2      ;i2=i1+n2
 ||     MV          .S2     B6,             B1                  ;ictr

        STW         .D2     B7,             *B15--[02]          ;Pushing ia2  and ia1 into stack
 ||     STW         .D1     A7,             *A15--[02]
 ||     MV          .L2     A8,             B8
 ||     ZERO        .L1     A0

        STW         .D2     B8,             *B15--[02]          ;Pushing ia3 AND t_i0 into stack
 ||     STW         .D1     A10,            *A15--[02]
 ||     ADD         .L2     B2,             B5,         B3      ;i3=i2+n2
 ||     ADD         .S1     A0,             A0,         A0      ;2*i0
 ||     ADD         .S2     B2,             B2,         B2      ;2*i2

        STW         .D2     B9,             *B15--[02]          ;Pushing t_ia1 into stack
 ||     ADD         .S1     A3,             A3,         A3      ;2*i1
 ||     ADD         .S2     B3,             B3,         B3      ;2*i3
 ||     STW         .D1     A0,             *A15--[02]          ;i0 in to stack

        STW         .D2     A3,             *B15--[02]          ;pusing i1 and i2 into stack
 ||     STW         .D1     B2,             *A15--[02]
 ||     ZERO        .L1     A10                                 ;j

        STW         .D2     B3,             *B15--[01]          ;Pushing i3 into stack
 ||     MV          .L2     A0,             B14
 ||     STW         .D1     A10,            *A15                ;store j
 ||     SUB         .S2     B1,             1,          B1      ;Decrement Innerloop Counter

        STW         .D2     B2,             *B15[2]             ;Push i2 in to stack
 ||     STW         .D1     A0,             *A15[4]

        STW         .D2     A3,             *B15[3]             ;pusing i1 and i3 into stack
 ||     STW         .D1     B3,             *A15[1]

        LDDW        .D1     *A12[A0],       A5:A4               ;load x[i0] real part
 ||     LDDW        .D2     *B12[B14],      B5:B4               ;load x[i0] imag part
 ||     MV          .L2     A3,             B14                 ;t_b

        LDDW        .D1     *A12[A3],       A7:A6               ;load x[i1] real part
 ||     LDDW        .D2     *B12[B14],      B7:B6               ;load x[i1] imag part
 ||     MV          .L1     B2,             A14                 ;t_a

        LDDW        .D1     *A12[A14],      A9:A8               ;load x[i2] real part
 ||     LDDW        .D2     *B12[B2],       B9:B8               ;load x[i2] imag part
 ||     MV          .L1     B3,             A14                 ;t_a

        LDDW        .D1     *A12[A14],      A11:A10             ;load x[i3] real part
 ||     LDDW        .D2     *B12[B3],       B11:B10             ;load x[i3] imag part

        LDW         .D1     *+A15[6],       A3                  ;load t_i0
 ||     LDW         .D2     *+B15[10],      B3                  ;load n1

        NOP         2

        ADDDP       .L1     A5:A4,          A9:A8,      A5:A4   ;r1
 ||     ADDDP       .L2     B5:B4,          B9:B8,      B5:B4   ;s1

   [A2] SUB         .S1     A2,             1,          A2      ;i=i-1

        SUBDP       .L1     A5:A4,          A9:A8,      A9:A8   ;r3
 ||     SUBDP       .L2     B5:B4,          B9:B8,      B9:B8   ;s3
 ||     ADD         .S1     A3,             B3,         A3      ;t_i0=t_i0+n1

        STW         .D1     A3,             *+A15[6]            ;store t_i0
 ||[!A2]LDW         .D2     *B15,           B2                  ;Load j

        ADDDP       .L1     A7:A6,          A11:A10,    A7:A6   ;r2
 ||     ADDDP       .L2     B7:B6,          B11:B10,    B7:B6   ;s2
 ||[!A2]LDW         .D1     *+A15[12],      A3                  ;load ie,1

        LDW         .D1     *A15[8],        A1                  ;Load ia1
 ||[!A2]LDW         .D2     *+B15[5],       B3                  ;load t_ia1
 ||     MPY         .M1     B0,             1,          A0

        SUBDP       .L1     A7:A6,          A11:A10,    A11:A10 ;r4
 ||     SUBDP       .L2     B7:B6,          B11:B10,    B11:B10 ;s4
*************************************************************************************
*************************************************************************************
*************************************************************************************
iloop:

   [!B1]SHR         .S1     B0,             2,          A0      ;o-K=>>2
 ||[!B1]LDW         .D1     *+A15[12],      A0                  ;o-load ie
 ||     LDW         .D2     *+B15[4],       B0

   [!A2]ADD         .S2     B2,             1,          B2      ;j=j+1
 ||[!B1]LDW         .D2     *+B15[13],      B2                  ;o- load n2
 ||     STW         .D1     A0,             *-A15[01]           ;Store k loop Counter

   [!A2]STW         .D2     B2,             *+B15[6]            ;t_i0=j
 ||     LDW         .D1     *+A15[4],       A0

        ADDDP       .L1     A5:A4,          A7:A6,      A11:A10 ;sa1:sa0
 ||     ADDDP       .L2     B5:B4,          B7:B6,      B11:B10 ;sa3:sa2
 ||     ADD         .D1     A1,             A1,         A1      ;2*ia1
 ||[!A2]STW         .D2     B3,             *+B15[8]            ;ia1=t_ia1
 ||[!A2]ADD         .S1     A3,             B3,         A3      ;t_ia1+=ie
 ||[!B1]ZERO        .S2     B3                                  ;o- ia1=0
 ||[!B1]MPY         .M2     B2,             0,          B2
 ||[!B1]MPY         .M1     A14,            0,          A14

        MV          .S2     A1,             B14                 ;t_b
 ||[!A2]SHL         .S1     B3,             1,          A3      ;ia2=ia1<<1
 ||[!A2]STW         .D2     B2,             *B15                ;store j
 ||[!A2]STW         .D1     A3,             *+A15[5]            ;store t_ia1

        SUBDP       .L1X    A9:A8,          B11:B10,    A5:A4   ;r1
 ||     ADDDP       .L2X    B9:B8,          A11:A10,    B5:B4   ;s1,2
 ||[!B1]STW         .D2     B2,             *+B15[6]            ;o- t_i0=0
 ||[!B1]STW         .D1     A14,            *A15                ;o- reset j

        LDDW        .D1     *A13[A1],       A11:A10             ;load si1
 ||     LDDW        .D2     *B13[B14],      B11:B10             ;load co1
 ||[!B1]SHL         .S1     A0,             2,          A1      ;o- ie=<<2
 ||     ADD         .S2     B0,             B0,         B0

        ADDDP       .L1X    A9:A8,          B11:B10,    A9:A8   ;r3
 ||     SUBDP       .L2X    B9:B8,          A11:A10,    B9:B8   ;s3
 ||     ADD         .S1     A0,             A0,         A0      ;2*i0
 ||[!B1]STW         .D1     A1,             *A15[12]            ;store ie
 ||[!B1]STW         .D2     B2,             *+B15[10]           ;o-n1=n2
 ||[!B1]SHR         .S2     B2,             2,          B2      ;n2=>>2

        MV          .S2     B0,             B14
 ||     LDW         .D1     *+A15[9],       A0                  ;load ia2
 ||[!B1]STW         .D2     B2,             *+B15[13]           ;o-n1=n2

        SUBDP       .L1     A5:A4,          A7:A6,      A7:A6   ;r2
 ||     SUBDP       .L2     B5:B4,          B7:B6,      B7:B6   ;s2
 ||     STW         .D1     A10,            *A12[A0]            ;store x[2*i0] and x[2*i0+1]
 ||     STW         .D2     B10,            *B12[B14]
 ||     ADD         .S1     A0,             1,          A0
 ||     ADD         .S2     B0,             1,          B14

        STW         .D1     A11,            *A12[A0]            ;store x[2*i0] and x[2*i0+1];30
 ||     STW         .D2     B11,            *B12[B14]
 ||[!A2]ADD         .S2     A3,             B3,         B3      ;ia3=ia1+ia2

        LDW         .D1     *+A15[6],       A0                  ;Load t_i0
 ||     LDW         .D2     *+B15[13],      B2                  ;Load n2
 ||[!B1]ZERO        .S2     B2

   [!B1]STW         .D1     A1,             *A15[5]             ;o-store t_ia1
 ||[!B1]ZERO        .S2     B14
 ||[!B1]STW         .D2     B2,             *+B15[8]            ;store ia1

        MPYDP       .M1X    B11:B10,        A9:A8,      A9:A8   ;co1*r3
 ||     MPYDP       .M2X    A11:A10,        B9:B8,      B9:B8   ;si1*s3
 ||[!A2]STW         .D1     A3,             *+A15[9]            ;store ia2
 ||     LDW         .D2     *-B15[1],       B0                  ;Load k loop Counter

        LDW         .D1     *+A15[7],       A1                  ;load ia3
 ||[!B1]STW         .D2     B14,            *+B15[9]            ;o-store ia2

        ADD         .S1     A0,             A0,         A1      ;2*ia2

        NOP         1

        MPYDP       .M2     B11:B10,        B9:B8,      B9:B8   ;co1*s3
 ||     MPYDP       .M1     A11:A10,        A9:A8,      A9:A8   ;si1*r3
 ||     MV          .S2     A1,             B14
 ||[!A2]LDW         .D1     *+A15[12],      A2                  ;i=ie
 ||     ADD         .S1     A0,             B2,         A0      ;ni1

        LDDW        .D1     *A13[A1],       B11:B10             ;load si2
 ||     LDDW        .D2     *B13[B14],      A11:A10             ;load co2

        ADD         .S1     A1,             A1,         A1      ;2*ia3
 ||[!A2]STW         .D2     B3,             *+B15[7]            ;store ia3
 ||     ADD         .S2     A0,             B2,         B3      ;ni2
 ||[!B1]ZERO        .L2     B14

        ADD         .S2     B3,             B2,         B3      ;ni3;20
 ||     MV          .L2     B3,             B2                  ;ni2
 ||[!B1]STW         .D2     B14,            *+B15[7]            ;store ia3

        ADD         .S1     A0,             A0,         A0      ;n2*i1
 ||     ADD         .S2     B2,             B2,         B2      ;n2*i2

        ADDDP       .L1X    A9:A8,          B9:B8,      A9:A8   ;co1*r3+si1*s3
 ||     LDW         .D1     *+A15[3],       A3                  ;Load i1
 ||     ADD         .S2     B3,             B3,         B3      ;n2*i3

        MPYDP       .M1     A11:A10,        A7:A6,      A7:A6   ;co2*r2
 ||     MPYDP       .M2     B11:B10,        B7:B6,      B7:B6   ;si2*s2
 ||     LDW         .D2     *+B15[3],       B14                 ;Load i1

        LDW         .D1     *+A15[6],       A0                  ;Load t_i0

        MV          .S2     A1,             B14                 ;4

        SUBDP       .L2X    B9:B8,          A9:A8,      B9:B8   ;co1*s3-si1*r3
 ||     STW         .D1     A0,             *+A15[3]            ;store new i1

        ADD         .S1     A3,             A3,         A3      ;2* i1
 ||     LDDW        .D1     *A13[A1],       B11:B10             ;load si3
 ||     LDDW        .D2     *B13[B14],      A11:A10             ;load co3


        STW         .D1     A8,             *A12[A3]            ;store x[2*i1] real part
 ||     ADD         .S1     A3,             1,          A3
 ||     ADD         .S2     B14,            B14,        B14
 ||     MPYDP       .M1X    A11:A10,        B7:B6,      A7:A6   ;co2*s2
 ||     MPYDP       .M2X    B11:B10,        A7:A6,      B7:B6   ;si2*r2

        STW         .D1     A9,             *A12[A3]            ;store x[2*i1] real part
 ||     ADD         .L1     A0,             A0,         A0      ;n 2*i0
 ||     LDW         .D2     *+B15[2],       B8                  ;Load i2

        STW         .D1     A0,             *+a15[4]            ;Store new 2*i0, 10
 ||     LDW         .D2     *+B15[1],       B9                  ;Load i3

        LDW         .D1     *+A15[3],       A3                  ;load new i3

        STW         .D2     B8,             *B12[B14]           ;store x[2*i1] Imag part
 ||     ADD         .S2     B14,            1,          B14
 ||     ADDDP       .L1X    A7:A6,          B7:B6,      A7:A6   ;co2*r2+si2*s2

        MPYDP       .M1     A11:A10,        A5:A4,      A11:A10 ;co3*r1
 ||     MPYDP       .M2     B11:B10,        B5:B4,      B11:B10 ;si3*s1
 ||     STW         .D2     B9,             *B12[B14]           ;store x[2*i1] Imag part

        ADD         .S2     B8,             B8,         B8      ;2*i2
 ||[!B1]LDW         .D1     *+A15[12],      A2                  ;load ie to i

        STW         .D1     A0,         *A15[4]                 ;store new 2*i0
 ||     STW         .D2     B2,         *B15[2]                 ;store new 2*i2

        STW         .D2     B3,         *B15[1]                 ;store new 2*i3
 ||     MV          .S2     A0,         B14
 ||     LDW         .D1     *+A15[2],   A14

        SUBDP       .L2X    A7:A6,          B7:B6,      B7:B6   ;co2*s2-si2*r2
 ||     MV          .S1     B8,             A14
 ||     ADD         .S2     B9,             B9,         B9      ;2*i3
 ||     LDW         .D2     *+B15[3],       B14
 ||     LDW         .D1     *+A15[1],       A14

        STW         .D1     A6,             *A12[A14]           ;store x[2*i2] real part
 ||     ADD         .S1     A14,            1,          A14

        STW         .D1     A7,             *A12[A14]           ;store x[2*i2] real part
 ||     MPYDP       .M1X    A11:A10,        B5:B4,      A11:A10 ;co3*s1
 ||     MPYDP       .M2X    B11:B10,        A5:A4,      B11:B10 ;si3*r1

        LDDW        .D1     *A12[A0],       A5:A4               ;load x[i0] real part
 ||     LDDW        .D2     *B12[B14],      B5:B4               ;load x[i0] imag part

        LDDW        .D1     *A12[A14],      A9:A8               ;load x[i2] real part
 ||     LDDW        .D2     *B12[B2],       B9:B8               ;load x[i2] imag part

        LDDW        .D1     *A12[A3],       A7:A6               ;load x[i1] real part
 ||     LDDW        .D2     *B12[B14],      B7:B6               ;load x[i1] imag part

        STW         .D2     B6,             *B12[B8]            ;store x[2*i2] Imag part
 ||     ADD         .S2     B8,             1,          B8
 ||     ADDDP       .L1X    A11:A10,        B11:B10,    A1:A0   ;co3*r1+si3*s1

        STW         .D2     B7,             *B12[B8]            ;store x[2*i2] Imag part
 ||     MV          .S2     B9,             B2

        LDDW        .D1     *A12[A14],      A11:A10             ;load x[i3] real part
 ||     LDDW        .D2     *B12[B3],       B11:B10             ;load x[i3] imag part
 ||     MV          .S1     B9,             A14

        ADDDP       .L1     A5:A4,          A9:A8,      A5:A4   ;r1
 ||     ADDDP       .L2     B5:B4,          B9:B8,      B5:B4   ;s1

        LDW         .D1     *+A15[6],       A3                  ;load t_i0
 ||     LDW         .D2     *+B15[10],      B3                  ;load n1
 || [A2]SUB         .S1     A2,             1,          A2      ;i=i-1

        SUBDP       .L1X    A11:A10,        B11:B10,    A1:A0   ;co3*s1-si3*r1

        STW         .D1     A0,             *A12[A14]           ;store x[2*i3] real part
 ||     ADD         .S1     A14,            1,          A14
 ||[!B1]MV          .S2     B0,             B1
 ||[!B1]LDW         .D2     *+B15[11],      B1                  ;reset innerlloop pointer

   [B1] B           .S1     iloop
 ||     STW         .D1     A1,             *A12[A14]           ;store x[2*i3] real part
 ||[B0] SUBDP       .L1     A5:A4,          A9:A8,      A9:A8   ;r3
 ||[B0] SUBDP       .L2     B5:B4,          B9:B8,      B9:B8   ;s3

        LDW         .D1     *A15[8],        A1                  ;Load ia1
 ||[!A2]LDW         .D2     *+B15[5],       B3                  ;load t_ia1

        ADD         .S1     A3,             B3,         A3      ;t_i0=t_i0+n1
 ||[!A2]LDW         .D2     *B15,           B2                  ;Load j
 ||[B0] ADDDP       .L1     A7:A6,          A11:A10,    A7:A6   ;r2
 ||[B0] ADDDP       .L2     B7:B6,          B11:B10,    B7:B6   ;s2
 ||[!A2]LDW         .D1     *+A15[12],      A3                  ;load ie,1

        STW         .D1     A3,             *+A15[6]            ;store t_i0

        STW         .D2     A0,             *B12[B2]
 ||     ADD         .L2     B2,             1,          B2
 ||     MPY         .M1     B0,             1,          A0
 ||[B1] SUB         .S2     B1,             1,          B1      ;

        STW         .D2     A1,             *B12[B2]            ;store x[2*i3] Imag part
 ||[B0] SUBDP       .L1     A7:A6,          A11:A10,    A11:A10 ;r4
 ||[B0] SUBDP       .L2     B7:B6,          B11:B10,    B11:B10 ;s4
***************************************************************************************************
***************************************************************************************************
        ADDAW       .D2     B15,        13,         B15         ;restore Sp

        SUB         .S1     B15,        4,          A15         ;TWIN SP
 ||     LDW         .D2     *+B15[11],      B7                  ;Get The CSR Back to enable interrupts

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10

        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address

        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11

        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12

        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Set CSR

        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;
                .end

* ======================================================================== *
*  End of file: DSPF_dp_cfftr4_dif.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_cfftr2./1117057376  803   0     0       47918     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr2 -- Double Precision Cache Optimized radix 2 forward FFT    *
*      with complex input                                                  *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Feb-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*         This routine is C-callable and can be called as:                  *
*                                                                           *
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          *
*                                                                           *
*         x : input and output sequences (dim-n)      (input/output)        *
*             x has n complex numbers (2*n DP values).                      *
*             The real and imaginary values are interleaved in memory.      *
*             The input is in normal order and output is in bit-reversed    *
*             Order.                                                        *
*         w : FFT coefficients (dim-n)                (input)               *
*             w has n complex numbers (n DP values).                        *
*             FFT coeficients are in a special sequence so that FFT can     *
*             be called on smaller input sets multiple times to avoid       *
*             cache thrashing.                                              *
*             The real and imaginary values are interleaved in memory.      *
*         n : FFT size which is a power of 2 and > 4  (input)               *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*       This routine is used to compute the Complex, Radix-2, Fast          *
*       Fourier Transform of a double precision complex sequence of size    *
*       n, and a power of 2 in a Cache-friendly way. The routine requires   *
*       normal order input and normal order coefficents (twiddle factors)   *
*       in a special sequence and produces results that are in              *
*       bit-reversed order.                                                 *
*                                                                           *
*       The input can be broken into smaller parts and called multiple      *
*       times to avoid cache thrashing.                                     *
*                                                                           *
*       How to use                                                          *
*                                                                           *
*       void main(void)                                                     *
*       {                                                                   *
*          gen_w_r2(w, N);         // Generate coefficient table            *
*                                  // in normal order                       *
*                                  // Function is given in C-CODE section   *
*                                                                           *
*         DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in      *
*                                  // order bit-reversed                    *
*                                                                           *
*         bit_rev(x, N)           // Bit reverse the output if              *
*                                  // normal order output is needed         *
*                                  // Function is given in C-CODE section   *
*       }                                                                   *
*                                                                           *
*       main fft of size N can be divided into several steps (where         *
*       number of steps is a power of 2), allowing as much data             *
*       reuse as possible.                                                  *
*                                                                           *
*       For example the following function                                  *
*       DSPF_dp_cfftr2(N, x, w, 1);                                              *
*                                                                           *
*       is equivalent to:                                                   *
*                                                                           *
*       DSPF_dp_cfftr2(N, x, w, N/4);                                            *
*                                                                           *
*       DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                  *
*                                                                           *
*       Notice how the 1st fft function is called on the entire data set.   *
*       It covers the 1st pass of the fft until the butterfly size is       *
*       N/4. The following 4 ffts do N/4 point ffts, 25% of the original    *
*       size. These continue down to the end when the buttly is of size     *
*       2. We use an index of 2* 3/4 *N to the main twiddle factor array    *
*       for the last 4 calls. This is because the twiddle factor array      *
*       is composed of successively decimated versions of the main array.   *
*                                                                           *
*       The twiddle factor array is composed of log2(N) sets of twiddle     *
*       factors of size N, N/2, N/4, N/8 etc. The index into this array     *
*       for each stage of the fft can be calculated by summing these        *
*       indices up appropriately. For example, if we are dividing the       *
*       input into 2 parts then index into this array should be N, if we    *
*       are dividing into 4 parts then index into this array should be      *
*       N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array, in the    *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       The functions for creating this special sequence of twiddle         *
*       factors and bit-reversal are provided in the C CODE section.        *
*                                                                           *
*       In general if divide the input into NO_OF_DIV parts we can call     *
*       the function as follows:                                            *
*                                                                           *
*       // Divide the input into NO_OF_DIV parts                            *
*       DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                    *
*                                                                           *
*                                                                           *
*       // Find out the index into twiddle factor array                     *
*       for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       *
*       {                                                                   *
*          w_index += j;                                                    *
*       }                                                                   *
*       w_index = N * w_index / NO_OF_DIV;                                  *
*                                                                           *
*       // Call the Function a subset of inputs                             *
*       for(i=0; i<NO_OF_DIV; i++)                                          *
*       {                                                                   *
*          DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);   *
*       }                                                                   *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*       1. Outer loop instructions are executed in parallel with the        *
*          inner loop epilog.                                               *
*                                                                           *
*  ASSUMPTIONS                                                              *
*       1. Both input x and coefficient w should be aligned on double       *
*          word boundary.                                                   *
*       2. n should be greater than 4 and a power of 2.                     *
*                                                                           *
*  C CODE                                                                   *
*         This is the C equivalent of the assembly code without             *
*         restrictions. Note that the assembly code is hand optimized       *
*         and restrictions may apply.                                       *
*                                                                           *
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          *
*         {                                                                 *
*              int n2, ie, ia, i, j, k, m;                                  *
*              double rtemp, itemp, c, s;                                   *
*                                                                           *
*              n2 = n;                                                      *
*              ie = 1;                                                      *
*                                                                           *
*              for(k = n; k > n_min; k >>= 1)                               *
*               {                                                           *
*                 n2 >>= 1;                                                 *
*                 ia = 0;                                                   *
*                 for(j=0; j < ie; j++)                                     *
*                 {                                                         *
*                  for(i=0; i < n2; i++)                                    *
*                    {                                                      *
*                       c = w[2*i];                                         *
*                       s = w[2*i+1];                                       *
*                       m = ia + n2;                                        *
*                       rtemp     = x[2*ia]   - x[2*m];                     *
*                       x[2*ia]   = x[2*ia]   + x[2*m];                     *
*                       itemp     = x[2*ia+1] - x[2*m+1];                   *
*                       x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   *
*                       x[2*m]    = c*rtemp   - s*itemp;                    *
*                       x[2*m+1]  = c*itemp   + s*rtemp;                    *
*                       ia++;                                               *
*                      }                                                    *
*                   ia += n2;                                               *
*                  }                                                        *
*                 ie <<= 1;                                                 *
*                 w = w + k;                                                *
*              }                                                            *
*          }                                                                *
*                                                                           *
*          The follwoing C code is used to generate the coefficient table.  *
*                                                                           *
*           #include <math.h>                                               *
*           // generate real and imaginary twiddle                          *
*           //  table of size n complex numbers (or 2*n numbers)            *
*                                                                           *
*           void gen_w_r2(double* w, int n)                                 *
*           {                                                               *
*                int i, j=1;                                                *
*                double pi = 4.0*atan(1.0);                                 *
*                double e = pi*2.0/n;                                       *
*                for(j=1; j < n; j <<= 1)                                   *
*                {                                                          *
*                for(i=0; i < ( n>>1 ); i += j)                             *
*                   {                                                       *
*                   *w++   = cos(i*e);                                      *
*                   *w++   = -sin(i*e);                                     *
*                   }                                                       *
*                }                                                          *
*           }                                                               *
*                                                                           *
*                                                                           *
*           The follwoing C code is used to bit-reverse the output.         *
*                                                                           *
*           bit_rev(double* x, int n)                                       *
*           {                                                               *
*             int i, j, k;                                                  *
*             double rtemp, itemp;                                          *
*                                                                           *
*             j = 0;                                                        *
*             for(i=1; i < (n-1); i++)                                      *
*             {                                                             *
*               k = n >> 1;                                                 *
*                while(k <= j)                                              *
*                {                                                          *
*                   j -= k;                                                 *
*                   k >>= 1;                                                *
*                }                                                          *
*                j += k;                                                    *
*                if(i < j)                                                  *
*                {                                                          *
*                   rtemp    = x[j*2];                                      *
*                   x[j*2]   = x[i*2];                                      *
*                   x[i*2]   = rtemp;                                       *
*                   itemp    = x[j*2+1];                                    *
*                   x[j*2+1] = x[i*2+1];                                    *
*                   x[i*2+1] = itemp;                                       *
*                }                                                          *
*             }                                                             *
*           }                                                               *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. The special sequence of twiddle factor array w can be generated  *
*         using the gen_w_r2 function provided in the previous section.     *
*                                                                           *
*       2. Endian:This code is LITTLE ENDIAN.                               *
*                                                                           *
*       3. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*        4 * n * lg(n) + 16 * lg(n) + 34                                    *
*        eg. IF n = 64,  cycles = 1666                                      *
*        eg. IF n = 32,  cycles = 754                                       *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*        1408 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

            .asg   A4,           A_n
            .asg   B4,           B_x
            .asg   A6,           A_w
            .asg   B6,           B_n_min

            .asg   B15,          B_SP
            .asg   A15,          A_SP
            .asg   A0,           A_SP1

            .asg   A0,           A_stptr1
            .asg   A1,           A_i
            .asg   A2,           A_cst
            .asg   A3,           A_ldptr1
            .asg   A4,           A_itmp
            .asg   A5,           A_itmph
            .asg   A6,           A_s
            .asg   A7,           A_sh
            .asg   A8,           A_b1
            .asg   A9,           A_b1h
            .asg   A8,           A_ci
            .asg   A9,           A_cih
            .asg   A8,           A_cisr
            .asg   A9,           A_cisrh
            .asg   A10,          A_b2
            .asg   A11,          A_b2h
            .asg   A12,          A_si
            .asg   A13,          A_sih
            .asg   A12,          A_b12
            .asg   A13,          A_b12h
            .asg   A10,          A_w_tmp
            .asg   A14,          A_stptr

            .asg   B0,           B_stptr
            .asg   B1,           B_i1
            .asg   B2,           B_j
            .asg   B2,           B_k
            .asg   B3,           B_ldptr
            .asg   B4,           B_rtemp
            .asg   B5,           B_rtemph
            .asg   B6,           B_c
            .asg   B7,           B_ch
            .asg   B8,           B_a1
            .asg   B9,           B_a1h
            .asg   B10,          B_a2
            .asg   B11,          B_a2h
            .asg   B10,          B_sr
            .asg   B11,          B_srh
            .asg   B10,          B_crsi
            .asg   B11,          B_crsih
            .asg   B12,          B_cr
            .asg   B13,          B_crh
            .asg   B12,          B_a12
            .asg   B13,          B_a12h
            .asg   B14,          B_w
            .asg   B15,          B_w_tmp
            .asg   B8,           B_stptr1

            .asg   B7,           B_IRP
            .asg   B8,           B_AMR
            .asg   B9,           B_IER
            .asg   B9,           B_CSR
            .asg   B0,           B_IRP1
            .asg   B1,           B_AMR1
            .asg   B2,           B_IER1
            .asg   A0,           A_tmp
            .asg   B3,           B_RET
            .asg   A6,           A_st
            .asg   A7,           A_st1
            .asg   A14,          A_cst1
        .text
        .global _DSPF_dp_cfftr2
_DSPF_dp_cfftr2:

* ======================================================================== *
* ======================================================================== *

         SUBAW .D2   B_SP,           16,               B_SP             ;Save Stack space
||       MVC   .S2   CSR,            B_CSR                              ;Get CSR
||       SHL   .S1   A_n,            3,                A_cst            ;cst = 16*n2

         MV    .L1X  B_SP,           A_SP1                              ;Copy stack pointer
||       STW   .D2T2 B_CSR,          *B_SP[16]                          ;Save CSR
||       AND   .L2   B_CSR,          -2,               B_CSR            ;Disable gie

         STW   .D2T2 B_ldptr,        *B_SP[12]                          ;Save registers
||       STW   .D1T1 A_SP,           *A_SP1[6]                          ;Save registers
||       MVC   .S2   B_CSR,          CSR                                ;Disable interrupts
||       MV    .L1   A_SP1,          A_SP                               ;Save Stack Pointer
||       MV    .L2   B_x,            B_ldptr                            ;x_ldptr = x
||       ADD   .S1X  B_x,            A_cst,            A_ldptr1         ;x_ldptr1 = x+2*n2

         STW   .D1T1 A_b2,           *A_SP1[1]                          ;Save registers
||       STW   .D2T2 B_w,            *B_SP[11]                          ;Save registers
||       SHL   .S1   A_n,            3,                A_i              ;initialise i (16*n2 = 8*n)
||       SHR   .S2X  A_n,            1,                B_j              ;j=n/2

         STW   .D1T1 A_stptr,        *A_SP1[5]                          ;Save registers
||       STW   .D2T2 B_a12h,         *B_SP[10]                          ;Save registers
||       MV    .S2X  A_i,            B_i1                               ;i1 = 16*n2

         STW   .D1T1 A_b12h,         *A_SP1[4]                          ;Save registers
||       STW   .D2T2 B_a12,          *B_SP[9]                           ;Save registers
||       MV    .S2X  A_w,            B_w                                ;Copy w to B-side

         STW   .D1T1 A_b12,          *A_SP1[3]                          ;Save registers
||       STW   .D2T2 B_a2h,          *B_SP[8]                           ;Save registers

         STW   .D1T1 A_b2h,          *A_SP1[2]                          ;Save registers
||       STW   .D2T2 B_a2,           *B_SP[7]                           ;Save registers
||       MV    .S1   A_ldptr1,       A_stptr1                           ;x_stptr1=x_ldptr1
||       SUB   .S2   B_j,            3,                B_j              ;j = j - 3 (for epilog)

; =================================================================
; -------------------- PROLOG STARTS ------------------------------
; =================================================================

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       MVC   .S2   IRP,            B_IRP                              ;Save IRP

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MVC   .S2   AMR,            B_AMR                              ;Save AMR

         MVC   .S2   IER,            B_IER                              ;Save IER
||       STW   .D2T2 B_IRP,          *B_SP[13]                          ;Save registers

         STW   .D2T2 B_AMR,          *B_SP[14]                          ;Save registers
||       MVC   .S2X  A_n,            IER                                ;Save n
||       LMBD  .L2   1,              B_n_min,          B_n_min          ;To get outer loop ctr
||       LMBD  .L1   1,              A_n,              A_n              ;To get outer loop ctr

         STW   .D2T2 B_IER,          *B_SP[15]                          ;Save registers
||       MVC   .S2   B_x,            IRP                                ;Save x
||       SUB   .L2X  B_n_min,        A_n,              B_n_min          ;n_min = lg(n >> (n_min))

         MV    .D2   B_w,            B_w_tmp                            ;w_tmp = w
||       MVC   .S2   B_n_min,        AMR                                ;Save outer loop ctr

         ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i=i-16

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1

; ----------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;copy w_tmp to B-side

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1

         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c

         MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side

   [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w


OLOOP:

         STW   .D1T1 A_b12,          *A_stptr[2]                        ;Store b12
||       STW   .D2T2 B_a12,          *B_stptr                           ;Store a12

         STW   .D1T1 A_b12h,         *A_stptr[3]                        ;Store b12
||       STW   .D2T2 B_a12h,         *B_stptr[1]                        ;Store a12
||       ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i = i-16

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_sih:A_si       ;si = s * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_crh:B_cr       ;cr = c * rtemp

; --------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;Copy w_tmp to B-side

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MV    .S1X  B_c,            A_s                                ;Change side of c & s
||       MV    .S2X  A_s,            B_c                                ;Change side of c & s


         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
||       MV    .S1X  B_ch,           A_sh                               ;Change side of c & s
||       MV    .S2X  A_sh,           B_ch                               ;Change side of c & s


         MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_cih:A_ci       ;ci = c * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_srh:B_sr       ;sr = s * rtemp

   [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w

         STW   .D1T1 A_b12,          *A_stptr[2]                        ;Store b12
||       STW   .D2T2 B_a12,          *B_stptr                           ;Store a12

         STW   .D1T1 A_b12h,         *A_stptr[3]                        ;Store b12
||       STW   .D2T2 B_a12h,         *B_stptr[1]                        ;Store a12
||       ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i = i-16

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_sih:A_si       ;si = s * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_crh:B_cr       ;cr = c * rtemp

; --------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;Copy w_tmp to B-side

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MV    .S1X  B_c,            A_s                                ;Change side of c & s
||       MV    .S2X  A_s,            B_c                                ;Change side of c & s

         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
||       MV    .S1X  B_ch,           A_sh                               ;Change side of c & s
||       MV    .S2X  A_sh,           B_ch                               ;Change side of c & s

         SUBDP .L2X  B_crh:B_cr,     A_sih:A_si,       B_crsih:B_crsi   ;crsi = cr - si
||       MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_cih:A_ci       ;ci = c * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_srh:B_sr       ;sr = s * rtemp

         ADDDP .L1X  A_cih:A_ci,     B_srh:B_sr,       A_cisrh:A_cisr   ;cisr = ci + sr
|| [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w

; --------------------------------------------------------------------------------
; ------------------------------- KERNEL STARTS ----------------------------------
; --------------------------------------------------------------------------------

LOOP:

         STW   .D1T1 A_b12,          *A_stptr[2]                        ;Store b12
||       STW   .D2T2 B_a12,          *B_stptr                           ;Store a12
||[!B_i1]ADD   .S1   A_stptr1,       A_cst,            A_stptr1         ;if(!i1) x_stptr1 += 16*n2
||  [B_j]SUB   .S2   B_j,            1,                B_j              ;j = j - 1

         STW   .D1T1 A_b12h,         *A_stptr[3]                        ;Store b12
||       STW   .D2T2 B_a12h,         *B_stptr[1]                        ;Store a12
||       ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i = i-16
||[!B_i1]MV    .S2X  A_cst,          B_i1                               ;if(!i1) i1 = 16*n2

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16
||  [B_j]B     .S1   LOOP                                               ;Branch to inner loop
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_sih:A_si       ;si = s * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_crh:B_cr       ;cr = c * rtemp

; -----------------------------------------------------------------

    [B_j]LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||  [B_j]LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;Copy w_tmp to B-side
||       MV    .S2X  A_stptr1,       B_stptr1                           ;Copy stptr1 to B-side

    [B_j]LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||  [B_j]LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MV    .S1X  B_c,            A_s                                ;Change side of c & s
||       MV    .S2X  A_s,            B_c                                ;Change side of c & s

         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
||       MV    .S1X  B_ch,           A_sh                               ;Change side of c & s
||       MV    .S2X  A_sh,           B_ch                               ;Change side of c & s

         STW   .D1T2 B_crsi,         *A_stptr1++                        ;Store crsi
||       STW   .D2T1 A_cisr,         *B_stptr1[2]                       ;Store cisr
||       SUBDP .L2X  B_crh:B_cr,     A_sih:A_si,       B_crsih:B_crsi   ;crsi = cr - si
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_cih:A_ci       ;ci = c * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_srh:B_sr       ;sr = s * rtemp
||       MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       SUB   .S2   B_i1,           16,               B_i1             ;i1 = i1-16

         STW   .D1T2 B_crsih,        *A_stptr1++[3]                     ;Store crsi
||       STW   .D2T1 A_cisrh,        *B_stptr1[3]                       ;Store cisr
||       ADDDP .L1X  A_cih:A_ci,     B_srh:B_sr,       A_cisrh:A_cisr   ;cisr = ci + sr
|| [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w
         ;---------------------------------------------------------
         ; BRANCH OCCURS HERE ( EPILOG STARTS )
         ;---------------------------------------------------------

         STW   .D1T1 A_b12,          *A_stptr[2]                        ;Store b12
||       STW   .D2T2 B_a12,          *B_stptr                           ;Store a12
||[!B_i1]ADD   .S1   A_stptr1,       A_cst,            A_stptr1         ;if(!i1) x_stptr1 += 16*n2

         STW   .D1T1 A_b12h,         *A_stptr[3]                        ;Store b12
||       STW   .D2T2 B_a12h,         *B_stptr[1]                        ;Store a12
||[!B_i1]MV    .S2X  A_cst,          B_i1                               ;if(!i1) i1 = 16*n2

         SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_sih:A_si       ;si = s * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_crh:B_cr       ;cr = c * rtemp

; -----------------------------------------------------------------

         MV    .S2X  A_stptr1,       B_stptr1                           ;Copy stptr1 to B-side

         MV    .S1X  B_c,            A_s                                ;Change side of c & s
||       MV    .S2X  A_s,            B_c                                ;Change side of c & s

         MV    .S1X  B_ch,           A_sh                               ;Change side of c & s
||       MV    .S2X  A_sh,           B_ch                               ;Change side of c & s

         STW   .D1T2 B_crsi,         *A_stptr1++                        ;Store crsi
||       STW   .D2T1 A_cisr,         *B_stptr1[2]                       ;Store cisr
||       SUBDP .L2X  B_crh:B_cr,     A_sih:A_si,       B_crsih:B_crsi   ;crsi = cr - si
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_cih:A_ci       ;ci = c * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_srh:B_sr       ;sr = s * rtemp
||       MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       SUB   .S2   B_i1,           16,               B_i1             ;i1 = i1-16

         STW   .D1T2 B_crsih,        *A_stptr1++[3]                     ;Store crsi
||       STW   .D2T1 A_cisrh,        *B_stptr1[3]                       ;Store cisr
||       ADDDP .L1X  A_cih:A_ci,     B_srh:B_sr,       A_cisrh:A_cisr   ;cisr = ci + sr
    ; -------------------------------------------------------------
    ; ------------- ( EPILOG ENDS )
    ; -------------------------------------------------------------
  [!B_i1]ADD   .D1   A_stptr1,       A_cst,            A_stptr1         ;if(!i1) x_stptr1 += 16*n2
||       MVC   .S2   IRP,            B_ldptr                            ; p x_ldptr = x
||       SHR   .S1   A_cst,          1,                A_cst1           ; p n2 >> 1
||       ADD   .L2X  B_w,            A_cst,            B_w              ; p w = w + k

  [!B_i1]MV    .L2X  A_cst,          B_i1                               ;if(!i1) i1 = 16*n2
||       MVC   .S2   AMR,            B_k                                ; p counter = k
||       ADD   .S1X  B_ldptr,        A_cst1,           A_ldptr1         ; p x_ldptr1 = x + 2*n2

         MV    .S1   A_cst1,         A_i                                ; p i = 16 * n2
||       MV    .S2   B_w,            B_w_tmp                            ; p w_tmp = w
||       MV    .D1   A_ldptr1,       A_st                               ; p save x_stptr1=x_ldptr1

; -----------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       MV    .S2X  A_stptr1,       B_stptr1                           ;Copy stptr1 to B-side

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1

         NOP

         STW   .D1T2 B_crsi,         *A_stptr1++                        ;Store crsi
||       STW   .D2T1 A_cisr,         *B_stptr1[2]                       ;Store cisr
||       SUBDP .L2X  B_crh:B_cr,     A_sih:A_si,       B_crsih:B_crsi   ;crsi = cr - si
||       SUB   .S2   B_i1,           16,               B_i1             ;i1 = i1-16

         STW   .D1T2 B_crsih,        *A_stptr1++[3]                     ;Store crsi
||       STW   .D2T1 A_cisrh,        *B_stptr1[3]                       ;Store cisr
||       ADDDP .L1X  A_cih:A_ci,     B_srh:B_sr,       A_cisrh:A_cisr   ;cisr = ci + sr

  [!B_i1]ADD   .S1   A_stptr1,       A_cst,            A_stptr1         ;if(!i1) x_stptr1 += 16*n2
||       MV    .D1   A_cst1,         A_cst                              ; p (n2 = n2 >> 1)
||       SUB   .S2   B_k,            1,                B_k              ; p k = k - 1
||       MV    .L2X  A_cst1,         B_i1                               ; p i1 = 16*n2

         ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i = i-16
||       MVC   .S2   B_k,            AMR                                ; p Save outer loop ctr, k

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16
||  [B_k]B     .S1   OLOOP                                              ; p Branch to outer loop
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1

; -----------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;Copy w_tmp to B-side
||       MVC   .S2   IER,            B_j                                ; p j = n

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MV    .S1   A_stptr1,       A_st1                              ; p Copy x_stptr1
||       AND   .S2   B_j,            0xFFFFFFFC,       B_j              ; p Zero the last 2 bits

         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
||       MV    .S1   A_st,           A_stptr1                           ; p x_st_ptr1 = x + 2*n2
||       SHR   .S2   B_j,       1,                     B_j              ; p j = n/2
||       MV    .L2X  A_stptr1,       B_stptr1                           ;Copy stptr1 to B-side

         STW   .D1T2 B_crsi,         *A_st1                             ;Store crsi
||       STW   .D2T1 A_cisr,         *B_stptr1[2]                       ;Store cisr
||       MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       SUB   .S2   B_j,            3,                B_j              ; p j = j - 2 (for epilog)

         STW   .D1T2 B_crsih,        *A_st1[1]                          ;Store crsi
||       STW   .D2T1 A_cisrh,        *B_stptr1[3]                       ;Store cisr
|| [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w


; =================================================================

         MV    .S2X  A_SP,           B_SP                               ;Copy Stack pointer
||       LDW   .D1T2 *A_SP[12],      B_RET                              ;Restore registers

         LDW   .D1T1 *A_SP[1],       A_b2                               ;Restore registers
||       LDW   .D2T2 *B_SP[13],      B_IRP1                             ;Restore registers

         LDW   .D1T1 *A_SP[2],       A_b2h                              ;Restore registers
||       LDW   .D2T2 *B_SP[14],      B_AMR1                             ;Restore registers

         LDW   .D1T1 *A_SP[3],       A_b12                              ;Restore registers
||       LDW   .D2T2 *B_SP[15],      B_IER1                             ;Restore registers

         LDW   .D1T1 *A_SP[4],       A_b12h                             ;Restore registers
||       LDW   .D2T2 *B_SP[16],      B_CSR                              ;Restore registers

         LDW   .D1T1 *A_SP[5],       A_stptr                            ;Restore registers
||       LDW   .D2T2 *B_SP[7],       B_a2                               ;Restore registers

         LDW   .D1T1 *A_SP[6],       A_SP                               ;Restore registers
||       LDW   .D2T2 *B_SP[8],       B_a2h                              ;Restore registers
||       MVC   .S2   B_IRP1,         IRP

         LDW   .D2T1 *B_SP[9],       A_tmp                              ;Restore registers
||       LDW   .D1T2 *A_SP[10],      B_a12h                             ;Restore registers
||       B     .S2   B_RET                                              ;Return back to caller

         LDW   .D2T2 *B_SP[11],      B_w                                ;Restore registers
||       MVC   .S2   B_IER1,         IER                                ;Restore IER

         MVC   .S2   B_AMR1,         AMR                                ;Restore AMR

         ADDAW .D2   B_SP,           16,               B_SP             ;Restore stack space

         NOP

         MV    .L2X  A_tmp,          B_a12                              ;Restore registers
||       MVC   .S2   B_CSR,          CSR                                ;enable interrupts

         .end

* ======================================================================== *
*  End of file: DSPF_dp_cfftr2.asm                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_icfftr2/1117057377  823   0     0       54100     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      *
*      FFT with complex input                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      12-Feb-2004                                                         *
*                                                                          *
*  USAGE                                                                   *  
*                                                                          *  
*         This routine is C-callable and can be called as:                 *  
*                                                                          *  
*         void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)        *  
*                                                                          *  
*         x : input and output sequences (dim-n)      (input/output)       *  
*             x has n complex numbers (2*n DP values).                     *  
*             The real and imaginary values are interleaved in memory.     *  
*             The input is in normal order and output is in bit-reversed   *  
*             Order.                                                       *  
*         w : FFT coefficients (dim-n)                (input)              *  
*             w has n complex numbers (n DP values).                       *  
*             FFT coeficients are in a special sequence so that FFT can    *  
*             be called on smaller input sets multiple times to avoid      *  
*             cache thrashing.                                             *  
*             The real and imaginary values are interleaved in memory.     *  
*         n : FFT size which is a power of 2 and > 4  (input)              *  
*                                                                          *  
*                                                                          *  
*  DESCRIPTION                                                             *  
*                                                                          *  
*       This routine is used to compute the Inverse Complex, Radix-2, Fast *  
*       Fourier Transform of a double precision complex sequence of size   *  
*       n, and a power of 2 in a Cache-friendly way. The routine requires  *  
*       normal order input and normal order coefficents (twiddle factors)  *  
*       in a special sequence and produces results that are in             *  
*       bit-reversed order.                                                *  
*                                                                          *  
*       The input can be broken into smaller parts and called multiple     *  
*       times to avoid cache thrashing.                                    *  
*                                                                          *  
*       How to use                                                         *  
*                                                                          *  
*       void main(void)                                                    *  
*       {                                                                  *  
*          gen_w_r2(w, N);         // Generate coefficient table           *  
*                                  // in normal order                      *  
*                                  // Function is given in C-CODE section  *  
*                                                                          *  
*         DSPF_dp_icfftr2(N, x, w, 1);  // input in normal order, output in     *  
*                                  // order bit-reversed                   *  
*                                                                          *  
*         bit_rev(x, N)            // Bit reverse the output if            *  
*                                  // normal order output is needed        *  
*                                  // Function is given in C-CODE section  *  
*                                                                          *  
*         divide(x, N);            // scale inverse FFT output             *  
*                                  // result is the same as original       *  
*                                  // input                                *  
*                                                                          *  
*      }                                                                   *  
*                                                                          *  
*       main Inverse fft of size N can be divided into several steps (wher *  
*       number of steps is a power of 2), allowing as much data            *  
*       reuse as possible.                                                 *  
*                                                                          *  
*       For example the following function                                 *  
*       DSPF_dp_icfftr2(N, x, w, 1);                                            *  
*                                                                          *  
*       is equivalent to:                                                  *  
*                                                                          *  
*       DSPF_dp_icfftr2(N, x, w, N/4);                                          *  
*                                                                          *  
*       DSPF_dp_icfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                *  
*       DSPF_dp_icfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                *  
*       DSPF_dp_icfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                *  
*       DSPF_dp_icfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                *  
*                                                                          *  
*       Notice how the 1st icfft function is called on the entire data set *  
*       It covers the 1st pass of the fft until the butterfly size is      *  
*       N/4. The following 4 ffts do N/4 point ffts, 25% of the original   *  
*       size. These continue down to the end when the buttly is of size    *  
*       2. We use an index of 2* 3/4 *N to the main twiddle factor array   *  
*       for the last 4 calls. This is because the twiddle factor array     *  
*       is composed of successively decimated versions of the main array.  *  
*                                                                          *  
*       The twiddle factor array is composed of log2(N) sets of twiddle    *  
*       factors of size N, N/2, N/4, N/8 etc. The index into this array    *  
*       for each stage of the fft can be calculated by summing these       *  
*       indices up appropriately. For example, if we are dividing the      *  
*       input into 2 parts then index into this array should be N, if we   *  
*       are dividing into 4 parts then index into this array should be     *  
*       N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.  *  
*                                                                          *  
*       For multiple iffts they can share the same table by calling the    *  
*       small iffts from further down in the twiddle factor array, in the  *  
*       same way as the decomposition works for more data reuse.           *  
*                                                                          *  
*       The functions for creating this special sequence of twiddle        *  
*       factors and bit-reversal are provided in the C CODE section.       *  
*                                                                          *  
*       In general if divide the input into NO_OF_DIV parts we can call    *  
*       the function as follows:                                           *  
*                                                                          *  
*       // Divide the input into NO_OF_DIV parts                           *  
*       DSPF_dp_icfftr2(N, x, w, N/NO_OF_DIV);                                  *  
*                                                                          *  
*                                                                          *  
*       // Find out the index into twiddle factor array                    *  
*       for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                      *  
*       {                                                                  *  
*          w_index += j;                                                   *  
*       }                                                                  *  
*       w_index = N * w_index / NO_OF_DIV;                                 *  
*                                                                          *  
*       // Call the Function a subset of inputs                            *  
*       for(i=0; i<NO_OF_DIV; i++)                                         *  
*       {                                                                  *  
*          DSPF_dp_icfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1); *  
*       }                                                                  *  
*                                                                          *  
*  TECHNIQUES                                                              *  
*                                                                          *  
*       1. Outer loop instructions are executed in parallel with the       *  
*          inner loop epilog.                                              *  
*                                                                          *  
*  ASSUMPTIONS                                                             *  
*                                                                          *  
*       1. Both input x and coefficient w should be aligned on double      *  
*          word boundary.                                                  *  
*       2. n should be greater than 4 and a power of 2.                    *  
*                                                                          *  
*  C CODE                                                                  *  
*                                                                          *  
*         This is the C equivalent of the assembly code without            *  
*         restrictions. Note that the assembly code is hand optimized      *  
*         and restrictions may apply.                                      *  
*                                                                          *  
*         void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)        *  
*         {                                                                *  
*              int n2, ie, ia, i, j, k, m;                                 *  
*              double rtemp, itemp, c, s;                                  *  
*                                                                          *  
*              n2 = n;                                                     *  
*              ie = 1;                                                     *  
*                                                                          *  
*              for(k = n; k > n_min; k >>= 1)                              *  
*               {                                                          *  
*                 n2 >>= 1;                                                *  
*                 ia = 0;                                                  *  
*                 for(j=0; j < ie; j++)                                    *  
*                 {                                                        *  
*                  for(i=0; i < n2; i++)                                   *  
*                    {                                                     *  
*                       c = w[2*i];                                        *  
*                       s = w[2*i+1];                                      *  
*                       m = ia + n2;                                       *  
*                       rtemp     = x[2*ia]   - x[2*m];                    *  
*                       x[2*ia]   = x[2*ia]   + x[2*m];                    *  
*                       itemp     = x[2*ia+1] - x[2*m+1];                  *  
*                       x[2*ia+1] = x[2*ia+1] + x[2*m+1];                  *  
*                       x[2*m]    = c*rtemp   + s*itemp;                   *  
*                       x[2*m+1]  = c*itemp   - s*rtemp;                   *  
*                       ia++;                                              *  
*                      }                                                   *  
*                   ia += n2;                                              *  
*                  }                                                       *  
*                 ie <<= 1;                                                *  
*                 w = w + k;                                               *  
*              }                                                           *  
*          }                                                               *  
*                                                                          *  
*          The follwoing C code is used to generate the coefficient table. *  
*                                                                          *  
*           #include <math.h>                                              *  
*           // generate real and imaginary twiddle                         *  
*           // table of size n complex numbers (or 2*n numbers)            *  
*                                                                          *  
*           void gen_w_r2(double* w, int n)                                *  
*           {                                                              *  
*                int i, j=1;                                               *  
*                double pi = 4.0*atan(1.0);                                *  
*                double e = pi*2.0/n;                                      *  
*                for(j=1; j < n; j <<= 1)                                  *  
*                {                                                         *  
*                for(i=0; i < ( n>>1 ); i += j)                            *  
*                   {                                                      *  
*                   *w++   = cos(i*e);                                     *  
*                   *w++   = -sin(i*e);                                    *  
*                   }                                                      *  
*                }                                                         *  
*           }                                                              *  
*                                                                          *  
*                                                                          *  
*           The follwoing C code is used to bit-reverse the output.        *  
*                                                                          *  
*           bit_rev(double* x, int n)                                      *  
*           {                                                              *  
*             int i, j, k;                                                 *  
*             double rtemp, itemp;                                         *  
*                                                                          *  
*             j = 0;                                                       *  
*             for(i=1; i < (n-1); i++)                                     *  
*             {                                                            *  
*               k = n >> 1;                                                *  
*                while(k <= j)                                             *  
*                {                                                         *  
*                   j -= k;                                                *  
*                   k >>= 1;                                               *  
*                }                                                         *  
*                j += k;                                                   *  
*                if(i < j)                                                 *  
*                {                                                         *  
*                   rtemp    = x[j*2];                                     *  
*                   x[j*2]   = x[i*2];                                     *  
*                   x[i*2]   = rtemp;                                      *  
*                   itemp    = x[j*2+1];                                   *  
*                   x[j*2+1] = x[i*2+1];                                   *  
*                   x[i*2+1] = itemp;                                      *  
*                }                                                         *  
*             }                                                            *  
*           }                                                              *  
*                                                                          *  
*       The follwoing C code is used to perform the final scaling          *  
*       of the IFFT:                                                       *  
*                                                                          *  
*       // divide each element of x by n                                   *  
*                                                                          *  
*       divide(double* x, int n)                                           *  
*       {                                                                  *  
*         int i;                                                           *  
*         double inv = 1.0 / n;                                            *  
*                                                                          *  
*          for(i=0; i < n; i++)                                            *  
*           {                                                              *  
*               x[2*i] = inv * x[2*i];                                     *  
*               x[2*i+1] = inv * x[2*i+1];                                 *  
*             }                                                            *  
*        }                                                                 *  
*                                                                          *  
*  NOTES                                                                   *  
*                                                                          *  
*       1. The special sequence of twiddle factor array w can be generated *  
*         using the gen_w_r2 function provided in the previous section.    *  
*                                                                          *  
*       2. Endian:This code is LITTLE ENDIAN.                              *  
*                                                                          *  
*       3. Interruptibility: This code is interrupt-tolerant but not       *  
*          interruptible.                                                  *  
*                                                                          *  
*  CYCLES                                                                  *  
*                                                                          *  
*        4 * n * lg(n) + 16 * lg(n) + 34                                   *  
*        eg. IF n = 64,  cycles = 1666                                     *  
*        eg. IF n = 32,  cycles = 754                                      *  
*                                                                          *  
*  CODESIZE                                                                *  
*                                                                          *  
*        1408 bytes                                                        *  
* ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *


            .asg   A4,           A_n
            .asg   B4,           B_x
            .asg   A6,           A_w
            .asg   B6,           B_n_min
            
            .asg   B15,          B_SP
            .asg   A15,          A_SP
            .asg   A0,           A_SP1
            
            .asg   A0,           A_stptr1
            .asg   A1,           A_i
            .asg   A2,           A_cst
            .asg   A3,           A_ldptr1
            .asg   A4,           A_itmp
            .asg   A5,           A_itmph
            .asg   A6,           A_s
            .asg   A7,           A_sh
            .asg   A8,           A_b1
            .asg   A9,           A_b1h
            .asg   A8,           A_ci
            .asg   A9,           A_cih
            .asg   A8,           A_cisr
            .asg   A9,           A_cisrh
            .asg   A10,          A_b2
            .asg   A11,          A_b2h
            .asg   A12,          A_si
            .asg   A13,          A_sih
            .asg   A12,          A_b12
            .asg   A13,          A_b12h
            .asg   A10,          A_w_tmp
            .asg   A14,          A_stptr

            .asg   B0,           B_stptr
            .asg   B1,           B_i1
            .asg   B2,           B_j
            .asg   B2,           B_k
            .asg   B3,           B_ldptr
            .asg   B4,           B_rtemp
            .asg   B5,           B_rtemph
            .asg   B6,           B_c
            .asg   B7,           B_ch
            .asg   B8,           B_a1
            .asg   B9,           B_a1h
            .asg   B10,          B_a2
            .asg   B11,          B_a2h
            .asg   B10,          B_sr
            .asg   B11,          B_srh
            .asg   B10,          B_crsi
            .asg   B11,          B_crsih
            .asg   B12,          B_cr
            .asg   B13,          B_crh
            .asg   B12,          B_a12
            .asg   B13,          B_a12h
            .asg   B14,          B_w
            .asg   B15,          B_w_tmp
            .asg   B8,           B_stptr1
            
            .asg   B7,           B_IRP
            .asg   B8,           B_AMR
            .asg   B9,           B_IER
            .asg   B9,           B_CSR
            .asg   B0,           B_IRP1
            .asg   B1,           B_AMR1
            .asg   B2,           B_IER1
            .asg   A0,           A_tmp
            .asg   B3,           B_RET
            .asg   A6,           A_st
            .asg   A7,           A_st1
            .asg   A14,          A_cst1

        .text
        .global _DSPF_dp_icfftr2
_DSPF_dp_icfftr2:


         SUBAW .D2   B_SP,           16,               B_SP             ;Save Stack space 
||       MVC   .S2   CSR,            B_CSR                              ;Get CSR
||       SHL   .S1   A_n,            3,                A_cst            ;cst = 16*n2

         MV    .L1X  B_SP,           A_SP1                              ;Copy stack pointer
||       STW   .D2T2 B_CSR,          *B_SP[16]                          ;Save CSR
||       AND   .L2   B_CSR,          -2,               B_CSR            ;Disable gie

         STW   .D2T2 B_ldptr,        *B_SP[12]                          ;Save registers
||       STW   .D1T1 A_SP,           *A_SP1[6]                          ;Save registers
||       MVC   .S2   B_CSR,          CSR                                ;Disable interrupts
||       MV    .L1   A_SP1,          A_SP                               ;Save Stack Pointer
||       MV    .L2   B_x,            B_ldptr                            ;x_ldptr = x
||       ADD   .S1X  B_x,            A_cst,            A_ldptr1         ;x_ldptr1 = x+2*n2

         STW   .D1T1 A_b2,           *A_SP1[1]                          ;Save registers                    
||       STW   .D2T2 B_w,            *B_SP[11]                          ;Save registers     
||       SHL   .S1   A_n,            3,                A_i              ;initialise i (16*n2 = 8*n)
||       SHR   .S2X  A_n,            1,                B_j              ;j=n/2

         STW   .D1T1 A_stptr,        *A_SP1[5]                          ;Save registers    
||       STW   .D2T2 B_a12h,         *B_SP[10]                          ;Save registers  
||       MV    .S2X  A_i,            B_i1                               ;i1 = 16*n2

         STW   .D1T1 A_b12h,         *A_SP1[4]                          ;Save registers                                      
||       STW   .D2T2 B_a12,          *B_SP[9]                           ;Save registers                   
||       MV    .S2X  A_w,            B_w                                ;Copy w to B-side

         STW   .D1T1 A_b12,          *A_SP1[3]                          ;Save registers                    
||       STW   .D2T2 B_a2h,          *B_SP[8]                           ;Save registers                               

         STW   .D1T1 A_b2h,          *A_SP1[2]                          ;Save registers                                
||       STW   .D2T2 B_a2,           *B_SP[7]                           ;Save registers
||       MV    .S1   A_ldptr1,       A_stptr1                           ;x_stptr1=x_ldptr1       
||       SUB   .S2   B_j,            3,                B_j              ;j = j - 3 (for epilog)         

; =================================================================
; -------------------- PROLOG STARTS ------------------------------
; =================================================================
         
         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       MVC   .S2   IRP,            B_IRP                              ;Save IRP

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1   
||       MVC   .S2   AMR,            B_AMR                              ;Save AMR
  
         MVC   .S2   IER,            B_IER                              ;Save IER
||       STW   .D2T2 B_IRP,          *B_SP[13]                          ;Save registers

         STW   .D2T2 B_AMR,          *B_SP[14]                          ;Save registers
||       MVC   .S2X  A_n,            IER                                ;Save n                
||       LMBD  .L2   1,              B_n_min,          B_n_min          ;To get outer loop ctr
||       LMBD  .L1   1,              A_n,              A_n              ;To get outer loop ctr
         
         STW   .D2T2 B_IER,          *B_SP[15]                          ;Save registers
||       MVC   .S2   B_x,            IRP                                ;Save x                                
||       SUB   .L2X  B_n_min,        A_n,              B_n_min          ;n_min = lg(n >> (n_min))                

         MV    .D2   B_w,            B_w_tmp                            ;w_tmp = w
||       MVC   .S2   B_n_min,        AMR                                ;Save outer loop ctr
         
         ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2            
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i=i-16

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1

; ----------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2                
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;copy w_tmp to B-side

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1

         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
         
         MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
         
   [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w


OLOOP:

         STW   .D1T1 A_b12,          *A_stptr[2]                        ;Store b12
||       STW   .D2T2 B_a12,          *B_stptr                           ;Store a12

         STW   .D1T1 A_b12h,         *A_stptr[3]                        ;Store b12
||       STW   .D2T2 B_a12h,         *B_stptr[1]                        ;Store a12
||       ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2            
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i = i-16

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_sih:A_si       ;si = s * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_crh:B_cr       ;cr = c * rtemp

; --------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;Copy w_tmp to B-side

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MV    .S1X  B_c,            A_s                                ;Change side of c & s
||       MV    .S2X  A_s,            B_c                                ;Change side of c & s


         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
||       MV    .S1X  B_ch,           A_sh                               ;Change side of c & s
||       MV    .S2X  A_sh,           B_ch                               ;Change side of c & s


         MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_cih:A_ci       ;ci = c * itemp 
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_srh:B_sr       ;sr = s * rtemp
         
   [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w

         STW   .D1T1 A_b12,          *A_stptr[2]                        ;Store b12
||       STW   .D2T2 B_a12,          *B_stptr                           ;Store a12

         STW   .D1T1 A_b12h,         *A_stptr[3]                        ;Store b12
||       STW   .D2T2 B_a12h,         *B_stptr[1]                        ;Store a12
||       ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2            
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i = i-16

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_sih:A_si       ;si = s * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_crh:B_cr       ;cr = c * rtemp

; --------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;Copy w_tmp to B-side

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MV    .S1X  B_c,            A_s                                ;Change side of c & s
||       MV    .S2X  A_s,            B_c                                ;Change side of c & s

         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
||       MV    .S1X  B_ch,           A_sh                               ;Change side of c & s
||       MV    .S2X  A_sh,           B_ch                               ;Change side of c & s

         ADDDP .L2X  B_crh:B_cr,     A_sih:A_si,       B_crsih:B_crsi   ;crsi = cr + si
||       MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_cih:A_ci       ;ci = c * itemp 
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_srh:B_sr       ;sr = s * rtemp

         SUBDP .L1X  A_cih:A_ci,     B_srh:B_sr,       A_cisrh:A_cisr   ;cisr = ci - sr
|| [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w

; --------------------------------------------------------------------------------
; ------------------------------- KERNEL STARTS ----------------------------------
; --------------------------------------------------------------------------------

LOOP: 

         STW   .D1T1 A_b12,          *A_stptr[2]                        ;Store b12
||       STW   .D2T2 B_a12,          *B_stptr                           ;Store a12
||[!B_i1]ADD   .S1   A_stptr1,       A_cst,            A_stptr1         ;if(!i1) x_stptr1 += 16*n2
||  [B_j]SUB   .S2   B_j,            1,                B_j              ;j = j - 1

         STW   .D1T1 A_b12h,         *A_stptr[3]                        ;Store b12
||       STW   .D2T2 B_a12h,         *B_stptr[1]                        ;Store a12
||       ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2            
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i = i-16
||[!B_i1]MV    .S2X  A_cst,          B_i1                               ;if(!i1) i1 = 16*n2

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
||  [B_j]B     .S1   LOOP                                               ;Branch to inner loop
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_sih:A_si       ;si = s * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_crh:B_cr       ;cr = c * rtemp

; -----------------------------------------------------------------

    [B_j]LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||  [B_j]LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;Copy w_tmp to B-side
||       MV    .S2X  A_stptr1,       B_stptr1                           ;Copy stptr1 to B-side

    [B_j]LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||  [B_j]LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MV    .S1X  B_c,            A_s                                ;Change side of c & s
||       MV    .S2X  A_s,            B_c                                ;Change side of c & s

         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
||       MV    .S1X  B_ch,           A_sh                               ;Change side of c & s
||       MV    .S2X  A_sh,           B_ch                               ;Change side of c & s

         STW   .D1T2 B_crsi,         *A_stptr1++                        ;Store crsi
||       STW   .D2T1 A_cisr,         *B_stptr1[2]                       ;Store cisr
||       ADDDP .L2X  B_crh:B_cr,     A_sih:A_si,       B_crsih:B_crsi   ;crsi = cr + si
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_cih:A_ci       ;ci = c * itemp 
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_srh:B_sr       ;sr = s * rtemp
||       MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       SUB   .S2   B_i1,           16,               B_i1             ;i1 = i1-16

         STW   .D1T2 B_crsih,        *A_stptr1++[3]                     ;Store crsi
||       STW   .D2T1 A_cisrh,        *B_stptr1[3]                       ;Store cisr
||       SUBDP .L1X  A_cih:A_ci,     B_srh:B_sr,       A_cisrh:A_cisr   ;cisr = ci - sr
|| [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w
         ;--------------------------------------------------------- 
         ; BRANCH OCCURS HERE ( EPILOG STARTS )
         ;---------------------------------------------------------

         STW   .D1T1 A_b12,          *A_stptr[2]                        ;Store b12
||       STW   .D2T2 B_a12,          *B_stptr                           ;Store a12
||[!B_i1]ADD   .S1   A_stptr1,       A_cst,            A_stptr1         ;if(!i1) x_stptr1 += 16*n2

         STW   .D1T1 A_b12h,         *A_stptr[3]                        ;Store b12
||       STW   .D2T2 B_a12h,         *B_stptr[1]                        ;Store a12
||[!B_i1]MV    .S2X  A_cst,          B_i1                               ;if(!i1) i1 = 16*n2                                

         SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_sih:A_si       ;si = s * itemp
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_crh:B_cr       ;cr = c * rtemp

; -----------------------------------------------------------------

         MV    .S2X  A_stptr1,       B_stptr1                           ;Copy stptr1 to B-side

         MV    .S1X  B_c,            A_s                                ;Change side of c & s
||       MV    .S2X  A_s,            B_c                                ;Change side of c & s

         MV    .S1X  B_ch,           A_sh                               ;Change side of c & s
||       MV    .S2X  A_sh,           B_ch                               ;Change side of c & s

         STW   .D1T2 B_crsi,         *A_stptr1++                        ;Store crsi
||       STW   .D2T1 A_cisr,         *B_stptr1[2]                       ;Store cisr                
||       ADDDP .L2X  B_crh:B_cr,     A_sih:A_si,       B_crsih:B_crsi   ;crsi = cr + si
||       MPYDP .M1   A_sh:A_s,       A_itmph:A_itmp,   A_cih:A_ci       ;ci = c * itemp 
||       MPYDP .M2   B_ch:B_c,       B_rtemph:B_rtemp, B_srh:B_sr       ;sr = s * rtemp
||       MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       SUB   .S2   B_i1,           16,               B_i1             ;i1 = i1-16

         STW   .D1T2 B_crsih,        *A_stptr1++[3]                     ;Store crsi
||       STW   .D2T1 A_cisrh,        *B_stptr1[3]                       ;Store cisr
||       SUBDP .L1X  A_cih:A_ci,     B_srh:B_sr,       A_cisrh:A_cisr   ;cisr = ci - sr
    ; -------------------------------------------------------------
    ; ------------- ( EPILOG ENDS )                
    ; -------------------------------------------------------------
  [!B_i1]ADD   .D1   A_stptr1,       A_cst,            A_stptr1         ;if(!i1) x_stptr1 += 16*n2
||       MVC   .S2   IRP,            B_ldptr                            ; p x_ldptr = x           
||       SHR   .S1   A_cst,          1,                A_cst1           ; p n2 >> 1
||       ADD   .L2X  B_w,            A_cst,            B_w              ; p w = w + k

  [!B_i1]MV    .L2X  A_cst,          B_i1                               ;if(!i1) i1 = 16*n2
||       MVC   .S2   AMR,            B_k                                ; p counter = k                                          
||       ADD   .S1X  B_ldptr,        A_cst1,           A_ldptr1         ; p x_ldptr1 = x + 2*n2

         MV    .S1   A_cst1,         A_i                                ; p i = 16 * n2
||       MV    .S2   B_w,            B_w_tmp                            ; p w_tmp = w                
||       MV    .D1   A_ldptr1,       A_st                               ; p save x_stptr1=x_ldptr1

; -----------------------------------------------------------------

         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       MV    .S2X  A_stptr1,       B_stptr1                           ;Copy stptr1 to B-side

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1

         NOP

         STW   .D1T2 B_crsi,         *A_stptr1++                        ;Store crsi
||       STW   .D2T1 A_cisr,         *B_stptr1[2]                       ;Store cisr
||       ADDDP .L2X  B_crh:B_cr,     A_sih:A_si,       B_crsih:B_crsi   ;crsi = cr + si                
||       SUB   .S2   B_i1,           16,               B_i1             ;i1 = i1-16

         STW   .D1T2 B_crsih,        *A_stptr1++[3]                     ;Store crsi
||       STW   .D2T1 A_cisrh,        *B_stptr1[3]                       ;Store cisr
||       SUBDP .L1X  A_cih:A_ci,     B_srh:B_sr,       A_cisrh:A_cisr   ;cisr = ci - sr
         
  [!B_i1]ADD   .S1   A_stptr1,       A_cst,            A_stptr1         ;if(!i1) x_stptr1 += 16*n2
||       MV    .D1   A_cst1,         A_cst                              ; p (n2 = n2 >> 1)
||       SUB   .S2   B_k,            1,                B_k              ; p k = k - 1
||       MV    .L2X  A_cst1,         B_i1                               ; p i1 = 16*n2

         ADDDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_b12h:A_b12     ;b12=b1+b2            
||       ADDDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_a12h:B_a12     ;a12=a1+a2
||       SUB   .S1   A_i,            16,               A_i              ;i = i-16
||       MVC   .S2   B_k,            AMR                                ; p Save outer loop ctr, k

   [!A_i]ADD   .D1   A_ldptr1,       A_cst,            A_ldptr1         ;x_ldptr1=x_ldptr1+2*n2
||       SUB   .D2   B_ldptr,        16,               B_stptr          ;x_stptr=x_ldptr-16    
||  [B_k]B     .S1   OLOOP                                              ; p Branch to outer loop                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
|| [!A_i]ADD   .S2X  A_ldptr1,       0,                B_ldptr          ;x_ldptr=x_ldptr1

; -----------------------------------------------------------------
     
         LDDW  .D1T1 *A_ldptr1[1],   A_b2h:A_b2                         ;Load b2
||       LDDW  .D2T2 *B_ldptr++,     B_a1h:B_a1                         ;Load a1
||       SUBDP .L1   A_b1h:A_b1,     A_b2h:A_b2,       A_itmph:A_itmp   ;itemp=b1-b2
||       SUBDP .L2   B_a1h:B_a1,     B_a2h:B_a2,       B_rtemph:B_rtemp ;rtemp=a1-a2
||       MV    .S1X  B_w_tmp,        A_w_tmp                            ;Copy w_tmp to B-side
||       MVC   .S2   IER,            B_j                                ; p j = n

         LDDW  .D1T2 *A_ldptr1++[2], B_a2h:B_a2                         ;Load a2
||       LDDW  .D2T1 *B_ldptr++,     A_b1h:A_b1                         ;Load b1
||       MV    .S1   A_stptr1,       A_st1                              ; p Copy x_stptr1
||       AND   .S2   B_j,            0xFFFFFFFC,       B_j              ; p Zero the last 2 bits

         LDDW  .D1T1 *A_w_tmp[1],    A_sh:A_s                           ;Load s
||       LDDW  .D2T2 *B_w_tmp++[2],  B_ch:B_c                           ;Load c
||       MV    .S1   A_st,           A_stptr1                           ; p x_st_ptr1 = x + 2*n2
||       SHR   .S2   B_j,       1,                     B_j              ; p j = n/2
||       MV    .L2X  A_stptr1,       B_stptr1                           ;Copy stptr1 to B-side

         STW   .D1T2 B_crsi,         *A_st1                             ;Store crsi
||       STW   .D2T1 A_cisr,         *B_stptr1[2]                       ;Store cisr
||       MV    .S1X  B_stptr,        A_stptr                            ;Copy stptr to A-side
||       SUB   .S2   B_j,            3,                B_j              ; p j = j - 2 (for epilog)

         STW   .D1T2 B_crsih,        *A_st1[1]                          ;Store crsi
||       STW   .D2T1 A_cisrh,        *B_stptr1[3]                       ;Store cisr
|| [!A_i]MV    .S1   A_cst,          A_i                                ;if(!i) i=16*n2
|| [!A_i]MV    .S2   B_w,            B_w_tmp                            ;if(!i) w_tmp=w


; =================================================================          
  
         MV    .S2X  A_SP,           B_SP                               ;Copy Stack pointer
||       LDW   .D1T2 *A_SP[12],      B_RET                              ;Restore registers                
         
         LDW   .D1T1 *A_SP[1],       A_b2                               ;Restore registers  
||       LDW   .D2T2 *B_SP[13],      B_IRP1                             ;Restore registers
         
         LDW   .D1T1 *A_SP[2],       A_b2h                              ;Restore registers               
||       LDW   .D2T2 *B_SP[14],      B_AMR1                             ;Restore registers     
         
         LDW   .D1T1 *A_SP[3],       A_b12                              ;Restore registers    
||       LDW   .D2T2 *B_SP[15],      B_IER1                             ;Restore registers
         
         LDW   .D1T1 *A_SP[4],       A_b12h                             ;Restore registers     
||       LDW   .D2T2 *B_SP[16],      B_CSR                              ;Restore registers               
         
         LDW   .D1T1 *A_SP[5],       A_stptr                            ;Restore registers     
||       LDW   .D2T2 *B_SP[7],       B_a2                               ;Restore registers  
         
         LDW   .D1T1 *A_SP[6],       A_SP                               ;Restore registers                                     
||       LDW   .D2T2 *B_SP[8],       B_a2h                              ;Restore registers                                 
||       MVC   .S2   B_IRP1,         IRP
  
         LDW   .D2T1 *B_SP[9],       A_tmp                              ;Restore registers     
||       LDW   .D1T2 *A_SP[10],      B_a12h                             ;Restore registers     
||       B     .S2   B_RET                                              ;Return back to caller

         LDW   .D2T2 *B_SP[11],      B_w                                ;Restore registers 
||       MVC   .S2   B_IER1,         IER                                ;Restore IER
  
         MVC   .S2   B_AMR1,         AMR                                ;Restore AMR
         
         ADDAW .D2   B_SP,           16,               B_SP             ;Restore stack space
         
         NOP
         
         MV    .L2X  A_tmp,          B_a12                              ;Restore registers
||       MVC   .S2   B_CSR,          CSR                                ;enable interrupts                                         
         
                .end


* ======================================================================== *
*  End of file: DSPF_dp_icfftr2.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_fir_cpl/1117057378  844   0     0       19324     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_cplx(                                                  *
*                         const double * restrict x,                        *
*                         const double * restrict h,                        *
*                         double *       restrict r,                        *
*                         int   nh,                                         *
*                         int   nr                                          *
*                        )                                                  *
*                                                                           *
*             x[2*(nr+nh-1)]: Pointer to complex input array.               *
*                             The input data pointer x must point to the    *
*                            (nh)th complex element, i.e. element 2*(nh-1). *
*             h[2*nh]       : Pointer to complex coefficient array          *
*                             (in normal order).                            *
*             r[2*nr]       : Pointer to complex output array.              *
*             nh            : Number of complex coefficients in vector h.   *
*             nr            : Number of complex output samples to           *
*                            calculate.                                     *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        This function implements the FIR filter for complex input data.    *
*        The filter has nr output samples and nh coefficients. Each array   *
*        consists of an even and odd term with even terms representing the  *
*        real part and the odd terms the imaginary part of the element.     *
*        The coefficients are expected in normal order.                     *
*                                                                           *
*                                                                           *
*      TECHNIQUES                                                           *
*                                                                           *
*     1. The outer loop is unrolled twice.                                  *
*     2. Outer loop instructions are executed in parallel with inner loop.  *
*     3. Register Sharing is used to make optimal use of available register *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. nr is a multiple of 2 and greater than or equal to 2.              *
*     2. nh is greater than or equal to 4.                                  *
*     3. x points to 2*(nh-1)th input element.                              *
*                                                                           *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_cplx(const double * x, const double * h,                    *
*                    double * restrict r, int nh, int nr)                   *
*   {                                                                       *
*        int i,j;                                                           *
*        double imag, real;                                                 *
*        for (i = 0; i < 2*nr; i += 2)                                      *
*        {                                                                  *
*            imag = 0;                                                      *
*            real = 0;                                                      *
*            for (j = 0; j < 2*nh; j += 2)                                  *
*            {                                                              *
*                real += h[j] * x[i-j] - h[j+1] * x[i+1-j];                 *
*                imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];                 *
*            }                                                              *
*            r[i] = real;                                                   *
*            r[i+1] = imag;                                                 *
*        }                                                                  *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*   8*nh*nr + 5*nr + 30                                                     *
*   For nh=24 and nr=48, cycles=9486                                        *
*   For nh=16 and nr=36, cycles=4818                                        *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   608 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_fir_cplx
_DSPF_dp_fir_cplx:
        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MVC         .S2     CSR,            B5                  ;Get CSR

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     MV          .L1     A4,             A3                  ;Pointer for x[i]
 ||     MV          .L2     B4,             B3                  ;Pointer for h[i]
 ||     MV          .S2     B4,             B7

        STW         .D2     B5,             *B15--[01]          ;store CSR
 ||     AND         .S2     -2,             B5,         B5      ;Disable Interrupts

        LDDW        .D1     *A3++[02],      A1:A0               ;p-load x[i-j] Real Part
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;p-load h[j] Real Part
 ||     MVC         .S2     B5,             CSR

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     MV          .L1     A8,             A2                  ;Set OuterLoop Counter
 ||     MV          .L2     B6,             B2                  ;Set InnerLoop Counter

        LDDW        .D1     *A3--[01],      A5:A4               ;p-load x[i-j+1] Real Part
 ||     LDDW        .D2     *B3++[01],      B5:B4               ;p-load h[j] Imag Part

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MV          .L2     B6,             B14                 ;nh
 ||     MV          .L1     A4,             A14                 ;Pointer for x[i]

        MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;p-P11=x0(real)*h(real)
 ||     ZERO        .S1     A13                                 ;Clearing A13 and B13
 ||     ZERO        .L2     B13

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]
 ||     MPYDP       .M2X    B1:B0,          A5:A4,      B7:B6   ;p-P12=x1(real)*h(real)
 ||     ZERO        .L1     A12                                 ;Clearing A12 and B12
 ||     ZERO        .S2     B12

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]
 ||     ZERO        .S1     A11                                 ;Clearing A11 and B11
 ||     ZERO        .L2     B11

        STW         .D2     B7,             *B15--[01]          ;Pushing *h into Stack
 ||     MV          .L1     A6,             A15                 ;Pointer to r
 ||     LDDW        .D1     *A3++[02],      A1:A0               ;p-load x[i-j] Imag Part

        MPYDP       .M1X    A1:A0,          B5:B4,      A9:A8   ;p-P13=x0(real)*h(imag)
 ||     ZERO        .L1     A10                                 ;Clearing A10 and B10
 ||     ZERO        .S2     B11

        LDDW        .D1     *A3--[05],      A5:A4               ;p-load x[i-j+1] Imag Part

        MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;p-P14=x1(real)*h(imag)

        SUB         .S2     B2,             1,          B2      ;p-Decrement InnerLoop Counter
*********************************************************************************************
*************************BEGINING OF KERNEL**************************************************
*********************************************************************************************
loop:

        MPYDP       .M1X    A1:A0,          B5:B4,      A7:A6   ;P21=x0(imag)*h(imag)
 ||[!B2]LDW         .D2     *+B15[01],      B3                  ;o-Load Pointer for h[j]
 ||[!B2]ADDAD       .D1     A14,            04,         A14     ;o-Set Pointer for x

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P11(r0(real))
 ||[!B2]MV          .S1     A14,            A3                  ;o-Load Pointer for x[i-j]

        MPYDP       .M2X    B5:B4,          A5:A4,      B7:B6   ;P22=x1(imag)*h(imag)

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P12(r1(real))
 ||[B2] LDDW        .D1     *A3++[02],      A1:A0               ;load x[i-j] Real Part
 ||[B2] LDDW        .D2     *B3++[01],      B1:B0               ;load h[j] Real Part

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;P23=x0(imag)*h(Real)
 ||     MV          .L2     B0,             B4                  ;

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P13(r0(Imag))
 ||[B2] LDDW        .D1     *A3--[01],      A5:A4               ;load x[i-j+1] Real Part
 ||[B2] LDDW        .D2     *B3++[01],      B5:B4               ;load h[j] Imag Part

        MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;P24=x1(imag)*h(Real)
 ||     MV          .L2     B1,             B5                  ;
 ||[!B2]LDDW        .D1     *A3++[02],      A1:A0               ;p-load x[i-j] Real Part
 ||[!B2]LDDW        .D2     *B3++[01],      B1:B0               ;p-load h[j] Real Part

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P14(r1(imag))

   [B2] MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;P11=x0(real)*h(real)
 ||[!B2]LDDW        .D1     *A3--[01],      A5:A4               ;p-load x[i-j+1] Real Part
 ||[!B2]LDDW        .D2     *B3++[01],      B5:B4               ;p-load h[j] Imag Part

        SUBDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1-=P21(r0(real))

   [B2] B           .S1     loop
 ||[B2] MPYDP       .M2X    B1:B0,          A5:A4,      B7:B6   ;P12=x1(real)*h(real)

        SUBDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2-=P22(r1(real))
 ||[B2] LDDW        .D1     *A3++[02],      A1:A0               ;load x[i-j] Imag Part

   [B2] MPYDP       .M1X    A1:A0,          B5:B4,      A9:A8   ;P13=x0(real)*h(imag)
 ||[!B2]ADDAD       .D1     A15,            02,         A6      ;o-Pointer for r[i+1]

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P23(r0(Imag))
 ||[B2] LDDW        .D1     *A3--[05],      A5:A4               ;load x[i-j+1] Imag Part

   [B2] MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;P14=x1(real)*h(imag)

   [B2] SUB         .S2     B2,             1,          B2      ;Decrement InnerLoop Counter
 ||     ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P24(r1(imag))

*****************************************************************************************
*******************************END OF KERNEL*********************************************
*****************************************************************************************
        STW         .D1     A10,            *A15++              ;o-Storing r0(real)
 ||     MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;p-P11=x0(real)*h(real)
 ||[A2] SUB         .S1     A2,             02,         A2      ;Decrement OuterLoop Counter
 ||[A2] ZERO        .L1     A10                                 ;p-Clearing A10 and A11

        STW         .D1     A11,            *A15++[3]           ;o-Storing r0(real)
 ||[A2] ZERO        .S1     A11                                 ;p-Clearing A10 and A11

        STW         .D1     B10,            *A15++              ;Storing r1(real)
 ||[A2] MPYDP       .M2X    B1:B0,          A5:A4,      B7:B6   ;p-P12=x1(real)*h(real)
 ||[A2] ZERO        .S2     B10                                 ;p-Clearing B10 and B11

   [A2] LDDW        .D1     *A3++[02],      A1:A0               ;p-load x[i-j] Imag Part

   [A2] B           .S1     loop                                ;OuterLoop Branch Occurs Here
 ||     STW         .D1     B11,            *A15--[3]           ;Storing r1(real)
 ||[A2] MPYDP       .M1X    A1:A0,          B5:B4,      A9:A8   ;p-P13=x0(real)*h(imag)
 ||[A2] ZERO        .S2     B11

        STW         .D1     A12,            *A15++              ;Storing r0(Imag)
 ||[!A2]ADD         .S2     B15,            04,         B15     ;Restoring Address of B15(sp)
 ||[A2] ZERO        .S1     A12                                 ;Clearing A12

   [A2] LDDW        .D1     *A3--[05],      A5:A4               ;p-load x[i-j+1] Imag Part

        STW         .D1     A13,            *A15++[3]           ;Storing r0(Imag)
 ||[A2] MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;p-P14=x1(real)*h(imag)
 ||[A2] ZERO        .S1     A13                                 ;Clearing A13

        STW         .D1     B12,            *A15++              ;Storing r1(imag)
 ||[A2] MV          .S2     B14,            B2                  ;Set Innerloop Counter
 ||[A2] ZERO        .L2     B12                                 ;Clearing B12

        STW         .D1     B13,            *A15++              ;Storing r1(imag)
 ||[A2] SUB         .S2     B2,             1,          B2      ;Decrement InnerLoop Counter
 ||[A2] ZERO        .L2     B13                                 ;Clearing B13

*****************************************************************************************
****************************OUTERLOOP BRANCH OCCURS HERE*********************************
*****************************************************************************************
        SUB         .L1     B15,            04,         A15     ;Restoring Address of A15(Twin sp)
 ||     LDW         .D2     *+B15[11],      B7                  ;Restoring Return address

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10

        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address

        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11

        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12

        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts

        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14

        B           .S2     B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,     B15         ;Clearing the Stack
        NOP         3;

               .end

* ======================================================================== *
*  End of file: DSPF_dp_fir_cplx.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_fir_gen/1117057379  866   0     0       19669     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*    This routine is C Callable and can be called as:                       *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                               double * restrict r,int nh, int nr);        *
*                                                                           *
*        x : Pointer to array holding the input floating point array        *
*        h : Pointer to array holding the coefficient floating point        *
*            array                                                          *
*        r : Pointer to output array                                        *
*        nh: Number of coefficents                                          *
*        nr: Number of output values                                        *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine implements a block FIR filter.  There are "nh"        *
*        filter coefficients, "nr" output samples, and "nh+nr-1"            *
*        input samples.    The coefficients need to be placed in the "h"    *
*        array in reverse order {h(nh-1), ... , h(1), h(0)} and the         *
*        array "x" starts at x(-nh+1) and ends at x(nr-1).  The             *
*        routine calculates y(0) through y(nr-1) using the following        *
*        formula:                                                           *
*                                                                           *
*        r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           *
*                                                                           *
*        where n = {0, 1, ... , nr-1}.                                      *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*        1.  The outer loop is unrolled 4 times.                            *
*        2.  The inner loop is unrolled 2 times and software pipelined.     *
*        3.  Register sharing is used to make optimum utilisation of        *
*            available registers                                            *
*        4.  Outerlop instructions and Prolog for next stage are scheduled  *
*            in parallel with last iteration of kernel                      *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*        1.  Little Endian is assumed for LDDW instructions.                *
*        2.  The number of coefficients must be greater than                *
*            or equal to 4.                                                 *
*        3.  The number of outputs must be greater than or equal to 4       *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*        This is the C equivalent for the assembly code.  Note that         *
*        the assembly code is hand optimized and restrictions may           *
*        apply.                                                             *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                    double * restrict r, int nh, int nr)                   *
*        {                                                                  *
*           int i, j;                                                       *
*           double sum;                                                     *
*                                                                           *
*           for(i=0; i < nr; i++)                                           *
*           {                                                               *
*              sum = 0;                                                     *
*              for(j=0; j < nh; j++)                                        *
*              {                                                            *
*                  sum += x[i+j] * h[j];                                    *
*              }                                                            *
*              r[i] = sum;                                                  *
*           }                                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*    NOTES                                                                  *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*    CYCLES                                                                 *
*                                                                           *
*    (16*floor((nh+1)/2)+10)*(ceil(nr/4)) + 32                              *
*     for nh=26, nr=42, cycles=2430 cycles.                                 *
*                                                                           *
*    CODESIZE                                                               *
*                                                                           *
*     672 bytes                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_fir_gen
_DSPF_dp_fir_gen:

            STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1     A4,             A0                  ;Pointer for x

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     MV          .L2     B6,             B1                  ;Set Innerloop Counter
 ||     MVC         .S2     CSR,            B7                  ;Get CSR

        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable the interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     MV          .L1     A4,             A9
 ||     MV          .L2     B4,             B9
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     MV          .L2     B4,             B14                 ;Set pointer for h

        LDDW        .D1     *A0++[01],      A3:A2               ;load x[0]
 ||     LDDW        .D2     *B14++[01],     B3:B2               ;load h[0]

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]

        LDDW        .D1     *A0++[01],      A5:A4               ;load x[1]
 ||     LDDW        .D2     *B14++[01],     B5:B4               ;load h[1]

        LDDW        .D1     *A0,            A15:A14             ;load x[2]

        LDDW        .D1     *+A0[01],       A3:A2               ;load x[3]
 ||     MV          .L1     A15,            A13

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A13--[02]
 ||     ZERO        .L2     B13
 ||     MPYDP       .M1X    A3:A2,          B3:B2,      A7:A6   ;P11=x[0]*h[0]

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A13--[02]
 ||     ZERO        .L1     A12                                 ;Clearing Registers A13 and B13
 ||     ZERO        .L2     B12

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A13--[02]
 ||     ZERO        .L1     A11                                 ;Clearing Registers A13 and B13
 ||     ZERO        .L2     B11
 ||     MPYDP       .M2X    B3:B2,          A5:A4,      B7:B6   ;P12=x[1]*h[0]

        STW         .D2     B9,             *B15--[02]          ;Pushing address of x into stack
 ||     STW         .D1     A9,             *A13--[02]          ;Pushing address of h into stack
 ||     ZERO        .L1     A10                                 ;Clearing Registers A13 and B13
 ||     ZERO        .L2     B10

        STW         .D2     B6,             *B15--[02]          ;Pushing nh into stack
 ||     STW         .D1     A6,             *A13--[02]          ;Pushing *r into  the stack
 ||     MPYDP       .M1X    A15:A14,        B3:B2,      A9:A8   ;P13=x[2]*h[0]

        STW         .D2     A8,             *B15--[01]          ;Push nr into stack
 ||     ZERO        .L1     A13                                 ;Clearing Registers A13 and B13

        MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P14=x[3]*h[0]
 ||     SUB         .S2     B1,             02,         B1      ;Decrement Innerloop Counter

        CMPGT       .L2     B1,             0,          B0      ;Checking nh odd or even

***********************************************************************************
*******************************BEGIN OF KERNEL*************************************
***********************************************************************************

iloop:

        LDDW        .D1     *+A0[02],       A5:A4               ;load x[4]
 ||     MPYDP       .M1X    A5:A4,          B5:B4,      A7:A6   ;P21=x[1]*h[1]

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P11
 ||[!B0]LDW         .D2     *+B15[04],      A14                 ;o-Load Pointer for x

        MPYDP       .M2X    B5:B4,          A15:A14,    B7:B6   ;P22=x[2]*h[1]
 ||[!B0]LDW         .D2     *+B15[05],      B14                 ;o-Load Pointer for h

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P12
 ||[B0] LDDW        .D1     *A0++[01],      A3:A2               ;load x[0]
 ||[B0] LDDW        .D2     *B14++[01],     B3:B2               ;load h[0]

        MPYDP       .M1X    A3:A2,          B5:B4,      A9:A8   ;P23+=x[3]*h[1]
 ||[!B0]LDW         .D2     *+B15[01],      B3                  ;o-load outerloop Counter

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P13
 ||[B0] LDDW        .D1     *A0++[01],      A5:A4               ;load x[1]
 ||[B0] LDDW        .D2     *B14++[01],     B5:B4               ;load h[1]

        MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;P24=x[4]*h[1]
 ||[B0] LDDW        .D1     *A0,            A15:A14             ;load x[2]
 ||[!B0]ADD         .S2     B1,             1,          B1

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P14
 ||[B0] LDDW        .D1     *+A0[01],       A3:A2               ;load x[3]

   [B0] MPYDP       .M1X    A3:A2,          B3:B2,      A7:A6   ;P11=x[0]*h[0]
 ||[!B0]ADDAD       .D1     A14,            04,         A14     ;Update pointer for x

   [B1]ADDDP        .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P21
 ||[!B0]MV          .D1     A14,            A0                  ;Set Pointer For x
 ||[!B0]STW         .D2     A14,            *+B15[04]           ;Storing Updated Pointer for x
 ||[!B0]SUB         .S2     B3,             04,         B3      ;Decrement outerloop Counter

   [B0] B           .S2     iloop
 ||[B0] MPYDP       .M2X    B3:B2,          A5:A4,      B7:B6   ;P12=x[1]*h[0]
 ||[!B0]LDW         .D2     *+B15[02],      B4                  ;Load pointer for r
 ||[!B0]CMPGT       .L2     B3,             00,         B5

   [B1] ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P22
 ||[!B0]LDDW        .D1     *A0++[01],      A3:A2               ;p-load x[0]
 ||[!B0]LDDW        .D2     *B14++[01],     B3:B2               ;p-load h[0]

   [B0] MPYDP       .M1X    A15:A14,        B3:B2,      A9:A8   ;P13=x[2]*h[0]
 ||[!B0]STW         .D2     B3,             *+B15[01]           ;Store outerloop Counter in Stack

    [B1]ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P23
 ||[!B0]LDDW        .D1     *A0++[01],      A5:A4               ;p-load x[1]
 ||[!B0]LDDW        .D2     *B14++[01],     B5:B4               ;p-load h[1]
 ||[!B0]MV          .S2     B3,             B6

   [B0] MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P14=x[3]*h[0]
 ||[!B0]LDDW        .D1     *A0,            A15:A14             ;p-load x[2]
 ||[!B0]LDW         .D2     *+B15[03],      B9                  ;Set Innerloop COunter
 ||     CMPGT       .L2     B1,             2,          B7      ;Checking nh odd or even

   [B0] MV          .D2     B7,             B0
 ||[B1] ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P24
 ||[B0] SUB         .S2     B1,             02,         B1      ;Decrement Inner Loop Counter


***********************************************************************************
***************************END OF KERNEL*******************************************
***********************************************************************************
        MV          .S2     B5,             B1                  ;Outerloop Flag
 ||     ADD         .D2     B6,             03,         B0      ;Outerloop counter

        STW         .D2     A10,            *B4                 ;Store r[0]
 ||     ADD         .S2     B4,             04,         B7      ;Pointer for Storing r values
 ||[B1] MPYDP       .M1X    A3:A2,          B3:B2,      A7:A6   ;p-P11=x[0]*h[0]
 ||[B1] ZERO        .S1     A10

        STW         .D2     A11,            *B7++
 ||[B1] ZERO        .S1     A11


   [B0] STW         .D2     B10,            *B7++               ;Store r[1]
 ||[B1] ZERO        .S1     A11
 ||[B1] LDDW        .D1     *+A0[01],       A3:A2               ;p-load x[3]


   [B1] B           .S1     iloop
 ||[B0] STW         .D2     B11,            *B7++               ;Store r[1]
 ||[B0] SUB         .S2     B0,             1,          B0
 ||[B1] MPYDP       .M2X    B3:B2,          A5:A4,      B7:B6   ;P12=x[1]*h[0]


   [B0] STW         .D2     A12,            *B7++               ;Store r[2]
 ||[B1] ZERO        .S2     B11


   [B0] STW         .D2     A13,            *B7++               ;Store r[2]
 ||[B0] SUB         .L2     B0,             1,          B0
 ||[B1] MPYDP       .M1X    A15:A14,        B3:B2,      A9:A8   ;P13=x[2]*h[0]
 ||[B1] ZERO        .L1     A12


   [B0] STW         .D2     B12,            *B7++               ;Store r[3]
 ||[B1] ZERO        .S1     A13
 ||[B1] SUB         .S2     B9,             02,         B9      ;Decrement Innerloop Counter


   [B0] STW         .D2     B13,            *B7++               ;Store r[3]
 ||[B1] MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P14=x[3]*h[0]
 ||[B1] ZERO        .S2     B12
 ||[B1] ZERO        .L2     B13

        STW         .D2     B7,             *+B15[02]           ;Store Pointer for r
 ||[B1] CMPGT       .L2     B9,             0,          B0      ;Checking nh odd or even
 ||[B1] MV          .S2     B9,             B1

************************************************************************************
***************************OUTERLOOP BRANCH OCCURS HERE*****************************
************************************************************************************

        ADDAW       .D2     B15,            5,          B15     ;Restoring Address of B10

        SUB         .L1     B15,            04,         A15     ;Twin stack Pointer
 ||     LDW         .D2     *+B15[11],      B7                  ;Restoring Return address

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;


                .end

* ======================================================================== *
*  End of file: DSPF_dp_fir_gen.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_fir_r2./1117057380  887   0     0       18779     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_r2(                                                    *
*                      const double * restrict x,                           *
*                      const double * restrict h,                           *
*                      double      * restrict r,                            *
*                      int   nh,                                            *
*                      int   nr                                             *
*                      )                                                    *
*             x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           *
*             h[nh]     : Pointer to coefficient array of size nh.          *
*                         (in reverse order).                               *
*             r[nr]     : Pointer to output array of size nr.               *
*             nh        : Number of coefficients                            *
*             nr        : Number of output samples.                         *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        Computes a real FIR filter (direct-form) using coefficients        *
*        stored in vector h[]. The real data input is stored in vector      *
*        x[]. The filter output result is stored in vector r[]. The         *
*        filter calculates nr output samples using nh coefficients.         *
*        The coefficients are expected to be in reverse order.              *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*        1. The outer loop is unrolled four times and inner loop is         *
*           unrolled twice.                                                 *
*        2. Register sharing is used to make optimum utilisation of         *
*           available Registers                                             *
*        3. Outer loop instructions are executed in parallel with           *
*           inner loop.                                                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*        1. nr is a multiple of 2 and greater than or equal to 2.           *
*        2. nh is a multiple of 2 and greater than or equal to 8.           *
*        3. Coefficients in array h are expected to be in reverse order.    *
*        4. x and h should be padded with 4 words at the end.               *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_r2(const double * x, const double * h,                      *
*                      double *restrict r, int nh, int nr)                  *
*   {                                                                       *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*           sum = 0;                                                        *
*                                                                           *
*           for (j = 0; j < nh; j++)                                        *
*              sum += x[i + j] * h[j];                                      *
*              r[i] = sum;                                                  *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*    (8*nh + 10)*ceil(nr/4) + 32                                            *
*     For nh=24 and nr=62, cycles=3264                                      *
*                                                                           *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   672 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_fir_r2
_DSPF_dp_fir_r2:

        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1     A4,             A0                  ;Pointer for x

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     MV          .L2     B6,             B1                  ;Set Innerloop Counter
 ||     MVC         .S2     CSR,            B7                  ;Get CSR

        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable Interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     MV          .L1     A4,             A9
 ||     MV          .L2     B4,             B9
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     MV          .L2     B4,             B14                 ;Set pointer for h

        LDDW        .D1     *A0++[01],      A3:A2               ;load x[0]
 ||     LDDW        .D2     *B14++[01],     B3:B2               ;load h[0]

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]

        LDDW        .D1     *A0++[01],      A5:A4               ;load x[1]
 ||     LDDW        .D2     *B14++[01],     B5:B4               ;load h[1]

        LDDW        .D1     *A0,            A15:A14             ;load x[2]

        LDDW        .D1     *+A0[01],       A3:A2               ;load x[3]
 ||     MV          .L1     A15,            A13

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A13--[02]
 ||     ZERO        .L2     B13
 ||     MPYDP       .M1X    A3:A2,          B3:B2,      A7:A6   ;P11=x[0]*h[0]

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A13--[02]
 ||     ZERO        .L1     A12                                 ;Clearing Registers A13 and B13
 ||     ZERO        .L2     B12

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A13--[02]
 ||     ZERO        .L1     A11                                 ;Clearing Registers A13 and B13
 ||     ZERO        .L2     B11
 ||     MPYDP       .M2X    B3:B2,          A5:A4,      B7:B6   ;P12=x[1]*h[0]

        STW         .D2     B9,             *B15--[02]          ;Pushing address of x into stack
 ||     STW         .D1     A9,             *A13--[02]          ;Pushing address of h into stack
 ||     ZERO        .L1     A10                                 ;Clearing Registers A13 and B13
 ||     ZERO        .L2     B10

        STW         .D2     B6,             *B15--[02]          ;Pushing nh into stack
 ||     STW         .D1     A6,             *A13--[02]          ;Pushing *r into  the stack
 ||     MPYDP       .M1X    A15:A14,        B3:B2,      A9:A8   ;P13=x[2]*h[0]

        STW         .D2     A8,             *B15--[01]          ;Push nr into stack
 ||     ZERO        .L1     A13                                 ;Clearing Registers A13 and B13

        MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P14=x[3]*h[0]

        SUB         .S2     B1,             02,         B1      ;Decrement Innerloop Counter

***********************************************************************************
*******************************BEGIN OF KERNEL*************************************
***********************************************************************************

iloop:

        LDDW        .D1     *+A0[02],       A5:A4               ;load x[4]
 ||     MPYDP       .M1X    A5:A4,          B5:B4,      A7:A6   ;P21=x[1]*h[1]

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P11
 ||[!B1]LDW         .D2     *+B15[04],      A14                 ;o-Load Pointer for x

        MPYDP       .M2X    B5:B4,          A15:A14,    B7:B6   ;P22=x[2]*h[1]
 ||[!B1]LDW         .D2     *+B15[05],      B14                 ;o-Load Pointer for h

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P12
 ||[B1] LDDW        .D1     *A0++[01],      A3:A2               ;load x[0]
 ||[B1] LDDW        .D2     *B14++[01],     B3:B2               ;load h[0]

        MPYDP       .M1X    A3:A2,          B5:B4,      A9:A8   ;P23+=x[3]*h[1]
 ||[!B1]LDW         .D2     *+B15[01],      B3                  ;o-load outerloop Counter

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P13
 ||[B1] LDDW        .D1     *A0++[01],      A5:A4               ;load x[1]
 ||[B1] LDDW        .D2     *B14++[01],     B5:B4               ;load h[1]

        MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;P24=x[4]*h[1]
 ||[B1] LDDW        .D1     *A0,            A15:A14             ;load x[2]

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P14
 ||[B1] LDDW        .D1     *+A0[01],       A3:A2               ;load x[3]

   [B1] MPYDP       .M1X    A3:A2,          B3:B2,      A7:A6   ;P11=x[0]*h[0]
 ||[!B1]ADDAD       .D1     A14,            04,         A14     ;Update pointer for x

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P21
 ||[!B1]MV          .D1     A14,            A0                  ;Set Pointer For x
 ||[!B1]STW         .D2     A14,            *+B15[04]           ;Storing Updated Pointer for x
 ||[!B1]SUB         .S2     B3,             04,         B3      ;Decrement outerloop Counter

   [B1] B           .S2     iloop
 ||[B1] MPYDP       .M2X    B3:B2,          A5:A4,      B7:B6   ;P12=x[1]*h[0]
 ||[!B1]LDW         .D2     *+B15[02],      B4                  ;Load pointer for r
 ||[!B1]CMPGT       .L2     B3,             00,         B5

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P22
 ||[!B1]LDDW        .D1     *A0++[01],      A3:A2               ;p-load x[0]
 ||[!B1]LDDW        .D2     *B14++[01],     B3:B2               ;p-load h[0]

   [B1] MPYDP       .M1X    A15:A14,        B3:B2,      A9:A8   ;P13=x[2]*h[0]
 ||[!B1]STW         .D2     B3,             *+B15[01]           ;Store outerloop Counter in Stack

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P23
 ||[!B1]LDDW        .D1     *A0++[01],      A5:A4               ;p-load x[1]
 ||[!B1]LDDW        .D2     *B14++[01],     B5:B4               ;p-load h[1]
 ||[!B1]MV          .S2     B3,             B6

   [B1] MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P14=x[3]*h[0]
 ||[!B1]LDDW        .D1     *A0,            A15:A14             ;p-load x[2]
 ||[!B1]LDW         .D2     *+B15[03],      B9                  ;Set Innerloop COunter

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P24
 ||[B1] SUB         .S2     B1,             02,         B1      ;Decrement Inner Loop Counter

***********************************************************************************
***************************END OF KERNEL*******************************************
***********************************************************************************
        MV          .S2     B5,             B1                  ;Outerloop Flag
 ||     ADD         .D2     B6,             02,         B0      ;Outerloop counter

        STW         .D2     A10,            *B4                 ;Store r[0]
 ||     ADD         .S2     B4,             04,         B7      ;Pointer for Storing r values
 ||[B1] MPYDP       .M1X    A3:A2,          B3:B2,      A7:A6   ;p-P11=x[0]*h[0]
 ||[B1] ZERO        .S1     A10

        STW         .D2     A11,            *B7++
 ||[B1] ZERO        .S1     A11

        STW         .D2     B10,            *B7++               ;Store r[1]
 ||[B1] ZERO        .S1     A11
 ||[B1] LDDW        .D1     *+A0[01],       A3:A2               ;p-load x[3]

   [B1] B           .S1     iloop
 ||     STW         .D2     B11,            *B7++               ;Store r[1]
 ||[B1] MPYDP       .M2X    B3:B2,          A5:A4,      B7:B6   ;P12=x[1]*h[0]

   [B0] STW         .D2     A12,            *B7++               ;Store r[2]
 ||[B1] ZERO        .S2     B11

   [B0] STW         .D2     A13,            *B7++               ;Store r[2]
 ||[B1] MPYDP       .M1X    A15:A14,        B3:B2,      A9:A8   ;P13=x[2]*h[0]
 ||[B1] ZERO        .L1     A12

   [B0] STW         .D2     B12,            *B7++               ;Store r[3]
 ||[B1] ZERO        .S1     A13


   [B0] STW         .D2     B13,            *B7++               ;Store r[3]
 ||[B1] MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P14=x[3]*h[0]
 ||[B1] ZERO        .S2     B12
 ||[B1] ZERO        .L2     B13

        STW         .D2     B7,             *+B15[02]           ;Store Pointer for r
 ||[B1] SUB         .S2     B9,             02,         B1      ;Decrement Innerloop Counter
************************************************************************************
***************************OUTERLOOP BRANCH OCCURS HERE*****************************
************************************************************************************

        ADDAW       .D2     B15,            5,          B15     ;Restoring Address of B10

        SUB         .L1     B15,            04,         A15     ;Twin stack Pointer
 ||     LDW         .D2     *+B15[11],      B7                  ;Restore CSR

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;

                            .end

* ======================================================================== *
*  End of file: DSPF_dp_fir_r2.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_fircirc/1117057381  907   0     0       19538     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      30-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          *
*                      int csize, int nh, int nr)                           *
*                                                                           *
*             x[]     :     Input array (circular buffer of 2^(csize+1)     *
*                           bytes)                                          *
*                           Must be aligned at 2^(csize+1) byte boundary    *
*             h[nh]   :     Filter coefficients array                       *
*                           Must be double-word aligned                     *
*             r[nr]   :     Output array                                    *
*             index   :     Offset by which to start reading from the       *
*                           input array. Must be multiple of 2              *
*             csize   :     Size of circular buffer x[] is 2^(csize+1)      *
*                           bytes. Must be 2 <= csize <= 31.                *
*             nh      :     Number of filter coefficients                   *
*                           Must be multiple of 2 and >= 4                  *
*             nr      :     Size of output array                            *
*                           Must be multiple of 4                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This routine implements a circularly addressed FIR filter.            *
*     'nh' is the number of filter coefficients. 'nr' is the number         *
*     of the output samples.                                                *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*     1. The outer loop is unrolled 4 times.                                *
*     2. The inner loop is unrolled 2 times.                                *
*     3. Regiter sharing is udes to make optimal utilisation of the         *
*        available registers.                                               *
*     4. Outerloop instructions and Prolog for next stage are               *
*        scheduled in the last cycle of Kernel.                             *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The circular input buffer x[] must be aligned at a 2^(csize+1)     *
*        byte boundary. csize must lie in the range 2 <= csize <= 31.       *
*     2. The number of coefficients  (nh) must be a multiple of 2           *
*        and greater than or equal to 4.                                    *
*     3. The number of outputs (nr) must be a multiple of 4 and             *
*        greater than or equal to 4.                                        *
*     4. The 'index' (offset to start reading input array) must be          *
*        mutiple of 2 and less than or equal to (2^(csize-2) - 6)           *
*     5. The coefficient array is assumed to be in reverse order,           *
*        i.e. h(nh-1) to h(0) hold coeffs. h0, h1, h2 etc.                  *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*     This is the C equivalent for the assembly code.  Note that            *
*     the assembly code is hand optimized and restrictions may              *
*     apply.                                                                *
*                                                                           *
*     void DSPF_dp_fircirc  (double x[], double h[], double r[], int index,      *
*                                   int csize, int nh, int nr)              *
*       {                                                                   *
*         int i, j;                                                         *
*         //Circular Buffer block size = ((2^(csize + 1)) / 8)              *
*         //floating point numbers                                          *
*         int mod = (1 << (csize - 2));                                     *
*         double r0;                                                        *
*                                                                           *
*         for (i = 0; i < nr; i++)                                          *
*         {                                                                 *
*             r0 = 0;                                                       *
*             for (j = 0; j < nh; j++)                                      *
*             {                                                             *
*              //Operation "% mod" is equivalent to "& (mod -1)"            *
*              //r0 += x[(i + j + index) % mod] * h[j];                     *
*                                                                           *
*                r0 += x[(i + j + index) & (mod - 1)] * h[j];               *
*             }                                                             *
*             r[i] = r0;                                                    *
*         }                                                                 *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*     (2*nh + 2) nr + 38                                                    *
*      For nh = 36 & nr=64, cycles = 4774                                   *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_fircirc
_DSPF_dp_fircirc:
        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1X    B6,             A8                  ;Move Index to A8
 ||     MV          .L2X    A8,             B6                  ;Move csize to B6
 ||     MV          .S2     B4,             B7

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     MVC         .S2     CSR,            B5                  ;Get CSR

        STW         .D2     B5,             *B15--[01]
 ||     AND         .S2     -2,             B5,         B5      ;Disable Interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     MV          .L2     B4,             B9                  ;Pointer for h
 ||     MVC         .S2     B5,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     SHL         .S2     B6,             16,         B5      ;BK0<--csize
 ||     MVK         .S1     0x00000040,     A5                  ;Set A7 in CircularMode

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     OR          .S1X    A5,             B5,         A9

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]
 ||     MVC         .S2     A9,             AMR

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]
 ||     MV          .L2X    A10,            B0                  ;Set OuterloopCounter
 ||     MV          .S2     B8,             B1                  ;Set innerloopCounter

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]

        STW         .D2     B9,             *B15--[02]          ;Pushing address of h into stack
 ||     STW         .D1     A6,             *A15--[02]          ;Pushing address of r into stack
 ||     MV          .L1     B8,             A6                  ;nr

        STW         .D2     B8,             *B15--[01]
 ||     ADDAD       .D1     A4,             A8,         A7      ;xptr+=index
************************************************************************************

        LDDW        .D1     *A7++[01],      A1:A0               ;Load x[0]
 ||     LDDW        .D2     *B7++[01],      B3:B2               ;Load h[0]

        MV          .L2     B15,            B6                  ;SP

        LDDW        .D1     *A7++[01],      A3:A2               ;Load x[1]
 ||     LDDW        .D2     *B7++[01],      B5:B4               ;Load h[1]

        LDDW        .D1     *A7,            A5:A4               ;Load x[2]

        LDDW        .D1     *+A7[01],       A1:A0               ;Load x[3]

        MPYDP       .M1X    A1:A0,          B3:B2,      A9:A8   ;P11=x[0]*h[0]

        ZERO        .L1     A13
 ||     ZERO        .S1     A12
 ||     ZERO        .L2     B12
 ||     ZERO        .S2     B13

        MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P12=x[1]*h[0]

        ZERO        .L1     A15
 ||     ZERO        .S1     A14
 ||     ZERO        .L2     B14
 ||     ZERO        .S2     B15

        MPYDP       .M1X    A5:A4,          B3:B2,      A11:A10 ;P13=x[2]*h[0]

        NOP         1

        MPYDP       .M2X    B3:B2,          A1:A0,      B11:B10 ;P14=x[3]*h[0]

   [B1] SUB         .S2     B1,             02,         B1      ;Decrement Inner Loop
***********************************************************************************
**************************BEGIN OF THE KERNEL**************************************
***********************************************************************************
iloop:
        MPYDP       .M1X    A3:A2,          B5:B4,      A9:A8   ;P21=x[1]*h[1]
 ||     LDDW        .D1     *+A7[02],       A3:A2               ;Load x[4]
 ||[!B1]LDW         .D2     *+B6[03],       B7                  ;o-Load h Pointer

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S1+=P11
 ||[!B1]ADD         .S1     A6,             A6,         A2      ;o-

        MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;P22=x[2]*h[1]

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S2+=P12
 ||[B1] LDDW        .D1     *A7++[01],      A1:A0               ;Load x[0]
 ||[B1] LDDW        .D2     *B7++[01],      B3:B2               ;Load h[0]
 ||[!B1]ADD         .S1     A2,             8,          A2      ;o-

        MPYDP       .M1X    A1:A0,          B5:B4,      A11:A10 ;P23=x[3]*h[1]
 ||[!B1]SUBAW       .D1     A7,             A2,         A7      ;Reset pointer for x

        ADDDP       .L1     A15:A14,        A11:A10,    A15:A14 ;S3+=P13
 ||[B1] LDDW        .D1     *A7++[01],      A3:A2               ;Load x[1]
 ||[B1] LDDW        .D2     *B7++[01],      B5:B4               ;Load h[1]

        MPYDP       .M2X    B5:B4,          A3:A2,      B11:B10 ;P24=x[4]*h[1]
 ||[B1] LDDW        .D1     *A7,            A5:A4               ;Load x[2]
 ||[!B1]LDW         .D2     *+B6[02],       B5                  ;o- Pointer for r

        ADDDP       .L2     B15:B14,        B11:B10,    B15:B14 ;S4+=P14
 ||[B1] LDDW        .D1     *+A7[01],       A1:A0               ;Load x[3]

   [B1] MPYDP       .M1X    A1:A0,          B3:B2,      A9:A8   ;P11=x[0]*h[0]
 ||[!B1]LDDW        .D1     *A7++[01],      A1:A0               ;Load x[0]
 ||[!B1]LDDW        .D2     *B7++[01],      B3:B2               ;Load h[0]

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S1+=P21

   [B1] B           .S1     iloop
 ||[B1] MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P12=x[1]*h[0]
 ||[!B1]LDDW        .D1     *A7++[01],      A3:A2               ;Load x[1]
 ||[!B1]LDDW        .D2     *B7++[01],      B5:B4               ;Load h[1]

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S2+=P22
 ||[!B1]LDDW        .D1     *A7,            A5:A4               ;Load x[2]

   [B1] MPYDP       .M1X    A5:A4,          B3:B2,      A11:A10 ;P13=x[2]*h[0]
 ||[!B1]MV          .S2     B5,             B9                  ;Pointer for r

        ADDDP       .L1     A15:A14,        A11:A10,    A15:A14 ;S3+=P23

   [B1] MPYDP       .M2X    B3:B2,          A1:A0,      B11:B10 ;P14=x[3]*h[0]
 ||[!B1]LDW         .D2     *+B6[01],       B1                  ;Load Innerloop Counter

        ADDDP       .L2     B15:B14,        B11:B10,    B15:B14 ;S4+=P24
 ||[B1] SUB         .S2     B1,             02,         B1      ;Decrement Inner Loop Counter
 ||[!B1]STW         .D2     A12,            *B9++               ;Store r0
*****************************************************************************************
***************************END OF KERNEL*************************************************
*****************************************************************************************

        STW         .D2     A13,            *B9++               ;Store r0
 ||     SUB         .S2     B0,             04,         B0      ;Decrement outerloopCounter
 ||     ZERO        .L1     A12
 ||[B0]MPYDP        .M1X    A1:A0,          B3:B2,      A9:A8   ;P11=x[0]*h[0]

        STW         .D2     B12,            *B9++               ;Store r1
 ||     ZERO        .L1     A13
 ||[B0] LDDW        .D1     *+A7[01],       A1:A0               ;Load x[3]

        STW         .D2     B13,            *B9++               ;Store r1
 ||     ZERO        .L2     B12
 ||[B0] B           .S1     iloop
 ||[B0] MPYDP       .M2X    B3:B2,          A3:A2,      B9:B8   ;P12=x[1]*h[0]

        STW         .D2     A14,            *B9++               ;Store r2
 ||     ZERO        .L2     B13

        STW         .D2     A15,            *B9++               ;Store r2
 ||[B0] SUB         .S2     B1,             02,         B1      ;Decrement Inner LooP
 ||     ZERO        .L1     A14
 ||[B0] MPYDP       .M1X    A5:A4,          B3:B2,      A11:A10 ;P13=x[2]*h[0]

        STW         .D2     B14,            *B9++               ;Store r3
 ||     ZERO        .L1     A15

        STW         .D2     B15,            *B9++               ;Store r3
 ||     ZERO        .L2     B14
 ||[B0] MPYDP       .M2X    B3:B2,          A1:A0,      B11:B10 ;P14=x[3]*h[0]

   [B0] STW         .D2     B9,             *+B6[02]            ;Store Pointer For r
 ||     ZERO        .L2     B15

**************************************************************************************
**************************OUTERLOOPBRANCH OCCURSHERE**********************************
**************************************************************************************

        ADDAW       .D2     B6,             3,          B15     ;Restoring Address of B10

        SUB         .L1     B15,            04,         A15     ;Twin stack Pointer
 ||     LDW         .D2     *+B15[11],      B7                  ;Restore CSR

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;enable Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;
                        .end

* ======================================================================== *
*  End of file: DSPF_dp_fircirc.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_biquad./1117057382  928   0     0       17774     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      03-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
*     This routine has following C prototype:                              *
*                                                                          *
*     void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,       *
*                    double *r, int nx)                                    *
*                                                                          *
*            x       :  Pointer to input samples                           *
*            b       :  Pointer to Nr coefs b0, b1, b2                     *
*            a       :  Pointer to Dr coefs a1, a2                         *
*            delay   :  Pointer to filter delays                           *
*            r       :  Pointer to output samples                          *
*            nx      :  Number of input/output samples                     *
*                                                                          *
*  DESCRIPTION                                                             *
*       This routine implements a DF 2 transposed structure of the biquad  *
*       filter. The transfer function of a biquad can be written           *
*       as:                                                                *
*                                                                          *
*                                    b(0) + b(1)z^(-1) + b(2)z^(-2)        *
*                        H(Z) =     _________________________________      *
*                                     1 + a(1)z^(-1) + a(2)z^(-2)          *
*                                                                          *
*    TECHNIQUES                                                            *
*                                                                          *
*         1.  Register sharing has been used to optimize on the use of     *
*         registers.                                                       *
*         2.  x[i] is loaded on both sides to avoid crosspath conflict     *
*                                                                          *
*  ASSUMPTIONS                                                             *
*                                                                          *
*         1. The value of nx is >=4.                                       *
*                                                                          *
*   C CODE                                                                 *
*                                                                          *
*    void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        *
*                                           double *r,  int nx)            *
*    {                                                                     *
*        int i;                                                            *
*        double a1, a2, b0, b1, b2, d0, d1, x_i;                           *
*                                                                          *
*        a1 = a[0];                                                        *
*        a2 = a[1];                                                        *
*                                                                          *
*        b0 = b[0];                                                        *
*        b1 = b[1];                                                        *
*        b2 = b[2];                                                        *
*                                                                          *
*        d0 = delay[0];                                                    *
*        d1 = delay[1];                                                    *
*                                                                          *
*        for (i = 0; i < nx; i++)                                          *
*        {                                                                 *
*            x_i = x[i];                                                   *
*            r[i] = b0 * x_i + d0;                                         *
*            d0 = b1 * x_i - a1 * r[i] + d1;                               *
*            d1 = b2 * x_i - a2 * r[i];                                    *
*        }                                                                 *
*        delay[0] = d0;                                                    *
*        delay[1] = d1;                                                    *
*   }                                                                      *
*                                                                          *
*  NOTES                                                                   *
*                                                                          *
*       1. Endian: This code is LITTLE ENDIAN.                             *
*       2. Interruptibility: This code is interrupt-tolerant but not       *
*      interruptible.                                                      *
*                                                                          *
*                                                                          *
*  CYCLES                                                                  *
*        16 * nx + 49                                                      *
*        For nx = 64,  cycles = 1073                                       *
*        For nx = 48,  cycles = 817.                                       *
*                                                                          *
*  CODESIZE                                                                *
*        576 bytes                                                         *
* ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *


        .text
        .global _DSPF_dp_biquad
_DSPF_dp_biquad:


        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     LDDW        .D1     *A6,            A1:A0               ;load a1
 ||     MV          .S1     A4,             A9                  ;Pointer for x
 ||     MV          .L1     B6,             A7                  ;Pointer for delay
 ||     MVC         .S2     CSR,            B5                  ;Get CSR

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     LDDW        .D1     *+A6[01],       B1:B0               ;load a2
 ||     MV          .L1     B4,             A5                  ;Pointer for b

        STW         .D2     B5,             *B15--[02]          ;Store CSR
 ||     AND         .S2     -2,             B5,         B5      ;Disable Interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     LDDW        .D1     *A5,            A3:A2               ;load b0
 ||     LDDW        .D2     *+B4[01],       B3:B2               ;load b1

        LDDW        .D1     *A7,            A5:A4               ;load d0
 ||     LDDW        .D2     *+B6[01],       B5:B4               ;load d1

        LDDW        .D1     *+A5[02],       A13:A12             ;load b2

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MV          .L2     B6,             B13                 ;Pointer for delay

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]
 ||     MV          .L2     A2,             B14
 ||     MV          .L1     B3,             A14

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]
 ||     MPYDP       .M1     A3:A2,          A1:A0,      A11:A10 ;a1*b0
 ||     MPYDP       .M2X    A3:A2,          B1:B0,      B11:B10 ;a2*b0

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]

        STW         .D2     B14,            *B15--[02]          ;Pushing b0 into stack
 ||     STW         .D1     A3,             *A15--[02]

        STW         .D2     B2,             *B15--[02]          ;Pushing b1 into stack
 ||     STW         .D1     A14,            *A15--[02]

        MV          .L2     A12,            B14
 ||     MV          .S2     B8,             B2                  ;Set the loop counter

        STW         .D2     B14,            *B15--[02]          ;Pushing b2 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MV          .L2     A8,             B3                  ;Pointer for r

        MV          .L2     A0,             B8                  ;a1
 ||     MV          .L1     B0,             A8                  ;
 ||     MV          .S1     A9,             A14                 ;Pointer for x

        MV          .L2     A1,             B9                  ;a2
 ||     MV          .L1     B1,             A9                  ;

        MV          .L2     A4,             B6                  ;d1
 ||     MV          .L1     B4,             A6                  ;

        MV          .L2     A5,             B7                  ;d2
 ||     MV          .L1     B5,             A7                  ;

        MV          .L2     A10,            B10                 ;d2
 ||     MV          .L1     B10,            A10                 ;

        STW         .D2     B10,            *B15--[02]          ;Pushing b2 into stack
 ||     STW         .D1     A11,            *A15--[02]

        STW         .D2     A10,            *B15--[02]          ;Pushing b2 into stack
 ||     STW         .D1     B11,            *A15--[02]

        STW         .D2     B13,            *B15                ;Pushing b2 into stack
 ||     MV          .L2     A14,            B14                 ;Twin Pointer for x
 ||     ADD         .L1     A15,            04,     A15         ;Twin SP

        LDDW        .D2     *+B15[4],       A3:A2               ;load b0

        LDDW        .D1     *+A15[3],       A5:A4               ;load b1
 ||     LDDW        .D2     *+B15[1],       B5:B4               ;load a1*b0

***********************************************************************************
******************************PROLOG BEGINS HERE***********************************
***********************************************************************************

        LDDW    .D1     *A14++[01],     A1:A0                   ;Load x[i]
 ||     LDDW    .D2     *B14++[01],     B1:B0                   ;Load x[i]

        NOP     3

        LDDW    .D1     *+A15[2],       B5:B4                   ;load b2
 ||     LDDW    .D2     *+B15[0],       A5:A4                   ;load a2*b0

        MPYDP   .M1     A5:A4,          A1:A0,      A11:A10     ;b1*X[i]
 ||     MPYDP   .M2     B5:B4,          B1:B0,      B11:B10     ;a1*b0*X[i]

        NOP     2

        B       .S1     sstore                                  ;To skip storing in first iteration
 ||     LDDW    .D1     *+A15[3],       A5:A4                   ;load b1
 ||     LDDW    .D2     *+B15[1],       B5:B4                   ;load a1*b0

        MPYDP   .M1     A5:A4,          A1:A0,      A13:A12     ;a2*b0*X[i]
 ||     MPYDP   .M2     B5:B4,          B1:B0,      B13:B12     ;b2*X[i]

        SUB     .L2     B2,             1,          B2          ;Decrement Innerloop Counter

        NOP     2

        MPYDP   .M1     A3:A2,          A1:A0,      A13:A12     ;b0*X[i]
**************************************************************************************
****************************BEGIN OF KERNEL*******************************************
**************************************************************************************

loop:
  [!B2] LDW     .D2     *B15,           A0                      ;

        STW     .D2     A12,            *B3++                   ;store r[i]

        MPYDP   .M1     A3:A2,          A1:A0,      A13:A12     ;b0*X[i]
 ||     STW     .D2     A13,            *B3++                   ;store r[i]
sstore:
        SUBDP   .L1X    A11:A10,        B11:B10,    A11:A10     ;A11:A10<--b1*X[i]-a1*b0*X[i]

   [!B2] MV     .S2     B3,             B0

   [B2] LDDW    .D1     *A14++[01],     A1:A0                   ;Load x[i]
 ||[B2] LDDW    .D2     *B14++[01],     B1:B0                   ;Load x[i]
 ||     MV      .S1X    B6,             A2

        MPYDP   .M1     A9:A8,          A3:A2,      A7:A6       ;a1*d0
 ||     MPYDP   .M2     B9:B8,          B7:B6,      B7:B6       ;a2*d0
 ||     MV      .S1X    B7,             A3

   [!B2]ADDAW   .D2     B15,            10,         B15

        SUBDP   .L2X    B13:B12,        A13:A12,    B13:B12     ;B13:B12<--b2*X[i]-a2*b0*X[i]
 ||[!B2]SUB     .S1     B15,            04,         A15         ;Twin stack Pointer

        ADDDP   .L1     A11:A10,        A7:A6,      A11:A10
 ||[B2] LDDW    .D1     *+A15[2],       B5:B4                   ;load b2
 ||[B2] LDDW    .D2     *+B15[0],       A5:A4                   ;load a2*b0

   [B2] MPYDP   .M1     A5:A4,          A1:A0,      A11:A10     ;b1*X[i]
 ||[B2] MPYDP   .M2     B5:B4,          B1:B0,      B11:B10     ;a1*b0*X[i]
 ||[B2] B       .S1     loop

        ADDDP   .L1     A13:A12,        A3:A2,      A13:A12     ;r[i]=b0*x[i]+d0
 ||[!B2]LDW     .D2     *++B15[02],     B10                     ;Poping B10 and A10 outof Stack
 ||[!B2]LDW     .D1     *++A15[02],     A10

   [B2] LDDW    .D2     *+B15[4],       A3:A2                   ;load b0
 ||[!B2]LDW     .D1     *+A15[13],      B3                      ;Restoring Return address

   [B2] LDDW    .D1     *+A15[3],       A5:A4                   ;load b1
 ||[B2] LDDW    .D2     *+B15[1],       B5:B4                   ;load a1*b0
 ||[!B2]MV      .S1     A0,             A8
 ||[!B2]MV      .S2     B0,             B9

   [B2] MPYDP   .M1     A5:A4,          A1:A0,      A13:A12     ;b2*X[i]
 ||[B2] MPYDP   .M2     B5:B4,          B1:B0,      B13:B12     ;a2*b0*X[i]
 ||[!B2]LDW     .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||[!B2]LDW     .D1     *++A15[02],     A11

        SUBDP   .L2X    A11:A10,        B7:B6,      B7:B6       ;d0
 ||     SUBDP   .L1X    B13:B12,        A7:A6,      A7:A6       ;d1
 ||[B2] SUB     .S2     B2,             1,          B2          ;Decrement Innerloop Counter
 ||[!B2]LDW     .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||[!B2]LDW     .D1     *++A15[02],     A12


********************************************************************************************
**********************************END OF KERNEL*********************************************
********************************************************************************************


        LDW     .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW     .D1     *++A15[02],     A13

        STW     .D2     A12,        *B9++                   ;store r[i]
 ||     LDW     .D1     *+A15[05],      B9                  ;Get CSR

        STW     .D2     A13,        *B9++                   ;store r[i]

        LDW     .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW     .D1     *++A15[02],     A14

        B               B3;

        LDW     .D2     *++B15[03],     A15                 ;Poping A15 out of Stack

        ADDAW   .D2     B15,            01,         B15     ;Clearing the Stack
 ||     STW     .D1     B6,             *A8++
 ||     MVC     .S2     B9,             CSR                 ;Enable Interrupts

        STW     .D1     B7,             *A8++

        STW     .D1     A6,             *A8++

        STW     .D1     A7,             *A8++


                .end

* ======================================================================== *
*  End of file: DSPF_dp_biquad.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_iir.asm/1117057383  0     0     0       19366     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*    This routine is C callable, and has the following C prototype:         *
*                                                                           *
*       void DSPF_dp_iir    (double* restrict r1,                                *
*                       const double*    x,                                 *
*                       double* restrict r2,                                *
*                       const double*    h2,                                *
*                       const double*    h1,                                *
*                       int nr                                              *
*                      );                                                   *
*                                                                           *
*            r1[nr+4]   :  Delay element values (i/p and o/p)               *
*            x[nr]      :  Pointer to the input array                       *
*            r2[nr+4]   :  Pointer to the output array                      *
*            h2[5]      :  Auto-regressive filter coefficients              *
*            h1[5]      :  Moving average filter coefficients               *
*            nr         :  Number of output samples                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*     The IIR performs an auto-regressive moving-average (ARMA)             *
*     filter with 4 auto-regressive filter coefficients and 5               *
*     moving-average filter coefficients for nr output samples.             *
*     The output vector is stored in two locations. This routine            *
*     is used as a high pass filter in the VSELP vocoder. The               *
*     4 values in the r1 vector store the initial values of the             *
*     delays.                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*     1. The inner loop is completely unrolled so that two loops            *
*        become one loop.                                                   *
*     2. Register Sharing is used to make Optimum Utilisation of            *
*        available registers.                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. The value of 'nr' must be > 0.                                     *
*     2. Extraneous loads are allowed in the program.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the Assembly Code without                   *
*   restrictions.                                                           *
*                                                                           *
*   Note that the assembly code is hand optimized and restrictions          *
*   may apply.                                                              *
*                                                                           *
*   void DSPF_dp_iir (double* restrict r1,                                       *
*                const double*    x,                                        *
*                double* restrict r2,                                       *
*                const double*    h2,                                       *
*                const double*    h1,                                       *
*                int nr                                                     *
*                )                                                          *
*    {                                                                      *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*          sum = h2[0] * x[4+i];                                            *
*          for (j = 1; j <= 4; j++)                                         *
*             sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];                  *
*                                                                           *
*          r1[4+i] = sum;                                                   *
*          r2[i] = r1[4+i];                                                 *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. Endian: The code is LITTLE ENDIAN.                                *
*      2. Interruptibility: This code is interrupt-tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      24*nr + 48                                                           *
*      eg. for nr = 32, cycles = 816.                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      608 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_iir
_DSPF_dp_iir:

        STW         .D2     B3,         *B15--[01]              ;Pushing returnaddress into Stack
 ||     MV          .L1     B6,         A3                      ;Pointer to h2
 ||     MV          .L2     B4,         B3                      ;Pointer for x

        STW         .D2     A15,        *B15--[01]              ;Pushing A15 into Stack
 ||     MVC         .S2     CSR,        B7                      ;Get CSR

        STW         .D2     B7,         *B15--[01]              ;Store CSR
 ||     AND         .S2     -2,         B7,         B7          ;Disable Interrupts

        SUB         .S1X    B15,        04,         A15         ;Setting A15<- SP-1
 ||     MV          .L2     A6,         B2                      ;Pointer for r2
 ||     LDDW        .D1     *A3++[04],  A1:A0                   ;load h2[0] &Set h2 to h2[4+i]
 ||     MVC         .S2     B7,         CSR

        STW         .D2     B14,        *B15--[02]              ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,        *A15--[02]
 ||     MV          .L2     A4,         B14                     ;Pointer for r1

        LDDW        .D2     *+B3[04],   B1:B0                   ;load x[4+i]
 ||     ADDAD       .D1     A8,         4,          A14         ;Set h1 to h1[4+i]

        STW         .D2     B13,        *B15--[02]              ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,        *A15--[02]
 ||     MV          .L1     B8,         A2                      ;Set the counter

        LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[4]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[i]

        STW         .D2     B12,        *B15--[02]              ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,        *A15--[02]

        STW         .D2     B11,        *B15--[02]              ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,        *A15--[02]

        STW         .D2     B10,        *B15--[02]              ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,        *A15--[02]

        LDDW        .D1     *A3--[01],  A5:A4                   ;Load h2[4]
 ||     LDDW        .D2     *B3++[01],  B5:B4                   ;Load x[i]
 ||     MV          .S1     B2,         A15

***********************************************************************************************
********************************PROLOG BEGINS HERE*********************************************
***********************************************************************************************
        MPYDP       .M1X    B1:B0,      A1:A0,      A11:A10     ;S1=h2[0]*x[4+i]
 ||     LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[3]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[1+i]

        MPYDP       .M2X    B7:B6,      A7:A6,      B11:B10     ;S2=h1[4]*r1[i]

        NOP         1

        LDDW        .D1     *A3--[01],  A5:A4                   ;Load h2[3]
 ||     LDDW        .D2     *B3++[01],  B5:B4                   ;Load x[1+i]

        MPYDP       .M1X    A5:A4,      B5:B4,      A9:A8       ;P1=h2[4]*x[i]
 ||     LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[2]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[2+i]

        MPYDP       .M2X    B7:B6,      A7:A6,      B9:B8       ;P2=h1[3]*r1[1+i]

        NOP         1

        LDDW        .D1     *A3--[01],  A5:A4                   ;Load h2[2]
 ||     LDDW        .D2     *B3++[01],  B5:B4                   ;Load x[2+i]

        MPYDP       .M1X    A5:A4,      B5:B4,      A9:A8       ;P1=h2[3]*x[1+i]
 ||     LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[1]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[3+i]

        MPYDP       .M2X    B7:B6,      A7:A6,      B9:B8       ;P2=h1[2]*r1[2+i]

        NOP         2

        LDDW        .D1     *A3--[01],  A5:A4                   ;Load h2[1]
 ||     LDDW        .D2     *B3++[01],  B5:B4                   ;Load x[3+i]

        MPYDP       .M1X    A5:A4,      B5:B4,      A9:A8       ;P1=h2[2]*x[2+i]
 ||     ADDDP       .L1     A11:A10,    A9:A8,      A11:A10     ;S1+=P1

        NOP         1

        ADDDP       .L2     B11:B10,    B9:B8,      B11:B10     ;S2+=P2
 ||     LDDW        .D2     *+B3[01],   B1:B0                   ;Load x[4+i](for next iteration)

        ADDAD       .D1     A14,        4,          A14         ;Reset h1 Pointer
 ||     SUBAW       .D2     B14,        6,          B14         ;reset r1 Pointer1

        ADDAD       .D1     A3,         4,          A3          ;Reset h2 Pointer
 ||     SUBAW       .D2     B3,         6,          B3          ;reset x Pointer

        MPYDP       .M1X    A5:A4,      B5:B4,      A9:A8       ;P1=h2[4]*x[i]
 ||     LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[4]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[i]

        MPYDP       .M2X    B7:B6,      A7:A6,      B9:B8       ;P2=h1[1]*r1[3+i]
 ||     ADDDP       .L1     A11:A10,    A9:A8,      A11:A10     ;S1+=P1

        NOP         1

        ADDDP       .L2     B11:B10,    B9:B8,      B11:B10     ;S2+=P2

 [A2]   SUB         .S1     A2,         1,          A2          ;Decrement loop Counter
****************************************************************************************
********************************BEGIN OF KERNEL*****************************************
****************************************************************************************
loop:

        LDDW        .D1     *A3--[01],  A5:A4                   ;Load h2[4]
 ||     LDDW        .D2     *B3++[01],  B5:B4                   ;Load x[i]

        MPYDP       .M1X    B1:B0,      A1:A0,      A11:A10     ;S1=h2[0]*x[4+i]
 ||     LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[3]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[1+i]

        ADDDP       .L1     A11:A10,    A9:A8,      A11:A10     ;S1+=P1
 ||     MPYDP       .M2X    B7:B6,      A7:A6,      B11:B10     ;S2=h1[4]*r1[i]

        NOP         1

        LDDW        .D1     *A3--[01],  A5:A4                   ;Load h2[3]
 ||     LDDW        .D2     *B3++[01],  B5:B4                   ;Load x[1+i]

        ADDDP       .L2     B11:B10,    B9:B8,      B13:B12     ;final S2
 ||     MPYDP       .M1X    A5:A4,      B5:B4,      A9:A8       ;P1=h2[4]*x[i]
 ||     LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[2]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[2+i]

        MPYDP       .M2X    B7:B6,      A7:A6,      B9:B8       ;P2=h1[3]*r1[1+i]

        NOP         1

        ADDDP       .L1     A11:A10,    A9:A8,      A13:A12     ;final S1
 ||     LDDW        .D1     *A3--[01],  A5:A4                   ;Load h2[2]
 ||     LDDW        .D2     *B3++[01],  B5:B4                   ;Load x[2+i]

        MPYDP       .M1X    A5:A4,      B5:B4,      A9:A8       ;P1=h2[3]*x[1+i]
 ||     LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[1]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[3+i]

        MPYDP       .M2X    B7:B6,      A7:A6,      B9:B8       ;P2=h1[2]*r1[2+i]

        NOP         2

        LDDW        .D1     *A3--[01],  A5:A4                   ;Load h2[1]
 ||     LDDW        .D2     *B3++[01],  B5:B4                   ;Load x[3+i]

        SUBDP       .L2X    A13:A12,    B13:B12,    B13:B12     ;final Sum
 ||     MPYDP       .M1X    A5:A4,      B5:B4,      A9:A8       ;P1=h2[2]*x[2+i]
 ||     ADDDP       .L1     A11:A10,    A9:A8,      A11:A10     ;S1+=P1

        NOP         1

        ADDDP       .L2     B11:B10,    B9:B8,      B11:B10     ;S2+=P2
 ||     LDDW        .D2     *+B3[01],   B1:B0                   ;Load x[4+i](for next iteration)

        ADDAD       .D1     A14,        4,          A14         ;Reset h1 Pointer
 ||     SUBAW       .D2     B14,        6,          B14         ;reset r1 Pointer1

   [A2] B           .S1     loop
 ||     ADDAD       .D1     A3,         4,          A3          ;Reset h2 Pointer
 ||     SUBAW       .D2     B3,         6,          B3          ;reset x Pointer

        MPYDP       .M1X    A5:A4,      B5:B4,      A9:A8       ;P1=h2[4]*x[i]
 ||     LDDW        .D1     *A14--[01], A7:A6                   ;Load h1[4]
 ||     LDDW        .D2     *B14++[01], B7:B6                   ;Load r1[i]

        MPYDP       .M2X    B13:B12,        A7:A6,      B9:B8   ;P2=h1[1]*r1[3+i]
 ||     ADDDP       .L1     A11:A10,    A9:A8,      A11:A10     ;S1+=P1
 ||     STW         .D2     B12,        *+B14[02]               ;Store r1[4+i]

        STW         .D2     B13,        *+B14[03]               ;Store r1[4+i]

        ADDDP       .L2     B11:B10,    B9:B8,      B11:B10     ;S2+=P2
 ||     STW         .D1     B12,        *A15++[01]              ;Store r2[i]

   [A2] SUB         .S1     A2,         1,          A2          ;Decrement loop Counter
 ||     STW         .D1     B13,        *A15++[01]              ;Store r2[i]
************************************************************************************
********************************END OF KERNEL***************************************
************************************************************************************

        SUB         .L1     B15,            04,         A15     ;Set Twin SP
 ||     LDW         .D2     *+B15[11],      B7                  ;Restore CSR

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;


                .end

* ======================================================================== *
*  End of file: DSPF_dp_iir.asm                                                 *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_iirlat./1117057384  948   0     0       22850     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*         This routine has following C prototype:                           *
*                                                                           *
*             void DSPF_dp_iirlat(                                               *
*                           double *x,                                      *
*                           int nx,                                         *
*                           const double * restrict k,                      *
*                           int nk,                                         *
*                           double * restrict b,                            *
*                           double * r                                      *
*                           )                                               *
*          x[nx]   : Input vector                                           *
*          nx      : Length of input vector.                                *
*          k[nk]   : Reflection coefficients                                *
*          nk      : Number of reflection coefficients/lattice stages       *
*                    Must be multiple of 2 and >=6.                         *
*          b[nk+1] : Delay line elements from previous call. Should be      *
*                    initialized to all zeros prior to the first call.      *
*          r[nx]   : Output vector                                          *
*                                                                           *
*      DESCRIPTION                                                          *
*                                                                           *
*          This routine implements a real all-pole IIR filter in lattice    *
*      structure (AR lattice). The filter consists of nk lattice stages.    *
*      Each  stage  requires one  reflection coefficient  k and one delay   *
*      element b. The routine takes an input vector x[] and returns the     *
*      filter output in r[]. Prior to the first call of the outine the      *
*      delay elements in b[]  should be set to zero. The input data may     *
*      have to be pre-scaled to avoid overflow or achieve better SNR. The   *
*      reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     *
*      order of the coefficients is such that k[nk-1] corresponds to the    *
*      first lattice stage after the input and k[0] Corresponds to the      *
*      last stage.                                                          *
*                                                                           *
*     TECHNIQUES                                                            *
*                                                                           *
*          1.  The loop has been unrolled by 4 times.                       *
*                                                                           *
*          2.  Register sharing has been used to optimize on the            *
*              use of registers.                                            *
*                                                                           *
*     ASSUMPTIONS                                                           *
*                                                                           *
*         1. nk is a multiple of 2 and >=6.                                 *
*         2. Extraneous loads are allowed (80 bytes) before the start of    *
*            array.                                                         *
*                                                                           *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    void DSPF_dp_iirlat(double * x, int nx, const double * restrict k, int nk,  *
*                    double * restrict b, double * r)                       *
*    {                                                                      *
*                                                                           *
*       double rt;     // output       //                                   *
*       int i, j;                                                           *
*                                                                           *
*       for (j = 0; j < nx; j++)                                            *
*       {                                                                   *
*          rt = x[j];                                                       *
*                                                                           *
*          for (i = nk - 1; i >= 0; i--)                                    *
*          {                                                                *
*              rt = rt - b[i] * k[i];                                       *
*              b[i + 1] = b[i] + rt * k[i];                                 *
*          }                                                                *
*                                                                           *
*          b[0] = rt;                                                       *
*          r[j] = rt;                                                       *
*       }                                                                   *
*     }                                                                     *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (24*Ceil(nk/4) + 19)* nx + 33                                       *
*        For nk = 14, nx = 64 cycles = 7393                                 *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_iirlat
_DSPF_dp_iirlat:

        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1     B6,             A5                  ;nk

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     ADDAD       .D1     A6,             A5,         A6      ;*k=*k+nk
 ||     MV          .L2     A8,             B7
 ||     MVC         .S2     CSR,            B5

        STW         .D2     B5,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B5,         B5      ;Disable Interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     ADDAD       .D2     B7,             B6,         B7      ;*b=*b+nk
 ||     MVC         .S2     B5,             CSR

        LDDW        .D1     *--A6[01],      B1:B0               ;Load k[i]
 ||     LDDW        .D2     *--B7[01],      A1:A0               ;Load b[i]

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     ADD         .L2     A6,             8,          B14     ;Pointer for k
 ||     ADD         .L1     B7,             8,          A14     ;Pointer for b

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MV          .S2     A6,             B13                 ;
 ||     MV          .S1     B7,             A13                 ;

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]
 ||     MV          .L1     A14,            A12                 ;Pointer for b
 ||     MV          .L2     B14,            B12                 ;Pointer for k
 ||     MV          .S1     B8,             A9

        LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i-1]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i-1]
 ||     MV          .S2     A14,            B3                  ;Pointer for b[i+1]
 ||     MV          .S1     B4,             A2                  ;Set the outerloop Counter

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]
 ||     MV          .L2     B6,             B2                  ;Set the Innerloop Counter
 ||     MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i]*k[i]
 ||     MV          .L1     A4,             A3                  ;Pointer for x

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]

        LDDW        .D1     *A3++[01],      A7:A6               ;rt
 ||     MV          .S1     A9,             A15                 ;Pointer for r
 ||     STW         .D2     B6,             *B15--[01]

        LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i-2]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i-2]

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i-1]*k[i-1]

        NOP         3

        LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i-3]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i-3]

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i-2]*k[i-2]
 ||     SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt-b[i]*k[i]

oloop:

        LDDW        .D2     *--B12[01],     B7:B6               ;Load k[i](2)

        LDW         .D2     *+B15[01],      B2                  ;o-Set Innerloop Counter

        NOP         2

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i-3]*k[i-3]

        MPYDP       .M2     B7:B6,          A7:A6,      B9:B8   ;rt1*k[i]
 ||     SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt1-b[i-1]*k[i-1]

        LDDW        .D2     *--B12[01],     B7:B6               ;Load k[i-1](2)

        MV          .S1     A2,             A10                 ;Save Outerloop Counter

        LDDW        .D1     *--A12[01],     B5:B4               ;Load b[i](2)
 ||     SUB         .S2     B2,             04,         B2      ;Decrement InnerloopCounter

        LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i]

        MV          .S2     A14,            B3                  ;Pointer for b[i+1]

        MPYDP       .M2X    B7:B6,          A7:A6,      B9:B8   ;rt2*k[i-1]
 ||     SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt2-b[i-2]*k[i-2]

        LDDW        .D2     *--B12[01],     B7:B6               ;Load k[i-2](2)

        LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i-1]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i-1]

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i]*k[i]
 ||     ADDDP       .L2     B5:B4,          B9:B8,      B11:B10 ;b[i]+rt*k[i]

        LDDW        .D1     *--A12[01],     B5:B4               ;Load b[i-1](2)

        LDDW        .D2     *--B12[01],     B7:B6               ;Load k[i-3](2)

        MPYDP       .M2X    B7:B6,          A7:A6,      B9:B8   ;rt3*k[i-2]
 ||     SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt3-b[i-3]*k[i-3]
 ||     LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i-2]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i-2]

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i-1]*k[i-1]


****************************************************************************************
*****************************BEGIN OF KERNEL********************************************
****************************************************************************************
iloop:
        LDDW        .D1     *--A12[01],     B5:B4               ;Load b[i-2](2)
 ||[B2] SUB         .S2     B2,             04,         B2      ;Decrement InnerloopCounter

        ADDDP       .L2     B5:B4,          B9:B8,      B11:B10 ;b[i-1]+rt1*k[i-1]
 ||     STW         .D2     B10,            *B3++[01]

        STW         .D2     B11,            *B3--[03]

        LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i-3]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i-3]

        MPYDP       .M2X    B7:B6,          A7:A6,      B9:B8   ;rt3*k[i-2]
 ||     MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i-2]*k[i-2]
 ||     SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt-b[i]*k[i]

        LDDW        .D2     *--B12[01],     B7:B6               ;Load k[i](2)

        NOP         1

        ADDDP       .L2     B5:B4,          B9:B8,      B11:B10 ;b[i-2]+rt2*k[i-2]
 ||     STW         .D2     B10,            *B3++[01]

        LDDW        .D1     *--A12[01],     B5:B4               ;Load b[i-3](2)
 ||     CMPGT       .L1     B2,             00,         A2      ;to Check nk Is multilple of 4 or not

        STW         .D2     B11,            *B3--[03]
 ||     MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i-3]*k[i-3]
 ||[!A2]ADD         .S2     B2,             02,         B2

        MPYDP       .M2     B7:B6,          A7:A6,      B9:B8   ;rt*k[i]
 ||     SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt1-b[i-1]*k[i-1]

        LDDW        .D2     *--B12[01],     B7:B6               ;Load k[i-1](2)

        NOP         1

        LDDW        .D1     *--A12[01],     B5:B4               ;Load b[i](2)
 ||     ADDDP       .L2     B5:B4,          B9:B8,      B11:B10 ;b[i-3]+rt3*k[i-3]

        LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i]

        STW         .D2     B10,            *B3++[01]

        STW         .D2     B11,            *B3--[03]
 ||     MPYDP       .M2X    B7:B6,          A7:A6,      B9:B8   ;rt1*k[i-1]
 ||[B2] SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt1-b[i-2]*k[i-2]

   [B2] LDDW        .D2     *--B12[01],     B7:B6               ;Load k[i-2](2)

        LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i-1]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i-1]
 ||[A2] B           .S1     iloop

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i]*k[i]
 ||     ADDDP       .L2     B5:B4,          B9:B8,      B11:B10 ;b[i]+rt*k[i]
 ||     STW         .D2     B10,            *B3++[01]

        LDDW        .D1     *--A12[01],     B5:B4               ;Load b[i-1](2)

   [B2] LDDW        .D2     *--B12[01],     B7:B6               ;Load k[i-3](2)

        MPYDP       .M2X    B7:B6,          A7:A6,      B9:B8   ;rt2*k[i-2]
 ||[B2] SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt2-b[i-3]*k[i-3]
 ||     LDDW        .D1     *--A13[01],     A1:A0               ;Load b[i-2]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;Load k[i-2]

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i-1]*k[i-1]
 ||     STW         .D2     B11,            *B3--[03]

***********************************************************************************
********************************END OF KERNEL**************************************
***********************************************************************************
   [B2] LDDW        .D1     *--A12[01],     B5:B4               ;e-Load b[i-2](2)
 ||     MV          .S1     A14,            A13                 ;o-reset Pointer forb[i]
 ||     MV          .S2     B14,            B13                 ;o-reset Pointer fork[i]

        ADDDP       .L2     B5:B4,          B9:B8,      B11:B10 ;e-b[i-1]+rt1*k[i-1]
 ||     LDDW        .D1     *--A13[01],     A1:A0               ;p-Load b[i]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;p-Load k[i]
 ||     MV          .S1     A10,            A2                  ;Get Outerloop Counter

        STW         .D2     B10,            *B3++[01]           ;e-
 ||[A2] SUB         .S1     A2,             01,         A2      ;o-Decrement Outerloop Counter

        STW         .D2     B11,            *B3--[03]           ;e-

        MPYDP       .M2X    B7:B6,          A7:A6,      B9:B8   ;e-rt3*k[i-2]
 ||     STW         .D1     A6,             *A15++              ;Store r[i]

        LDDW        .D1     *--A13[01],     A1:A0               ;p-Load b[i-1]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;p-Load k[i-1]

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;p-b[i]*k[i]
 ||     STW         .D1     A7,             *A15++              ;o-Store r[i]

   [B2] ADDDP       .L2     B5:B4,          B9:B8,      B11:B10 ;e-b[i-2]+rt2*k[i-2]
 ||     STW         .D2     B10,            *B3++[01]           ;e-
 ||     LDDW        .D1     *A3++[01],      A7:A6               ;rt

   [B2] LDDW        .D1     *--A12[01],     B5:B4               ;e-Load b[i-3](2)

        STW         .D2     B11,            *B3--[03]           ;e-
 ||     STW         .D1     A6,             *A12                ;Store b[0]

        STW         .D1     A7,             *+A12[01]           ;Store b[0]

        LDDW        .D1     *--A13[01],     A1:A0               ;p-Load b[i-2]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;p-Load k[i-2]

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;p-b[i]*k[i]

   [B2] ADDDP       .L2     B5:B4,          B9:B8,      B11:B10 ;e-b[i-3]+rt3*k[i-3]

        MV          .S1     A14,            A12                 ;o-reset Pointer forb[i]
 ||     MV          .S2     B14,            B12                 ;o-reset Pointer fork[i]

   [B2] STW         .D2     B10,            *B3++[01]           ;e-
 ||[A2] B           .S1     oloop

   [B2] STW         .D2     B11,            *B3--[03]           ;e-

        LDDW        .D1     *--A13[01],     A1:A0               ;p-Load b[i-2]
 ||     LDDW        .D2     *--B13[01],     B1:B0               ;p-Load k[i-2]

        MPYDP       .M1X    A1:A0,          B1:B0,      A9:A8   ;b[i-2]*k[i-2]
 ||     SUBDP       .L1     A7:A6,          A9:A8,      A7:A6   ;rt-b[i]*k[i]

   [B2] STW         .D2     B10,            *B3++[01]           ;e-

   [B2] STW         .D2     B11,            *B3--[03]           ;e-
*************************************************************************************
****************OUTRLOOP BRANCH+END OF EPILOG+PROLOG+OUTERLOOPINSTRUCTIONS***********
*************************************************************************************
        LDW         .D2     *+B15[12],      B7                  ;Restore CSR

        MV          .L1     B15,            A15
 ||     ADD         .L2     B15,            04,         B15     ;Twin stack Pointer

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
 ||     MVC         .S2     B7,             CSR                 ;Enable interrupts
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;

                .end

* ======================================================================== *
*  End of file: DSPF_dp_iirlat.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_convol./1117057384  968   0     0       18647     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_convol -- Double Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*     This routine has the following C prototype:                           *
*                                                                           *
*     void DSPF_dp_convol                                                        *
*          (                                                                *
*                double *x, //x: Pointer to input samples//                 *
*                double *h, //h: Pointer to impulse response samples//      *
*                double *r, //r: Pointer to output samples//                *
*                int   nh, //nh: Number of impulse response samples//       *
*                int   nr  //nr: Number of output samples//                 *
*          )                                                                *
*                                                                           *
*           x = pointer to real input vector of size = nr+nh-1              *
*           a typically contains input data (x) padded with                 *
*           consecutive nh - 1  zeros at the beginning and end.             *
*           h = pointer to real input vector of size nh in forward order.   *
*           h typically contains the filter coefs.                          *
*           r = Pointer to real output vector of size nr                    *
*           nh= Number of elements in vector b. NOTE: nh <= nr  nh is       *
*           typically noted as m in convol formulas. nh must be a           *
*           MULTIPLE of 2                                                   *
*           nr= Number of elements in vector r. nr must be a MULTIPLE of 4  *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*           This function calculates the full-length convolution of real    *
*           vectors x and h using time-domain techniques. The result is     *
*           placed in real vector r.                                        *
*                                                                           *
*           It is assumed that input vector x is padded with nh-1 no of     *
*           zeros in the beginning and end.                                 *
*                                                                           *
*           It is assumed that the length of the input vector h, nh, is a   *
*           multiple of 2 and the length of the output vector r, nr, is a   *
*           multiple of 4. nh is greater than or equal to 4 and nr is       *
*           greater than or equal to nh. The routine computes 4 output      *
*           samples at a time.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*           1. The inner loop is unrolled twice and the outer loop is       *
*              unrolled four times.                                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*           1. nh is a multiple of 2 and greater than or equal to 4         *
*           2. nr is a multiple of 4                                        *
*                                                                           *
*   C CODE                                                                  *
*           This is the C equivalent of the assembly code.  Note that       *
*           the assembly code is hand optimized and restrictions may        *
*           apply.                                                          *
*                                                                           *
*                                                                           *
*           void DSPF_dp_convol(double *x, double *h, double *r, short nh,       *
*                          short nr)                                        *
*           {                                                               *
*             short   octr, ictr;                                           *
*             double  acc ;                                                 *
*                                                                           *
*             for (octr = nr ; octr > 0 ; octr--)                           *
*             {                                                             *
*               acc = 0 ;                                                   *
*                                                                           *
*               for (ictr = nh ; ictr > 0 ; ictr--)                         *
*               {                                                           *
*              acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       *
*               }                                                           *
*               r[nr-octr] = acc;                                           *
*             }                                                             *
*           }                                                               *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*           1. Endian: This code is LITTLE ENDIAN.                          *
*           2. Interruptibility: This code is interrupt tolerant but not    *
*                        interruptible.                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*           2*(nh*nr) + 5/2*nr + 32                                         *
*           For nh=24 and nr=48, cycles=2456                                *
*           For nh=20 and nr=32, cycles=1392                                *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*           544 bytes                                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_convol
_DSPF_dp_convol:
        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     MVC         .S2     CSR,            B7

        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable Interrupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1,Twin SP's
 ||     ADDAD       .D2     B4,             B6,         B4      ;Set the pointer for array h[i]
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     MV          .L1     A4,             A14                 ;Pointer for x[]
 ||     MV          .L2     B4,             B14                 ;Pointer for h[nh]

        LDDW        .D1     *A14++[01],     A1:A0               ;p-Load x[0]
 ||     LDDW        .D2     *--B14[01],     B3:B2               ;p-Load h[n-1]

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MV          .L2     A8,             B0                  ;Set Outerloop Counter nr
 ||     MV          .S2     B6,             B1                  ;Set Innerloop Counter nr

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]

        LDDW        .D1     *A14++[01],     A3:A2               ;p-Load x[1]
 ||     LDDW        .D2     *--B14[01],     B5:B4               ;p-Load h[n-2]

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]

        LDDW        .D1     *A14,           A5:A4               ;p-Load x[2]

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]
 ||     MPYDP       .M1X    A1:A0,          B3:B2,      A7:A6   ;p-P11=h[n-1]*x[0]

        STW         .D2     B4,             *B15--[02]          ;Pushing address of h[i]into stack
 ||     STW         .D1     A4,             *A15--[02]          ;Pushing address of x[i]into stack

        LDDW        .D1     *+A14[01],      A1:A0               ;p-Load x[3]

        STW         .D2     B6,             *B15--[01]          ;Pushing nh into stack
 ||     MV          .L1     A6,             A15                 ;Pointer for r[i]
 ||     MPYDP       .M2X    B3:B2,          A3:A2,      B7:B6   ;p-P12=h[n-1]*x[1]

        ZERO        .L1     A10
 ||     ZERO        .S1     A11
 ||     ZERO        .L2     B10
 ||     ZERO        .S2     B11

        MPYDP       .M1X    A5:A4,          B3:B2,      A9:A8   ;P13=h[n-1]*x[2]

        ZERO        .L1     A12
 ||     ZERO        .S1     A13
 ||     ZERO        .L2     B12
 ||     ZERO        .S2     B13

        MPYDP       .M2X    B3:B2,          A1:A0,      B9:B8   ;P14=h[n-1]*x[3]

        LDDW        .D1     *+A14[02],      A3:A2               ;Load x[4]
 ||     SUB         .L2     B1,             02,         B1      ;Decrement Innerloop Counter

************************************************************************************
*********************************BEGIN OF KERNEL************************************
************************************************************************************
loop:

        MPYDP       .M1X    A3:A2,          B5:B4,      A7:A6   ;P21=h[n-2]*x[1]
 ||[!B1]LDW         .D2     *+B15[02],      A14                 ;o-Load x Pointer

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P11
 ||[!B1]LDW         .D2     *+B15[03],      B14                 ;o-Load h Pointer

        MPYDP       .M2X    B5:B4,          A5:A4,      B7:B6   ;P22=h[n-2]*x[2]

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P12
 ||[B1] LDDW        .D1     *A14++[01],     A1:A0               ;Load x[0]
 ||[B1] LDDW        .D2     *--B14[01],     B3:B2               ;Load h[n-1]

        MPYDP       .M1X    A1:A0,          B5:B4,      A9:A8   ;P23=h[n-2]*x[3]

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P13
 ||[B1] LDDW        .D1     *A14++[01],     A3:A2               ;Load x[1]
 ||[B1] LDDW        .D2     *--B14[01],     B5:B4               ;Load h[n-2]

        MPYDP       .M2X    B5:B4,          A3:A2,      B9:B8   ;P24=h[n-2]*x[4]
 ||[!B1]ADDAD       .D1     A14,            4,          A14     ;o-Update x Pointer

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P14
 ||[B1] LDDW        .D1     *A14,           A5:A4               ;Load x[2]

   [B1] MPYDP       .M1X    A1:A0,          B3:B2,      A7:A6   ;P11=h[n-1]*x[0]
 ||[!B1]STW         .D2     A14,            *+B15[02]           ;o-Store Updated Pointer of x

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P21
 ||[B1] LDDW        .D1     *+A14[01],      A1:A0               ;Load x[3]

   [B1] B           .S1     loop
 ||[B1] MPYDP       .M2X    B3:B2,          A3:A2,      B7:B6   ;P12=h[n-1]*x[1]
 ||[!B1]LDDW        .D1     *A14++[01],     A1:A0               ;p-Load x[0]
 ||[!B1]LDDW        .D2     *--B14[01],     B3:B2               ;p-Load h[n-1]

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P22
 ||[!B1]LDW         .D2     *+B15[01],      B1                  ;o-Set Innerloop Counter

   [B1] MPYDP       .M1X    A5:A4,          B3:B2,      A9:A8   ;P13=h[n-1]*x[2]
 ||[!B1]LDDW        .D1     *A14++[01],     A3:A2               ;p-Load x[1]
 ||[!B1]LDDW        .D2     *--B14[01],     B5:B4               ;p-Load h[n-2]

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P23

   [B1] MPYDP       .M2X    B3:B2,          A1:A0,      B9:B8   ;P14=h[n-1]*x[3]
 ||[!B1]LDDW        .D1     *A14,           A5:A4               ;p-Load x[2]

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P24
 ||[B1] LDDW        .D1     *+A14[02],      A3:A2               ;Load x[4]
 ||[B1] SUB         .S2     B1,             02,         B1      ;Decrement Innerloop Counter

************************************************************************************
***********************************END OF KERNEL************************************
************************************************************************************

        STW         .D1     A10,            *A15++[1]           ;o-Store r1
 ||[B0] SUB         .S2     B0,             04,         B0      ;o-Decrement Outerloop Counter
 ||     ZERO        .S1     A10
 ||[B0] MPYDP       .M1X    A1:A0,          B3:B2,      A7:A6   ;p-P11=h[n-1]*x[0]

   [B0] LDDW        .D1     *+A14[01],      A1:A0               ;p-Load x[3]

        STW         .D1     A11,            *A15++[1]           ;o-Store r1
 ||     ZERO        .S1     A11
 ||[B0] MPYDP       .M2X    B3:B2,          A3:A2,      B7:B6   ;p-P12=h[n-1]*x[1]

        STW         .D1     B10,            *A15++[1]           ;o-Store r2
 ||     ZERO        .S2     B10

   [B0] B           .S1     loop
 ||     STW         .D1     B11,            *A15++[1]           ;o-Store r2
 ||     ZERO        .S2     B11
 ||[B0] MPYDP       .M1X    A5:A4,          B3:B2,      A9:A8   ;p-P13=h[n-1]*x[2]

        STW         .D1     A12,            *A15++[1]           ;o-Store r3
 ||     ZERO        .S1     A12

        STW         .D1     A13,            *A15++[1]           ;o-Store r3
 ||[B0] MPYDP       .M2X    B3:B2,          A1:A0,      B9:B8   ;p-P14=h[n-1]*x[3]
 ||     ZERO        .S1     A13
 ||[!B0]ADD         .S2     B15,            12,         B15     ;Restore SP

        STW         .D1     B12,            *A15++[1]           ;o-Store r4
 ||     ZERO        .S2     B12

        STW         .D1     B13,            *A15++[1]           ;o-Store r4
 ||     ZERO        .S2     B13

   [B0] LDDW        .D1     *+A14[02],      A3:A2               ;p-Load x[4]
 ||[B0] SUB         .S2     B1,             02,         B1      ;p-Decrement Innerloop Counter
 ||[!B0]SUB         .S1     B15,            4,          A15     ;Twin SP
 ||[!B0]LDW         .D2     *+B15[11],      B7                  ;Restore CSR
************************************************************************************
***************************OUTERLOOP BRANCH OCCURS HERE*****************************
************************************************************************************
        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;



                .end

* ======================================================================== *
*  End of file: DSPF_dp_convol.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_dotp_sq/1117057385  988   0     0       10805     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_dotp_sqr(                                                *
*                        double G,                                          *
*                        const double * x,                                  *
*                        const double * y,                                  *
*                        double *  restrict r,                              *
*                        int   nx                                           *
*                        )                                                  *
*             G:      Sum of y-squared initial value.                       *
*             x[nx]:  Pointer to First input array.                         *
*             y[nx]:  Pointer to Second input array.                        *
*             r:      Pointer to Output for Accumulation of x[]*y[].        *
*             nx:     Length of input vectors.                              *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine computes the dot product of x[] and y[] arrays,       *
*    adding it to the value in the location pointed to by r.                *
*    Additionally, it computes the sum of the squares of the terms          *
*    in the y array,adding it to the argument G. The final value of         *
*    G is given as the return value of the function.                        *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*      1. Multiple Assignment was used to reduce loop carry path.           *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*      1. There are no special alignment requirements.                      *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    *
*                         double *restrict r, int nx)                       *
*       {                                                                   *
*                                                                           *
*          int i;                                                           *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          {                                                                *
*                *r += x[i] * y[i];     /* Compute Dot Product */           *
*                G += y[i] * y[i];      /* Compute Square  */               *
*          }                                                                *
*                                                                           *
*          return G;                                                        *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*         1. Endian : This code is LITTLE ENDIAN .                          *
*         2. Interruptibility: This code is interrupt-tolerant but not      *
*                              interruptible.                               *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*       4*nx + 26                                                           *
*                                                                           *
*        For nx=64, cycles=282.                                             *
*        For nx=30, cycles=146.                                             *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*       244 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_dotp_sqr
_DSPF_dp_dotp_sqr:

            LDDW    .D1     *A6++[01],      A1:A0               ;load y[i]
 ||     LDDW    .D2     *B4++[01],      B1:B0               ;load x[i]
 ||     MV      .L2     B6,             B5                  ;Pointer for r
 ||     MVC     .S2     CSR,            B7

        AND     .S2     -2,             B7,         B7      ;Disable Interrupts
 ||     ZERO    .L1     A7                                  ;Clear Accumulator
 ||     ZERO    .S1     A9                                  ;Clear Accumulator
 ||     MV      .D1     A6,             A3
 ||     MV      .L2     A8,             B2                  ;Set the Loop Counter
 ||     ZERO    .D2     B8                                  ;Clear Accumulator

        SUB     .S2     B2,             1,          B2      ;Decrement the loopCounter
 ||     B       .S1     loop
 ||     STW     .D2     B7,             *B15--[01]          ;Store CSR
 ||     ZERO    .L2     B9                                  ;Clear Accumulator

        ZERO    .L2     B6                                  ;Clear Accumulator
 ||     ZERO    .D2     B7                                  ;Clear Accumulator
 ||     ZERO    .L1     A6                                  ;Clear Accumulator
 ||     ZERO    .S1     A8                                  ;Clear Accumulator
 ||     MVC     .S2     B7,             CSR

******************************************************************************
*****************************BEGIN OF KERNEL**********************************
******************************************************************************
loop:

   [B2] LDDW    .D1     *A3++[01],      A1:A0               ;load y[i]
 ||[B2] LDDW    .D2     *B4++[01],      B1:B0               ;load x[i]

        MPYDP   .M1     A1:A0,          A1:A0,      A9:A8   ;y[i]*y[i]
 ||     MPYDP   .M2X    B1:B0,          A1:A0,      B7:B6   ;x[i]*y[i]

        ADDDP   .L1     A7:A6,          A9:A8,      A7:A6   ;P1+=y[i]*y[i]
 ||     ADDDP   .L2     B9:B8,          B7:B6,      B9:B8   ;P2+=x[i]*y[i]
 ||[B2] SUB     .S2     B2,             1,          B2      ;Decrement the loopCounter
 ||[B2] B       .S1     loop

        NOP     1
******************************************************************************
*******************************END OF KERNEL**********************************
******************************************************************************
        LDDW    .D2     *B5,            B1:B0               ;load R[i]

        LDW     .D2     *++B15[01],     B4                  ;Restore CSR

        ADDDP   .L1     A7:A6,          A9:A8,      A7:A6   ;P1+=y[i]*y[i]
 ||     ADDDP   .L2     B9:B8,          B7:B6,      B9:B8   ;P2+=x[i]*y[i]

        NOP     1
******************************************************************************
*****************************END OF EPILOG************************************
******************************************************************************

        ADDDP   .L1     A5:A4,          A7:A6,      A5:A4   ;G+=P1
 ||     ADDDP   .L2     B1:B0,          B9:B8,      B1:B0   ;*r+=P1

        NOP     2
        MVC     .S2     B4,             CSR                 ;Enable Interrupts
        NOP     2

        ADDDP   .L1     A5:A4,          A7:A6,      A5:A4   ;G+=P1
 ||     ADDDP   .L2     B1:B0,          B9:B8,      B1:B0   ;*r+=P2
        NOP     1
        B       B3
        NOP     3
        STW     .D2     B0,             *B5                 ;store *r
        STW     .D2     B1,             *+B5[01]            ;store *r

                .end

* ======================================================================== *
*  End of file: DSPF_dp_dotp_sqr.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_dotprod/1117057386  1010  0     0       10069     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                  *
*                                                                          *
*     This routine is C Callable and can be called as:                     *
*                                                                          *
*       double DSPF_dp_dotprod(const double *x, const double *y, const int nx); *
*                                                                          *
*       x     : Pointer to array holding the first floating point vector   *
*       y     : Pointer to array holding the second floating point vector  *
*       nx    : Number of values in the x & y vectors                      *
*                                                                          *
*                                                                          *
*   DESCRIPTION                                                            *
*                                                                          *
*       This routine calculates the dot product of 2 Double precision      *
*   float vectors.                                                         *
*                                                                          *
*   TECHNIQUES                                                             *
*                                                                          *
*       1.  The loop is unrolled once and software pipelined.              *
*           However, by conditionally adding to the dot product            *
*           odd numbered array sizes are also permitted.                   *
*       2.  Multilple assignments are used to reduce loop carry path       *
*                                                                          *
*   ASSUMPTIONS                                                            *
*                                                                          *
*       1.  A memory pad of 4 bytes is required at the end of each         *
*           array if the number of inputs is odd.                          *
*       2.  The value of nx must be > 0.                                   *
*                                                                          *
*   C CODE                                                                 *
*       This is the C equivalent for the assembly code.  Note that         *
*       the assembly code is hand optimized and restrictions may           *
*       apply.                                                             *
*                                                                          *
*       double DSPF_dp_dotprod(const double *x, const double *y, const int nx)  *
*       {                                                                  *
*          int i;                                                          *
*          double sum = 0;                                                 *
*                                                                          *
*          for (i=0; i < nx; i++)                                          *
*          {                                                               *
*             sum += x[i] * y[i];                                          *
*          }                                                               *
*          return sum;                                                     *
*       }                                                                  *
*                                                                          *
*   NOTES                                                                  *
*   1. Endian: This code is LITTLE ENDIAN.                                 *
*   2. Interruptibility: This code is interrupt tolerant but not           *
*      interruptible.                                                      *
*                                                                          *
*   CYCLES                                                                 *
*                                                                          *
*      4*ceil(nx/2) + 33                                                   *
*      eg. for nx = 256, cycles = 545                                      *
*                                                                          *
*   CODESIZE                                                               *
*      256 bytes                                                           *
* ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *



        .text
        .global _DSPF_dp_dotprod
_DSPF_dp_dotprod:

        LDDW    .D1     *A4++[01],      A1:A0               ;load x[i]
 ||     LDDW    .D2     *B4++[01],      B3:B2               ;load y[i]
 ||     MV      .L2     A6,             B0                  ;Set the loop Counter
 ||     ZERO    .S2     B7                                  ;Clear Accumulator

        LDDW    .D1     *A4++[01],      A5:A4               ;load x[i+1]
 ||     LDDW    .D2     *B4++[01],      B5:B4               ;load y[i+1]
 ||     ZERO    .L1     A9                                  ;Clear Accumulator
 ||     ZERO    .S1     A8                                  ;Clear Accumulator
 ||     ZERO    .L2     B8                                  ;Clear Accumulator
 ||     SUB     .S2     B0,         02,         B0          ;Decrement loop Counter

        B       .S1     loop
 ||     MV      .D1     A4,         A3                      ;Pointer for x
 ||     ZERO    .S2     B9                                  ;Clear Accumulator
 ||     STW     .D2     B10,        *B15--[01]                  ;Push Return address
 ||     CMPGT   .L2     B0,         0,          B1

        STW     .D2     B3,         *B15--[01]              ;Push Return address
 ||     ZERO    .L1     A6                                  ;Clear Accumulator
 ||     ZERO    .S1     A7                                  ;Clear Accumulator
 ||     MV      .S2     B4,         B10                     ;pointer for y
 ||     ZERO    .L2     B6                                  ;Clear Accumulator
******************************************************************************
*****************************BEGIN OF KERNEL**********************************
******************************************************************************
loop:

   [B1] LDDW    .D1     *A3++[01],      A1:A0               ;load x[i]
 ||[B1] LDDW    .D2     *B10++[01],     B3:B2               ;load y[i]

   [B1] LDDW    .D1     *A3++[01],      A5:A4               ;load x[i+1]
 ||[B1] LDDW    .D2     *B10++[01],     B5:B4               ;load y[i+1]
 ||     MPYDP   .M1X    A1:A0,          B3:B2,      A7:A6   ;x[i]*y[i]
 ||[B1] SUB     .S2     B0,             2,          B0      ;Decrement the loopCounter


   [B1] B       .S1     loop
 ||     CMPGT   .L2     B0,             0,          B1
 ||     MPYDP   .M2X    B5:B4,          A5:A4,      B7:B6   ;x[i+1]*y[i+1]
 ||     ADDDP   .L1     A9:A8,          A7:A6,      A9:A8   ;S1+=x[i]*y[i]

        ADDDP   .L2     B9:B8,          B7:B6,      B9:B8   ;S2+=x[i+1]*y[i+1]
******************************************************************************
*****************************END OF KERNEL**********************************
******************************************************************************
        LDW     .D2     *++B15[01],     B3                  ;Pop out return address
  ||    ADD     .S2     B0,             1,      B0

   [!B0]MV      .S2     B8,         B4

   [!B0]MV      .S2     B9,         B5
  ||    ADDDP   .L1     A9:A8,          A7:A6,      A9:A8   ;S1+=x[i]*y[i]

    [B0]ADDDP   .L2     B9:B8,          B7:B6,      B9:B8   ;S2+=x[i+1]*y[i+1]
******************************************************************************
*****************************END OF EPILOG************************************
******************************************************************************
        MV      .S1     A8,     A4
 ||     LDW     .D2     *++B15[01],     B10                 ;Pop out B10

        MV      .S1     A9,     A5
 ||[B0] MV      .S2     B8,     B4

   [B0] MV      .S2     B9,     B5
        NOP     1
        ADDDP   .L1     A9:A8,          A5:A4,      A9:A8
        ADDDP   .L2     B9:B8,          B5:B4,      B9:B8
        NOP     5
        ADDDP   .L1     A9:A8,          B9:B8,      A5:A4
        B       B3
        NOP     5
                .end

* ======================================================================== *
*  End of file: DSPF_dp_dotprod.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_dotp_cp/1117057387  1031  0     0       14271     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *  
*                                                                          *  
*     This routine is C Callable and can be called as:                     *  
*                                                                          *  
*       void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double  *  
*                         restrict re, double * restrict im);              *  
*                                                                          *  
*       x     : Pointer to array holding the first floating point vector   *  
*       y     : Pointer to array holding the second floating point vector  *  
*       n     : Number of values in the x & y vectors                      *  
*       re    : Pointer to the location storing the real                   *  
*               part of the result.                                        *  
*       im    : Pointer to the location storing the imaginary part of      *  
*               the result                                                 *  
*                                                                          *  
*                                                                          *  
*  DESCRIPTION                                                             *  
*                                                                          *  
*       This routine calculates the dot product of 2 Double   precision    *  
*   complex float vectors. The even numbered locations hold the real parts *  
*   of the complex numbers while the odd numbered locations contain the    *  
*   imaginary portions.                                                    *  
*                                                                          *  
*  ASSUMPTIONS                                                             *  
*                                                                          *  
*       1.  The value of nx must be  > 0.                                  *  
*                                                                          *  
*                                                                          *  
*  C CODE                                                                  *  
*                                                                          *  
*       This is the C equivalent for the assembly code.  Note that         *  
*       the assembly code is hand optimized and restrictions may           *  
*       apply.                                                             *  
*                                                                          *  
*       void DSPF_dp_dotp_cplx(const double* x, const double* y, int n,         *  
*                     double* restrict re, double* restrict im)            *  
*       {                                                                  *  
*                                                                          *  
*           double real=0, imag=0;                                         *  
*           int i=0;                                                       *  
*                                                                          *  
*           for(i=0; i<n; i++)                                             *  
*           {                                                              *  
*               real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                 *  
*               imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                 *  
*           }                                                              *  
*                                                                          *  
*           *re=real;                                                      *  
*           *im=imag;                                                      *  
*      }                                                                   *  
*                                                                          *  
*                                                                          *  
*  NOTES                                                                   *  
*                                                                          *  
*   1. Endian: This code is LITTLE ENDIAN.                                 *  
*   2. Interruptibility: This code is interrupt tolerant but not           *  
*      interruptible.                                                      *  
*                                                                          *  
*                                                                          *  
*  CYCLES                                                                  *  
*                                                                          *  
*      8*N + 29                                                            *  
*      eg. for N = 128, cycles = 1053.                                     *  
*                                                                          *  
*  CODESIZE                                                                *  
*                                                                          *  
*      352 bytes                                                           *  
* ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *


        .text
        .global _DSPF_dp_dotp_cplx
_DSPF_dp_dotp_cplx:


        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1     A4,             A3                  ;Poniter to x[i]
 ||     MV          .L2     B4,             B3                  ;Poniter to y[i]        
        
        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     MV          .L2     A6,             B2                  ;Set the loop counter
 ||     MVC         .S2     CSR,            B7                  ;Get CSR
 
        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable Interrupts
        
        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     LDDW        .D1     *A3++[01],      A1:A0               ;load x[i] Real Part
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;load y[i] Real Part
 ||     MVC         .S2     B7,             CSR     
        
        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MV          .L1     A8,             A2                  ;*im        
        
        LDDW        .D1     *A3++[01],      A5:A4               ;load x[i] imag Part
 ||     LDDW        .D2     *B3++[01],      B5:B4               ;load y[i] imag Part
                
        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]  
                
        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]  
 ||     MV          .L1     B6,             A7      
        
        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]  
 ||     MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;P1=xreal*yreal         

        MV          .L1     A7,             A15                 ;*re
 ||     ZERO        .D1     A10
 ||     ZERO        .S1     A11
 ||     ZERO        .L2     B10
 ||     ZERO        .S2     B11
        
        MPYDP       .M2X    A1:A0,          B5:B4,      B7:B6   ;P2=xreal*yimag
 ||     ZERO        .D1     A12
 ||     ZERO        .S1     A13
 ||     ZERO        .L2     B12
 ||     ZERO        .S2     B13
        
        LDDW        .D1     *A3++[01],      A1:A0               ;load x[i] real Part
 ||     LDDW        .D2     *B3++[01],      B1:B0               ;load y[i] real Part
        
        MPYDP       .M1X    A5:A4,          B1:B0,      A9:A8   ;P3=ximag*yreal         
        
        LDDW        .D1     *A3++[01],      A5:A4               ;load x[i] imag Part
 ||     LDDW        .D2     *B3++[01],      B5:B4               ;load y[i] imag Part
        
        MPYDP       .M2X    A5:A4,          B5:B4,      B9:B8   ;P4=ximag*yimag
        
        SUB         .L2     B2,             01,         B2      ;Decrement the loop Counter
        
**********************************************************************************
******************************BEGIN OF KERNEL*************************************
**********************************************************************************
loop:
        
        MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;P1=xreal*yreal         
        
        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P1
        
   [B2] B           .S1     loop        
 ||     MPYDP       .M2X    A1:A0,          B5:B4,      B7:B6   ;P2=xreal*yimag
        
        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S2+=P2
 ||[B2] LDDW        .D1     *A3++[01],      A1:A0               ;load x[i] real Part
 ||[B2] LDDW        .D2     *B3++[01],      B1:B0               ;load y[i] real Part
                    
        MPYDP       .M1X    A5:A4,          B1:B0,      A9:A8   ;P3=ximag*yreal         
        
   [B2] LDDW        .D1     *A3++[01],      A5:A4               ;load x[i] imag Part
 ||[B2] LDDW        .D2     *B3++[01],      B5:B4               ;load y[i] imag Part
 ||     ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S3+=P3 
    
        MPYDP       .M2X    A5:A4,          B5:B4,      B9:B8   ;P4=ximag*yimag
                                                                                                        
        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S4+=P4
 ||[B2] SUB         .S2     B2,             01,         B2      ;Decrement the loop Counter                                                                                                                 
**********************************************************************************
********************************END OF KERNEL*************************************
**********************************************************************************      
        MV          .S1     A15,            A4                  ;*re
 ||     LDW         .D2     *+B15[9],       B5                  ;Restore CSR        
        
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
 ||     SUB         .S1     B15,            04,         A15     ;Twin Sp        
        
        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10             
 ||     MV          .S2     A4,             B4      
        
        ADDDP       .L1X    A13:A12,        B11:B10,    A1:A0   ;S2+S3
 ||     LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11 
        
        
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12             
        
        
        SUBDP       .L2X    A11:A10,        B13:B12,    B1:B0   ;S1-S4
 ||     LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13 
 ||     MVC         .S2     B5,             CSR                 ;Enable Interrupts      
        
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        
        B       B3
        
        ADDAW       .D2     B15,        1,          B15             ;clear the stack
        
        STW         .D1     A0,         *A2                         ;Store Im Part  
        STW         .D1     A1,         *+A2[01]
        STW         .D2     B0,         *B4                         ;Store Re Part
        STW         .D2     B1,         *+B4[01]

        
                .end

* ======================================================================== *
*  End of file: DSPF_dp_dotp_cplx.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_maxval./1117057388  1054  0     0       17353     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxval -- Maximum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                  *  
*                                                                          *  
*        This routine has the following C prototype:                       *  
*                                                                          *  
*        double DSPF_dp_maxval(                                                 *  
*                        const double* x,                                  *  
*                        int nx                                            *  
*                       )                                                  *  
*                                                                          *  
*             x :  Pointer to Input array.                                 *  
*             nx:  Number of Inputs in the input Array.                    *  
*                                                                          *  
*                                                                          *  
*   DESCRIPTION                                                            *  
*                                                                          *  
*        This routine finds out the maximum number in the                  *  
*    input array.This code returns the maximum value                       *  
*    in the array.                                                         *  
*                                                                          *  
*   TECHNIQUES                                                             *  
*                                                                          *  
*      1. The loop is unrolled six times.                                  *  
*      2. Six maximums are maintained in each iteration.                   *  
*                                                                          *  
*   ASSUMPTIONS                                                            *  
*                                                                          *  
*       1. nx should be multiple of 2 and >= 2.                            *  
*       2. NAN( Not a Number in Double Precision format) in the input is   *  
*          disregarded.                                                    *  
*                                                                          *  
*   C CODE                                                                 *  
*                                                                          *  
*       This is the C equivalent of the assembly code.  Note that          *  
*       the assembly code is hand optimized and restrictions may apply.    *  
*                                                                          *  
*       double DSPF_dp_maxval(const double* x, int nx)                          *  
*       {                                                                  *  
*          int i;                                                          *  
*          double max;                                                     *  
*          *((int *)&max) = 0x00000000;                                    *  
*          *((int *)&max+1) = 0xfff00000;                                  *  
*                                                                          *  
*           for (i = 0; i < nx; i++)                                       *  
*           if (x[i] > max)                                                *  
*            {                                                             *  
*             max = x[i];                                                  *  
*            }                                                             *  
*                                                                          *  
*           return max;                                                    *  
*        }                                                                 *  
*                                                                          *  
*   NOTES                                                                  *  
*                                                                          *  
*       1. NAN( Not a Number in Double Precision format) in the input are  *  
*          disregarded.                                                    *  
*       2. Endian: This code is LITTLE ENDIAN.                             *  
*       3. Interruptibility: This code is interrupt-tolerant but not       *  
*                            interruptible.                                *  
*                                                                          *  
*   CYCLES                                                                 *  
*                                                                          *  
*       7*ceil(nx/6) + 31                                                  *  
*       For nx=60, cycles=101.                                             *  
*       For nx=34, cycles=73.                                              *  
*                                                                          *  
*   CODESIZE                                                               *  
*       672 bytes                                                          *  
*                                                                          *  
* ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *




        .text
        .global _DSPF_dp_maxval
_DSPF_dp_maxval:

        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1     A4,             A3,                 ;Ponter to x
 ||     MVKL        .S1     0x00000006,     A2                  ;Set A2=6
 ||     MVC         .S2     CSR,            B5                  ;Get CSR                
        
        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     ADD         .L2     A4,             8,          B3      ;Ponter to x        
 ||     MV          .S2     B4,             B2                  ;Set the loop counter
 ||     MVKH        .S1     0x00000006,     A9              
 
        STW         .D2     B5,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B5,         B5      ;Disable Interrupts     
        
        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     ADD         .L2X    A3,             8,          B3      ;Twin Pointer for x
 ||     MVC         .S2     B5,             CSR
        
        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     MVKL        .S2     0x00000000,     B8                  ;Set A9:A8 =B9:B8=-INF
 ||     MVKL        .S1     0x00000000,     A8              

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MVKH        .S2     0x00000000,     B8                  ;Set A9:A8 =B9:B8=-INF
 ||     MVKH        .S1     0x00000000,     A8              

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]  
 ||     MVKL        .S2     0xfff00000,     B9                  ;Set A9:A8 =B9:B8=-INF
 ||     MVKL        .S1     0xfff00000,     A9              

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]  
 ||     MVKH        .S2     0xfff00000,     B9                  ;Set A9:A8 =B9:B8=-INF
 ||     MVKH        .S1     0xfff00000,     A9              

        LDDW        .D1     *A3++[02],      A11:A10             ;p-load x1
 ||     LDDW        .D2     *B3++[02],      B11:B10             ;p-load x2

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]  
 ||     MV          .L2     B8,             B6                  ;Set -INF in initial max's
 ||     MV          .S2     B8,             B4
 ||     MV          .L1     A8,             A6
 ||     MV          .S1     A8,             A4

        LDDW        .D1     *A3++[02],      A13:A12             ;p-load x3
 ||     LDDW        .D2     *B3++[02],      B13:B12             ;p-load x4
 ||     ZERO        .S1     A1                                  ;Clear the flags
 ||     ZERO        .L2     B1      
 ||     SUB         .S2     B2,             6,          B2      ;Decrement the loop counter                 
        
        MV          .L2     B9,             B7
 ||     MV          .S2     B9,             B5
 ||     MV          .D1     A9,             A7
 ||     MV          .S1     A9,             A5
 ||     MV          .L1X    B15,            A0                  ;SP     

************************************************************************************
*******************************BEGIN OF KERNEL**************************************
************************************************************************************
loop:
        CMPGT       .L2     B2,             0,          B0      
 ||[A1] MV          .L1     A12,            A6                  ;max3=x3
 ||[A1] MV          .D1     A13,            A7                  ;max3=x3
 ||[B1] MPY         .M2     B12,            1,          B6      ;max4=x4
 ||[B1] MV          .D2     B13,            B7                  ;max4=x4
        
        LDDW        .D1     *A3++[02],      A15:A14             ;load x5
 ||     LDDW        .D2     *B3++[02],      B15:B14             ;load x6
 ||[B0] B           .S1     loop
 ||[B0] SUB         .S2     B2,             6,          B2      ;Decrement the Counter      
        
        CMPGTDP     .S1     A11:A10,        A5:A4,      A1      ;x1>max1
 ||     CMPGTDP     .S2     B11:B10,        B5:B4,      B1      ;x2>max2                        
 ||[!B0]ADD         .L2     B2,             4,          B2      
    
   [A1] MV          .L1     A14,            A8                  ;max5=x5
 ||[A1] MV          .D1     A15,            A9                  ;max5=x5
 ||[B1] MV          .L2     B14,            B8                  ;max6=x6
 ||[B1] MV          .D2     B15,            B9                  ;max6=x6
        
        CMPGTDP     .S1     A13:A12,        A7:A6,      A1      ;x3>max3
 ||     CMPGTDP     .S2     B13:B12,        B7:B6,      B1      ;x4>max4                        
 ||     LDDW        .D1     *A3++[02],      A11:A10             ;load x1
 ||     LDDW        .D2     *B3++[02],      B11:B10             ;load x2
 ||[!B0]AND         .L2     B2,             A2,         B0        
    
   [A1] MV          .L1     A10,            A4                  ;max1=x1
 ||[A1] MV          .D1     A11,            A5                  ;max1=x1
 ||[B1] MV          .L2     B10,            B4                  ;max2=x2
 ||[B1] MV          .D2     B11,            B5                  ;max2=x2
        
        CMPGTDP     .S1     A15:A14,        A9:A8,      A1      ;x5>max5
 ||     CMPGTDP     .S2     B15:B14,        B9:B8,      B1      ;x6>max6                        
 ||     LDDW        .D1     *A3++[02],      A13:A12             ;load x3
 ||     LDDW        .D2     *B3++[02],      B13:B12             ;load x4
 ||[!B0]ZERO        .L1     A1
 ||[!B0]ZERO        .L2     B1
        
***********************************************************************************
***************************END OF KERNEL*******************************************
***********************************************************************************
   [A1] MV          .L1     A12,            A6                  ;max3=x3
 ||[A1] MV          .D1     A13,            A7                  ;max3=x3
 ||[B1] MV          .L2     B12,            B6                  ;max4=x4
 ||[B1] MV          .D2     B13,            B7                  ;max4=x4
 ||[B2] SUB         .S2     B2,             02,         B2

        AND         .L2     B2,             A2,         B0        

   [!B0]ZERO        .S1     A1
 ||[!B0]ZERO        .S2     B1
    
        CMPGTDP     .S1     A5:A4,          A7:A6,      A1      ;max of(max1, max3)
 ||     CMPGTDP     .S2     B5:B4,          B7:B6,      B1      ;max of(max2, max4)                     
        
   [A1] MV          .L1     A14,            A8                  
 ||[A1] MV          .D1     A15,            A9                  
 ||[B1] MV          .L2     B14,            B8                  
 ||[B1] MV          .D2     B15,            B9                  

   [A1] MV          .L1     A4,             A6                  
 ||[A1] MV          .S1     A5,             A7                  
 ||[B1] MV          .L2     B4,             B6                  
 ||[B1] MV          .S2     B5,             B7                  
        
        CMPGTDP     .S1     A7:A6,          A9:A8,      A1      ;max(max1, max3, max5)
 ||     CMPGTDP     .S2     B7:B6,          B9:B8,      B1      ;max(max2, max4, max6)                      
 ||     SUB         .L1     A0,             4,          A15     ;Twin stack Pointer  
 ||     MV          .L2X    A0,             B15                 ;SP
 ||     LDW         .D1     *+A0[11],      B7                  ;Restore  CSR
        
        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10             
        
   [A1] MV          .L1     A6,             A8                  
 ||[A1] MV          .S1     A7,             A9                  
 ||[B1] MV          .L2     B6,             B8                  
 ||[B1] MV          .S2     B7,             B9                  
 ||     LDW         .D2     *+B15[11],      B3                  ;Restoring Return address       
        
        CMPGTDP     .S1X    A9:A8,          B9:B8,      A1      ;max(max1, max3, max5)
 ||     LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11 
        
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12             
 
   [A1] MV          .L1     A8,             A4                  ;A5:A4=MAX(max1, max2, max3, max4, max5, max6)          
 ||[!A1]MV          .S1     B8,             A4                  
 ||     LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13 
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts      
          
   [!A1]MV          .L1     B9,             A5                  ;A5:A4=MAX(max1, max2, max3, max4, max5, max6)
 ||[A1] MV          .S1     A9,             A5
 ||     LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14 
  
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;  
                    




                .end

* ======================================================================== *
*  End of file: DSPF_dp_maxval.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_maxidx./1117057389  1074  0     0       12790     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      16-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        int DSPF_dp_maxidx(                                                     *
*                       const double* x,                                    *
*                       int nx                                              *
*                     )                                                     *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the index of maximum number in the input    *
*        array. This function returns the index of the greatest value.      *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled three times.                                *
*       2. Three maximums are maintained in each iteration.                 *
*       3. MPY instructions are  used for move.                             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 3.                                           *
*       2. nx >= 3, and nx <= 2^16-1.                                       *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       int DSPF_dp_maxidx(const double* x, int nx)                              *
*       {                                                                   *
*          int index, i;                                                    *
*          double max;                                                      *
*                                                                           *
*          *((int *)&max) = 0x00000000;                                     *
*          *((int *)&max+1) = 0xfff00000;                                   *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] > max)                                                  *
*          {                                                                *
*             max = x[i];                                                   *
*             index = i;                                                    *
*          }                                                                *
*          return index;                                                    *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. Endian: This code is LITTLE ENDIAN.                               *
*      2. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       4*nx/3 + 22                                                         *
*       For nx=60, cycles=102.                                              *
*       For nx=30, cycles=62.                                               *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       448 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_maxidx
_DSPF_dp_maxidx:


        MVC         .S2     CSR,            B5

        STW         .D2     B5,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B5,         B5      ;Disable Interrupts

        MVC         .S2     B5,             CSR

        LDDW        .D1     *A4++[01],      A5:A4               ;load x1
 ||     MV          .L2     B4,             B2                  ;Set the loop Counter
 ||     MVKL        .S2     0x00000000,     B8                  ;Set A9:A8 =B9:B8=-INF
 ||     MVKL        .S1     0x00000000,     A8
 ||     MV          .D2     B3,             B0                  ;Save return address in stack

        MV          .L1     A4,             A3                  ;Pointer for x
 ||     MVKH        .S2     0x00000000,     B8                  ;Set A9:A8 =B9:B8=-INF
 ||     MVKH        .S1     0x00000000,     A8
 ||     STW         .D2     A10,            *B15--[01]          ;Push A10 in stack
 ||     MV          .L2     A4,             B5

        MVKL        .S2     0xfff00000,     B9                  ;Set A9:A8 =B9:B8=-INF
 ||     MVKL        .S1     0xfff00000,     A9
 ||     ZERO        .L1     A10                                 ;Initial Index
 ||     SUB         .L2     B2,             3,          B2      ;Decrement the Counter
 ||     STW         .D2     A11,            *B15--[01]          ;Push A11 in stack

        MVKH        .S2     0xfff00000,     B9                  ;Set A9:A8 =B9:B8=-INF
 ||     MVKH        .S1     0xfff00000,     A9
 ||     ADD         .D2     B5,             8,          B3      ;Pointer for x
 ||     SUB         .L1     A10,            3,          A10

        LDDW        .D1     *A3++[02],      A7:A6               ;load x2
 ||     LDDW        .D2     *B3++[03],      B5:B4               ;load x3
 ||[B2] B           .S1     loop
 ||     MV          .L2     B8,             B6
 ||     MV          .S2     B9,             B7

        ZERO        .L1     A2                                  ;Clear the Initial Flags
 ||     ZERO        .L2     B1
 ||     STW         .D2     B10,            *B15--[01]          ;Push A11 in stack
 ||     MV          .S2     B0,             B10                 ;return address
***************************************************************************************
**********************************BEGIN OF KERNEL**************************************
***************************************************************************************
loop:
        LDDW        .D1     *A3++[01],      A5:A4               ;load x1
 ||[B2] SUB         .L2     B2,             3,          B2      ;Decrement the loop Counter

        CMPGTDP     .S1     A5:A4,          A9:A8,      A2      ;x1>max1
 ||[A2] MV          .S2     A7,             B7                  ;max2=x2
 ||[B1] MV          .L2     B4,             B8                  ;max3=x3
 ||[A2] MV          .L1     A10,            A11,                ;m2idx
 ||[B1] MV          .D1     A10,            A1                  ;m3idx
 ||[B1] MV          .D2     B5,             B9                  ;max3=x3

        LDDW        .D1     *A3++[02],      A7:A6               ;load x2
 ||     LDDW        .D2     *B3++[03],      B5:B4               ;load x3
 ||[B2] B           .S2     loop
 ||[A2] MV          .L2     A6,             B6                  ;max2=x2
 ||     ADD         .L1     A10,            3,          A10     ;Index+=3

        CMPGTDP     .S1     A7:A6,          B7:B6,      A2      ;x2>max2
 ||     CMPGTDP     .S2     B5:B4,          B9:B8,      B1      ;x3>max3
 ||[A2] MV          .L1     A4,             A8                  ;max1=x1
 ||[A2] MV          .D1     A5,             A9                  ;max1=x1
 ||[A2] MPY         .M1     A10,            1,          A0      ;m1idx

************************************************************************************
******************************END OF KERNEL*****************************************
************************************************************************************
        MV          .L2     B10,            B3                  ;restore return address
 ||     LDW         .D2     *++B15[01],     B10                 ;pop b10

   [A2] MV          .S2     A7,             B7                  ;max2=x2
 ||[B1] MV          .L2     B4,             B8                  ;max3=x3
 ||[A2] MV          .L1     A10,            A11,                ;m2idx
 ||[B1] MV          .S1     A10,            A1                  ;m3idx

   [A2] MV          .L2     A6,             B6                  ;max2=x2
 ||[B1] MV          .S2     B5,             B9                  ;max3=x3
 ||     LDW         .D2     *++B15[01],     A11                 ;pop A11

        CMPGTDP     .S1X    A9:A8,          B7:B6,      A2      ;max1>max2
 ||     LDW         .D2     *++B15[01],     A10                 ;pop A10

        MV          .L1     A11,            A5
 ||     LDW         .D2     *++B15[01],     B5                  ;pop CSR

   [A2] CMPGTDP     .S2     A9:A8,          B9:B8,      B2      ;max1>max3
 ||     MV          .L1     A1,             A6

        ZERO        .L1     A1
 ||     ZERO        .L2     B0

        B           .S2     B3
 ||[A2] AND         .L2     A2,             B2,         B0
 ||[A2] XOR         .S1     A2,             B2,         A1

   [!A2]CMPGTDP     .S2     B7:B6,          B9:B8,      B2      ;max2>max3
 ||[B0] MV          .L1     A0,             A4                  ;max1 is the maximum
 ||[A1] ADD         .S1     A6,             2,          A4      ;max3 is the maximum

        ZERO        .L1     A1
 ||[A2] MVK         .S2     1,              B0

   [!A2]XOR         .S1     A2,             B2,         A1
 ||[!A2]XOR         .S2     A2,             B2,         B0

   [A1] ADD         .S1     A5,             1,          A4      ;max2 is the maximum
 ||[!B0]ADD         .L1     A6,             2,          A4      ;max3 is the maximum
 ||     MVC         .S2     B5,             CSR                 ;Enable Interrupts

        NOP         1

                .end

* ======================================================================== *
*  End of file: DSPF_dp_maxidx.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_minval./1117057390  1094  0     0       16966     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_minval -- Minimum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                  *  
*                                                                          *  
*        This routine has the following C prototype:                       *  
*                                                                          *  
*        double DSPF_dp_minval(                                                 *  
*                        const double* x,                                  *  
*                        int nx                                            *  
*                       )                                                  *  
*                                                                          *  
*             x :  Pointer to Input array.                                 *  
*             nx:  Number of Inputs in the input Array.                    *  
*                                                                          *  
*   DESCRIPTION                                                            *  
*                                                                          *  
*        This routine finds out and returns the minimum number             *  
*    in the input array.                                                   *  
*                                                                          *  
*   TECHNIQUES                                                             *  
*                                                                          *  
*       1. The loop is unrolled six times.                                 *  
*       2. Six minimums are maintained in each iteration.                  *  
*                                                                          *  
*   ASSUMPTIONS                                                            *  
*                                                                          *  
*       1. nx should be multiple of 2 and >= 2.                            *  
*       2. NAN( Not a Number in Double Precision format) in the input are  *  
*          disregarded.                                                    *  
*                                                                          *  
*  C CODE                                                                  *  
*                                                                          *  
*       double DSPF_dp_minval(const double* x, int nx)                          *  
*       {                                                                  *  
*          int i;                                                          *  
*          double min;                                                     *  
*          *((int *)&min) = 0x00000000;                                    *  
*          *((int *)&min+1) = 0x7ff00000;                                  *  
*                                                                          *  
*          for (i = 0; i < nx; i++)                                        *  
*          if (x[i] < min)                                                 *  
*          {                                                               *  
*             min = x[i];                                                  *  
*            }                                                             *  
*                                                                          *  
*          return min;                                                     *  
*       }                                                                  *  
*                                                                          *  
*   NOTES                                                                  *  
*                                                                          *  
*   1. NAN( Not a Number in Double Precision format) in the input are      *  
*      disregarded.                                                        *  
*   2. Endian: This code is LITTLE ENDIAN.                                 *  
*   3. Interruptibility: This code is interrupt tolerant but not           *  
*      interruptible.                                                      *  
*                                                                          *  
*   CYCLES                                                                 *  
*                                                                          *  
*       7*ceil(nx/6) + 31                                                  *  
*       For nx=60 cycles=101                                               *  
*       For nx=34 cycles=73                                                *  
*                                                                          *  
*   CODESIZE                                                               *  
*                                                                          *  
*       640 bytes                                                          *  
* ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *



        .text
        .global _DSPF_dp_minval
_DSPF_dp_minval:

        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1     A4,             A3,                 ;Ponter to x
 ||     MVKL        .S1     0x00000006,     A2                  ;Set A2=6
 ||     MVC         .S2     CSR,            B7                  ;Get CSR                
        
        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     ADD         .L2     A4,             8,          B3      ;Ponter to x        
 ||     MV          .S2     B4,             B2                  ;Set the loop counter
 ||     MVKH        .S1     0x00000006,     A9              
 
        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable Interrupts     
        
        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     ADD         .L2X    A3,             8,          B3      ;Twin Pointer for x
 ||     MVC         .S2     B7,             CSR
        
        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     MVKL        .S2     0x00000000,     B8                  ;Set A9:A8 =B9:B8=+INF
 ||     MVKL        .S1     0x00000000,     A8              

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]
 ||     MVKH        .S2     0x00000000,     B8                  ;Set A9:A8 =B9:B8=+INF
 ||     MVKH        .S1     0x00000000,     A8              

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]  
 ||     MVKL        .S2     0x7ff00000,     B9                  ;Set A9:A8 =B9:B8=+INF
 ||     MVKL        .S1     0x7ff00000,     A9              

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]  
 ||     MVKH        .S2     0x7ff00000,     B9                  ;Set A9:A8 =B9:B8=+INF
 ||     MVKH        .S1     0x7ff00000,     A9              

        LDDW        .D1     *A3++[02],      A11:A10             ;p-load x1
 ||     LDDW        .D2     *B3++[02],      B11:B10             ;p-load x2

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]  
 ||     MV          .L2     B8,             B6                  ;Set +INF in initial min's
 ||     MV          .S2     B8,             B4
 ||     MV          .L1     A8,             A6
 ||     MV          .S1     A8,             A4

        LDDW        .D1     *A3++[02],      A13:A12             ;p-load x3
 ||     LDDW        .D2     *B3++[02],      B13:B12             ;p-load x4
 ||     ZERO        .S1     A1                                  ;Clear the flags
 ||     ZERO        .L2     B1      
 ||     SUB         .S2     B2,             6,          B2      ;Decrement the loop counter                 
        
        MV          .L2     B9,             B7
 ||     MV          .S2     B9,             B5
 ||     MV          .D1     A9,             A7
 ||     MV          .S1     A9,             A5
 ||     MV          .L1X    B15,            A0                  ;SP     

************************************************************************************
*******************************BEGIN OF KERNEL**************************************
************************************************************************************
loop:
        CMPGT       .L2     B2,             0,          B0      
 ||[A1] MV          .L1     A12,            A6                  ;min3=x3
 ||[A1] MV          .D1     A13,            A7                  ;min3=x3
 ||[B1] MPY         .M2     B12,            1,          B6      ;min4=x4
 ||[B1] MV          .D2     B13,            B7                  ;min4=x4
        
        LDDW        .D1     *A3++[02],      A15:A14             ;load x5
 ||     LDDW        .D2     *B3++[02],      B15:B14             ;load x6
 ||[B0] B           .S1     loop
 ||[B0] SUB         .S2     B2,             6,          B2      ;Decrement the Counter      
        
        CMPLTDP     .S1     A11:A10,        A5:A4,      A1      ;x1<min1
 ||     CMPLTDP     .S2     B11:B10,        B5:B4,      B1      ;x2<min2                        
 ||[!B0]ADD         .L2     B2,             4,          B2      
    
   [A1] MV          .L1     A14,            A8                  ;min5=x5
 ||[A1] MV          .D1     A15,            A9                  ;min5=x5
 ||[B1] MV          .L2     B14,            B8                  ;min6=x6
 ||[B1] MV          .D2     B15,            B9                  ;min6=x6
        
        CMPLTDP     .S1     A13:A12,        A7:A6,      A1      ;x3<min3
 ||     CMPLTDP     .S2     B13:B12,        B7:B6,      B1      ;x4<min4                        
 ||     LDDW        .D1     *A3++[02],      A11:A10             ;load x1
 ||     LDDW        .D2     *B3++[02],      B11:B10             ;load x2
 ||[!B0]AND         .L2     B2,             A2,         B0        
    
   [A1] MV          .L1     A10,            A4                  ;min1=x1
 ||[A1] MV          .D1     A11,            A5                  ;min1=x1
 ||[B1] MV          .L2     B10,            B4                  ;min2=x2
 ||[B1] MV          .D2     B11,            B5                  ;min2=x2
        
        CMPLTDP     .S1     A15:A14,        A9:A8,      A1      ;x5<min5
 ||     CMPLTDP     .S2     B15:B14,        B9:B8,      B1      ;x6<min6                        
 ||     LDDW        .D1     *A3++[02],      A13:A12             ;load x3
 ||     LDDW        .D2     *B3++[02],      B13:B12             ;load x4
 ||[!B0]ZERO        .L1     A1
 ||[!B0]ZERO        .L2     B1
        
***********************************************************************************
***************************END OF KERNEL*******************************************
***********************************************************************************
   [A1] MV          .L1     A12,            A6                  ;min3=x3
 ||[A1] MV          .D1     A13,            A7                  ;min3=x3
 ||[B1] MV          .L2     B12,            B6                  ;min4=x4
 ||[B1] MV          .D2     B13,            B7                  ;min4=x4
 ||[B2] SUB         .S2     B2,             02,         B2

        AND         .L2     B2,             A2,         B0        

   [!B0]ZERO        .S1     A1
 ||[!B0]ZERO        .S2     B1
    
        CMPLTDP     .S1     A5:A4,          A7:A6,      A1      ;min of(min1, min3)
 ||     CMPLTDP     .S2     B5:B4,          B7:B6,      B1      ;min of(min2, min4)                     
        
   [A1] MV          .L1     A14,            A8                  
 ||[A1] MV          .D1     A15,            A9                  
 ||[B1] MV          .L2     B14,            B8                  
 ||[B1] MV          .D2     B15,            B9                  

   [A1] MV          .L1     A4,             A6                  
 ||[A1] MV          .S1     A5,             A7                  
 ||[B1] MV          .L2     B4,             B6                  
 ||[B1] MV          .S2     B5,             B7                  
        
        CMPLTDP     .S1     A7:A6,          A9:A8,      A1      ;min(min1, min3, min5)
 ||     CMPLTDP     .S2     B7:B6,          B9:B8,      B1      ;min(min2, min4, min6)                      
 ||     SUB         .L1     A0,             4,          A15     ;Twin stack Pointer  
 ||     MV          .L2X    A0,             B15                 ;SP
 ||     LDW         .D1     *+A0[11],       B5                  ;Restore CSR                
        
        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10             
        
   [A1] MV          .L1     A6,             A8                  
 ||[A1] MV          .S1     A7,             A9                  
 ||[B1] MV          .L2     B6,             B8                  
 ||[B1] MV          .S2     B7,             B9                  
 ||     LDW         .D2     *+B15[11],      B3                  ;Restoring Return address       
        
        CMPLTDP     .S1X    A9:A8,          B9:B8,      A1      ;min(min1, min2, min3, min4, min5, min6)
 ||     LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11 
        
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12 
 
   [A1] MV          .L1     A8,             A4                  ;A5:A4=MIN(min1, min2, min3, min4, min5, min6)          
 ||[!A1]MV          .S1     B8,             A4                  
 ||     LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13             
          
   [!A1]MV          .L1     B9,             A5                  ;A5:A4=MIN(min1, min2, min3, min4, min5, min6)          
 ||[A1] MV          .S1     A9,             A5
 ||     LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14 
 ||     MVC         .S2     B5,             CSR                 ;Enable Interrupts      
        
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;  
        
           .end

* ======================================================================== *
*  End of file: DSPF_dp_minval.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_vecreci/1117057391  1114  0     0       15054     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecrecip -- Double Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void  DSPF_dp_vecrecip(const double *x,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_dp_vecrecip module calculates the reciprocal of each element    *
*   in the array x and returns the output in array r. It uses 3             *
*   iterations of the Newton-Raphson method to improve the accuracy         *
*   of the output generated by the RCPDP instruction of the C67x.           *
*   Each iteration doubles the accuracy. The initial output generated       *
*   by RCPDP is 8 bits.So after the first iteration it is 16 bits and       *
*   after the second it is the  23 bits and after third it is full 52 bits. *
*   The formula used is:                                                    *
*                                                                           *
*                r[n+1] = r[n](2 - v*r[n])                                  *
*                                                                           *
*       where v = the number whose reciprocal is to be found.               *
*       x[0], the seed value for the algorithm, is given by RCPDP.          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled four times to allow calculation of    *
*          four reciprocals in the kernel. However the stores are executed  *
*          conditionally to allow 'n' to be any number > 0.                 *
*                                                                           *
*       2. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. There are no alignment requirements.                             *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*     void DSPF_dp_vecrecip(const double* x, double* restrict r, int n)          *
*     {                                                                     *
*      int i;                                                               *
*      for(i = 0; i < n; i++)                                               *
*         r[i] = 1 / x[i];                                                  *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant                *
*          but not interruptible.                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      78*ceil(n/4) + 24                                                    *
*      eg. for n = 54, cycles = 1116                                        *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      448 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_vecrecip
_DSPF_dp_vecrecip:

        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack
 ||     MV          .L1     A4,             A3                  ;Pointer for x

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     ADD         .L2     A4,             8,          B3      ;Twin Pointer for x
 ||     MVC         .S2     CSR,            B7                  ;Get CSR

        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable Interuupts

        SUB         .S1X    B15,            04,         A15     ;Setting A15<- SP-1
 ||     MV          .L1     A6,             A2                  ;Set the Loop Counter
 ||     LDDW        .D1     *A3++[02],      A1:A0               ;Load x1
 ||     LDDW        .D2     *B3++[02],      B1:B0               ;Load x2
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A15--[02]
 ||     ADD         .L2     B4,             8,          B14     ;Pointer for r[i]
 ||     MV          .L1     B4,             A14

        LDDW        .D1     *A3++[02],      A5:A4               ;Load x3
 ||     LDDW        .D2     *B3++[02],      B5:B4               ;Load x4

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A15--[02]

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A15--[02]

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A15--[02]
 ||     MVK         .S2     2,              B2                  ;for 3 iterations

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A15--[02]
 ||     RCPDP       .S1     A1:A0,          A7:A6               ;1/x1
 ||     RCPDP       .S2     B1:B0,          B7:B6               ;1/x2

        STW         .D2     A2,             *B15--[01]          ;Push loop Counter into Stack
 ||     RCPDP       .S1     A5:A4,          A9:A8               ;1/x3
 ||     RCPDP       .S2     B5:B4,          B9:B8               ;1/x4

*************************************************************************************
********************************BEGIN OF KERNEL**************************************
*************************************************************************************

loop:
        MPYDP       .M1     A1:A0,          A7:A6,      A11:A10 ;v1*r[0]
 ||     MPYDP       .M2     B1:B0,          B7:B6,      B11:B10 ;v2*r[0]

   [!B2]LDDW        .D1     *A3++[02],      A1:A0               ;Load x1
 ||[!B2]LDDW        .D2     *B3++[02],      B1:B0               ;Load x2

   [!B2]LDW         .D2     *+B15[01],      A2                  ;Load loop Counetr

        NOP         1

        MPYDP       .M1     A5:A4,          A9:A8,      A13:A12 ;v3*r[0]
 ||     MPYDP       .M2     B5:B4,          B9:B8,      B13:B12 ;v4*r[0]

   [!B2]LDDW        .D1     *A3++[02],      A5:A4               ;Load x3
 ||[!B2]LDDW        .D2     *B3++[02],      B5:B4               ;Load x4

        NOP         2

   [!B2]SUB         .S1     A2,             4,          A2      ;Decrement loop Counter

        MPYDP       .M1     A7:A6,          A11:A10,    A7:A6   ;v1*r[0]*r[0]
 ||     MPYDP       .M2     B7:B6,          B11:B10,    B7:B6   ;v2*r[0]*r[0]

        ADDDP       .L1     A7:A6,          A7:A6,      A11:A10 ;2*r[0]
 ||     ADDDP       .L2     B7:B6,          B7:B6,      B11:B10 ;2*r[0]

   [!B2]STW         .D2     A2,             *+B15[01]           ;Store loop Counetr

   [!B2]CMPGT       .L1     A2,             0,          A15     ;

        MPYDP       .M1     A9:A8,          A13:A12,    A9:A8   ;v3*r[0]*r[0]
 ||     MPYDP       .M2     B9:B8,          B13:B12,    B9:B8   ;v4*r[0]*r[0]

        ADDDP       .L1     A9:A8,          A9:A8,      A13:A12 ;2*r[0]
 ||     ADDDP       .L2     B9:B8,          B9:B8,      B13:B12 ;2*r[0]

   [!B2]ADD         .S1     A2,             4,          A2

        NOP         2

   [B2] B           .S1     loop
 ||     SUBDP       .L1     A11:A10,        A7:A6,      A7:A6   ;2*r[0]-v1*r[0]*r[0]
 ||     SUBDP       .L2     B11:B10,        B7:B6,      B7:B6   ;2*r[0]-v2*r[0]*r[0]

        NOP         3

        SUBDP       .L1     A13:A12,        A9:A8,      A9:A8   ;2*r[0]-v1*r[0]*r[0]
 ||     SUBDP       .L2     B13:B12,        B9:B8,      B9:B8   ;2*r[0]-v2*r[0]*r[0]
 ||[!B2]MPY         .M2     A15,            1,          B2

    [B2]SUB         .S2     B2,             1,          B2      ;Decrement the Counter

*************************************************************************************
**********************************END OF KERNEL**************************************
*************************************************************************************

   [B2] B           .S2     loop
 ||[!B2]SUB         .S1     A2,             1,          A2      ;

        STW         .D1     A6,             *A14++              ;store r1
 ||[A2] STW         .D2     B6,             *B14++              ;store r2

        STW         .D1     A7,             *A14++[03]          ;store r1
 ||[A2] STW         .D2     B7,             *B14++[03]          ;store r2
 ||[A2] SUB         .S1     A2,             1,          A2
 ||[A2] SUB         .S2     A2,             2,          B2

        RCPDP       .S1     A1:A0,          A7:A6               ;1/x1
 ||     RCPDP       .S2     B1:B0,          B7:B6               ;1/x2

   [A2] STW         .D1     A8,             *A14++              ;store r3
 ||[B2] STW         .D2     B8,             *B14++              ;store r4
 ||     RCPDP       .S1     A5:A4,          A9:A8               ;1/x3
 ||     RCPDP       .S2     B5:B4,          B9:B8               ;1/x4

   [A2] STW         .D1     A9,             *A14++[03]          ;store r3
 ||[B2] STW         .D2     B9,             *B14++[03]          ;store r4
 ||     MVK         .S2     2,              B2
**************************************************************************************
**************************************************************************************
        MV          .L1     B15,            A15
 ||     ADD         .L2     B15,            04,         B15     ;Twin stack Pointer
        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10

        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
 ||     LDW         .D1     *+A15[10],      A7                  ;Restore CSR

        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
 ||     MV          .L2X    A7,             B7
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;
                .end

* ======================================================================== *
*  End of file: DSPF_dp_vecrecip.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_vecsum_/1117057392  1136  0     0       10632     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecsum_sq -- Double Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       double DSPF_dp_vecsum_sq(const double *x,                                *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs a sum of squares of the elements of the      *
*        array x and returns the sum.                                       *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice. Hence, 2 registers are used    *
*          to hold the sum of squares. ADDDPs are staggered.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Since loads of 4 doubles beyond the array occur,                 *
*          a pad must be provided.                                          *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions. Note that the assembly code is hand optimized          *
*      and restrictions may apply.                                          *
*                                                                           *
*      double DSPF_dp_vecsum_sq(const double *x,int n)                           *
*      {                                                                    *
*          int i;                                                           *
*          double sum=0;                                                    *
*                                                                           *
*          for(i = 0;  i < n; i++ )                                         *
*              sum += x[i]*x[i];                                            *
*                                                                           *
*          return sum;                                                      *
*      }                                                                    *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*     1. Endian: This code is ENDIAN NEUTRAL.                               *
*     2. Interruptibility: This code is interrupt tolerant                  *
*                             but not interruptible.                        *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     4*Ceil(n/2) + 33                                                      *
*     eg. for n = 100, cycles = 233                                         *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     288 bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_vecsum_sq
_DSPF_dp_vecsum_sq:

    MVC     .S2     CSR,            B5                  ;Get CST

        MV      .L2     B4,             B0                  ;Set the loop Counter
 ||     STW     .D2     B5,             *B15--[01]          ;Store CSR
 ||     AND     .S2     -2,             B5,     B5          ;Disable Interrupts

        MV      .L2     A4,             B4                  ;twin pointer for x
 ||     MVC     .S2     B5,             CSR

        LDDW    .D1     *A4++[01],      A1:A0               ;load x[i]
 ||     LDDW    .D2     *B4++[01],      B3:B2               ;load x[i]
 ||     ZERO    .S2     B7                                  ;Clear Accumulator

        LDDW    .D1     *A4++[01],      A5:A4               ;load x[i+1]
 ||     LDDW    .D2     *B4++[01],      B5:B4               ;load x[i+1]
 ||     ZERO    .L1     A9                                  ;Clear Accumulator
 ||     ZERO    .S1     A8                                  ;Clear Accumulator
 ||     ZERO    .L2     B8                                  ;Clear Accumulator
 ||     SUB     .S2     B0,         02,         B0          ;Decrement loop Counter

        B       .S1     loop
 ||     MV      .D1     A4,         A3                      ;Pointer for x
 ||     ZERO    .S2     B9                                  ;Clear Accumulator
 ||     STW     .D2     B10,        *B15--[01]              ;Push B10
 ||     CMPGT   .L2     B0,         0,          B1

        STW     .D2     B3,         *B15--[01]              ;Push Return address
 ||     ZERO    .L1     A6                                  ;Clear Accumulator
 ||     ZERO    .S1     A7                                  ;Clear Accumulator
 ||     MV      .S2     B4,         B10                     ;Twin pointer for x
 ||     ZERO    .L2     B6                                  ;Clear Accumulator
******************************************************************************
*****************************BEGIN OF KERNEL**********************************
******************************************************************************
loop:

   [B1] LDDW    .D1     *A3++[01],      A1:A0               ;load x[i]
 ||[B1] LDDW    .D2     *B10++[01],     B3:B2               ;load x[i]

   [B1] LDDW    .D1     *A3++[01],      A5:A4               ;load x[i+1]
 ||[B1] LDDW    .D2     *B10++[01],     B5:B4               ;load x[i+1]
 ||     MPYDP   .M1X    A1:A0,          B3:B2,      A7:A6   ;x[i]*x[i]
 ||[B1] SUB     .S2     B0,             2,          B0      ;Decrement the loopCounter


   [B1] B       .S1     loop
 ||     CMPGT   .L2     B0,             0,          B1
 ||     MPYDP   .M2X    B5:B4,          A5:A4,      B7:B6   ;x[i+1]*x[i+1]
 ||     ADDDP   .L1     A9:A8,          A7:A6,      A9:A8   ;S1+=x[i]*x[i]

        ADDDP   .L2     B9:B8,          B7:B6,      B9:B8   ;S2+=x[i+1]*x[i+1]
******************************************************************************
*****************************END OF KERNEL**********************************
******************************************************************************
        LDW     .D2     *++B15[01],     B3                  ;Pop out return address
  ||    ADD     .S2     B0,             1,      B0

   [!B0]MV      .S2     B8,         B4

   [!B0]MV      .S2     B9,         B5
  ||    ADDDP   .L1     A9:A8,          A7:A6,      A9:A8   ;S1+=x[i]*y[i]

    [B0]ADDDP   .L2     B9:B8,          B7:B6,      B9:B8   ;S2+=x[i+1]*y[i+1]
******************************************************************************
*****************************END OF EPILOG************************************
******************************************************************************
        MV      .S1     A8,     A4
 ||     LDW     .D2     *++B15[01],     B10                 ;Pop out B10

        MV      .S1     A9,     A5
 ||[B0] MV      .S2     B8,     B4
 ||     LDW     .D2     *++B15[01],     B7                  ;Pop out CSR

   [B0] MV      .S2     B9,     B5
        NOP     1
        ADDDP   .L1     A9:A8,          A5:A4,      A9:A8
        ADDDP   .L2     B9:B8,          B5:B4,      B9:B8
        MVC     .S2     B7,             CSR                 ;Enable Interrupts
        NOP     4
        ADDDP   .L1     A9:A8,          B9:B8,      A5:A4
        B       B3
        NOP     5

                .end

* ======================================================================== *
*  End of file: DSPF_dp_vecsum_sq.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_w_vec.a/1117057393  1159  0     0       11863     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_w_vec -- Double Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void DSPF_dp_w_vec(const double* x,                                    *
*                       const double* y,                                    *
*                       double m,                                           *
*                       double * restrict r,                                *
*                       int     nr                                          *
*                      )                                                    *
*                                                                           *
*              x    :  Pointer to first input array                         *
*              y    :  Pointer to second input array                        *
*              m    :  Weight factor                                        *
*              r    :  Output array pointer                                 *
*              nr   :  Number of elements in arrays                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine is used to obtain the weighted vector sum.              *
*      Both the inputs and output are Double precision floating             *
*      point numbers.                                                       *
*   TECHNIQUES                                                              *
*                                                                           *
*      1. The inner loop is unrolled twice.                                 *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The value of nr must be > 0.                                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_w_vec( const double * x,const double * y, double  m,         *
*                     double * restrict r,int nr)                           *
*                                                                           *
*     {                                                                     *
*         int i;                                                            *
*         for (i = 0; i < nr; i++)                                          *
*             r[i] = (m * x[i]) + y[i];                                     *
*     }                                                                     *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt tolerant but not          *
*                          interruptible.                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      4*Ceil(n/2) + 32                                                     *
*      eg. for n = 100, cycles = 232.                                       *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     352 bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_w_vec
_DSPF_dp_w_vec:

        MVC     .S2     CSR,    B5                          ;Get CSR

        STW     .D2     B5,     *B15--[01]                  ;Store CSR
 ||     AND     .S2     -2,     B5,         B5              ;Disable Interrupts

        SUB     .L1     B15,    4,      A9                  ;Twin stack Pointer
 ||     MV      .L2     B3,     B7                          ;Store the return address
 ||     MVC     .S2     B5,     CSR

        STW     .D2     B14,    *B15--[02]                  ;Push B14 and A14 in to stack
 ||     STW     .D1     A14,    *A9--[02]
 ||     MV      .L2     A8,     B2                          ;Set the loop Counter

        STW     .D2     B13,    *B15--[02]                  ;Push B13 and A13 in to stack
 ||     STW     .D1     A13,    *A9--[02]
 ||     MV      .L1     A4,     A14                         ;Pointer for x1
 ||     ADD     .L2     A4,     8,          B14             ;Pointer for x2

        LDDW    .D1     *A14++[02],         A5:A4           ;Load x1
 ||     LDDW    .D2     *B14++[02],         B5:B4           ;Load x2
 ||     MVK     .S2     1,      B1

        STW     .D2     B12,    *B15--[02]                  ;Push B12 and A12 in to stack
 ||     STW     .D1     A12,    *A9--[02]
 ||     MVK     .S2     1,      B0                          ;Branch Counter
 ||     MVK     .S1     4,      A1                          ;Store Counter

        B       .S1     loop
 ||     STW     .D2     B11,    *B15--[02]                  ;Push B11 and A11 in to stack
 ||     STW     .D1     A11,    *A9--[02]
 ||     ADD     .L2     B4,     8,          B3              ;Pointer for y1
 ||     MV      .L1     B4,     A3                          ;Pointer for y2


        STW     .D2     B10,    *B15--[02]                  ;Push B10 and A10 in to stack
 ||     STW     .D1     A10,    *A9--[02]
 ||     ADD     .L2     B6,     8,          B6              ;Pointer for r1
 ||     MV      .L1     B6,     A0                          ;Pointer for r2
 ||     MVK     .S1     3,      A2                          ;ADDDP Counter
*************************************************************************************
*************************************************************************************
loop:

        LDDW    .D1     *A14++[02],     A5:A4               ;Load x1
 ||     LDDW    .D2     *B14++[02],     B5:B4               ;Load x2

   [!B1]LDDW    .D1     *A3++[02],      A11:A10             ;Load y1
 ||[!B1]LDDW    .D2     *B3++[02],      B11:B10             ;Load y2
 ||     MPYDP   .M1     A5:A4,          A7:A6,      A9:A8   ;m1*x1
 ||     MPYDP   .M2     B5:B4,          A7:A6,      B9:B8   ;m2*x2
 ||[B0] SUB     .S2     B2,             02,         B2      ;Decrement the loop Counter
 ||     CMPGT   .L2     B2,             0,          B0      ;
 ||[A2] SUB     .L1     A2,             1,          A2      ;ADDDP Counter

   [B0] B       .S1     loop
 ||[!A2]ADDDP   .L1     A9:A8,          A11:A10,    A13:A12 ;m1*x1+y1
 ||[!A2]ADDDP   .L2     B9:B8,          B11:B10,    B13:B12 ;m2*x2+y2
 ||[!A1]STW     .D1     A12,            *A0++               ;store r1
 ||[!A1]STW     .D2     B12,            *B6++               ;store r2
 ||[B1] SUB     .S2     B1,             1,          B1      ;load y Counter


   [!A1]STW     .D1     A13,            *A0++[03]           ;store r1
 ||[!A1]STW     .D2     B13 ,           *B6++[03]           ;store r2
 ||[A1] SUB     .S1     A1,             1,          A1      ;Store Counter
*************************************************************************************
*************************************************************************************

   [!A1]STW     .D1     A12,            *A0++               ;store r1
 ||[!A1]STW     .D2     B12,            *B6++               ;store r2
 ||     SUB     .S1     B15,            4,          A4
 ||     MV      .S2     B7,             B3                  ;Restore return address

   [!A1]STW     .D1     A13,            *A0++[03]           ;store r1
 ||[!A1]STW     .D2     B13 ,           *B6++[03]           ;store r2

        LDW     .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW     .D1     *++A4[02],      A10

        ADD     .S2     B2,             1,          B1
 ||     LDW     .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW     .D1     *++A4[02],      A11

        STW     .D1     A12,            *A0++               ;store r1
 ||[B1] STW     .D2     B12,            *B6++               ;store r2

        STW     .D1     A13,            *A0++[03]           ;store r1
 ||[B1] STW     .D2     B13 ,           *B6++[03]           ;store r2

        LDW     .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW     .D1     *++A4[02],      A12

        LDW     .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW     .D1     *++A4[02],      A13

        LDW     .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW     .D1     *++A4[02],      A14

        B       .S2     B3;
 ||     LDW     .D2     *++B15[01],     B7

        NOP         4
        MVC     .S2     B7,             CSR                 ;Enable Interrupts
                .end

* ======================================================================== *
*  End of file: DSPF_dp_w_vec.asm                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_vecmul./1117057394  1178  0     0       10538     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecmul -- Double Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void DSPF_dp_vecmul   (const double *x,                                  *
*                         const double *y,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                         )                                                 *
*                                                                           *
*              x        :  Pointer to first input array                     *
*              y        :  Pointer to second input array                    *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in arrays                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs an element by element Double Precision       *
*        floating point  multiplication of the vectors x[] and y[] and      *
*        returns the values in r[].                                         *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*       1. The inner loop is unrolled twice to allow calculation of         *
*          2 outputs in the kernel. However the stores are executed         *
*          conditionally to allow 'n' to be any number > 0.                 *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*       1. The value of n > 0.                                              *
*                                                                           *
*                                                                           *
*     C CODE                                                                *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_vecmul(const double * x, const double * y,                   *
*                            double * restrict r, int n)                    *
*       {                                                                   *
*         int i;                                                            *
*                                                                           *
*         for(i = 0; i < n; i++)                                            *
*              r[i] = x[i] * y[i];                                          *
*                                                                           *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*        1. Endian: This code is LITTLE ENDIAN.                             *
*        2. Interruptibility: The code is interrupt tolerant but not        *
*           interruptible.                                                  *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*          4*Ceil(n/2) + 13                                                 *
*          eg. for n = 100, cycles = 213                                    *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*          256 bytes                                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_vecmul
_DSPF_dp_vecmul:


        LDDW    .D1     *A4++[01],      A3:A2               ;load x1
 ||     LDDW    .D2     *B4++[01],      B3:B2               ;load y1
 ||     MV      .L1     B3,             A0                  ;Save the return address
 ||     MV      .L2     B6,             B1                  ;Set the loop Counter
 ||     MVC     .S2     CSR,            B7                  ;GET CSR

        LDDW    .D1     *A4++[01],      A5:A4               ;load x2;
 ||     LDDW    .D2     *B4++[01],      B5:B4               ;load y2;
 ||     MV      .L1     A6,             A9                  ;Pointer for r1
 ||     ADD     .L2     A6,             8,          B9      ;Pointer for r2
 ||     AND     .S2     -2,             B7,         B6      ;Disable Interrupts

        B       loop
 ||     SUB     .L2     B1,             02,         B1      ;Decrement loop Counter
 ||     MV      .L1     A4,             A8                  ;Pointer for x
 ||     MV      .S2     B4,             B8                  ;Pointer for y
 ||     STW     .D2     B7,             *B15--[01]

        CMPGT   .L2     B1,             2,          B0
 ||     MVK     .S1     3,              A1                  ;To prevent store in first2 iterations
 ||     MVC     .S2     B6,             CSR
*************************************************************************************
********************************BEGIN OF KERNEL**************************************
*************************************************************************************
loop:

        LDDW    .D1     *A8++[01],      A3:A2               ;load x1
 ||     LDDW    .D2     *B8++[01],      B3:B2               ;load y1

        LDDW    .D1     *A8++[01],      A5:A4               ;load x2;
 ||     LDDW    .D2     *B8++[01],      B5:B4               ;load y2;
 ||[B0] SUB     .L2     B1,             02,         B1      ;Decrement the loop Counter
 ||     MPYDP   .M1X    A3:A2,          B3:B2,      A7:A6   ;r1=x1*y1

   [B0] B       .S1     loop
 ||     MPYDP   .M2X    A5:A4,          B5:B4,      B7:B6   ;r2=x2*y2
 ||[!A1]STW     .D1     A7,             *A9++[03]           ;store r1
 ||[!A1]STW     .D2     B7,             *B9++[03]           ;store r2
 ||     CMPGT   .L2     B1,             2,          B0
 ||[A1] SUB     .L1     A1,             1,          A1


   [!A1]STW     .D1     A6,             *A9++               ;store r1
 ||[!A1]STW     .D2     B6,             *B9++               ;store r2

*************************************************************************************
**********************************END OF KERNEL**************************************
*************************************************************************************


   [!A1]STW     .D1     A7,             *A9++[03]           ;store r1
 ||[!A1]STW     .D2     B7,             *B9++[03]           ;store r2

   [A1] SUB     .S1     A1,             1,          A1
 ||     LDW     .D2     *++B15[01],     B5                  ;Get CSR

         MV     .S2     A0,             B3                  ;restore return Address

        B       .S2     B3
 ||[!A1]STW     .D1     A6,             *A9++               ;store r1
 ||[!A1]STW     .D2     B6,             *B9++               ;store r2

   [!A1]STW     .D1     A7,             *A9++[03]           ;store r1
 ||[!A1]STW     .D2     B7,             *B9++[03]           ;store r2

        NOP     1

        SUB     .S2     B2,             1,          B2

        STW     .D1     A6,             *A9++               ;store r1
 ||[B2] STW     .D2     B6,             *B9++               ;store r2
 ||     MVC     .S2     B5,             CSR                 ;Enable Interrupts

        STW     .D1     A7,             *A9++[03]           ;store r1
 ||[B2] STW     .D2     B7,             *B9++[03]           ;store r2

                .end

* ======================================================================== *
*  End of file: DSPF_dp_vecmul.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_mat_mul/1117057395  1198  0     0       23363     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine has following C prototype:                              *
*      void DSPF_dp_mat_mul(double *x, int r1, int c1,                           *
*                      double *y, int c2, double *r)                        *
*                                                                           *
*      x      : Pointer to r1 by c1 input matrix.                           *
*      r1     : Number of rows in x.                                        *
*      c1     : Number of columns in x.  Also number of rows in y.          *
*      y      : Pointer to c1 by c2 input matrix.                           *
*      c2     : Number of columns in y.                                     *
*      r      : Pointer to r1 by c2 output matrix.                          *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      This function computes the expression "r = x * y" for the matrices   *
*      x and y.  The column dimension of x must match the row dimension     *
*      of y.  The resulting matrix has the same number of rows as x and     *
*      the same number of columns as y.                                     *
*                                                                           *
*      The values stored in the matrices are assumed to be Double           *
*      precision floating point values.                                     *
*                                                                           *
*      This code is suitable for dense matrices.  No optimizations are      *
*      made for sparse matrices.                                            *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*      1.    All three loops are unrolled two times                         *
*      2.    All the prolog stages of the innermost loop (kLoop) are        *
*            Scheduled in Parallel with outer loop.                         *
*      3.    Extraneous Loads are allowed in Program                        *
*      4.    Outer most Loop Instructions are scheduled in Parallel with In *r
*            Loop Instructions.                                                   *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*      1.    The arrays 'x', 'y', and 'r' are stored in distinct arrays.    *
*            That is, in-place processing is not allowed.                   *
*      2.    All r1, c1, c2 are assumed to be > 1                           *
*      3.   If r1 is odd, one extra row of x[] matrix is loaded             *
*      4.   If c2 is odd, one extra col of y[] matrix is loaded.            *
*      5.   If c1 is odd, one extra col of x[] and  one extra row of        *
*           y[] array is loaded                                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*     void DSPF_dp_mat_mul(double *x, int r1, int c1,                            *
*                     double *y, int c2, double *r)                         *
*     {                                                                     *
*         int i, j, k;                                                      *
*         double sum;                                                       *
*                                                                           *
*      //  Multiply each row in x by each column in y.                      *
*      //  The product of row m in x and column n in y is placed            *
*      //  in position (m,n) in the result.                                 *
*                                                                           *
*         for (i = 0; i < r1; i++)                                          *
*             for (j = 0; j < c2; j++)                                      *
*             {                                                             *
*                 sum = 0;                                                  *
*                 for (k = 0; k < c1; k++)                                  *
*                     sum += x[k + i*c1] * y[j + k*c2];                     *
*                                                                           *
*                 r[j + i*c2] = sum;                                        *
*             }                                                             *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1.   Endian: This code is LITTLE ENDIAN .                            *
*      2.   Interruptibility: This code is interrupt-tolerant but not       *
*           interruptible.                                                  *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*     (2 * r1' * c1 * c2') + 18*( c2'/2 * r1'/2) + 40                       *
*     where                                                                 *
*            r1' = r1 + (r1&1)                                              *
*            c2' = c2 + (c2&1)                                              *
*     For r1 = 12, c1 = 14 and c2 = 12,     cycles = 4720                   *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*     960 Bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_mat_mul
_DSPF_dp_mat_mul:

            STW     .D2     B3,             *B15--[01]          ;Pushing Return Address into Stack
 ||     MV      .L1     A6,             A3                  ;C1

        STW     .D2     A15,            *B15--[01]          ;Pushing A15 into stack
 ||     MV      .L2X    A8,             B2                  ;C2
 ||     MVC     .S2     CSR,            B7                  ;Get CSR

        STW     .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND     .S2     -2,             B7,         B7      ;Disable Interrupts

        SUB     .S1X    B15,            04,         A15     ;A15<-B15-4, Twin Stack Pointer
 ||     MVC     .S2     B7,             CSR

        STW     .D2     B14,            *B15--[02]          ;Pushing B14 And A14 into Stack
 ||     STW     .D1     A14,            *A15--[02]

        STW     .D2     B13,            *B15--[02]          ;Pushing B13 And A13 into Stack
 ||     STW     .D1     A13,            *A15--[02]
 ||     MV      .L1     A4,             A14                 ;Pointer for X
 ||     MV      .L2     B6,             B14                 ;Pointer for Y

        STW     .D2     B12,            *B15--[02]          ;Pushing B12 And A12 into Stack
 ||     STW     .D1     A12,            *A15--[02]
 ||     MV      .L1X    B4,             A1                  ;i Loop Counter

        STW     .D2     B11,            *B15--[02]          ;Pushing B11 And A11 into Stack
 ||     STW     .D1     A11,            *A15--[02]
 ||     ZERO    .L1     A13                                 ;Index for X
 ||     ZERO    .L2     B13                                 ;Index for Y
 ||     MV      .S2     B2,             B1                  ;jLoop Counter

        STW     .D2     B10,            *B15--[02]          ;Pushing B10 And A10 into Stack
 ||     STW     .D1     A10,            *A15--[02]
 ||     MV      .L1     A3,             A2                  ; C1 k Loop Counter

        STW     .D2     B8,             *B15--[02]          ;Pushing *R in to Stack
 ||     STW     .D1     A13,            *A15--[02]          ;Pushing Index of X into Stack

        STW     .D2     B13,            *B15--[02]          ;Pushing Index of Y into Stack
 ||     STW     .D1     A13,            *A15--[02]          ;Pushing Index of R into Stack

        STW     .D2     B4,             *B15--[02]          ;Pushing r1 into Stack
 ||     STW     .D1     A1,             *A15--[02]          ;Pushing iLoop Counter into Stack

        STW     .D2     B1,             *B15--[01]          ;Pushing jLoop Counter into Stack
 ||     MV      .L1     A13,            A15                 ;Setting Initial Index for X
 ||     MV      .L2     B13,            B3                  ;Setting Initial Index for Y

*****************************************************************************************
*****************************PROLOG FOR ijkLOOP KERNEL***********************************
*****************************************************************************************

        LDDW    .D1     *+A14[A15],     A7:A6                   ;Loading X[0][0] And Y[0][0]
 ||     LDDW    .D2     *+B14[B3],      B7:B6

        ADD     .L1     A15,            A3,         A15         ;Setting Indexes of X And Y
 ||     ADD     .L2     B3,             1,          B3

        LDDW    .D1     *+A14[A15],     A9:A8                   ;Loading X[1][0] and Y[0][1]
 ||     LDDW    .D2     *+B14[B3],      B9:B8

        SUB     .L1     A15,            A3,         A15         ;Setting Indexes of X And Y
 ||     ADD     .L2     B3,             B2,         B3

        ADD     .S1     A15,            1,          A15
 ||     SUB     .S2     B3,             1,          B3

        MPYDP   .M1X    A7:A6,          B7:B6,      A1:A0       ;P11

        ZERO    .L1     A12                                     ;Clearing Registers A13:A12
 ||     ZERO    .S1     A13
 ||     ZERO    .L2     B12                                     ;Clearing Registers B13:B12
 ||     ZERO    .S2     B13

        MPYDP   .M2X    B9:B8,          A7:A6,      B1:B0       ;P21
 ||     ZERO    .D1     A10                                     ;Clearing Registers A11:A10
 ||     ZERO    .S1     A11
 ||     ZERO    .L2     B10                                     ;Clearing Registers B11:B10
 ||     ZERO    .S2     B11

        LDDW    .D1     *+A14[A15],     A7:A6                   ;Loading X[0][1] and Y[1][0]
 ||     LDDW    .D2     *+B14[B3],      B7:B6

        MPYDP   .M1X    A9:A8,          B7:B6,      A5:A4       ;P31
 ||     ADD     .S1     A15,            A3,         A15
 ||     ADD     .S2     B3,             1,          B3

   [A2] SUB     .S1     A2,             02,         A2
 ||     LDDW    .D1     *+A14[A15],     A9:A8                   ;Loading X[1][1] and Y[1][1]
 ||     LDDW    .D2     *+B14[B3],      B9:B8

        MPYDP   .M2X    B9:B8,          A9:A8,      B5:B4       ;P41
 ||     SUB     .S1     A15,            A3,         A15
 ||     ADD     .S2     B3,             B2,         B3

        ADD     .S1     A15,            1,          A15
 ||     SUB     .S2     B3,             1,          B3

************************************************************************************
******************************BEGIN OF KERNEL (ijk Loop)****************************
************************************************************************************

ijkLOOP:

        MPYDP   .M1X    A7:A6,          B7:B6,      A1:A0       ;P12

        ADDDP   .L1     A11:A10,        A1:A0,      A11:A10     ;S1+=P11

        MPYDP   .M2X    B9:B8,          A7:A6,      B1:B0       ;P22

        LDDW    .D1     *+A14[A15],     A7:A6
 ||     LDDW    .D2     *+B14[B3],      B7:B6
 ||     ADDDP   .L2     B11:B10,        B1:B0,      B11:B10     ;S2+=P21

        MPYDP   .M1X    A9:A8,          B7:B6,      A5:A4       ;P32
 ||     ADD     .S1     A15,            A3,         A15
 ||     ADD     .S2     B3,             1,          B3
 ||[!A2]LDW     .D2     *+B15[01],      B7                      ;Load j loop Counter


        ADDDP   .L1     A13:A12,        A5:A4,      A13:A12     ;S3+=P31
 ||     LDDW    .D1     *+A14[A15],     A9:A8
 ||     LDDW    .D2     *+B14[B3],      B9:B8

        MPYDP   .M2X    B9:B8,          A9:A8,      B5:B4       ;P42
 ||     SUB     .S1     A15,            A3,         A15
 ||     ADD     .S2     B3,             B2,         B3
 ||[!A2]LDW     .D2     *+B15[05],      B6                      ;Loading Index for Y

        ADDDP   .L2     B13:B12,        B5:B4,      B13:B12     ;S4+=P41
 ||     ADD     .S1     A15,            1,          A15
 ||     SUB     .S2     B3,             1,          B3
 ||[!A2]LDW     .D2     *+B15[07],      B8                      ;Load Pointer for *R

   [A2] MPYDP   .M1X    A7:A6,          B7:B6,      A1:A0       ;P11
 ||[!A2]LDW     .D2     *+B15[07],      A8                      ;Load Pointer for *R

        ADDDP   .L1     A11:A10,        A1:A0,      A11:A10     ;S1+=P12
 ||[!A2]SUB     .S2     B7,             2,          B7          ;Decrement jloop Counter
 ||[!A2]LDW     .D2     *+B15[06],      A15                     ;Loading Index for X

   [A2] B       .S2     ijkLOOP
 ||[A2] MPYDP   .M2X    B9:B8,          A7:A6,      B1:B0       ;P21
 ||[!A2]LDW     .D2     *+B15[04],      B9                      ;Loading Index for R

        ADDDP   .L2     B11:B10,        B1:B0,      B11:B10     ;S2+=P22
 ||[A2] LDDW    .D1     *+A14[A15],     A7:A6
 ||[A2] LDDW    .D2     *+B14[B3],      B7:B6
 ||[!A2]ADD     .S2     B6,             2,          B6          ;jloop Updated Index for Y

   [A2] MPYDP   .M1X    A9:A8,          B7:B6,      A5:A4       ;P31
 ||[A2] ADD     .S1     A15,            A3,         A15
 ||[A2] ADD     .S2     B3,             1,          B3
 ||[!A2]MV      .D2     B7,             B1

        ADDDP   .L1     A13:A12,        A5:A4,      A13:A12     ;S3+=P32
 ||[A2] LDDW    .D1     *+A14[A15],     A9:A8
 ||[A2] LDDW    .D2     *+B14[B3],      B9:B8
 ||[!A2]ADD     .S1     A3,             A3,         A7          ;2*c1

   [A2] MPYDP   .M2X    B9:B8,          A9:A8,      B5:B4       ;P31
 ||[A2] SUB     .S1     A15,            A3,         A15
 ||[A2] ADD     .L2     B3,             B2,         B3
 ||[!A2]ADD     .S2     B2,             B2,         B7          ;2*C2

    [A2]SUB     .S1     A2,             02,         A2
 ||     ADDDP   .L2     B13:B12,        B5:B4,      B13:B12     ;S4+=P42
 ||[A2] ADD     .D1     A15,            1,          A15
 ||[A2] SUB     .S2     B3,             1,          B3
 ||[!A2]STW     .D2     A10,            *+B8[B9]                ;Store Sum 1

************************************************************************************
********************************END OF KERNEL (ijk Loop)****************************
************************************************************************************

   [!B1]LDW     .D2     *+B15[02],      A1                  ;Loading iLoop Counter
 ||[!B1]ZERO    .S2     B6                                  ;iLoop Updated Index Y
 ||[!B1]ADD     .L1     A15,            A7,         A15     ;iLoop Updated Index X
 ||     ADD     .S1X    B9,             1,          A9

        STW     .D2     A15,            *+B15[06]           ;Storing X Index

   [B1] STW     .D2     B1,             *+B15[1]            ;Store jloop Counter

        LDDW    .D1     *+A14[A15],     A7:A6               ;p-Loading X[0][0] And Y[0][0]
 ||     LDDW    .D2     *+B14[B6],      B7:B6               ;p-
 ||     ADD     .L2     B6,             1,          B3      ;p-

        STW     .D2     B6,             *+B15[05]           ;Storing Y Index
 ||     STW     .D1     A11,            *+A8[A9]            ;Store Sum 1
 ||     ADD     .S2     B9,             2,          B9
 ||     ADD     .S1     A15,            A3,         A15     ;p-Setting Indexes of X And Y

        STW     .D2     B10,            *+B8[B9]            ;Store Sum 2
 ||     ADD     .S1     A9,             2,          A9
 ||     SUB     .S2     B7,             2,          B7

        STW     .D1     B11,            *+A8[A9]            ;Store Sum 2
 ||     ADD     .S2     B9,             B7,         B9
 ||     ADD     .S1     A9,             1,          A4

        LDDW    .D1     *+A14[A15],     A9:A8               ;p-Loading X[1][0] and Y[0][1]
 ||     LDDW    .D2     *+B14[B3],      B9:B8
 ||     MV      .S1     A3,             A10                 ;kloop Counter

        STW     .D2     A12,            *+B8[B9]            ;Store Sum 3
 ||     ADD     .S1X    B9,             1,          A9
 ||     SUB     .L1     A15,            A3,         A15     ;p-Setting Indexes of X And Y
 ||     ADD     .L2     B3,             B2,         B3      ;p-

        STW     .D1     A13,            *+A8[A9]            ;Store Sum 3
 ||     ADD     .S2     B9,             2,          B9
 ||[!B1]SUB     .S1     A1,             2,          A1      ;Decrement iloop counter
 ||     MV      .L1X    B1,             A2
 ||     SUB     .L2     B3,             1,          B3      ;p-
 ||[!B1]STW     .D2     B2,             *+B15[01]           ;store j loop Counter

        STW     .D2     B12,            *+B8[B9]            ;Store Sum 4
 ||     ADD     .S1     A9,             2,          A9
 ||[!B1]MV      .L1     A1,             A2
 ||     MPYDP   .M1X    A7:A6,          B7:B6,      A1:A0   ;p-P11

        STW     .D1     B13,            *+A8[A9]            ;Store Sum 4
 ||[!B1]ADD     .S1     A9,             1,          A4      ;
 ||[!B1]STW     .D2     A1,             *+B15[2]            ;Store i loop Counter
 ||     ADD     .L1     A15,            1,          A15     ;p-

   [A2] B       .S1     ijkLOOP
 ||     STW     .D2     A4,             *+B15[4]            ;Store Index for R
 ||[A2] MPYDP   .M2X    B9:B8,          A7:A6,      B1:B0   ;P-P21
 ||     ZERO    .D1     A11
 ||     ZERO    .L2     B10                                 ;p-Clearing Registers B11:B10
 ||     ZERO    .S2     B11

        LDDW    .D1     *+A14[A15],     A7:A6               ;p-Loading X[0][1] and Y[1][0]
 ||     LDDW    .D2     *+B14[B3],      B7:B6
 ||     ZERO    .L1     A12                                 ;p-Clearing Registers A13:A12
 ||     ZERO    .S1     A13
 ||     ZERO    .L2     B12                                 ;p-Clearing Registers B13:B12
 ||     ZERO    .S2     B13

   [A2] MPYDP   .M1X    A9:A8,          B7:B6,      A5:A4   ;p-P31
 ||     ADD     .S1     A15,            A3,         A15
 ||     ADD     .S2     B3,             1,          B3

        LDDW    .D1     *+A14[A15],     A9:A8               ;p-Loading X[1][1] and Y[1][1]
 ||     LDDW    .D2     *+B14[B3],      B9:B8

   [A2] MPYDP   .M2X    B9:B8,          A9:A8,      B5:B4   ;p-P41
 ||     SUB     .S1     A15,            A3,         A15
 ||     ADD     .S2     B3,             B2,         B3
 ||     MV      .L1     A10,            A2

        ADD     .D1     A15,            1,          A15     ;p-
 ||     SUB     .S2     B3,             1,          B3
 ||[A2] SUB     .S1     A2,             02,         A2
 ||     ZERO    .L1     A10

************************************************************************************
******************************** j Loop Branch occurs here**************************
************************************************************************************

        ADDAW       .D2     B15,            7,          B15     ;Initialising SP
        SUB         .L1X    B15,            4,          A15     ;Twin sp's
 ||     LDW         .D2     *+B15[11],      B7                  ;Restore CSR
        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;



                .end

* ======================================================================== *
*  End of file: DSPF_dp_mat_mul.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_mat_tra/1117057396  1219  0     0       9920      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_trans -- Double Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x,                        *
*                          int rows,                                        *
*                          int cols,                                        *
*                          double *restrict r                               *
*                          )                                                *
*                                                                           *
*           x       :  Input matrix containing rows*cols Double Precision   *
*                      floating point numbers.                              *
*           rows    :  No. of rows in matrix x.                             *
*                      Also no. of columns in matrix r                      *
*           cols    :  No. of columns in matrix x.                          *
*                      Also no. of rows in matrix r.                        *
*           r       :  Output matrix containing cols*rows Double Precision  *
*                      floating point numbers.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This function transposes the input matrix x[] and writes the          *
*     result to matrix r[].                                                 *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The number of rows and columns is > 0.                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*        This is the C equivalent of the assembly code.  Note that          *
*        the assembly code is hand optimized and restrictions may apply.    *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x, int rows,              *
*        int cols, double *restrict r)                                      *
*        {                                                                  *
*           int i,j;                                                        *
*                                                                           *
*           for(i=0; i<cols; i++)                                           *
*              for(j=0; j<rows; j++)                                        *
*                 r[i * rows + j] = x[i + cols * j];                        *
*        }                                                                  *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2 * rows * cols + 15                                                *
*       For rows=10 and cols=20, cycles=415                                 *
*       For rows=15 and cols=20, cycles=615                                 *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       256  bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_mat_trans
_DSPF_dp_mat_trans:

            MPY     .M2     A6,             B4,         B2      ;Set the Loop Counter
 ||     ZERO    .L1     A3                                  ;indexfor loading x[i][j]
 ||     MVK     .S2     1,              B0                  ;Index Save

        MVC     .S2     CSR,            B7                  ;Get CSR

        SUB     .S1     B4,             1,          A5      ;r1-1
 ||     ZERO    .L1     A2
 ||     STW     .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND     .S2     -2,             B7,         B7      ;Disable Interrupts

        ADD     .L1     B6,             04,         A7      ;For storing result
 ||     MPY     .M1     A5,             A6,         A0      ;(r1-1)*c1
 ||     MVK     .S2     1,              B1


        SUB     .L2     B2,             1,          B2      ;Decrement the Counter
 ||     MV      .L1     B6,             A7
 ||     MV      .S2     A7,             B6
 ||     MVK     .S1     1,              A5

*******************************************************************************************

        LDDW    .D1     *+A4[A3],       A9:A8               ;Load x[0][0]
 ||     ADD     .S1     A3,             A6,         A3      ;Next Index for x[i][j]
 ||     CMPEQ   .L1     A3,             A0,         A2
 ||[A2] ADD     .L2     B0,             1,          B0      ;Increment Index
 ||[B2] B       .S2     loop


   [A2] MV      .S1     B0,             A3
 ||[B2] SUB     .L2     B2,             1,          B2      ;Decrement the Counter
 ||[A2] ADD     .L1     A0,             A5,         A0
 ||     MVC     .S2     B7,             CSR

        LDDW    .D1     *+A4[A3],       A9:A8               ;Load x[i][j]
 ||     ADD     .S1     A3,             A6,         A3      ;Next Index for x[i][j]
 ||     CMPEQ   .L1     A3,             A0,         A2
 ||[A2] ADD     .L2     B0,             1,          B0      ;Increment Index
 ||[B2] B       .S2     loop


   [A2] MV      .S1     B0,             A3
 ||[B2] SUB     .L2     B2,             1,          B2      ;Decrement the Counter
 ||[A2] ADD     .L1     A0,             A5,         A0
*************************************************************************************
*******************************BEGIN OF KERNEL***************************************
*************************************************************************************

loop:

        LDDW    .D1     *+A4[A3],       A9:A8               ;Load x[i][j]
 ||     ADD     .S1     A3,             A6,         A3      ;Next Index for x[i][j]
 ||     CMPEQ   .L1     A3,             A0,         A2
 ||[A2] ADD     .L2     B0,             1,          B0      ;Increment Index
 ||[B2] B       .S2     loop
 ||[!B1]STW     .D2     B9,             *B6++[02]


   [A2] MV      .S1     B0,             A3
 ||[B2] SUB     .S2     B2,             1,          B2      ;Decrement the Counter
 ||     STW     .D1     A8,             *A7++[02]
 ||[B1] SUB     .D2     B1,             1,          B1
 ||     MV      .L2     A9,             B9
 ||[A2] ADD     .L1     A0,             A5,         A0

*************************************************************************************
*******************************END OF KERNEL***************************************
*************************************************************************************
        B       .S2     B3
 ||     LDW     .D2     *++B15[01],         B7              ;Get CSR

        STW     .D2     B9,             *B6++

        NOP     3

        MVC     .S2     B7,                 CSR             ;Enable Interrupts
                .end

* ======================================================================== *
*  End of file: DSPF_dp_mat_trans.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_mat_mul/1117057397  1242  0     0       24543     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_mul_cplx(                                              *
*                               const double* x,                            *
*                               int r1,                                     *
*                               int c1,                                     *
*                               const double* y,                            *
*                               int c2,                                     *
*                               double* restrict r                          *
*                            )                                              *
*                                                                           *
*             x[2*r1*c1]:   Input matrix containing r1*c1 complex           *
*                           floating point numbers having r1 rows and c1    *
*                           columns of complex numbers.                     *
*             r1        :   No. of rows in matrix x.                        *
*             c1        :   No. of columns in matrix x.                     *
*                           Also no. of rows in matrix y.                   *
*             y[2*c1*c2]:   Input matrix containing c1*c2 complex           *
*                           floating point numbers having c1 rows and c2    *
*                           columns of complex numbers.                     *
*             c2        :   No. of columns in matrix y.                     *
*             r[2*r1*c2]:   Output matrix of c1*c2 complex floating         *
*                           point numbers having c1 rows and c2 columns of  *
*                           complex numbers.                                *
*                                                                           *
*                           Complex numbers are stored consecutively with   *
*                           real values stored in even positions and        *
*                           imaginary values in odd positions.              *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*         This function computes the expression "r = x * y" for the         *
*         matrices x and y. The columnar dimension of x must match the row  *
*         dimension of y. The resulting matrix has the same number of rows  *
*         as x and the same number of columns as y.                         *
*                                                                           *
*         Each element of the matrix is assumed to be complex numbers with  *
*         Real values are stored in even positions and imaginary            *
*         values in odd positions.                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*         1. Innermost loop is unrolled twice.                              *
*         2. Outermost loop is executed in parallel with innner loops.      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*         1. r1,r2>=1,c1 should be a multiple of 2 and >=2.                 *
*         2. x should be padded with 6 words                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*    the assembly code is hand optimized and restrictions may apply.        *
*                                                                           *
*         void DSPF_dp_mat_mul_cplx(const double* x, int r1, int c1,             *
*           const double* y, int c2, double* restrict r)                    *
*         {                                                                 *
*             double real, imag;                                            *
*             int i, j, k;                                                  *
*                                                                           *
*             for(i = 0; i < r1; i++)                                       *
*             {                                                             *
*               for(j = 0; j < c2; j++)                                     *
*               {                                                           *
*                 real=0;                                                   *
*                 imag=0;                                                   *
*                                                                           *
*                 for(k = 0; k < c1; k++)                                   *
*                 {                                                         *
*                 real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j]                  *
*                 -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);              *
*                                                                           *
*                 imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1]              *
*                    + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);              *
*                 }                                                         *
*                 r[i*2*c2 + 2*j] = real;                                   *
*                 r[i*2*c2 + 2*j + 1] = imag;                               *
*               }                                                           *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*         1. Real values are stored in even word positions and imaginary    *
*            values in odd positions.                                       *
*         2. Endian: This code is LITTLE ENDIAN.                            *
*         3. Interruptibility: This code is interrupt tolerant but not      *
*            interruptible.                                                 *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*         8*r1*c1*c2'+ 18*(r1*c2)+40 WHERE c2'=2*ceil(c2/2)                 *
*         When r1=3, c1=4, c2=4, cycles = 640                               *
*         When r1=4, c1=4, c2=5, cycles = 1040                              *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_mat_mul_cplx
_DSPF_dp_mat_mul_cplx:


        STW         .D2     B3,             *B15--[01]          ;Pushing returnaddress into Stack

        STW         .D2     A15,            *B15--[01]          ;Pushing A15 into Stack
 ||     ZERO        .L1     A3                                  ;Index for x
 ||     MVC         .S2     CSR,            B7                  ;Get CSR

        STW         .D2     B7,             *B15--[01]          ;Store CSR
 ||     AND         .S2     -2,             B7,         B7      ;Disable Interrupts

        SUB         .S1X    B15,            04,         A9      ;Setting A9<- SP-1
 ||     ZERO        .L2     B3                                  ;index for array Y
 ||     MVC         .S2     B7,             CSR

        STW         .D2     B14,            *B15--[02]          ;Pushing B14 and A14 into stack
 ||     STW         .D1     A14,            *A9--[02]
 ||     MV          .L1     A4,             A14                 ;Pointer for x
 ||     MV          .L2     B6,             B14                 ;Pointer for y

        STW         .D2     B13,            *B15--[02]          ;Pushing B13 and A13 into stack
 ||     STW         .D1     A13,            *A9--[02]
 ||     MV          .L1     B8,             A15                 ;Pointer for r
 ||     MV          .S1     A6,             A2                  ;kloop Counter  c1

        STW         .D2     B12,            *B15--[02]          ;Pushing B12 and A12 into stack
 ||     STW         .D1     A12,            *A9--[02]
 ||     MV          .L2     A8,             B2                  ;jloop Counter c2

        STW         .D2     B11,            *B15--[02]          ;Pushing B11 and A11 into stack
 ||     STW         .D1     A11,            *A9--[02]

        STW         .D2     B10,            *B15--[02]          ;Pushing B10 and A10 into stack
 ||     STW         .D1     A10,            *A9--[02]
 ||     ZERO        .L1     A13
 ||     ZERO        .L2     B13
 ||     ZERO        .S1     A12
 ||     ZERO        .S2     B12

        STW         .D2     B4,             *B15--[02]          ;Pushing r1 into stack
 ||     STW         .D1     A6,             *A9--[02]           ;Pushing c1 into stack
 ||     ZERO        .L1     A11
 ||     ZERO        .L2     B11
 ||     ZERO        .S1     A10
 ||     ZERO        .S2     B10

        STW         .D2     A8,             *B15--[02]          ;Pushing c2 into stack
 ||     STW         .D1     B4,             *A9--[02]           ;Pushing iloop Counter into stack

        STW         .D2     B2,             *B15--[02]          ;Pushing jloop Counter into stack
 ||     STW         .D1     A3,             *A9--[02]           ;Pushing X Index into stack

        STW         .D2     B3,             *B15--[01]          ;Pushing Y Index into stack
 ||     ADD         .L2     B2,             B2,         B2      ;2*c2
**************************************************************************************
*****************************PROLOG BEGINS FOR FIRST TIME*****************************
**************************************************************************************
        LDDW        .D1     *+A14[A3],      A1:A0               ;Load x1real
 ||     LDDW        .D2     *+B14[B3],      B1:B0               ;Load y1real
 ||     SUB         .L2     B2,             1,          B2      ;2*c2-1

        ADD         .L1     A3,             1,          A3      ;Increment the x Index
 ||     ADD         .L2     B3,             1,          B3      ;Increment the y Index

        LDDW        .D1     *+A14[A3],      A5:A4               ;Load x1Imag
 ||     LDDW        .D2     *+B14[B3],      B5:B4               ;Load y1Imag

        ADD         .L1     A3,             1,          A3      ;Increment the x Index
 ||     ADD         .L2     B3,             B2,         B3      ;Increment the y Index

        NOP         1

        MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;P11=x1real*y1real

        NOP         1

        MPYDP       .M2X    B5:B4,          A1:A0,      B7:B6   ;P12=x1real*y1Imag

        LDDW        .D1     *+A14[A3],      A1:A0               ;Load x2real
 ||     LDDW        .D2     *+B14[B3],      B1:B0               ;Load y2real

        MPYDP       .M1X    A5:A4,          B1:B0,      A9:A8   ;P13=x1Imag*y1real
 ||     ADD         .L1     A3,             1,          A3      ;Increment the x Index
 ||     ADD         .L2     B3,             1,          B3      ;Increment the y Index

        LDDW        .D1     *+A14[A3],      A5:A4               ;Load x1Imag
 ||     LDDW        .D2     *+B14[B3],      B5:B4               ;Load y1Imag

        MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;P14=x1Imag*y1Imag

        ADD         .L1     A3,             1,          A3      ;Increment the x Index
 ||     ADD         .L2     B3,             B2,         B3      ;Increment the y Index
 ||     SUB         .S1     A2,             2,          A2      ;Decrement k Loop Counter

************************************************************************************
******************************BEGIN OF KERNEL***************************************
************************************************************************************
ijkloop:

        MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;P21=x2real*y2real

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S11+=P11

        MPYDP       .M2X    B5:B4,          A1:A0,      B7:B6   ;P22=x2real*y2Imag

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S12+=P12
 ||[A2] LDDW        .D1     *+A14[A3],      A1:A0               ;Load x1real
 ||[A2] LDDW        .D2     *+B14[B3],      B1:B0               ;Load y1real

        MPYDP       .M1X    A5:A4,          B1:B0,      A9:A8   ;P23=x2Imag*y2real
 ||     ADD         .S1     A3,             1,          A3      ;Increment the x Index
 ||     ADD         .S2     B3,             1,          B3      ;Increment the y Index
 ||[!A2]LDW         .D2     *+B15[03],      B1                  ;o-load jloop Counter

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S13+=P13
 ||[A2] LDDW        .D1     *+A14[A3],      A5:A4               ;Load x1Imag
 ||[A2] LDDW        .D2     *+B14[B3],      B5:B4               ;Load y1Imag

        MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;P24=x2Imag*y2Imag
 ||     ADD         .S1     A3,             1,          A3      ;Increment the x Index
 ||     ADD         .S2     B3,             B2,         B3      ;Increment the y Index
 ||[!A2]LDW         .D2     *+B15[01],      B3                  ;o-load Y Index

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S14+=P14

   [A2] MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;P11=x1real*y1real

        ADDDP       .L1     A11:A10,        A7:A6,      A11:A10 ;S1+=P21
 ||[!A2]SUB         .S2     B1,             1,          B1      ;o-Decrement jloop Counter
 ||[!A2]LDW         .D2     *+B15[06],      A0                  ;o-load C1 for index

   [A2] B           .S1     ijkloop
 ||[A2] MPYDP       .M2X    B5:B4,          A1:A0,      B7:B6   ;P12=x1real*y1Imag
 ||[!A2]LDW         .D2     *+B15[02],      A3                  ;o-load X index

        ADDDP       .L2     B11:B10,        B7:B6,      B11:B10 ;S12+=P22
 ||[A2] LDDW        .D1     *+A14[A3],      A1:A0               ;Load x2real
 ||[A2] LDDW        .D2     *+B14[B3],      B1:B0               ;Load y2real
 ||[!A2]ADD         .S2     B3,             2,          B3      ;o-Set Y index for Next Iteration

   [A2] MPYDP       .M1X    A5:A4,          B1:B0,      A9:A8   ;P13=x1Imag*y1real
 ||[A2] ADD         .S1     A3,             1,          A3      ;Increment the x Index
 ||[A2] ADD         .S2     B3,             1,          B3      ;Increment the y Index
 ||[!A2]LDW         .D2     *+B15[06],      A2                  ;o-load C1 kloop Counter

        ADDDP       .L1     A13:A12,        A9:A8,      A13:A12 ;S13+=P23
 ||[A2] LDDW        .D1     *+A14[A3],      A5:A4               ;Load x2Imag
 ||[A2] LDDW        .D2     *+B14[B3],      B5:B4               ;Load y2Imag

   [A2] MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;P14=x1Imag*y1Imag
 ||[!A2]ADD         .S1     A0,             A0,         A0      ;o-2*C1

        ADDDP       .L2     B13:B12,        B9:B8,      B13:B12 ;S14+=P24
 ||[A2] ADD         .D1     A3,             1,          A3      ;Increment the x Index
 ||[A2] ADD         .S2     B3,             B2,         B3      ;Increment the y Index
 ||[A2] SUB         .S1     A2,             2,          A2      ;Decrement k Loop Counter
*****************************************************************************************
*********************************END OF KERNEL*******************************************
*****************************************************************************************
***********i, j loop Instuctions + outerlloop Ins + Prolog for next iteration************
*****************************************************************************************

   [!B1]LDW         .D2     *+B15[04],      A1                  ;(iloop)Load i loop Counter
 ||[!B1]ZERO        .S2     B3                                  ;(iloop)reset y Index
 ||[!B1]ADD         .S1     A3,             A0,         A3      ;(iloop)Update X Index

   [!B1]LDW         .D2     *+B15[05],      B8                  ;(iloop)Set j loop Counter

        STW         .D2     B3,             *+B15[01]           ;o-Store Y Index

        ADDDP       .L1X    A13:A12,        B11:B10,    A13:A12 ;e-rImag=S12+S13
 ||[B1] MV          .L2     B1,             B2
 ||     STW         .D2     A3,             *+B15[02]           ;o-Store X Index
 ||     MV          .S2     B2,             B9                  ;o-Temp kloop Counter

   [B1] STW         .D2     B1,             *+B15[03]           ;o-Store jloop Counter

        SUBDP       .L2X    A11:A10,        B13:B12,    B13:B12 ;e-rreal=S11-S14
 ||[!B1]SUB         .S1     A1,             1,          A1      ;(iloop)Decrement iloop Counter
 ||     LDDW        .D1     *+A14[A3],      A1:A0               ;p-Load x1real
 ||     LDDW        .D2     *+B14[B3],      B1:B0               ;p-Load y1real


   [!B1]STW         .D2     B8,             *+B15[03]           ;(iloop)Store jloop Counter
 ||     ADD         .S1     A3,             1,          A3      ;p-Increment the x Index
 ||     ADD         .S2     B3,             1,          B3      ;p-Increment the y Index

   [!B1]MV          .S2     A1,             B2                  ;(iloop)
 ||     LDDW        .D1     *+A14[A3],      A5:A4               ;p-Load x1Imag
 ||     LDDW        .D2     *+B14[B3],      B5:B4               ;p-Load y1Imag

        ADD         .S1     A3,             1,          A3      ;p-Increment the x Index
 ||     ADD         .S2     B3,             B9,         B3      ;p-Increment the y Index
 ||[!B1]STW         .D2     A1,             *+B15[04]           ;(iloop)Store i loop Counter

        STW         .D1     A12,            *++A15[02]          ;o-store r imag

        STW         .D1     A13,            *++A15[01]          ;o-store r imag
 ||     MPYDP       .M1X    A1:A0,          B1:B0,      A7:A6   ;p-P11=x1real*y1real

        STW         .D1     B12,            *--A15[03]          ;o-store r real

   [B2] B           .S1     ijkloop
 ||     STW         .D1     B13,            *++A15[01]          ;o-store r real
 ||     MPYDP       .M2X    B5:B4,          A1:A0,      B7:B6   ;p-P12=x1real*y1Imag

        ADD         .S1     A15,            12,         A15     ;o-Set *r for next store
 ||     LDDW        .D1     *+A14[A3],      A1:A0               ;p-Load x2real
 ||     LDDW        .D2     *+B14[B3],      B1:B0               ;p-Load y2real

        MPYDP       .M1X    A5:A4,          B1:B0,      A9:A8   ;p-P13=x1Imag*y1real
 ||     ADD         .S1     A3,             1,          A3      ;p-Increment the x Index
 ||     ADD         .S2     B3,             1,          B3      ;p-Increment the y Index

        LDDW        .D1     *+A14[A3],      A5:A4               ;p-Load x1Imag
 ||     LDDW        .D2     *+B14[B3],      B5:B4               ;p-Load y1Imag
 ||     MV          .L2     B9,             B2                  ;o-k loop Counter
 ||     ZERO        .L1     A13
 ||     ZERO        .S1     A12
 ||     ZERO        .S2     B12

        MPYDP       .M2X    B5:B4,          A5:A4,      B9:B8   ;p-P14=x1Imag*y1Imag
 ||     ZERO        .L1     A11
 ||     ZERO        .L2     B11
 ||     ZERO        .S1     A10
 ||     ZERO        .S2     B10

        ADD         .L1     A3,             1,          A3      ;p-Increment the x Index
 ||     ADD         .L2     B3,             B2,         B3      ;p-Increment the y Index
 ||     SUB         .S1     A2,             2,          A2      ;p-Decrement k Loop Counter
 ||     ZERO        .S2     B13
***************************************************************************************
*********************************i,j loop Branch Occurs here***************************
***************************************************************************************

        ADDAW       .D2     B15,            7,          B15     ;Restoring Address of B10

        SUB         .L1     B15,            04,         A15     ;Twin stack Pointer
 ||     LDW         .D2     *+B15[11],      B7                  ;Restore  CSR

        LDW         .D2     *++B15[02],     B10                 ;Poping B10 and A10 outof Stack
 ||     LDW         .D1     *++A15[02],     A10
        LDW         .D2     *+B15[11],      B3                  ;Restoring Return address
        LDW         .D2     *++B15[02],     B11                 ;Poping B11 and A11 outof Stack
 ||     LDW         .D1     *++A15[02],     A11
        LDW         .D2     *++B15[02],     B12                 ;Poping B12 and A12 outof Stack
 ||     LDW         .D1     *++A15[02],     A12
        LDW         .D2     *++B15[02],     B13                 ;Poping B13 and A13 outof Stack
 ||     LDW         .D1     *++A15[02],     A13
 ||     MVC         .S2     B7,             CSR                 ;Enable Interrupts
        LDW         .D2     *++B15[02],     B14                 ;Poping B14 and A14 outof Stack
 ||     LDW         .D1     *++A15[02],     A14
        B           B3;
        LDW         .D2     *++B15[02],     A15                 ;Poping A15 out of Stack
        ADDAW       .D2     B15,            01,         B15     ;Clearing the Stack
        NOP         3;



                .end

* ======================================================================== *
*  End of file: DSPF_dp_mat_mul_cplx.asm                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_blk_mov/1117057398  1268  0     0       7004      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_blk_move -- DSPF_dp_blk_move                                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_blk_move(                                                  *
*                         const double *   x,                               *
*                         double *restrict r,                               *
*                         int nx                                            *
*                        )                                                  *
*                                                                           *
*             x[nx]: Pointer to source data to be moved.                    *
*             r[nx]: Pointer to destination array.                          *
*             nx:    Number of floats to move.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*    This routine moves nx doubles from one memory location                 *
*        pointed to by x to another pointed to by r.                        *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*        1. nx is greater than 0.                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*        void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     *
*        {                                                                  *
*            int i;                                                         *
*            for (i = 0 ; i < nx; i++)                                      *
*                r[i] = x[i];                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. Endian: This implementation is Little-Endian.                    *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*                            interruptible.                                 *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2*nx+ 8                                                             *
*       For nx=64, cycles=136.                                              *
*       For nx=25, cycles=58.                                               *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       96 bytes                                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_blk_move
_DSPF_dp_blk_move:

        LDDW    .D1     *A4++[01],  A7:A6
 ||     MV      .L1     A6,         A2              ;Set the loop Counter
 ||     B       .S2     loop
 ||     ADD     .L2     B4,         4,      B5

        MVK     .S2     1,          B1              ;Store Counter
 ||[A2] SUB     .S1     A2,         1,      A2      ;Decrement the loop Counter
 ||     MV      .L1     B4,         A3
 ||     ZERO    .L2     B0

        LDDW    .D1     *A4++[01],  A7:A6
 ||[A2] B       .S2     loop
 ||     MVK     .S1     1,          A1

   [A2] SUB     .S1     A2,         1,      A2      ;Decrement the loop Counter
 ||[!A2]MVK     .S2     1,          B0
loop:

        LDDW    .D1     *A4++[01],  A7:A6
 ||[A2] B       .S1     loop
 ||[!B1]STW     .D2     B7,         *B5++[02]
 ||[B1] SUB     .L2     B1,         1,          B1
 ||[B0]B        .S2     B3

   [A1] STW     .D1     A6,         *A3++[02]
 ||[A2] SUB     .L1     A2,         1,      A2      ;Decrement the loop Counter
 ||     MV      .L2     A7,         B7
 ||[!A2]MVK     .S2     1,          B0
 ||[B0] MVK     .S1     0,          A1

        NOP     2
            .end

* ======================================================================== *
*  End of file: DSPF_dp_blk_move.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_lms.h/  1117057336  0     0     0       11198     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_lms -- Single Precision floating point LMS algorithm             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_lms                                                        */
/*      (                                                                   */
/*          float *x,                                                       */
/*          float *h,                                                       */
/*          float *desired,                                                 */
/*          float *r,                                                       */
/*          float adaptrate,                                                */
/*          float error,                                                    */
/*          int nh,                                                         */
/*          int nr                                                          */
/*      );                                                                  */
/*                                                                          */
/*      x        :  Pointer to input samples                                */
/*      h        :  Pointer to the coefficient array                        */
/*      desired  :  Pointer to the desired output array                     */
/*      r        :  Pointer to filtered output array                        */
/*      adaptrate:  Adaptation rate                                         */
/*      error    :  Initial error                                           */
/*      nh       :  Number of coefficients                                  */
/*      nr       :  Number of output samples                                */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       */
/*      input signal and a desired input signal, the filter produces an     */
/*      output signal, the final coefficient values, and returns the final  */
/*      output error signal.                                                */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled six times to allow update of          */
/*         six coefficients in the kernel.                                  */
/*      2. The outer loop has been unrolled twice to enable use of LDDW     */
/*         for loading the input coefficients.                              */
/*      3. LDDW instruction is used to load in the coefficients.            */
/*      4. Register sharing is used to make optimal use of available        */
/*         registers.                                                       */
/*      5. The outer loop instructions are scheduled in parallel with       */
/*         epilog and prolog wherever possible.                             */
/*      6. The 'error' term needs to be computed in the outer loop          */
/*         before a new iteration of the inner loop can start. As a         */
/*         result the prolog cannot be placed in parallel with epilog       */
/*         (after the loop kernel).                                         */
/*      7. Pushing and popping variables from the stack does not            */
/*         really add any overhead except increase stack size. This         */
/*         is because the pops and pushes are done in the delay slots       */
/*         of the outer loop instructions.                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The inner loop counter must be a multiple of 6 and >=6.          */
/*      2. Little endianness is assumed.                                    */
/*      3. Extraneous loads are allowed in the program.                     */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions      */
/*      may apply.                                                          */
/*                                                                          */
/*      float DSPF_sp_lms                                                        */
/*      (                                                                   */
/*          float *x,                                                       */
/*          float *h,                                                       */
/*          float *desired,                                                 */
/*          float *r,                                                       */
/*          float adaptrate,                                                */
/*          float error,                                                    */
/*          int nh,                                                         */
/*          int nr                                                          */
/*      )                                                                   */
/*      {                                                                   */
/*          int i,j;                                                        */
/*                                                                          */
/*          float sum, temp, ae;                                            */
/*          temp = 0.0f;                                                    */
/*                                                                          */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              sum = 0.0f;                                                 */
/*              ae = adaptrate * error;                                     */
/*                                                                          */
/*              for (j = 0; j < nh; j++)                                    */
/*              {                                                           */
/*                  h[j] = h[j] + (ae * temp);                              */
/*                  sum += h[j] * x[i+j];                                   */
/*                  temp = x[i + j];                                        */
/*              }                                                           */
/*                                                                          */
/*              r[i] = sum;                                                 */
/*              error = desired[i] - sum;                                   */
/*              temp = x[i];                                                */
/*          }                                                               */
/*          // return the final error //                                    */
/*          return error;                                                   */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*      (nh + 35) nr + 21                                                   */
/*      eg. for nh = 36 and nr = 64                                         */
/*      cycles = 4565                                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      1376 bytes                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_LMS_H_
#define DSPF_SP_LMS_H_ 1

float DSPF_sp_lms
(
    float *x,
    float *h,
    float *desired,
    float *r,
    float adaptrate,
    float error,
    int nh,
    int nr
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_lms.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_lms.h67/1117057336  0     0     0       11188     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_lms -- Single Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       );                                                                  *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       *
*       input signal and a desired input signal, the filter produces an     *
*       output signal, the final coefficient values, and returns the final  *
*       output error signal.                                                *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled six times to allow update of          *
*          six coefficients in the kernel.                                  *
*       2. The outer loop has been unrolled twice to enable use of LDDW     *
*          for loading the input coefficients.                              *
*       3. LDDW instruction is used to load in the coefficients.            *
*       4. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*       5. The outer loop instructions are scheduled in parallel with       *
*          epilog and prolog wherever possible.                             *
*       6. The 'error' term needs to be computed in the outer loop          *
*          before a new iteration of the inner loop can start. As a         *
*          result the prolog cannot be placed in parallel with epilog       *
*          (after the loop kernel).                                         *
*       7. Pushing and popping variables from the stack does not            *
*          really add any overhead except increase stack size. This         *
*          is because the pops and pushes are done in the delay slots       *
*          of the outer loop instructions.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The inner loop counter must be a multiple of 6 and >=6.          *
*       2. Little endianness is assumed.                                    *
*       3. Extraneous loads are allowed in the program.                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions      *
*       may apply.                                                          *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i,j;                                                        *
*                                                                           *
*           float sum, temp, ae;                                            *
*           temp = 0.0f;                                                    *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0.0f;                                                 *
*               ae = adaptrate * error;                                     *
*                                                                           *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   h[j] = h[j] + (ae * temp);                              *
*                   sum += h[j] * x[i+j];                                   *
*                   temp = x[i + j];                                        *
*               }                                                           *
*                                                                           *
*               r[i] = sum;                                                 *
*               error = desired[i] - sum;                                   *
*               temp = x[i];                                                *
*           }                                                               *
*           /* return the final error */                                    *
*           return error;                                                   *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       (nh + 35) nr + 21                                                   *
*       eg. for nh = 36 and nr = 64                                         *
*       cycles = 4565                                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1376 bytes                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_lms

*  ======================================================================== *
*   End of file:  DSPF_sp_lms.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_autocor/1117057337  1290  0     0       4797      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_autocor -- Single Precision autocorrelation                      */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_autocor                                                    */
/*                     (                                                    */
/*                         float       *  restrict r,                       */
/*                         const short *  restrict x,                       */
/*                         int            nx,                               */
/*                         int            nr                                */
/*                     )                                                    */
/*            r  = pointer to output array of autocorrelation of length nr  */
/*            x  = pointer to input array of length nx+nr. Input data must  */
/*                 be padded with nr consecutive zeros at the beginning.    */
/*            nx = Length of Autocorrelation vector.                        */
/*            nr = Length of lags.                                          */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This routine performs the autocorrelation of the input array inp.  */
/*       It is assumed that the length of the input array, x, is a multiple */
/*       of 2 and the length of the output array, r, is a multiple of 4.    */
/*       The assembly routine computes 4 output samples at a time.          */
/*                                                                          */
/*       It is assumed that input vector x is padded with nr no of zeros in */
/*       the beginning.                                                     */
/*                                                                          */
/*       x is to be aligned on a double word boundary.                      */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       The inner loop is unrolled twice and the outer loop is unrolled    */
/*       four times.                                                        */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nx is a multiple of 2 and greater than or equal to 4.           */
/*       2. nr is a multiple of 4 and greater than or equal to 4.           */
/*       3. nx is greater than or equal to nr                               */
/*       4. x  is double word aligned.                                      */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_AUTOCOR_ASM_H_
#define DSPF_SP_AUTOCOR_ASM_H_ 1

void DSPF_sp_autocor(float     *restrict r, float *restrict x, int nx, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_autocor_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_autocor/1117057337  1309  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_autocor -- Single Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_autocor

* ======================================================================== *
*  End of file: DSPF_sp_autocor_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_bitrev_/1117057338  1330  0     0       7052      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_bitrev_cplx -- Bit reversal for Single Precision Complex         */
/*      numbers                                                             */
/*                                                                          */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*     This routine is C Callable and can be called as:                     */
/*                                                                          */
/*     void bitrev_cplx(double *x, short *index, int nx);                   */
/*                                                                          */
/*     x[nx]  : Complex input array to be bit-reversed.                     */
/*              Contains 2*nx floats                                        */
/*     index[]: Array of size ~sqrt(nx) created by the routine              */
/*              bitrev_index to allow the fast implementation of the        */
/*              bit-reversal.                                               */
/*     nx     : Number of elements in array x[]. Must be power of 2.        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine performs the bit-reversal of the input array x[],       */
/*     where x[] is an integer array of length nx containing 16-bit         */
/*     complex pairs of data.  This routine requires the index array        */
/*     provided by the program below.  This index should be generated at    */
/*     compile time not by the DSP.                                         */
/*                                                                          */
/*     TI retains all rights, title and interest in this code and only      */
/*     authorizes the use of the bit-reversal code and related table        */
/*     generation code with TMS320-family DSPs manufactured by TI.          */
/*                                                                          */
/*     // ----------------------------------------------------------- //    */
/*     //  This routine calculates the index for bit reversal of      //    */
/*     //  an array of length nx.  The length of the index table is   //    */
/*     //  2^(2*ceil(k/2)) where nx = 2^k.                            //    */
/*     //                                                             //    */
/*     //  In other words, the length of the index table is:          //    */
/*     //      - for even power of radix: sqrt(nx)                    //    */
/*     //      - for odd  power of radix: sqrt(2*nx)                  //    */
/*     // ----------------------------------------------------------- //    */
/*     void bitrev_index(short *index, int nx)                              */
/*     {                                                                    */
/*         int   i, j, k, radix = 2;                                        */
/*         short nbits, nbot, ntop, ndiff, n2, raddiv2;                     */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*             i = i >> 1;                                                  */
/*             nbits++;                                                     */
/*         }                                                                */
/*                                                                          */
/*         raddiv2 = radix >> 1;                                            */
/*         nbot    = nbits >> raddiv2;                                      */
/*         nbot    = nbot << raddiv2 - 1;                                   */
/*         ndiff   = nbits & raddiv2;                                       */
/*         ntop    = nbot + ndiff;                                          */
/*         n2      = 1 << ntop;                                             */
/*                                                                          */
/*         index[0] = 0;                                                    */
/*         for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  */
/*         {                                                                */
/*             index[i] = j - 1;                                            */
/*                                                                          */
/*             for (k = n2/radix; k*(radix-1) < j; k /= radix)              */
/*                 j -= k*(radix-1);                                        */
/*                                                                          */
/*             j += k;                                                      */
/*         }                                                                */
/*         index[n2 - 1] = n2 - 1;                                          */
/*     }                                                                    */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_BITREV_CPLX_ASM_H_
#define DSPF_SP_BITREV_CPLX_ASM_H_ 1

void DSPF_sp_bitrev_cplx(double     * x, short * index, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_bitrev_cplx_h.asm                                       */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_bitrev_/1117057337  1353  0     0       1766      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_bitrev_cplx -- Bit reversal for Single Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_bitrev_cplx

* ======================================================================== *
*  End of file: DSPF_sp_bitrev_cplx_h.asm                                       *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr4_/1117057339  1378  0     0       7440      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      */
/*                                                                          */
/*  USAGE                                                                 */
/*                                                                          */
/*  This routine is C Callable and can be called as:                        */
/*                                                                        */
/*  void cfftr4_dif(float* x, float* w, short n)                          */
/*                                                                          */
/*  x is pointer to an array holding the input and output floating        */
/*     point array which contains 'n' complex points                      */
/*  w is pointer to an array holding the coefficient floating point       */
/*     array which contains 3*n/4 complex numbers                         */
/*  n is the number of complex points in x                                */
/*                                                                          */
/*  If the routine is not to be used as a C callable function,            */
/*  then you need to initialize values for all of the parameters          */
/*  passed to the function since these are assumed to be in               */
/*  registers as defined by the calling convention of the                 */
/*  compiler, (refer to the TMS320C6x Optimizing C Compiler               */
/*  User's Guide).                                                        */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                            */
/*                                                                          */
/*  This routine implements the DIF (decimation in frequency)             */
/*  complex radix 4 FFT with digit-reversed output and normal             */
/*  order input.  The number of points, 'n', must be a power              */
/*  of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                 */
/*  in-place routine in the sense that the output is written              */
/*  over the input.  It is not an in-place routine in the                 */
/*  sense that the input is in normal order and the output is             */
/*  in digit-reversed order.                                              */
/*                                                                          */
/*  There must be n complex points (2*n values), and 3*n/4 complex        */
/*  coefficients (3*n/2 values).                                          */
/*                                                                          */
/*  Each real and imaginary input value is interleaved in the             */
/*  'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers           */
/*  are in normal order.  Each real and imaginary output value            */
/*  is interleaved in the 'x' array and the complex numbers are           */
/*  in digit-reversed  order {rx0, ix0, ...}.  The real and               */
/*  imaginary values of the coefficients are interleaved in the           */
/*  'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers         */
/*  are in normal order.                                                  */
/*                                                                          */
/*  Note that the imaginary coefficients are negated                      */
/*  {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than         */
/*  {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                     */
/*  where d = 2*PI/n.  The value of w(n,k) is usually written             */
/*  w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).              */
/*                                                                          */
/*  The routine can be used to implement an inverse FFT by                */
/*  performing the complex conjugate on the input complex numbers         */
/*  (negating the imaginary value), and dividing the result by n.         */
/*  Another method to use the FFT to perform an inverse FFT, is to        */
/*  swap the real and imaginary values of the input and the result,       */
/*  and divide the result by n.  In either case, the input is still       */
/*  in normal order and the output is still in digit-reversed order.      */
/*                                                                          */
/*  Note that you can not make the radix 4 FFT into an inverse            */
/*  FFT by using the complex conjugate of the coefficients as             */
/*  you can do with the complex radix 2 FFT.                              */
/*                                                                          */
/*  If you label the input locations from 0 to (n-1) (normal order),      */
/*  the digit-reversed locations can be calculated by reversing the       */
/*  order of the bit pairs of the labels.  For example, for a 1024        */
/*  point FFT, the digit reversed location for                            */
/*  617d = 1001101001b = 10 01 10 10 01  is                               */
/*  422d = 0110100110b = 01 10 10 01 10  and visa versa.                  */
/*                                                                          */
/*  TI plans to provide an inverse complex radix 4 FFT with digit-        */
/*  reversed input and normal order output.  With these 2 routines,       */
/*  the digit-reversed output of the FFT can be the input to the          */
/*  inverse FFT without performing digit-reversing on the data.           */
/*                                                                          */
/*  TI also plans to provide a complex digit reverse routine.             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_CFFTR4_DIF_ASM_H_
#define DSPF_SP_CFFTR4_DIF_ASM_H_ 1

void DSPF_sp_cfftr4_dif(float     * x, float * w, short n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_cfftr4_dif_h.asm                                        */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_cfftr4_/1117057339  1400  0     0       1692      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_cfftr4_dif

* ======================================================================== *
*  End of file: DSPF_sp_cfftr4_dif_h.asm                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr2_/1117057340  1424  0     0       7763      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_cfftr2_dit -- Single Precision floating point radix-2 FFT with   */
/*      complex input                                                       */
/*                                                                          */
/*  USAGE                                                                   */
/*          This routine is C-callable and can be called as:                */
/*                                                                          */
/*          void DSPF_sp_cfftr2_dit(float * x, float * w, short n);              */
/*                                                                          */
/*          x : Pointer to complex data input                               */
/*          w : pointer to complex twiddle factor in Bit reverse order      */
/*          N : length of FFT in complex samples, power of 2 such that N>=3 */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine performs the Decimation-in-Time (DIT) Radix-2 FFT      */
/*      of the input array x.                                               */
/*      x has N complex floating point numbers arranged as successive       */
/*      real and imaginary number pairs. Input array x contains N           */
/*      complex points (N*2 elements). The coefficients for the             */
/*      FFT are passed to the function in array w which contains            */
/*      N/2 complex numbers (N elements) as successive real and             */
/*      imaginary number pairs.                                             */
/*      The FFT Coefficients w are in N/2 bit-reversed order                */
/*      The elements of input array x are in normal order                   */
/*      The assembly routine performs 4 output samples (2 real and 2        */
/*      imaginary) for a pass through inner loop.                           */
/*                                                                          */
/*      Note that (bit-reversed) coefficients for higher order FFT (1024    */
/*      point) can be used unchanged as coefficients for a lower order      */
/*      FFT (512, 256, 128 ... ,2)                                          */
/*                                                                          */
/*      The routine can be used to implement Inverse-FFT by any ONE of      */
/*      the following methods:                                              */
/*                                                                          */
/*      1.Inputs (x) are replaced by their Complex-conjugate values         */
/*        Output values are divided by N                                    */
/*      2.FFT Coefficients (w) are replaced by their Complex-conjugates     */
/*        Output values are divided by N                                    */
/*      3.Swap Real and Imaginary values of input                           */
/*      4.Swap Real and Imaginary values of output                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_cfftr2_dit(float* x, float* w, short n)                     */
/*      {                                                                   */
/*         short n2, ie, ia, i, j, k, m;                                    */
/*         float rtemp, itemp, c, s;                                        */
/*                                                                          */
/*         n2 = n;                                                          */
/*         ie = 1;                                                          */
/*                                                                          */
/*         for(k=n; k > 1; k >>= 1)                                         */
/*         {                                                                */
/*            n2 >>= 1;                                                     */
/*            ia = 0;                                                       */
/*            for(j=0; j < ie; j++)                                         */
/*            {                                                             */
/*               c = w[2*j];                                                */
/*               s = w[2*j+1];                                              */
/*               for(i=0; i < n2; i++)                                      */
/*               {                                                          */
/*                  m = ia + n2;                                            */
/*                  rtemp     = c * x[2*m]   + s * x[2*m+1];                */
/*                  itemp     = c * x[2*m+1] - s * x[2*m];                  */
/*                  x[2*m]    = x[2*ia]   - rtemp;                          */
/*                  x[2*m+1]  = x[2*ia+1] - itemp;                          */
/*                  x[2*ia]   = x[2*ia]   + rtemp;                          */
/*                  x[2*ia+1] = x[2*ia+1] + itemp;                          */
/*                  ia++;                                                   */
/*               }                                                          */
/*               ia += n2;                                                  */
/*            }                                                             */
/*            ie <<= 1;                                                     */
/*         }                                                                */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_CFFTR2_DIT_ASM_H_
#define DSPF_SP_CFFTR2_DIT_ASM_H_ 1

void DSPF_sp_cfftr2_dit(float     * x, float * w, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_cfftr2_dit_h.asm                                        */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_cfftr2_/1117057339  1446  0     0       1765      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr2_dit -- Single Precision floating point radix-2 FFT with   *
*      complex input                                                       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_cfftr2_dit

* ======================================================================== *
*  End of file: DSPF_sp_cfftr2_dit_h.asm                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fftSPxS/1117057341  1470  0     0       37257     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          */
/*     forwards FFT with complex input                                     */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSPF_sp_fftSPxSP                                                    */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*                                                                          */
/*      N      :  Length of fft in complex samples, power of 2 such that    */
/*                   N >=8 and N<= 16385.                                   */
/*      ptr_x  :  Pointer to complex data input.                            */
/*      ptr_w  :  Pointer to complex twiddle factor (see below).            */
/*      ptr_y  :  Pointer to complex output data.                           */
/*      brev   :  Pointer to bit reverse table containing 64 entries.       */
/*      n_min  :  Smallest fft butterfly used in computation used for       */
/*                decomposing fft into subffts, see notes.                  */
/*      offset :  Index in complex samples of sub-fft from start of main    */
/*                fft.                                                      */
/*      n_max  :  size of main fft in complex samples.                      */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The benchmark performs a mixed radix forwards fft using a special   */
/*      sequece of coefficients generated in the following way:             */
/*                                                                          */
/*      // generate vector of twiddle factors for optimized algorithm //    */
/*      void tw_gen(float * w, int N)                                       */
/*      {                                                                   */
/*          int j, k;                                                       */
/*          double x_t, y_t, theta1, theta2, theta3;                        */
/*          const double PI = 3.141592654;                                  */
/*                                                                          */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                             */
/*          {                                                               */
/*              for (i=0; i < N>>2; i+=j)                                   */
/*              {                                                           */
/*                  theta1 = 2*PI*i/N;                                      */
/*                  x_t = cos(theta1);                                      */
/*                  y_t = sin(theta1);                                      */
/*                  w[k]   =  (float)x_t;                                   */
/*                  w[k+1] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta2 = 4*PI*i/N;                                      */
/*                  x_t = cos(theta2);                                      */
/*                  y_t = sin(theta2);                                      */
/*                  w[k+2] =  (float)x_t;                                   */
/*                  w[k+3] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta3 = 6*PI*i/N;                                      */
/*                  x_t = cos(theta3);                                      */
/*                  y_t = sin(theta3);                                      */
/*                  w[k+4] =  (float)x_t;                                   */
/*                  w[k+5] =  (float)y_t;                                   */
/*                  k+=6;                                                   */
/*               }                                                          */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      This redundant set of twiddle factors is size 2*N float samples.    */
/*      The function is accurate to about 130dB of signal to noise ratio    */
/*      to the DFT function below:                                          */
/*                                                                          */
/*      void dft(int N, float x[], float y[])                               */
/*      {                                                                   */
/*          int k,i, index;                                                 */
/*          const float PI = 3.14159654;                                    */
/*          float * p_x;                                                    */
/*          float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      */
/*                                                                          */
/*          for(k = 0; k<N; k++)                                            */
/*          {                                                               */
/*              p_x = x;                                                    */
/*              fy_0 = 0;                                                   */
/*              fy_1 = 0;                                                   */
/*              for(i=0; i<N; i++)                                          */
/*              {                                                           */
/*                  fx_0 = p_x[0];                                          */
/*                  fx_1 = p_x[1];                                          */
/*                  p_x += 2;                                               */
/*                  index = (i*k) % N;                                      */
/*                  arg = 2*PI*index/N;                                     */
/*                  co = cos(arg);                                          */
/*                  si = -sin(arg);                                         */
/*                  fy_0 += ((fx_0 * co) - (fx_1 * si));                    */
/*                  fy_1 += ((fx_1 * co) + (fx_0 * si));                    */
/*              }                                                           */
/*              y[2*k] = fy_0;                                              */
/*              y[2*k+1] = fy_1;                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      The function takes the table and input data and calculates the fft  */
/*      producing the frequency domain data in the Y array.                 */
/*      As the fft allows every input point to effect every output point    */
/*      in a cache based system such as the c6711, this causes cache        */
/*      thrashing. This is mitigated by allowing the main fft of size N to  */
/*      be divided into several steps, allowing as much data reuse as       */
/*      possible.                                                           */
/*                                                                          */
/*      For example the following function:                                 */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           */
/*                                                                          */
/*      Notice how the 1st fft function is called on the entire 1K data     */
/*      set it covers the 1st pass of the fft until the butterfly size is   */
/*      256. The following 4 ffts do 256 pt ffts 25% of the size. These     */
/*      continue down to the end when the buttefly is of size 4. They use   */
/*      an index the main twiddle factor array of 0.75*2*N. This is         */
/*      because the twiddle factor array is composed of successively        */
/*      decimated versions of the main array.                               */
/*                                                                          */
/*      N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*      decompose the fft the following would be needed :                   */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            */
/*                                                                          */
/*      The twiddle factor array is composed of log4(N) sets of twiddle     */
/*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*      array for each stage of the fft is calculated by summing these      */
/*      indices up appropriately.                                           */
/*                                                                          */
/*      For multiple ffts they can share the same table by calling the      */
/*      small ffts from further down in the twiddle factor array. In the    */
/*      smae way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      Thus, the above decomposition can be summarized for a general N,    */
/*      radix "rad" as follows:                                             */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         */
/*                                                                          */
/*      As discussed previously, N can be either a power of 4 or 2.         */
/*      If N is a power of 4, then rad = 4, and if N is a power of 2 and    */
/*      not a power of 4, then rad = 2. "rad" is used to control how many   */
/*      stages of decomposition are performed. It is also used to           */
/*      determine whether a radix-4 or radix-2 decomposition should be      */
/*      performed at the last stage. Hence when "rad" is set to "N/4" the   */
/*      first stage of the transform alone is performed and the code        */
/*      exits. To complete the FFT, four other calls are required to        */
/*      perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        */
/*      amongst themselves does not matter and hence from a cache           */
/*      perspective, it helps to go through the remaining 4 FFTs in         */
/*      exactly the opposite order to the first. This is illustrated as     */
/*      follows:                                                            */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         */
/*                                                                          */
/*      In addition this function can be used to minimize call overhead,    */
/*      by completing the FFT with one function call invocation as shown    */
/*      below:                                                              */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. A special sequence of coeffs. used as generated above            */
/*         produces the fft. This collapses the inner 2 loops in the        */
/*         taditional Burrus and Parks implementation Fortran Code.         */
/*                                                                          */
/*      2. The revised FFT uses a redundant sequence of twiddle factors to  */
/*         allow a linear access through the data. This linear access       */
/*         enables data and instruction level parallelism.                  */
/*                                                                          */
/*      3. The data produced by the fftSPxSP fft is in normal form, the     */
/*         whole data array is written into a new output buffer.            */
/*                                                                          */
/*      4. The fftSPxSP butterfly is bit reversed, i.e. the inner 2 points  */
/*         of the butterfly are corssed over, this has the effect of        */
/*         making the data come out in bit reversed rather than fftSPxSP    */
/*         digit reversed order. This simplifies the last pass of the       */
/*         loop. A simple table is used to do the bit reversal out of       */
/*         place.                                                           */
/*                                                                          */
/*             unsigned char brev[64] =                                     */
/*             {                                                            */
/*                   0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,          */
/*                   0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,          */
/*                   0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,          */
/*                   0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,          */
/*                   0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,          */
/*                   0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,          */
/*                   0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,          */
/*                   0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f           */
/*             };                                                           */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. N must be a power of 2 and N >= 8  N <= 16384 points.            */
/*                                                                          */
/*      2. Complex time data x and twiddle facotrs w are aligned on double  */
/*         word boundares. Real values are stored in even word positions    */
/*         and imaginary values in odd positions.                           */
/*                                                                          */
/*      3. All data is in single precision floating point format. The       */
/*         complex frequency data will be returned in linear order.         */
/*                                                                          */
/*      4. This code is interupt tolerant, interupts are disabled on entry  */
/*         to each loop and reanlbed on exit out of the loop.               */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions may  */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_fftSPxSP                                                    */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      )                                                                   */
/*      {                                                                   */
/*          int  i, j, k, l1, l2, h2, predj;                                */
/*          int  tw_offset, stride, fft_jmp;                                */
/*                                                                          */
/*          float x0, x1, x2, x3,x4,x5,x6,x7;                               */
/*          float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        */
/*          float yt4, yt5, yt6, yt7;                                       */
/*          float si1,si2,si3,co1,co2,co3;                                  */
/*          float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      */
/*          float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      */
/*          float xl0_0, xl1_0, xl0_1, xl1_1;                               */
/*          float xh0_0, xh1_0, xh0_1, xh1_1;                               */
/*          float *x,*w;                                                    */
/*          int   k0, k1, j0, j1, l0, radix;                                */
/*          float * y0, * ptr_x0, * ptr_x2;                                 */
/*                                                                          */
/*          radix = n_min;                                                  */
/*                                                                          */
/*          stride = N; // N is the number of complex samples //            */
/*          tw_offset = 0;                                                  */
/*          while (stride > radix)                                          */
/*          {                                                               */
/*              j = 0;                                                      */
/*              fft_jmp = stride + (stride>>1);                             */
/*              h2 = stride>>1;                                             */
/*              l1 = stride;                                                */
/*              l2 = stride + (stride>>1);                                  */
/*              x = ptr_x;                                                  */
/*              w = ptr_w + tw_offset;                                      */
/*                                                                          */
/*              for (i = 0; i < N; i += 4)                                  */
/*              {                                                           */
/*                  co1 = w[j];                                             */
/*                  si1 = w[j+1];                                           */
/*                  co2 = w[j+2];                                           */
/*                  si2 = w[j+3];                                           */
/*                  co3 = w[j+4];                                           */
/*                  si3 = w[j+5];                                           */
/*                                                                          */
/*                  x_0    = x[0];                                          */
/*                  x_1    = x[1];                                          */
/*                  x_h2   = x[h2];                                         */
/*                  x_h2p1 = x[h2+1];                                       */
/*                  x_l1   = x[l1];                                         */
/*                  x_l1p1 = x[l1+1];                                       */
/*                  x_l2   = x[l2];                                         */
/*                  x_l2p1 = x[l2+1];                                       */
/*                                                                          */
/*                  xh0  = x_0    + x_l1;                                   */
/*                  xh1  = x_1    + x_l1p1;                                 */
/*                  xl0  = x_0    - x_l1;                                   */
/*                  xl1  = x_1    - x_l1p1;                                 */
/*                                                                          */
/*                  xh20 = x_h2   + x_l2;                                   */
/*                  xh21 = x_h2p1 + x_l2p1;                                 */
/*                  xl20 = x_h2   - x_l2;                                   */
/*                  xl21 = x_h2p1 - x_l2p1;                                 */
/*                                                                          */
/*                  ptr_x0 = x;                                             */
/*                  ptr_x0[0] = xh0 + xh20;                                 */
/*                  ptr_x0[1] = xh1 + xh21;                                 */
/*                                                                          */
/*                  ptr_x2 = ptr_x0;                                        */
/*                  x += 2;                                                 */
/*                  j += 6;                                                 */
/*                  predj = (j - fft_jmp);                                  */
/*                  if (!predj) x += fft_jmp;                               */
/*                  if (!predj) j = 0;                                      */
/*                                                                          */
/*                  xt0 = xh0 - xh20;                                       */
/*                  yt0 = xh1 - xh21;                                       */
/*                  xt1 = xl0 + xl21;                                       */
/*                  yt2 = xl1 + xl20;                                       */
/*                  xt2 = xl0 - xl21;                                       */
/*                  yt1 = xl1 - xl20;                                       */
/*                                                                          */
/*                  ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;                   */
/*                  ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;                   */
/*                  ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;                   */
/*                  ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;                   */
/*                  ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;                   */
/*                  ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;                   */
/*              }                                                           */
/*                                                                          */
/*              tw_offset += fft_jmp;                                       */
/*              stride = stride>>2;                                         */
/*          }// end while //                                                */
/*                                                                          */
/*          j = offset>>2;                                                  */
/*                                                                          */
/*          ptr_x0 = ptr_x;                                                 */
/*          y0 = ptr_y;                                                     */
/*          //l0 = _norm(n_max) - 17;    get size of fft //                 */
/*          l0=0;                                                           */
/*                                                                          */
/*          for(k=30;k>=0;k--)                                              */
/*              if( (n_max & (1 << k)) == 0 )                               */
/*                  l0++;                                                   */
/*          else                                                            */
/*              break;                                                      */
/*                                                                          */
/*          l0=l0-17;                                                       */
/*          if (radix <= 4) for (i = 0; i < N; i += 4)                      */
/*          {                                                               */
/*              // reversal computation //                                  */
/*              j0 = (j     ) & 0x3F;                                       */
/*              j1 = (j >> 6);                                              */
/*              k0 = brev[j0];                                              */
/*              k1 = brev[j1];                                              */
/*              k = (k0 << 6) +  k1;                                        */
/*              k = k >> l0;                                                */
/*              j++;        // multiple of 4 index //                       */
/*                                                                          */
/*              x0   = ptr_x0[0];  x1 = ptr_x0[1];                          */
/*              x2   = ptr_x0[2];  x3 = ptr_x0[3];                          */
/*              x4   = ptr_x0[4];  x5 = ptr_x0[5];                          */
/*              x6   = ptr_x0[6];  x7 = ptr_x0[7];                          */
/*              ptr_x0 += 8;                                                */
/*                                                                          */
/*              xh0_0  = x0 + x4;                                           */
/*              xh1_0  = x1 + x5;                                           */
/*              xh0_1  = x2 + x6;                                           */
/*              xh1_1  = x3 + x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xh0_0 = x0;                                             */
/*                  xh1_0 = x1;                                             */
/*                  xh0_1 = x2;                                             */
/*                  xh1_1 = x3;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt0  = xh0_0 + xh0_1;                                       */
/*              yt1  = xh1_0 + xh1_1;                                       */
/*              yt4  = xh0_0 - xh0_1;                                       */
/*              yt5  = xh1_0 - xh1_1;                                       */
/*                                                                          */
/*              xl0_0  = x0 - x4;                                           */
/*              xl1_0  = x1 - x5;                                           */
/*              xl0_1  = x2 - x6;                                           */
/*              xl1_1  = x3 - x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xl0_0 = x4;                                             */
/*                  xl1_0 = x5;                                             */
/*                  xl1_1 = x6;                                             */
/*                  xl0_1 = x7;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt2  = xl0_0 + xl1_1;                                       */
/*              yt3  = xl1_0 - xl0_1;                                       */
/*              yt6  = xl0_0 - xl1_1;                                       */
/*              yt7  = xl1_0 + xl0_1;                                       */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  yt7  = xl1_0 - xl0_1;                                   */
/*                  yt3  = xl1_0 + xl0_1;                                   */
/*              }                                                           */
/*                                                                          */
/*              y0[k] = yt0; y0[k+1] = yt1;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt2; y0[k+1] = yt3;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt4; y0[k+1] = yt5;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt6; y0[k+1] = yt7;                                 */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      Configuration is LITTLE ENDIAN.                                     */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   */
/*      e.g. N = 1024,  cycles = 14464                                      */
/*      e.g. N = 512,   cycles = 7296                                       */
/*      e.g. N = 256,   cycles = 2923                                       */
/*      e.g. N = 128,   cycles = 1515                                       */
/*      e.g. N = 64,    cycles = 598                                        */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      1472 bytes                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FFTSPXSP_H_
#define DSPF_SP_FFTSPXSP_H_ 1

void DSPF_sp_fftSPxSP
(
    int N,
    float * ptr_x,
    float * ptr_w,
    float * ptr_y,
    unsigned char * brev,
    int n_min,
    int offset,
    int n_max
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_fftSPxSP.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_fftSPxS/1117057341  1490  0     0       36898     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          *
*      forwards FFT with complex input                                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of fft in complex samples, power of 2 such that    *
*                    N >=8 and N<= 16385.                                   *
*       ptr_x  :  Pointer to complex data input.                            *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data.                           *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest fft butterfly used in computation used for       *
*                 decomposing fft into subffts, see notes.                  *
*       offset :  Index in complex samples of sub-fft from start of main    *
*                 fft.                                                      *
*       n_max  :  size of main fft in complex samples.                      *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards fft using a special   *
*       sequece of coefficients generated in the following way:             *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the fft  *
*       producing the frequency domain data in the Y array.                 *
*       As the fft allows every input point to effect every output point    *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main fft of size N to  *
*       be divided into several steps, allowing as much data reuse as       *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           *
*                                                                           *
*       Notice how the 1st fft function is called on the entire 1K data     *
*       set it covers the 1st pass of the fft until the butterfly size is   *
*       256. The following 4 ffts do 256 pt ffts 25% of the size. These     *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the fft the following would be needed :                   *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the fft is calculated by summing these      *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array. In the    *
*       smae way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the FFT, four other calls are required to        *
*       perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 FFTs in         *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the FFT with one function call invocation as shown    *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the fft. This collapses the inner 2 loops in the        *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised FFT uses a redundant sequence of twiddle factors to  *
*          allow a linear access through the data. This linear access       *
*          enables data and instruction level parallelism.                  *
*                                                                           *
*       3. The data produced by the fftSPxSP fft is in normal form, the     *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The fftSPxSP butterfly is bit reversed, i.e. the inner 2 points  *
*          of the butterfly are corssed over, this has the effect of        *
*          making the data come out in bit reversed rather than fftSPxSP    *
*          digit reversed order. This simplifies the last pass of the       *
*          loop. A simple table is used to do the bit reversal out of       *
*          place.                                                           *
*                                                                           *
*              unsigned char brev[64] =                                     *
*              {                                                            *
*                    0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,          *
*                    0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,          *
*                    0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,          *
*                    0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,          *
*                    0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,          *
*                    0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,          *
*                    0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,          *
*                    0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f           *
*              };                                                           *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on double  *
*          word boundares. Real values are stored in even word positions    *
*          and imaginary values in odd positions.                           *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on entry  *
*          to each loop and reanlbed on exit out of the loop.               *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       )                                                                   *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, fft_jmp;                                *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               fft_jmp = stride + (stride>>1);                             *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - fft_jmp);                                  *
*                   if (!predj) x += fft_jmp;                               *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 + xl21;                                       *
*                   yt2 = xl1 + xl20;                                       *
*                   xt2 = xl0 - xl21;                                       *
*                   yt1 = xl1 - xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += fft_jmp;                                       *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of fft */                 *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1472 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_fftSPxSP

*  ======================================================================== *
*   End of file:  DSPF_sp_fftSPxSP.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_ifftSPx/1117057343  1512  0     0       37500     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         */
/*     inverse FFT with complex input                                      */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*                                                                          */
/*      void DSPF_sp_ifftSPxSP                                                   */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*                                                                          */
/*      N      :  Length of ifft in complex samples, power of 2 such that   */
/*                N >=8 and N<= 16385.                                      */
/*      ptr_x  :  Pointer to complex data input (normal order).             */
/*      ptr_w  :  Pointer to complex twiddle factor (see below).            */
/*      ptr_y  :  Pointer to complex output data (normal order).            */
/*      brev   :  Pointer to bit reverse table containing 64 entries.       */
/*      n_min  :  Smallest ifft butterfly used in computation used for      */
/*                decomposing ifft into sub iffts, see notes.               */
/*      offset :  Index in complex samples of sub-ifft from start of main   */
/*                ifft.                                                     */
/*      n_max  :  size of main ifft in complex samples.                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The benchmark performs a mixed radix forwards ifft using a special  */
/*      sequence of coefficients generated in the following way:            */
/*                                                                          */
/*      // generate vector of twiddle factors for optimized algorithm //    */
/*      void tw_gen(float * w, int N)                                       */
/*      {                                                                   */
/*          int j, k;                                                       */
/*          double x_t, y_t, theta1, theta2, theta3;                        */
/*          const double PI = 3.141592654;                                  */
/*                                                                          */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                             */
/*          {                                                               */
/*              for (i=0; i < N>>2; i+=j)                                   */
/*              {                                                           */
/*                  theta1 = 2*PI*i/N;                                      */
/*                  x_t = cos(theta1);                                      */
/*                  y_t = sin(theta1);                                      */
/*                  w[k]   =  (float)x_t;                                   */
/*                  w[k+1] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta2 = 4*PI*i/N;                                      */
/*                  x_t = cos(theta2);                                      */
/*                  y_t = sin(theta2);                                      */
/*                  w[k+2] =  (float)x_t;                                   */
/*                  w[k+3] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta3 = 6*PI*i/N;                                      */
/*                  x_t = cos(theta3);                                      */
/*                  y_t = sin(theta3);                                      */
/*                  w[k+4] =  (float)x_t;                                   */
/*                  w[k+5] =  (float)y_t;                                   */
/*                  k+=6;                                                   */
/*               }                                                          */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      This redundant set of twiddle factors is size 2*N float samples.    */
/*      The function is accurate to about 130dB of signal to noise ratio    */
/*      to the DFT function below:                                          */
/*                                                                          */
/*      void dft(int N, float x[], float y[])                               */
/*      {                                                                   */
/*          int k,i, index;                                                 */
/*          const float PI = 3.14159654;                                    */
/*          float * p_x;                                                    */
/*          float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      */
/*                                                                          */
/*          for(k = 0; k<N; k++)                                            */
/*          {                                                               */
/*              p_x = x;                                                    */
/*              fy_0 = 0;                                                   */
/*              fy_1 = 0;                                                   */
/*              for(i=0; i<N; i++)                                          */
/*              {                                                           */
/*                  fx_0 = p_x[0];                                          */
/*                  fx_1 = p_x[1];                                          */
/*                  p_x += 2;                                               */
/*                  index = (i*k) % N;                                      */
/*                  arg = 2*PI*index/N;                                     */
/*                  co = cos(arg);                                          */
/*                  si = -sin(arg);                                         */
/*                  fy_0 += ((fx_0 * co) - (fx_1 * si));                    */
/*                  fy_1 += ((fx_1 * co) + (fx_0 * si));                    */
/*              }                                                           */
/*              y[2*k] = fy_0;                                              */
/*              y[2*k+1] = fy_1;                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      The function takes the table and input data and calculates the      */
/*      ifft producing the time domain data in the Y array. The output is   */
/*      scaled by a scaling factor of 1/N.                                  */
/*                                                                          */
/*      As the ifft allows every input point to effect every output point   */
/*      in a cache based system such as the c6711, this causes cache        */
/*      thrashing. This is mitigated by allowing the main ifft of size N    */
/*      to be divided into several steps, allowing as much data reuse as    */
/*      possible.                                                           */
/*                                                                          */
/*      For example the following function:                                 */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          */
/*                                                                          */
/*      Notice how the 1st ifft function is called on the entire 1K data    */
/*      set it covers the 1st pass of the ifft until the butterfly size is  */
/*      256. The following 4 iffts do 256 pt iffts 25% of the size. These   */
/*      continue down to the end when the buttefly is of size 4. They use   */
/*      an index the main twiddle factor array of 0.75*2*N. This is         */
/*      because the twiddle factor array is composed of successively        */
/*      decimated versions of the main array.                               */
/*                                                                          */
/*      N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*      decompose the ifft the following would be needed :                  */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           */
/*                                                                          */
/*      The twiddle factor array is composed of log4(N) sets of twiddle     */
/*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*      array for each stage of the ifft is calculated by summing these     */
/*      indices up appropriately.                                           */
/*                                                                          */
/*      For multiple iffts they can share the same table by calling the     */
/*      small iffts from further down in the twiddle factor array. In the   */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      Thus, the above decomposition can be summarized for a general N,    */
/*      radix "rad" as follows:                                             */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        */
/*                                                                          */
/*      As discussed previously, N can be either a power of 4 or 2.         */
/*      If N is a power of 4, then rad = 4, and if N is a power of 2 and    */
/*      not a power of 4, then rad = 2. "rad" is used to control how many   */
/*      stages of decomposition are performed. It is also used to           */
/*      determine whether a radix-4 or radix-2 decomposition should be      */
/*      performed at the last stage. Hence when "rad" is set to "N/4" the   */
/*      first stage of the transform alone is performed and the code        */
/*      exits. To complete the IFFT, four other calls are required to       */
/*      perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      */
/*      amongst themselves does not matter and hence from a cache           */
/*      perspective, it helps to go through the remaining 4 IFFTs in        */
/*      exactly the opposite order to the first. This is illustrated as     */
/*      follows:                                                            */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        */
/*                                                                          */
/*      In addition this function can be used to minimize call overhead,    */
/*      by completing the IFFT with one function call invocation as shown   */
/*      below:                                                              */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. A special sequence of coeffs. used as generated above            */
/*         produces the ifft. This collapses the inner 2 loops in the       */
/*         taditional Burrus and Parks implementation Fortran Code.         */
/*                                                                          */
/*      2. The revised IFFT uses a redundant sequence of twiddle            */
/*         factors to allow a linear access through the data. This linear   */
/*         access enables data and instruction level parallelism.           */
/*                                                                          */
/*      3.The data produced by the ifftSPxSP ifft is in normal form, the    */
/*         whole data array is written into a new output buffer.            */
/*                                                                          */
/*      4. The ifftSPxSP butterfly is bit reversed, i.e. the inner 2        */
/*         points of the butterfly are corssed over, this has the effect    */
/*         of making the data come out in bit reversed rather than          */
/*         ifftSPxSP digit reversed order. This simplifies the last pass    */
/*         of the loop. A simple table is used to do the bit reversal out   */
/*         of place.                                                        */
/*                                                                          */
/*      unsigned char brev[64] =                                            */
/*      {                                                                   */
/*          0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,                   */
/*          0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,                   */
/*          0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,                   */
/*          0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,                   */
/*          0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,                   */
/*          0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,                   */
/*          0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,                   */
/*          0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f                    */
/*      };                                                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      1. N must be a power of 2 and N >= 8  N <= 16384 points.            */
/*                                                                          */
/*      2. Complex time data x and twiddle facotrs w are aligned on         */
/*         double word boundares. Real values are stored in even word       */
/*         positions and imaginary values in odd positions.                 */
/*                                                                          */
/*      3. All data is in single precision floating point format. The       */
/*         complex frequency data will be returned in linear order.         */
/*                                                                          */
/*      4. This code is interupt tolerant, interupts are disabled on        */
/*         entry to each loop and reanlbed on exit out of the loop.         */
/*                                                                          */
/*      5. x must be padded with 16 words at the end.                       */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions may  */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_ifftSPxSP                                                   */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*      {                                                                   */
/*          int  i, j, k, l1, l2, h2, predj;                                */
/*          int  tw_offset, stride, ifft_jmp;                               */
/*                                                                          */
/*          float x0, x1, x2, x3,x4,x5,x6,x7;                               */
/*          float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        */
/*          float yt4, yt5, yt6, yt7;                                       */
/*          float si1,si2,si3,co1,co2,co3;                                  */
/*          float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      */
/*          float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      */
/*          float xl0_0, xl1_0, xl0_1, xl1_1;                               */
/*          float xh0_0, xh1_0, xh0_1, xh1_1;                               */
/*          float *x,*w;                                                    */
/*          int   k0, k1, j0, j1, l0, radix;                                */
/*          float * y0, * ptr_x0, * ptr_x2;                                 */
/*                                                                          */
/*          radix = n_min;                                                  */
/*                                                                          */
/*          stride = N; // N is the number of complex samples //            */
/*          tw_offset = 0;                                                  */
/*          while (stride > radix)                                          */
/*          {                                                               */
/*              j = 0;                                                      */
/*              ifft_jmp = stride + (stride>>1);                            */
/*              h2 = stride>>1;                                             */
/*              l1 = stride;                                                */
/*              l2 = stride + (stride>>1);                                  */
/*              x = ptr_x;                                                  */
/*              w = ptr_w + tw_offset;                                      */
/*                                                                          */
/*              for (i = 0; i < N; i += 4)                                  */
/*              {                                                           */
/*                  co1 = w[j];                                             */
/*                  si1 = w[j+1];                                           */
/*                  co2 = w[j+2];                                           */
/*                  si2 = w[j+3];                                           */
/*                  co3 = w[j+4];                                           */
/*                  si3 = w[j+5];                                           */
/*                                                                          */
/*                  x_0    = x[0];                                          */
/*                  x_1    = x[1];                                          */
/*                  x_h2   = x[h2];                                         */
/*                  x_h2p1 = x[h2+1];                                       */
/*                  x_l1   = x[l1];                                         */
/*                  x_l1p1 = x[l1+1];                                       */
/*                  x_l2   = x[l2];                                         */
/*                  x_l2p1 = x[l2+1];                                       */
/*                                                                          */
/*                  xh0  = x_0    + x_l1;                                   */
/*                  xh1  = x_1    + x_l1p1;                                 */
/*                  xl0  = x_0    - x_l1;                                   */
/*                  xl1  = x_1    - x_l1p1;                                 */
/*                                                                          */
/*                  xh20 = x_h2   + x_l2;                                   */
/*                  xh21 = x_h2p1 + x_l2p1;                                 */
/*                  xl20 = x_h2   - x_l2;                                   */
/*                  xl21 = x_h2p1 - x_l2p1;                                 */
/*                                                                          */
/*                  ptr_x0 = x;                                             */
/*                  ptr_x0[0] = xh0 + xh20;                                 */
/*                  ptr_x0[1] = xh1 + xh21;                                 */
/*                                                                          */
/*                  ptr_x2 = ptr_x0;                                        */
/*                  x += 2;                                                 */
/*                  j += 6;                                                 */
/*                  predj = (j - ifft_jmp);                                 */
/*                  if (!predj) x += ifft_jmp;                              */
/*                  if (!predj) j = 0;                                      */
/*                                                                          */
/*                  xt0 = xh0 - xh20;                                       */
/*                  yt0 = xh1 - xh21;                                       */
/*                  xt1 = xl0 - xl21;                                       */
/*                  yt2 = xl1 - xl20;                                       */
/*                  xt2 = xl0 + xl21;                                       */
/*                  yt1 = xl1 + xl20;                                       */
/*                                                                          */
/*                  ptr_x2[l1  ] = xt1 * co1 - yt1 * si1;                   */
/*                  ptr_x2[l1+1] = yt1 * co1 + xt1 * si1;                   */
/*                  ptr_x2[h2  ] = xt0 * co2 - yt0 * si2;                   */
/*                  ptr_x2[h2+1] = yt0 * co2 + xt0 * si2;                   */
/*                  ptr_x2[l2  ] = xt2 * co3 - yt2 * si3;                   */
/*                  ptr_x2[l2+1] = yt2 * co3 + xt2 * si3;                   */
/*              }                                                           */
/*                                                                          */
/*              tw_offset += ifft_jmp;                                      */
/*              stride = stride>>2;                                         */
/*          }// end while //                                                */
/*                                                                          */
/*          j = offset>>2;                                                  */
/*                                                                          */
/*          ptr_x0 = ptr_x;                                                 */
/*          y0 = ptr_y;                                                     */
/*          //l0 = _norm(n_max) - 17;    get size of ifft //                */
/*          l0=0;                                                           */
/*                                                                          */
/*          for(k=30;k>=0;k--)                                              */
/*              if( (n_max & (1 << k)) == 0 )                               */
/*                  l0++;                                                   */
/*          else                                                            */
/*              break;                                                      */
/*                                                                          */
/*          l0=l0-17;                                                       */
/*          if (radix <= 4) for (i = 0; i < N; i += 4)                      */
/*          {                                                               */
/*              // reversal computation //                                  */
/*              j0 = (j     ) & 0x3F;                                       */
/*              j1 = (j >> 6);                                              */
/*              k0 = brev[j0];                                              */
/*              k1 = brev[j1];                                              */
/*              k = (k0 << 6) +  k1;                                        */
/*              k = k >> l0;                                                */
/*              j++;        // multiple of 4 index //                       */
/*                                                                          */
/*              x0   = ptr_x0[0];  x1 = ptr_x0[1];                          */
/*              x2   = ptr_x0[2];  x3 = ptr_x0[3];                          */
/*              x4   = ptr_x0[4];  x5 = ptr_x0[5];                          */
/*              x6   = ptr_x0[6];  x7 = ptr_x0[7];                          */
/*              ptr_x0 += 8;                                                */
/*                                                                          */
/*              xh0_0  = x0 + x4;                                           */
/*              xh1_0  = x1 + x5;                                           */
/*              xh0_1  = x2 + x6;                                           */
/*              xh1_1  = x3 + x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xh0_0 = x0;                                             */
/*                  xh1_0 = x1;                                             */
/*                  xh0_1 = x2;                                             */
/*                  xh1_1 = x3;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt0  = xh0_0 + xh0_1;                                       */
/*              yt1  = xh1_0 + xh1_1;                                       */
/*              yt4  = xh0_0 - xh0_1;                                       */
/*              yt5  = xh1_0 - xh1_1;                                       */
/*                                                                          */
/*              xl0_0  = x0 - x4;                                           */
/*              xl1_0  = x1 - x5;                                           */
/*              xl0_1  = x2 - x6;                                           */
/*              xl1_1  = x3 - x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xl0_0 = x4;                                             */
/*                  xl1_0 = x5;                                             */
/*                  xl1_1 = x6;                                             */
/*                  xl0_1 = x7;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt2  = xl0_0 + xl1_1;                                       */
/*              yt3  = xl1_0 - xl0_1;                                       */
/*              yt6  = xl0_0 - xl1_1;                                       */
/*              yt7  = xl1_0 + xl0_1;                                       */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  yt7  = xl1_0 - xl0_1;                                   */
/*                  yt3  = xl1_0 + xl0_1;                                   */
/*              }                                                           */
/*                                                                          */
/*              y0[k] = yt0; y0[k+1] = yt1;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt2; y0[k+1] = yt3;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt4; y0[k+1] = yt5;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt6; y0[k+1] = yt7;                                 */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      Configuration is LITTLE ENDIAN.                                     */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   */
/*      e.g. N = 1024,  cycles = 14464                                      */
/*      e.g. N = 512,   cycles = 7296                                       */
/*      e.g. N = 256,   cycles = 2923                                       */
/*      e.g. N = 128,   cycles = 1515                                       */
/*      e.g. N = 64,    cycles = 598                                        */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*      1504 bytes                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_IFFTSPXSP_H_
#define DSPF_SP_IFFTSPXSP_H_ 1

void DSPF_sp_ifftSPxSP
(
    int N,
    float * ptr_x,
    float * ptr_w,
    float * ptr_y,
    unsigned char * brev,
    int n_min,
    int offset,
    int n_max
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_ifftSPxSP.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_ifftSPx/1117057342  1533  0     0       37136     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         *
*      inverse FFT with complex input                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of ifft in complex samples, power of 2 such that   *
*                 N >=8 and N<= 16385.                                      *
*       ptr_x  :  Pointer to complex data input (normal order).             *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data (normal order).            *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest ifft butterfly used in computation used for      *
*                 decomposing ifft into sub iffts, see notes.               *
*       offset :  Index in complex samples of sub-ifft from start of main   *
*                 ifft.                                                     *
*       n_max  :  size of main ifft in complex samples.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards ifft using a special  *
*       sequence of coefficients generated in the following way:            *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the      *
*       ifft producing the time domain data in the Y array. The output is   *
*       scaled by a scaling factor of 1/N.                                  *
*                                                                           *
*       As the ifft allows every input point to effect every output point   *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main ifft of size N    *
*       to be divided into several steps, allowing as much data reuse as    *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          *
*                                                                           *
*       Notice how the 1st ifft function is called on the entire 1K data    *
*       set it covers the 1st pass of the ifft until the butterfly size is  *
*       256. The following 4 iffts do 256 pt iffts 25% of the size. These   *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the ifft the following would be needed :                  *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the ifft is calculated by summing these     *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple iffts they can share the same table by calling the     *
*       small iffts from further down in the twiddle factor array. In the   *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the IFFT, four other calls are required to       *
*       perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 IFFTs in        *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the IFFT with one function call invocation as shown   *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the ifft. This collapses the inner 2 loops in the       *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised IFFT uses a redundant sequence of twiddle            *
*          factors to allow a linear access through the data. This linear   *
*          access enables data and instruction level parallelism.           *
*                                                                           *
*       3.The data produced by the ifftSPxSP ifft is in normal form, the    *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The ifftSPxSP butterfly is bit reversed, i.e. the inner 2        *
*          points of the butterfly are corssed over, this has the effect    *
*          of making the data come out in bit reversed rather than          *
*          ifftSPxSP digit reversed order. This simplifies the last pass    *
*          of the loop. A simple table is used to do the bit reversal out   *
*          of place.                                                        *
*                                                                           *
*       unsigned char brev[64] =                                            *
*       {                                                                   *
*           0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,                   *
*           0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,                   *
*           0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,                   *
*           0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,                   *
*           0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,                   *
*           0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,                   *
*           0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,                   *
*           0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f                    *
*       };                                                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on         *
*          double word boundares. Real values are stored in even word       *
*          positions and imaginary values in odd positions.                 *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on        *
*          entry to each loop and reanlbed on exit out of the loop.         *
*                                                                           *
*       5. x must be padded with 16 words at the end.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, ifft_jmp;                               *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               ifft_jmp = stride + (stride>>1);                            *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - ifft_jmp);                                 *
*                   if (!predj) x += ifft_jmp;                              *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 - xl21;                                       *
*                   yt2 = xl1 - xl20;                                       *
*                   xt2 = xl0 + xl21;                                       *
*                   yt1 = xl1 + xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 - yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 + xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 - yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 + xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 - yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 + xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += ifft_jmp;                                      *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of ifft */                *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*       1504 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_ifftSPxSP

*  ======================================================================== *
*   End of file:  DSPF_sp_ifftSPxSP.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_icfftr2/1117057344  1556  0     0       17513     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void DSPF_sp_icfftr2_dif(                                            */
/*                              float* x,                                   */
/*                              float* w,                                   */
/*                              short n                                     */
/*                             );                                           */
/*                                                                          */
/*          x : input and output sequences (dim-n)      (input/output)      */
/*              x has n complex numbers (2*n SP values).                    */
/*              The real and imaginary values are interleaved in memory.    */
/*              The input is in Bit reversed order nad output is in Normal  */
/*              Order.                                                      */
/*          w : FFT coefficients (dim-n/2)              (input)             */
/*              w has n/2 complex numbers (n SP values).                    */
/*              FFT coeficients must be in bit-reversed order               */
/*              The real and imaginary values are interleaved in memory     */
/*          n : FFT size                                (input)             */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine is used to compute the Inverse, Complex, Radix-2,      */
/*      Decimation-in-Frequency Fast Fourier Transform of a single          */
/*      precision complex sequence of size n, and a power of 2. The         */
/*      routine requires bit-reversed input and bit-reversed coefficents    */
/*      (twiddle factors) and produces results that are in normal order.    */
/*      Final scaling by 1/N is not done in this function.                  */
/*                                                                          */
/*      How To Use                                                          */
/*                                                                          */
/*          void main(void)                                                 */
/*          {                                                               */
/*              gen_w_r2(w, N);      // Generate coefficient table          */
/*              bit_rev(w, N>>1);    // Bit-reverse coefficient table       */
/*              cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   */
/*                                   // from TI available                   */
/*                                   // input in normal order, output in    */
/*                                   // order bit-reversed                  */
/*                                   // coefficient table in bit-reversed   */
/*                                   // order                               */
/*                                                                          */
/*              icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 */
/*                                   // input in bit-reversed order,        */
/*                                   // order output in normal              */
/*                                   // coefficient table in bit-reversed   */
/*                                   // order                               */
/*                                                                          */
/*              divide(x, N);        // scale inverse FFT output            */
/*                                   // result is same as original input    */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. Loading input x as well as coefficient w in double word.         */
/*      2. mpy was used to perform a mv.  EX. mpy x, 1, y <=> mv x, y       */
/*      3. Because the data loads are 1 itteration ahead of the             */
/*         coefficent loads, counter i was copied so that the actual        */
/*         count could live longer for the coefficent loads.                */
/*      4. 2 Inner loops are callapsed into one loop.                       */
/*      5. prolog and epilog are done in parallel with the outermost loop.  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. Both input x and coefficient w should be aligned on double word  */
/*         boundary.                                                        */
/*      2. x should be padded with 4 words.                                 */
/*      3. n should be greater than 8.                                      */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions. Note that the assembly code is hand optimized         */
/*      and restrictions may apply.                                         */
/*                                                                          */
/*          void icfftr2_dif(float* x, float* w, short n)                   */
/*          {                                                               */
/*              short n2, ie, ia, i, j, k, m;                               */
/*              float rtemp, itemp, c, s;                                   */
/*                                                                          */
/*              n2 = 1;                                                     */
/*              ie = n;                                                     */
/*              for(k=n; k > 1; k >>= 1)                                    */
/*              {                                                           */
/*                  ie >>= 1;                                               */
/*                  ia = 0;                                                 */
/*                  for(j=0; j < ie; j++)                                   */
/*                  {                                                       */
/*                      c = w[2*j];                                         */
/*                      s = w[2*j+1];                                       */
/*                      for(i=0; i < n2; i++)                               */
/*                      {                                                   */
/*                          m = ia + n2;                                    */
/*                          rtemp     = x[2*ia]   - x[2*m];                 */
/*                          x[2*ia]   = x[2*ia]   + x[2*m];                 */
/*                          itemp     = x[2*ia+1] - x[2*m+1];               */
/*                          x[2*ia+1] = x[2*ia+1] + x[2*m+1];               */
/*                          x[2*m]    = c*rtemp   - s*itemp;                */
/*                          x[2*m+1]  = c*itemp   + s*rtemp;                */
/*                          ia++;                                           */
/*                      }                                                   */
/*                      ia += n2;                                           */
/*                  }                                                       */
/*                  n2 <<= 1;                                               */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to generate the coefficient table      */
/*      (non-bit reversed).                                                 */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*             table of size n/2 complex numbers //                         */
/*                                                                          */
/*          gen_w_r2(float* w, int n)                                       */
/*          {                                                               */
/*              int i;                                                      */
/*              float pi = 4.0*atan(1.0);                                   */
/*              float e = pi*2.0/n;                                         */
/*                                                                          */
/*              for(i=0; i < ( n>>1 ); i++)                                 */
/*              {                                                           */
/*                  w[2*i]   = cos(i*e);                                    */
/*                  w[2*i+1] = sin(i*e);                                    */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to bit-reverse the coefficents.        */
/*                                                                          */
/*          bit_rev(float* x, int n)                                        */
/*          {                                                               */
/*              int i, j, k;                                                */
/*              float rtemp, itemp;                                         */
/*                                                                          */
/*              j = 0;                                                      */
/*              for(i=1; i < (n-1); i++)                                    */
/*              {                                                           */
/*                  k = n >> 1;                                             */
/*                  while(k <= j)                                           */
/*                  {                                                       */
/*                      j -= k;                                             */
/*                      k >>= 1;                                            */
/*                  }                                                       */
/*                  j += k;                                                 */
/*                  if(i < j)                                               */
/*                  {                                                       */
/*                      rtemp    = x[j*2];                                  */
/*                      x[j*2]   = x[i*2];                                  */
/*                      x[i*2]   = rtemp;                                   */
/*                      itemp    = x[j*2+1];                                */
/*                      x[j*2+1] = x[i*2+1];                                */
/*                      x[i*2+1] = itemp;                                   */
/*                  }                                                       */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to perform the final scaling           */
/*      of the IFFT.                                                        */
/*                                                                          */
/*          // divide each element of x by n //                             */
/*          divide(float* x, int n)                                         */
/*          {                                                               */
/*              int i;                                                      */
/*              float inv = 1.0 / n;                                        */
/*                                                                          */
/*              for(i=0; i < n; i++)                                        */
/*              {                                                           */
/*                  x[2*i]   = inv * x[2*i];                                */
/*                  x[2*i+1] = inv * x[2*i+1];                              */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      x should be padded with 4 words at the end.                         */
/*                                                                          */
/*      Since the twiddle table is in bit-reversed order, it turns out      */
/*      that the same twiddle table will also work for smaller IFFTs.This   */
/*      means that if you need to do both 512 and 1024 point IFFTs in the   */
/*      same application, you only need to have the 1024 point twiddle      */
/*      table.  The 512 point FFT will use the first half of the 1024       */
/*      point twiddle table.                                                */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*       2*n*log2(n) + 37                                                   */
/*       eg. IF n = 64, cycles = 805                                        */
/*       eg. IF n = 128, cycles = 1829                                      */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*       1600 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_ICFFTR2_DIF_H_
#define DSPF_SP_ICFFTR2_DIF_H_ 1

void DSPF_sp_icfftr2_dif(
                    float* x,
                    float* w,
                    short n
                   );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_icfftr2_dif.h                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_icfftr2/1117057344  1579  0     0       17432     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSPF_sp_icfftr2_dif(                                            *
*                               float* x,                                   *
*                               float* w,                                   *
*                               short n                                     *
*                              );                                           *
*                                                                           *
*           x : input and output sequences (dim-n)      (input/output)      *
*               x has n complex numbers (2*n SP values).                    *
*               The real and imaginary values are interleaved in memory.    *
*               The input is in Bit reversed order nad output is in Normal  *
*               Order.                                                      *
*           w : FFT coefficients (dim-n/2)              (input)             *
*               w has n/2 complex numbers (n SP values).                    *
*               FFT coeficients must be in bit-reversed order               *
*               The real and imaginary values are interleaved in memory     *
*           n : FFT size                                (input)             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine is used to compute the Inverse, Complex, Radix-2,      *
*       Decimation-in-Frequency Fast Fourier Transform of a single          *
*       precision complex sequence of size n, and a power of 2. The         *
*       routine requires bit-reversed input and bit-reversed coefficents    *
*       (twiddle factors) and produces results that are in normal order.    *
*       Final scaling by 1/N is not done in this function.                  *
*                                                                           *
*       How To Use                                                          *
*                                                                           *
*           void main(void)                                                 *
*           {                                                               *
*               gen_w_r2(w, N);      // Generate coefficient table          *
*               bit_rev(w, N>>1);    // Bit-reverse coefficient table       *
*               cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   *
*                                    // from TI available                   *
*                                    // input in normal order, output in    *
*                                    // order bit-reversed                  *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 *
*                                    // input in bit-reversed order,        *
*                                    // order output in normal              *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               divide(x, N);        // scale inverse FFT output            *
*                                    // result is same as original input    *
*           }                                                               *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. Loading input x as well as coefficient w in double word.         *
*       2. mpy was used to perform a mv.  EX. mpy x, 1, y <=> mv x, y       *
*       3. Because the data loads are 1 itteration ahead of the             *
*          coefficent loads, counter i was copied so that the actual        *
*          count could live longer for the coefficent loads.                *
*       4. 2 Inner loops are callapsed into one loop.                       *
*       5. prolog and epilog are done in parallel with the outermost loop.  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Both input x and coefficient w should be aligned on double word  *
*          boundary.                                                        *
*       2. x should be padded with 4 words.                                 *
*       3. n should be greater than 8.                                      *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions. Note that the assembly code is hand optimized         *
*       and restrictions may apply.                                         *
*                                                                           *
*           void icfftr2_dif(float* x, float* w, short n)                   *
*           {                                                               *
*               short n2, ie, ia, i, j, k, m;                               *
*               float rtemp, itemp, c, s;                                   *
*                                                                           *
*               n2 = 1;                                                     *
*               ie = n;                                                     *
*               for(k=n; k > 1; k >>= 1)                                    *
*               {                                                           *
*                   ie >>= 1;                                               *
*                   ia = 0;                                                 *
*                   for(j=0; j < ie; j++)                                   *
*                   {                                                       *
*                       c = w[2*j];                                         *
*                       s = w[2*j+1];                                       *
*                       for(i=0; i < n2; i++)                               *
*                       {                                                   *
*                           m = ia + n2;                                    *
*                           rtemp     = x[2*ia]   - x[2*m];                 *
*                           x[2*ia]   = x[2*ia]   + x[2*m];                 *
*                           itemp     = x[2*ia+1] - x[2*m+1];               *
*                           x[2*ia+1] = x[2*ia+1] + x[2*m+1];               *
*                           x[2*m]    = c*rtemp   - s*itemp;                *
*                           x[2*m+1]  = c*itemp   + s*rtemp;                *
*                           ia++;                                           *
*                       }                                                   *
*                       ia += n2;                                           *
*                   }                                                       *
*                   n2 <<= 1;                                               *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to generate the coefficient table      *
*       (non-bit reversed).                                                 *
*                                                                           *
*           #include <math.h>                                               *
*           /* generate real and imaginary twiddle                          *
*              table of size n/2 complex numbers */                         *
*                                                                           *
*           gen_w_r2(float* w, int n)                                       *
*           {                                                               *
*               int i;                                                      *
*               float pi = 4.0*atan(1.0);                                   *
*               float e = pi*2.0/n;                                         *
*                                                                           *
*               for(i=0; i < ( n>>1 ); i++)                                 *
*               {                                                           *
*                   w[2*i]   = cos(i*e);                                    *
*                   w[2*i+1] = sin(i*e);                                    *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to bit-reverse the coefficents.        *
*                                                                           *
*           bit_rev(float* x, int n)                                        *
*           {                                                               *
*               int i, j, k;                                                *
*               float rtemp, itemp;                                         *
*                                                                           *
*               j = 0;                                                      *
*               for(i=1; i < (n-1); i++)                                    *
*               {                                                           *
*                   k = n >> 1;                                             *
*                   while(k <= j)                                           *
*                   {                                                       *
*                       j -= k;                                             *
*                       k >>= 1;                                            *
*                   }                                                       *
*                   j += k;                                                 *
*                   if(i < j)                                               *
*                   {                                                       *
*                       rtemp    = x[j*2];                                  *
*                       x[j*2]   = x[i*2];                                  *
*                       x[i*2]   = rtemp;                                   *
*                       itemp    = x[j*2+1];                                *
*                       x[j*2+1] = x[i*2+1];                                *
*                       x[i*2+1] = itemp;                                   *
*                   }                                                       *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to perform the final scaling           *
*       of the IFFT.                                                        *
*                                                                           *
*           /* divide each element of x by n */                             *
*           divide(float* x, int n)                                         *
*           {                                                               *
*               int i;                                                      *
*               float inv = 1.0 / n;                                        *
*                                                                           *
*               for(i=0; i < n; i++)                                        *
*               {                                                           *
*                   x[2*i]   = inv * x[2*i];                                *
*                   x[2*i+1] = inv * x[2*i+1];                              *
*               }                                                           *
*           }                                                               *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       x should be padded with 4 words at the end.                         *
*                                                                           *
*       Since the twiddle table is in bit-reversed order, it turns out      *
*       that the same twiddle table will also work for smaller IFFTs.This   *
*       means that if you need to do both 512 and 1024 point IFFTs in the   *
*       same application, you only need to have the 1024 point twiddle      *
*       table.  The 512 point FFT will use the first half of the 1024       *
*       point twiddle table.                                                *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*        2*n*log2(n) + 37                                                   *
*        eg. IF n = 64, cycles = 805                                        *
*        eg. IF n = 128, cycles = 1829                                      *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*        1600 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_icfftr2_dif

*  ======================================================================== *
*   End of file:  DSPF_sp_icfftr2_dif.h67                                        *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_fir_cpl/1117057345  1604  0     0       4588      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     */
/*      Filter                                                              */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_fir_cplx(                                                  */
/*                        const float * restrict x,                         */
/*                        const float * restrict h,                         */
/*                        float *       restrict r,                         */
/*                        int   nh,                                         */
/*                        int   nr                                          */
/*                       )                                                  */
/*            x[2*(nr+nh-1)]:Pointer to complex Input array.                */
/*                           The input data pointer x must point to the     */
/*                           (nh)th complex element, i.e. element 2*(nh-1). */
/*            h[2*nh]:       Pointer to complex Coefficient array           */
/*                           (in normal order).                             */
/*            r[2*nr]:       Pointer to complex Output array.               */
/*            nh:            Number of complex coefficients in vector h.    */
/*            nr:            Number of complex output samples to calculate. */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This function implements the FIR filter for complex input data.    */
/*       The filter has nr output samples and nh coefficients. Each array   */
/*       consists of an even and odd term with even terms representing the  */
/*       real part and the odd terms the imaginary part of the element.     */
/*       The coefficients are expected in normal order.                     */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       The outer loop is unrolled twice.                                  */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nr is a multiple of 2 and greater than or equal to 2.           */
/*       2. nh is greater than or equal to 5.                               */
/*       3. x and h are double word aligned.                                */
/*       4. x points to 2*(nh-1)th input element.                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FIR_CPLX_ASM_H_
#define DSPF_SP_FIR_CPLX_ASM_H_ 1

void DSPF_sp_fir_cplx(const     float *restrict x, const float *restrict h, float *restrict r, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_fir_cplx_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_fir_cpl/1117057345  1624  0     0       1763      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_fir_cplx

* ======================================================================== *
*  End of file: DSPF_sp_fir_cplx_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fir_gen/1117057346  1646  0     0       5398      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   */
/*                                                                          */
/*   USAGE                                                                  */
/*                                                                          */
/*   This routine is C Callable and can be called as:                       */
/*                                                                          */
/*       void sp_firgen(const float *x, const float *h, float * restrict r, */
/*                  int nh, int nr);                                        */
/*                                                                          */
/*       x : Pointer to array holding the input floating point array        */
/*       h : Pointer to array holding the coefficient floating point        */
/*           array                                                          */
/*       y : Pointer to array holding the output floating point array       */
/*       nh: Number of coefficents                                          */
/*       nr: Number of output values                                        */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine implements a block FIR filter.  There are "nh"        */
/*       filter coefficients, "nr" output samples, and "nh+nr-1"            */
/*       input samples.    The coefficients need to be placed in the "h"    */
/*       array in reverse order {h(nh-1), ... , h(1), h(0)} and the         */
/*       array "x" starts at x(-nh+1) and ends at x(nr-1).  The             */
/*       routine calculates y(0) through y(nr-1) using the following        */
/*       formula:                                                           */
/*                                                                          */
/*       y(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           */
/*                                                                          */
/*       where n = {0, 1, ... , nr-1}.                                      */
/*   C CODE                                                                 */
/*       This is the C equivalent for the assembly code.  Note that         */
/*       the assembly code is hand optimized and restrictions may           */
/*       apply.                                                             */
/*                                                                          */
/*       void DSPF_sp_fir_gen(const float *x, const float *h, float * restrict r */
/*                   int nh, int nr)                                        */
/*       {                                                                  */
/*          int i, j;                                                       */
/*          float sum;                                                      */
/*                                                                          */
/*          for(j=0; j < nh; j++)                                           */
/*          {                                                               */
/*             sum = 0;                                                     */
/*             for(i=0; i < nr; i++)                                        */
/*             {                                                            */
/*                 sum += x[i+j] * h[i];                                    */
/*             }                                                            */
/*             r[j] = sum;                                                  */
/*          }                                                               */
/*       }                                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FIR_GEN_ASM_H_
#define DSPF_SP_FIR_GEN_ASM_H_ 1

void DSPF_sp_fir_gen(const     float * restrict x, const float * restrict h, float * restrict r, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_fir_gen_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_fir_gen/1117057346  1665  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_fir_gen

* ======================================================================== *
*  End of file: DSPF_sp_fir_gen_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_fir_r2./1117057347  1686  0     0       4491      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       */
/*      Filter                                                              */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_fir_r2(                                                    */
/*                     const float * restrict x,                            */
/*                     const float * restrict h,                            */
/*                     float       * restrict r,                            */
/*                     int   nh,                                            */
/*                     int   nr                                             */
/*                     )                                                    */
/*            x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           */
/*            h[nh]:      Pointer to Coefficient array of size nh.          */
/*                        (in reverse order).                               */
/*            r[nr]:      Pointer to Output array od size nr.               */
/*            nh:         Number of coefficients                            */
/*            nr:         Number of output samples.                         */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       Computes a real FIR filter (direct-form) using coefficients        */
/*       stored in vector h[]. The real data input is stored in vector      */
/*       x[]. The filter output result is stored in vector r[]. The         */
/*       filter calculates nr output samples using nh coefficients.         */
/*       The coefficients are expected to be in reverse order.              */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       The outer loop is unrolled four times and inner loop is            */
/*       unrolled twice.                                                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nr is a multiple of 2 and greater than or equal to 2.           */
/*       2. nh is a multiple of 2 and greater than or equal to 8.           */
/*       3. x and h are double word aligned.                                */
/*       4. Coefficients in array h are expected to be in revrse order.     */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef SP_fir_r2_ASM_H_
#define SP_fir_r2_ASM_H_ 1

void DSPF_sp_fir_r2(const     float *restrict x, const float *restrict h, float *restrict r, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_fir_r2_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_fir_r2./1117057346  1704  0     0       1784      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_fir_r2

* ======================================================================== *
*  End of file: DSPF_sp_fir_r2_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_fircirc/1117057348  1724  0     0       11470     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has following C prototype                              */
/*                                                                          */
/*      void DSPF_sp_fircirc                                                     */
/*      (                                                                   */
/*          float *x,       // Pointer to input samples                     */
/*          float *h,       // Pointer to impulse response samples          */
/*          float *r,       // Pointer to output samples                    */
/*          int index,      // Offset by which to start reading from        */
/*                          // input array                                  */
/*          int csize,      // Size of circular buffer for input is         */
/*                          // 2^(csize+1) bytes                            */
/*          int nh,         // Number of impulse response samples           */
/*          int nr          // Number of output samples                     */
/*       );                                                                 */
/*                                                                          */
/*      x[]     : Input array (circular buffer of 2^(csize+1) bytes)        */
/*                Must be aligned at 2^(csize+1) byte boundary              */
/*      h[nh]   : Filter coefficients array                                 */
/*                Must be double-word aligned                               */
/*      r[nr]   : Output array                                              */
/*      index   : Offset by which to start reading from the input array     */
/*                Must be multiple of 2                                     */
/*      csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         */
/*                Must be 2 <= csize <= 31.                                 */
/*      nh      : Number of filter coefficients                             */
/*                Must be multiple of 2 and >= 4                            */
/*      nr      : Size of output array                                      */
/*                Must be multiple of 4                                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine implements a circularly addressed FIR filter.          */
/*      'nh' is the number of filter coefficients. 'nr' is the number       */
/*      of the output samples.                                              */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. LDDW instructions are used to load two SP floating point         */
/*         values simultaneously for the x and h arrays.                    */
/*      2. The outer loop is unrolled 4 times.                              */
/*      3. The inner loop is unrolled 2 times.                              */
/*      4. The variables prod1, prod3, prod5 and prod7 share A9.            */
/*         The variables prod0, prod2, prod4 and prod6 share B6.            */
/*         The variables sum1, sum3, sum5 and sum7 share A7.                */
/*         The variables sum0, sum2, sum4 and sum6 share B8.                */
/*         This multiple assignment is possible since the variables         */
/*         are always read just once on the first cycle that they are       */
/*         avaliable.                                                       */
/*      6. A load counter is used so that an epilog is not needed.  No      */
/*         extraneous loads are performed.                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The circular input buffer x[] must be aligned at a 2^(csize+1)   */
/*         byte boundary. csize must lie in the range 2 <= csize <= 31.     */
/*      2. The number of coefficients  (nh) must be a multiple of 2         */
/*         and greater than or equal to 4.                                  */
/*      3. The number of outputs (nr) must be a multiple of 4 and           */
/*         greater than or equal to 4.                                      */
/*      4. The 'index' (offset to start reading input array) must be        */
/*         mutiple of 2 and less than or equal to (2^(csize-1) - 6)         */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_fircirc                                                     */
/*      (                                                                   */
/*          float *x,       // Pointer to input samples                     */
/*          float *h,       // Pointer to impulse response samples          */
/*          float *r,       // Pointer to output samples                    */
/*          int index,      // Offset by which to start reading from        */
/*                          // input array                                  */
/*          int csize,      // Size of circular buffer for input is         */
/*                          // 2^(csize+1) bytes                            */
/*          int nh,         // Number of impulse response samples           */
/*          int nr          // Number of output samples                     */
/*       )                                                                  */
/*      {                                                                   */
/*          int i, j;                                                       */
/*          //Circular Buffer block size = ((2^(csize + 1)) / 4)            */
/*          //floating point numbers                                        */
/*          int mod = (1 << (csize - 1));                                   */
/*          float r0;                                                       */
/*                                                                          */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              r0 = 0;                                                     */
/*              for (j = 0; j < nh; j++)                                    */
/*              {                                                           */
/*                  //Operation "% mod" is equivalent to "& (mod -1)"       */
/*                  //r0 += x[(i + j + index) % mod] * h[j];                */
/*                  r0 += x[(i + j + index) & (mod - 1)] * h[j];            */
/*              }                                                           */
/*          r[i] = r0;                                                      */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. This code is LITLLE ENDIAN.                                      */
/*      2. This routine disables interupts for its entire duration.         */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      (2*nh + 10) nr/4 + 18                                               */
/*      eg. for nh = 30, nr=100                                             */
/*      cycles = 1768                                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      512 bytes                                                           */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FIRCIRC_ASM_H_
#define DSPF_SP_FIRCIRC_ASM_H_ 1

void DSPF_sp_fircirc(float     * x, float * h, float * r, int index, int csize, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_fircirc.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_fircirc/1117057347  1743  0     0       11503     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has following C prototype                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        );                                                                 *
*                                                                           *
*       x[]     : Input array (circular buffer of 2^(csize+1) bytes)        *
*                 Must be aligned at 2^(csize+1) byte boundary              *
*       h[nh]   : Filter coefficients array                                 *
*                 Must be double-word aligned                               *
*       r[nr]   : Output array                                              *
*       index   : Offset by which to start reading from the input array     *
*                 Must be multiple of 2                                     *
*       csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         *
*                 Must be 2 <= csize <= 31.                                 *
*       nh      : Number of filter coefficients                             *
*                 Must be multiple of 2 and >= 4                            *
*       nr      : Size of output array                                      *
*                 Must be multiple of 4                                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine implements a circularly addressed FIR filter.          *
*       'nh' is the number of filter coefficients. 'nr' is the number       *
*       of the output samples.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. LDDW instructions are used to load two SP floating point         *
*          values simultaneously for the x and h arrays.                    *
*       2. The outer loop is unrolled 4 times.                              *
*       3. The inner loop is unrolled 2 times.                              *
*       4. The variables prod1, prod3, prod5 and prod7 share A9.            *
*          The variables prod0, prod2, prod4 and prod6 share B6.            *
*          The variables sum1, sum3, sum5 and sum7 share A7.                *
*          The variables sum0, sum2, sum4 and sum6 share B8.                *
*          This multiple assignment is possible since the variables         *
*          are always read just once on the first cycle that they are       *
*          avaliable.                                                       *
*       6. A load counter is used so that an epilog is not needed.  No      *
*          extraneous loads are performed.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The circular input buffer x[] must be aligned at a 2^(csize+1)   *
*          byte boundary. csize must lie in the range 2 <= csize <= 31.     *
*       2. The number of coefficients  (nh) must be a multiple of 2         *
*          and greater than or equal to 4.                                  *
*       3. The number of outputs (nr) must be a multiple of 4 and           *
*          greater than or equal to 4.                                      *
*       4. The 'index' (offset to start reading input array) must be        *
*          mutiple of 2 and less than or equal to (2^(csize-1) - 6)         *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        )                                                                  *
*       {                                                                   *
*           int i, j;                                                       *
*           //Circular Buffer block size = ((2^(csize + 1)) / 4)            *
*           //floating point numbers                                        *
*           int mod = (1 << (csize - 1));                                   *
*           float r0;                                                       *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               r0 = 0;                                                     *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   //Operation "% mod" is equivalent to "& (mod -1)"       *
*                   //r0 += x[(i + j + index) % mod] * h[j];                *
*                   r0 += x[(i + j + index) & (mod - 1)] * h[j];            *
*               }                                                           *
*           r[i] = r0;                                                      *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. This code is LITLLE ENDIAN.                                      *
*       2. This routine disables interupts for its entire duration.         *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (2*nh + 10) nr/4 + 18                                               *
*       eg. for nh = 30, nr=100                                             *
*       cycles = 1768                                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       512 bytes                                                           *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_fircirc

*  ======================================================================== *
*   End of file:  DSPF_sp_fircirc.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_sp_biquad./1117057348  1764  0     0       3961      `
/* ============================================================================*/
/*                                                                             */
/*  TEXAS INSTRUMENTS, INC.                                                    */
/*                                                                             */
/*  NAME                                                                       */
/*      DSPF_sp_biquad: Biquad filter (IIR filter of 2nd order)                     */
/*                                                                             */
/*  USAGE                                                                      */
/*      This routine has following C prototype:                                */
/*                                                                             */
/*           void DSPF_sp_biquad (                                                  */
/*                         float x[],    Pointer to input samples              */
/*                         float b[],    Pointer to Nr coefs b0, b1, b2        */
/*                         float a[],    Pointer to Dr coefs a1, a2            */
/*                         float delay[] Pointer to filter delays              */
/*                         float r[],    Pointer to output samples             */
/*                         int   nx      Number of input/output samples        */
/*                         )                                                   */
/*                                                                             */
/*                                                                             */
/*                                                                             */
/*  DESCRIPTION                                                                */
/*      This routine implements a DF 2 transposed structure of the biquad      */
/*      filter. The transfer function of a biquad can be written               */ 
/*      as:                                                                    */
/*                                                                             */
/*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)            */
/*                       H(Z) =     _________________________________          */
/*                                    1 + a(1)z^(-1) + a(2)z^(-2)              */
/*                                                                             */
/* ============================================================================*/
/*            Copyright (c) 2002 Texas Instruments, Incorporated.              */
/*                           All Rights Reserved.                              */
/* ============================================================================*/

#ifndef DSPF_SP_BIQUAD_ASM
#define DSPF_SP_BIQUAD_ASM 1

void DSPF_sp_biquad     (
                float x[],         //Pointer to input samples
                float b[],         //Pointer to numerator coefficients b[0], b[1] and b[2]
                float a[],         //Pointer to denominator coefficients a[1] and a[2]
                float delay[],     //Pointer to filter delays delay[0] and delay[1]
                float r[],         //Pointer to output samples
                int      nx         //Number of input/output samples
               );
#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_biquad.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */





DSPF_sp_biquad./1117057348  1782  0     0       1680      `
 ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_biquad -- Single Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_biquad

* ======================================================================== *
*  End of file: DSPF_sp_biquad_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_iir.h/  1117057349  0     0     0       6054      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_iir -- Single Precision IIR filter (used in the VSELP vocoder)   */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*   This routine is C callable, and has the following C prototype:         */
/*                                                                          */
/*      void DSPF_sp_iir    (float* restrict r1,                                 */
/*                      const float*    x,                                  */
/*                      float* restrict r2,                                 */
/*                      const float*    h2,                                 */
/*                      const float*    h1,                                 */
/*                      int nr                                              */
/*                     );                                                   */
/*                                                                          */
/*           r1   :  Delay element values (i/p and o/p)                     */
/*           x    :  Pointer to the input array                             */
/*           r2   :  Pointer to the output array                            */
/*           h2   :  Auto-regressive filter coefficients                    */
/*           h1   :  Moving average filter coefficients                     */
/*           nr   :  Number of output samples                               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    The IIR performs an auto-regressive moving-average (ARMA)             */
/*    filter with 4 auto-regressive filter coefficients and 5               */
/*    moving-average filter coefficients for nr output samples.             */
/*    The output vector is stored in two locations. This routine            */
/*    is used as a high pass filter in the VSELP vocoder.                   */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the Assembly Code without                   */
/*  restrictions.                                                           */
/*                                                                          */
/*  Note that the assembly code is hand optimized and restrictions          */
/*  may apply.                                                              */
/*                                                                          */
/*  void DSPF_sp_iir (float* restrict r1,                                        */
/*                   const float*    x,                                     */
/*                   float* restrict r2,                                    */
/*                   const float*    h2,                                    */
/*                   const float*    h1,                                    */
/*                   int nr                                                 */
/*                  )                                                       */
/*      {                                                                   */
/*         int i, j;                                                        */
/*         float sum;                                                       */
/*                                                                          */
/*         for (i = 0; i < nr; i++)                                         */
/*         {                                                                */
/*             sum = h2[0] * x[4+i];                                        */
/*                                                                          */
/*             for (j = 1; j <= 4; j++)                                     */
/*                 sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];             */
/*                                                                          */
/*             r1[4+i] = sum;                                               */
/*             r2[i] = r1[4+i];                                             */
/*         }                                                                */
/*     }                                                                    */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_IIR_ASM_H_
#define DSPF_SP_IIR_ASM_H_ 1

void DSPF_sp_iir(float     *restrict r1, const float * x, float *restrict r2, const float * h2, const float * h1, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_iir_h.asm                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_iir.h67/1117057349  0     0     0       1680      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iir -- Single Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_iir

* ======================================================================== *
*  End of file: DSPF_sp_iir_h.asm                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_iirlat./1117057350  1802  0     0       7263      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           */
/*                                                                          */
/*    USAGE                                                                  */ 
/*        This routine has following C prototype:                            */
/*                                                                           */ 
/*             void DSPF_sp_iirlat(                                               */ 
/*                           float *x,                                       */ 
/*                           int nx,                                         */ 
/*                           const float * restrict k,                       */ 
/*                           int nk,                                         */ 
/*                           float * restrict b,                             */ 
/*                           float * r                                       */ 
/*                           )                                               */ 
/*          x[nx]   : Input vector                                           */ 
/*          nx      : Length of input vector.                                */ 
/*          k[nk]   : Reflection coefficients                                */ 
/*          nk      : Number of reflection coefficients/lattice stages       */ 
/*                    Must be multiple of 2 and >=6.                         */ 
/*          b[nk+1] : Delay line elements from previous call. Should be      */ 
/*                    initialized to all zeros prior to the first call.      */ 
/*          r[nx]   : Output vector                                          */ 
/*                                                                           */ 
/*      DESCRIPTION                                                          */ 
/*          This routine implements a real all-pole IIR filter in lattice    */ 
/*          structure (AR lattice). The filter consists of nk lattice stages */ 
/*          Each stage requires one reflection coefficient k and one delay   */ 
/*          element b. The routine takes an input vector x[] and returns the */ 
/*          filter output in r[]. Prior to the first call of the routine the */ 
/*          delay elements in b[] should be set to zero. The input data may  */ 
/*          have to be pre-scaled to avoid overflow or achieve better SNR. T */ 
/*          reflections coefficients lie in the range -1.0 < k < 1.0. The    */ 
/*          order of the coefficients is such that k[nk-1] corresponds to th */ 
/*          first lattice stage after the input and k[0] corresponds to the  */ 
/*          last stage.                                                      */ 
/*                                                                           */
/*     TECHNIQUES                                                            */ 
/*          1.  The loop has been unrolled by 4 times.                       */ 
/*                                                                           */ 
/*          2.  Register sharing has been used to optimize on the use of regs*/
/*                                                                           */ 
/*                                                                           */ 
/*     ASSUMPTIONS                                                           */
/*                                                                           */ 
/*         1. nk is a multiple of 2 and >=6.                                 */
/*         2. Extraneous loads are allowed (80 bytes) before the start of    */
/*            array.                                                         */ 
/*                                                                           */ 
/*     C CODE                                                                */
/*                                                                           */ 
/*        void DSPF_sp_iirlat(float * x, int nx, const float * restrict k, int nk,*/ 
/*                       float * restrict b, float * r)                      */
/*        {                                                                  */
/*                                                                           */ 
/*       float rt;     // output       //                                    */
/*       int i, j;                                                           */
/*                                                                           */
/*       for (j = 0; j < nx; j++)                                            */
/*       {                                                                    */
/*           rt = x[j];                                                         */
/*                                                                            */
/*           for (i = nk - 1; i >= 0; i--)                                    */
/*           {                                                                 */
/*               rt = rt - b[i] * k[i];                                         */
/*               b[i + 1] = b[i] + rt * k[i];                                 */
/*           }                                                                 */
/*                                                                            */
/*           b[0] = rt;                                                      */                                
/*           r[j] = rt;                                                         */
/*       }                                                                    */
/*                                                                             */ 
/*      }                                                                     */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_IIRLAT_ASM_H_
#define DSPF_SP_IIRLAT_ASM_H_ 1

void DSPF_sp_iirlat(float     * x, int nx, const float * restrict k, int nk, float * restrict b, float * r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_iirlat_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_iirlat./1117057350  1820  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_iirlat

* ======================================================================== *
*  End of file: DSPF_sp_iirlat_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_convol./1117057351  1840  0     0       5887      `
/* =======================================================================      */
/*                                                                              */     
/*  TEXAS INSTRUMENTS, INC.                                                     */
/*                                                                              */
/*  NAME                                                                         */
/*      DSPF_sp_convol: Convolution(Floating Point Version)                          */ 
/*                                                                              */
/*  USAGE                                                                       */
/*      This routine is C callable, and has the following C prototype:          */
/*                                                                              */
/*      void DSPF_sp_convol                                                          */  
/*             (                                                                */
/*                       float *x, //x: Pointer to input samples//              */          
/*                       float *h, //h: Pointer to impulse response samples//   */
/*                       float *r, //r: Pointer to output samples//             */
/*                       int   nh, //nh: Number of impulse response samples//   */
/*                       int   nr  //nr: Number of output samples//             */
/*             )                                                                */
/*                                                                              */
/*              x = pointer to real input vector of size = nr+nh-1              */
/*                  a typically contains input data (x) padded with             */
/*                  consecutive nh - 1  zeros at the beginning and end.         */
/*              h = pointer to real input vector of size nh in forward order.   */
/*                  h typically contains the filter coefs.                      */
/*              r = pointer to real output vector of size nr                    */
/*              nh= number of elements in vector b. NOTE: nh <= nr  nh is       */
/*                  typically noted as m in convol formulas. nh must be a       */
/*                  MULTIPLE of 2                                               */
/*              nr= number of elements in vector r. nr must be a MULTIPLE of 4  */
/*                                                                              */
/*              If routine is not to be used as a C callable function then      */
/*              you need to initialize values for all of the values passed      */
/*              as these are assumed to be in registers as defined by the       */
/*              calling convention of the compiler, (refer to the C compiler    */
/*              reference guide).                                               */
/*                                                                              */
/*  DESCRIPTION                                                                 */
/*              This fucntion calculates the full-lenght convolution of real    */
/*              vectors x and h using time-domain techniques. The result is     */
/*              placed in real vector r.                                        */
/*                                                                              */
/*              It is assumed that input vector x is padded with nh-1 no of     */
/*              zeros in the beginning and end.                                 */
/*                                                                              */
/*              It is assumed that the length of the input vector h, nh, is a   */
/*              multiple of 2 and the length of the output vector r, nr, is a   */    
/*              multiple of 4. nh is greater thanor equal to 4 and nr is greater*/
/*              than or equal to nh. The routine computes 4 output              */
/*              samples at a time.                                              */
/*                                                                              */
/*              x and h are assumed to be aligned on a double word boundary     */
/*                                                                              */
/* -----------------------------------------------------------------------      */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.               */
/*                           All Rights Reserved.                               */
/* =======================================================================      */

#ifndef DSPF_SP_CONVOL_ASM
#define DSPF_SP_CONVOL_ASM 1

void DSPF_sp_convol
        (                                                                   
             float *x, /*x: Pointer to input samples*/                                   
             float *h, /*h: Pointer to impulse response samples*/           
             float *r, /*r: Pointer to output samples*/                       
             int   nh, /*nh: Number of impulse response samples*/            
             int   nr  /*nr: Number of output samples*/                     
        );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_convol.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_convol./1117057351  1858  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_convol -- Single Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_convol

* ======================================================================== *
*  End of file: DSPF_sp_convol_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_dotp_sq/1117057352  1878  0     0       4412      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_dotp_sqr(                                                  */
/*                       float G,                                           */
/*                       const float * x,                                   */
/*                       const float * y,                                   */
/*                       float *  restrict r,                               */
/*                       int   nx                                           */
/*                       )                                                  */
/*            G:      Sum of y-squared initial value.                       */
/*            x[nx]:  Pointer to First input array.                         */
/*            y[nx]:  Pointer to Second input array.                        */
/*            r:      Pointer to Output for Accumulation of x[]*y[].        */
/*            nx:     Length of input vectors.                              */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This routine computes the dot product of x[] and y[] arrays,adding */
/*       it to the value in the location pointed to by r. Additionally, it  */
/*       computes the sum of the squares of the terms in the y array,adding */
/*       it to the argument G. The final value of G is given as the return  */
/*       value of the function.                                             */
/*                                                                          */
/*       x and y should be aligned on a double word boundary.               */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The loop is unrolled four times.                                    */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*      1. nx is a multiple of 4.                                           */
/*      2. x and y should be double word aligned.                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_DOTP_SQR_ASM_H_
#define DSPF_SP_DOTP_SQR_ASM_H_ 1

float DSPF_sp_dotp_sqr(float     G, const float * x, const float * y, float *restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_dotp_sqr_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_dotp_sq/1117057352  1898  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotp_sqr

* ======================================================================== *
*  End of file: DSPF_sp_dotp_sqr_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_dotprod/1117057353  1920  0     0       4089      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      float DSPF_sp_dotprod(const float *x, const float *y, const int nx);     */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      nx    : Number of values in the x & y vectors                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 single precision       */
/*  float vectors.                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      float dotp(const float *x, const float *y, const int nx)            */
/*      {                                                                   */
/*         int i;                                                           */
/*         float sum = 0;                                                   */
/*                                                                          */
/*         for (i=0; i < nx; i++)                                           */
/*         {                                                                */
/*            sum += x[i] * y[i];                                           */
/*         }                                                                */
/*         return sum;                                                      */
/*      }                                                                   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_DOTPROD_ASM_H_
#define DSPF_SP_DOTPROD_ASM_H_ 1

float DSPF_sp_dotprod(const     float * x, const float * y, const int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_dotprod_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_dotprod/1117057353  1939  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotprod

* ======================================================================== *
*  End of file: DSPF_sp_dotprod_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_dotp_cp/1117057354  1960  0     0       6614      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_dotp_cplx -- Complex single precision floating point dot         */
/*      product                                                             */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      void DSPF_sp_dotp_cplx(const float *x, const float *y, int n, float *    */
/*                        restrict re, float * restrict im);                */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      n     : Number of values in the x & y vectors                       */
/*      re    : Pointer to the location storing the real part of the result */
/*      im    : Pointer to the location storing the imaginary part of       */
/*          the result                                                      */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 single precision       */
/*  complex float vectors. The even numbered locations hold the real parts  */
/*  of the complex numbers while the odd numbered locations contain the     */
/*  imaginary portions.                                                     */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1.  The loop is unrolled 4 times because the loop carried           */
/*      dependency bound is 4.                                              */
/*                                                                          */
/*      2.  LDDW instructions are used to load two SP floating point        */
/*          values at a time for the x and y arrays.                        */
/*                                                                          */
/*      3.  A load counter avoids all extraneous loads.                     */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1.  Little Endian is assumed for LDDW instructions.                 */
/*      2.  Since single assignment of registers is not used,               */
/*          interrupts should be disabled before this function is           */
/*          called.                                                         */
/*      3.  Loop counter must be > 0.                                       */
/*  4.  The x and y arrays must be double word aligned.                     */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_dotp_cplx(const    float* x, const float* y,                */
/*                       int n, float* restrict re,                         */
/*               float* restrict im)                                        */
/*      {                                                                   */
/*                                                                          */
/*          float real=0, imag=0;                                           */
/*          int i=0;                                                        */
/*                                                                          */
/*          for(i=0; i<n; i++)                                              */
/*          {                                                               */
/*              real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  */
/*              imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  */
/*          }                                                               */
/*                                                                          */
/*          *re=real;                                                       */
/*          *im=imag;                                                       */
/*     }                                                                    */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_DOTP_CPLX_ASM_H_
#define DSPF_SP_DOTP_CPLX_ASM_H_ 1

void DSPF_sp_dotp_cplx(const     float * x, const float * y, int n, float * restrict re, float * restrict im);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_dotp_cplx_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_dotp_cp/1117057354  1981  0     0       1764      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_cplx -- Complex single precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotp_cplx

* ======================================================================== *
*  End of file: DSPF_sp_dotp_cplx_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_maxval./1117057355  2004  0     0       3716      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       float DSPF_sp_maxval(                                                   */
/*                       const float* x,                                    */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*            Returns float: Maximum value in the input array               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       This routine Finds out the maximum number in the input array.      */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The loop is unrolled Six times.                                     */
/*      Six maximums are maintained in each iteration.                      */ 
/*      One of the maximums are calculated using SUBSP in place of CMPGTSP  */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      nx should be multiple of 2 and >= 2.                                */ 
/*      x should be double word aligned.                                    */ 
/*      NAN( Not a Number in Single Precision format) in the input are      */ 
/*      disregarded.                                                        */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAXVAL_ASM_H_
#define DSPF_SP_MAXVAL_ASM_H_ 1

float DSPF_sp_maxval(const     float* x, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_maxval_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_maxval./1117057355  2022  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_maxval

* ======================================================================== *
*  End of file: DSPF_sp_maxval_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_maxidx./1117057356  2042  0     0       3580      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       int DSPF_sp_maxidx(                                                     */
/*                      const float* x,                                     */
/*                      int nx                                              */
/*                    )                                                     */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*            Returns int: Index of Maximum value                           */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       This routine Finds out the index of maximum number in the input    */
/*       array.                                                             */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The loop is unrolled three times.                                   */
/*      Three maximums are maintained in each iteration.                    */
/*      MPY indtructions are  used for move.                                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      nx is a multiple of 3                                               */
/*      nx >= 3, and nx <= 2^16-1.                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAXIDX_ASM_H_
#define DSPF_SP_MAXIDX_ASM_H_ 1

int DSPF_sp_maxidx(const     float* x, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_maxidx_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_maxidx./1117057356  2060  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_maxidx

* ======================================================================== *
*  End of file: DSPF_sp_maxidx_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_minval./1117057357  2080  0     0       3881      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             */
/*                                                                          */
/*     USAGE                                                                */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       float DSPF_sp_minval(                                                   */
/*                       const float* x,                                    */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*            Returns float: Minimum value in the input array               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       This routine Finds out the minimum number in the input array.      */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       The loop is unrolled Six times.                                    */ 
/*       Six minimums are maintained in each iteration.                     */ 
/*       One of the minimums are calculated using SUBSP in place of CMPGTSP */ 
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       nx should be multiple of 2 and >= 2.                               */ 
/*       x should be double word aligned.                                   */ 
/*       NAN( Not a Number in Single Precision format) in the input are     */ 
/*       disregarded.                                                       */ 
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MINVAL_ASM_H_
#define DSPF_SP_MINVAL_ASM_H_ 1

float DSPF_sp_minval(const     float* x, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_minval_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_minval./1117057356  2098  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_minval

* ======================================================================== *
*  End of file: DSPF_sp_minval_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecreci/1117057359  2118  0     0       5137      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_vecrecip(const float *x,                                   */
/*                        float * restrict r,                               */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_sp_vecrecip module calculates the reciprocal of each element in */
/*      array x and returns the output in array r. It uses 2 iterations     */
/*      of the Newton-Raphson method to improve the accuracy of the output  */
/*      generated by the RCPSP instruction of the C67x. Each iteration      */
/*      doubles the accuracy. The initial output generated by RCPSP is 8 bi */
/*      So after the first iteration it is 16 bits and after the second it  */
/*      the full 23 bits. The formula used is:                              */
/*                                                                          */
/*               r[n+1] = r[n](2 - v*r[n])                                  */
/*                                                                          */
/*      where v = the number whose reciprocal is to be found.               */
/*      x[0], the seed value for the algorithm, is given by RCPSP.          */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*      1. The inner loop is unrolled four times to allow calculation of    */
/*         four reciprocals in the kernel.                                  */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*                                                                          */
/*    C CODE                                                                */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*  void DSPF_sp_vecrecip(const    float* x, float* restrict r, int n)           */
/*      {                                                                   */
/*          int i;                                                          */
/*          for(i = 0; i < n; i++)                                          */
/*              r[i] = 1 / x[i];                                            */
/*      }                                                                   */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECRECIP_ASM_H_
#define DSPF_SP_VECRECIP_ASM_H_ 1

void DSPF_sp_vecrecip(const     float * x, float * restrict r, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecrecip_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_vecreci/1117057359  2138  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecrecip

* ======================================================================== *
*  End of file: DSPF_sp_vecrecip_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecsum_/1117057360  2160  0     0       3996      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_vecsum_sq(const float *x,                                  */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs a sum of squares of the elements of the      */
/*   array x and returns the sum.                                           */
/*                                                                          */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     float DSPF_sp_vecsum_sq(const    float *x,int n)                          */
/*     {                                                                    */
/*         int i;                                                           */
/*         float sum=0;                                                     */
/*                                                                          */
/*         for(i=0; i<n; i++)                                               */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECSUM_SQ_ASM_H_
#define DSPF_SP_VECSUM_SQ_ASM_H_ 1

float DSPF_sp_vecsum_sq(const     float * x, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecsum_sq_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_vecsum_/1117057360  2181  0     0       1686      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecsum_sq

* ======================================================================== *
*  End of file: DSPF_sp_vecsum_sq_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_w_vec.h/1117057361  0     0     0       4750      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void DSPF_sp_w_vec(const float* x,                                     */
/*                      const float * y,                                    */
/*                      float m,                                            */
/*                      float * restrict r,                                 */
/*                      int     nr                                          */
/*                     )                                                    */
/*                                                                          */
/*             x    :  Pointer to first input array                         */
/*             y    :  Pointer to second input array                        */
/*             m    :  Weight factor                                        */
/*             r    :  Output array pointer                                 */
/*             nr   :  Number of elements in arrays                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine is used to obtain the weighted vector sum.              */
/*     Both the inputs and output are single precision floating             */
/*     point numbers.                                                       */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_sp_w_vec(    const float *    x,                                */
/*                       const float *    y,                                */
/*                       float         m,                                   */
/*                       float *        restrict r,                         */
/*                       int         nr                                     */
/*                    )                                                     */
/*                                                                          */
/*    {                                                                     */
/*        int i;                                                            */
/*        for (i = 0; i < nr; i++)                                          */
/*            r[i] = (m * x[i]) + y[i];                                     */
/*    }                                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_W_VEC_ASM_H_
#define DSPF_SP_W_VEC_ASM_H_ 1

void DSPF_sp_w_vec(const     float * x, const float * y, float m, float * restrict r, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_w_vec_h.asm                                             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_w_vec.h/1117057361  2204  0     0       1682      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_w_vec

* ======================================================================== *
*  End of file: DSPF_sp_w_vec_h.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_vecmul./1117057362  2223  0     0       4338      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecmul -- Single Precision vector multiplication                 */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void DSPF_sp_vecmul   (const float *x,                                   */
/*                        const float *x,                                   */
/*                        float * restrict r,                               */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             y        :  Pointer to second input array                    */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs an element by element floating point         */
/*   multiply of the vectors x[] and y[] and returns the values in r[].     */
/*                                                                          */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     float sp_vecsum_sq(const    float *x,int n)                         */
/*     {                                                                    */
/*         int i;                                                           */
/*         float sum=0;                                                     */
/*                                                                          */
/*         for(i=0; i<n; i++)                                               */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECMUL_ASM_H_
#define DSPF_SP_VECMUL_ASM_H_ 1

void DSPF_sp_vecmul(const     float * x, const float * y, float * restrict r, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecmul_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_vecmul./1117057362  2241  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecmul -- Single Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecmul

* ======================================================================== *
*  End of file: DSPF_sp_vecmul_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_mat_mul/1117057363  2261  0     0       3828      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                */
/*                                                                          */
/* USAGE                                                                    */
/*     This routine has following C prototype                               */
/*                                                                          */
/*         void DSPF_sp_mat_mul                                                  */
/*         (                                                                */
/*             float *x, int r1, int c1,                                    */
/*             float *y,         int c2,                                    */
/*             float *r,                                                    */
/*         );                                                               */
/*                                                                          */
/*     x[]  : Pointer to r1 by c1 input matrix.                             */
/*     r1   : Number of rows in x.                                          */
/*     c1   : Number of columns in x.  Also number of rows in y.            */
/*     y[]  : Pointer to c1 by c2 input matrix.                             */
/*     c2   : Number of columns in y.                                       */
/*     r[]  : Pointer to r1 by c2 output matrix.                            */
/*                                                                          */
/* DESCRIPTION                                                              */
/*     This function computes the expression "r = x * y" for the matrices   */
/*     x and y.  The column dimension of x must match the row dimension     */
/*     of y.  The resulting matrix has the same number of rows as x and     */
/*     the same number of columns as y.                                     */
/*                                                                          */
/*     The values stored in the matrices are assumed to be single precision */
/*     floating point values.                                               */
/*                                                                          */
/*     This code is suitable for dense matrices.  No optimizations are      */
/*     made for sparse matrices.                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAT_MUL_ASM_H_
#define DSPF_SP_MAT_MUL_ASM_H_ 1

void DSPF_sp_mat_mul(float     * x, int r1, int c1, float * y, int c2, float * r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_mat_mul_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_mat_mul/1117057363  2280  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      14-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_mul

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_mat_tra/1117057364  2301  0     0       3790      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_mat_trans -- Single Precision matrix transpose                   */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_mat_trans(                                                 */
/*                            const float *restrict x,                      */
/*                            int rows,                                     */
/*                            int cols,                                     */
/*                            float *restrict r)                            */
/*                                                                          */
/*          x[r1*c1]:  Input matrix containing r1*c1 floating point         */
/*                     numbers having r1 rows and c1 columns.               */
/*          rows    :  Number of rows in Matrix x.                          */
/*                     Also Number of columns in matrix y                   */
/*          cols    :  No. of columns in Matrx x.                           */
/*                     Also no. of rows in Matrix y.                        */
/*          y[c1*c2]:  Output matrix containing c1*r1 floating point        */
/*                     numbers having c1 rows and r1 columns.               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    This function transposes the input matrix x[] and writes the          */
/*    result to matrix r[].                                                 */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*    The loop is unrolled twice.                                           */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    rows > 0 and cols > 0                                                 */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAT_TRANS_ASM_H_
#define DSPF_SP_MAT_TRANS_ASM_H_ 1

void DSPF_sp_mat_trans(const     float *restrict x, int rows, int cols, float *restrict r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_mat_trans_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_mat_tra/1117057364  2322  0     0       1686      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_trans -- Single Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_trans

* ======================================================================== *
*  End of file: DSPF_sp_mat_trans_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_mat_mul/1117057365  2345  0     0       5724      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_mat_mul_cplx -- complex matrix multiplication                    */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_mat_mul_cplx(                                              */
/*                              const float* x,                             */
/*                              int r1,                                     */
/*                              int c1,                                     */
/*                              const float* y,                             */
/*                              int c2,                                     */
/*                              float* restrict r                           */
/*                           )                                              */
/*                                                                          */
/*            x[2*r1*c1]:   Input matrix containing r1*c1 complex           */
/*                          floating point numbers having r1 rows and c1    */
/*                          columns of complex numbers.                     */
/*            r1        :   Number of rows in Matrix x.                     */
/*            c1        :   No. of columns in Matrx x.                      */
/*                          Also no. of rows in Matrix y.                   */
/*            y[2*c1*c2]:   Input matrix containing c1*c2 complex           */
/*                          floating point numbers having c1 rows and c2    */
/*                          columns of complex numbers.                     */
/*            c2        :   No. of columns in Matrix y.                     */
/*            r[2*r1*c2]:   Output matrix of c1*c2 complex floating         */
/*                          point numbers having c1 rows and c2 columns of  */
/*                          complex numbers.                                */
/*                                                                          */
/*                          Complex numbers are stored consecutively with   */
/*                          Real values are stored in even word positions   */
/*                          and imaginary values in odd positions.          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*        This function computes the expression "r = x * y" for the         */
/*        matrices x and y. The columnar dimension of x must match the row  */
/*        dimension of y. The resulting matrix has the same number of rows  */
/*        as x and the same number of columns as y.                         */
/*                                                                          */
/*        Each element of Matrices are assumed to be complex numbers with   */
/*        Real values are stored in even word positions and imaginary       */
/*        values in odd positions.                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*        Innermost loop is Unrolled twice.                                 */
/*        Two inner loops are collapsed into one loop.                      */
/*        Outermost loop is executed in parallel with innner loops.         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*        c1 >= 4, and r1,r2>=1                                             */
/*        x should be padded with 6 words                                   */
/*        x and y should be double word aligned                             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAT_MUL_CPLX_ASM_H_
#define DSPF_SP_MAT_MUL_CPLX_ASM_H_ 1

void DSPF_sp_mat_mul_cplx(const     float* x, int r1, int c1, const float* y, int c2, float* restrict r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_mat_mul_cplx_h.asm                                      */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_mat_mul/1117057365  2369  0     0       1689      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul_cplx -- complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_mul_cplx

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul_cplx_h.asm                                      *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_blk_mov/1117057366  2395  0     0       3207      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_blk_move -- Single Precision Block Move                          */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_blk_move                                                   */
/*                     (                                                    */
/*                         const float    *r,                               */
/*                         const float *  restrict r,                       */
/*                         int            nx,                               */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data to be moved.                       */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:        Number of floats to move.                               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This routine moves nx floats from memory location pointed to by x  */
/*       to a separate memory location pointed to by r.                     */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_BLK_MOVE_ASM_H_
#define DSPF_SP_BLK_MOVE_ASM_H_ 1

void DSPF_sp_blk_move(const     float * x, float *restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_blk_move_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_blk_mov/1117057366  2415  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_blk_move -- Single Precision Block Move                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_blk_move

* ======================================================================== *
*  End of file: DSPF_sp_blk_move_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap1/1117057367  2437  0     0       3931      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap16                                                   */
/*                     (                                                    */
/*                         void * restrict x,                               */
/*                         void * restrict r,                               */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of shorts (16-bit values) to endian-swap.          */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*         The date in the x array is endian swapped, meaning that the      */
/*      byte-order of the bytest within wach half-word (short) of x is      */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP16_ASM_H_
#define DSPF_BLK_ESWAP16_ASM_H_ 1

void DSPF_blk_eswap16(short     * restrict x, short * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap16_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap1/1117057367  2457  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap16

* ======================================================================== *
*  End of file: DSPF_blk_eswap16_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap3/1117057368  2479  0     0       3931      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap32                                                   */
/*                     (                                                    */
/*                         float * restrict x,                              */
/*                         float * restrict r,                              */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of words (32-bit values) to endian-swap.           */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      The date in the x array is endian swapped, meaning that the         */
/*      byte-order of the bytest within wach word of x is                   */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP32_ASM_H_
#define DSPF_BLK_ESWAP32_ASM_H_ 1

void DSPF_blk_eswap32(float     * restrict x, float * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap32_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap3/1117057367  2499  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap32

* ======================================================================== *
*  End of file: DSPF_blk_eswap32_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap6/1117057368  2521  0     0       3933      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap64                                                   */
/*                     (                                                    */
/*                         double * restrict x,                             */
/*                         double * restrict r,                             */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of double words (64-bit values) to endian-swap.    */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      The date in the x array is endian swapped, meaning that the         */
/*      byte-order of the bytes within each double word of x is             */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP64_ASM_H_
#define DSPF_BLK_ESWAP64_ASM_H_ 1

void DSPF_blk_eswap64(double     * restrict x, double * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap64_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap6/1117057368  2541  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap64

* ======================================================================== *
*  End of file: DSPF_blk_eswap64_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_fltoq15.h/ 1117057369  0     0     0       4801      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       */
/*                                                                          */
/*  USAGE                                                                   */
/*     This routine is C-callable and can be called as:                     */
/*                                                                          */
/*     void DSPF_fltoq15                                                         */
/*     (                                                                    */
/*         const float* restrict x,                                         */
/*         short*       restrict r,                                         */
/*         int         nx                                                   */
/*     );                                                                   */
/*                                                                          */
/*     x[nx] :  Input array contaning values of type float                  */
/*     r[nx] :  Output array contains Q15 equivalents of x[nx]              */
/*     nx    :  Number of elements in both arrays                           */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*     Convert the IEEE floating point numbers stored in vector x[] into    */
/*     Q.15 format numbers stored in vector r[]. Results will be rounded    */
/*     towards negative infinity. All values that exceed the size limit     */
/*     will be saturated to 0x7fff if value is positive and 0x8000 if       */
/*     value is negative.                                                   */
/*                                                                          */
/*  C CODE                                                                  */
/*     void DSPF_fltoq15                                                         */
/*     (                                                                    */
/*         const float* restrict x,                                         */
/*         short*       restrict r,                                         */
/*         int         nx                                                   */
/*     )                                                                    */
/*     {                                                                    */
/*         int i, a;                                                        */
/*                                                                          */
/*         for(i = 0; i < nx; i++)                                          */
/*         {                                                                */
/*             a = floor(32768 * x[i]);                                     */
/*                                                                          */
/*             // saturate to 16-bit //                                     */
/*             if (a>32767)  a =  32767;                                    */
/*             if (a<-32768) a = -32768;                                    */
/*                                                                          */
/*             r[i] = (short) a;                                            */
/*         }                                                                */
/*     }                                                                    */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_FLTOQ15_ASM_H_
#define DSPF_FLTOQ15_ASM_H_ 1

void DSPF_fltoq15(const     float * x, short * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_fltoq15_h.asm                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_fltoq15.h6/1117057369  2563  0     0       1681      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_fltoq15

* ======================================================================== *
*  End of file: DSPF_fltoq15_h.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_minerr./1117057370  2581  0     0       4111      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_minerr -- Searching for a pair of numbers producing maximum      */
/*      dot product                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       float DSPF_sp_minerr(const float* GSP0_TABLE, const float* errCoefs,    */
/*                                              int *restrict max_index)    */
/*                                                                          */
/*          GSP0_TABLE[256*9]: GSP0 terms array.                            */
/*          errCoefs[9]:       Array of error coefficients.                 */
/*                             Must be Double word aligned.                 */
/*          max_index:         Index to GSP0_TABLE[max_index], the first    */
/*                             element of the 9-element vector that         */
/*                             resulted in the maximum dot product.         */
/*          return float       Maximum dot product result.                  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       Performs a dot product on 256 pairs of 9 element vectors and       */
/*       searches for the pair of vectors which produces the maximum dot    */
/*       product result. This is a large part of the VSELP vocoder          */
/*       codebook search.                                                   */
/*                                                                          */
/*       The function stores the index to the first element of the          */
/*       9-element vector that resulted in the maximum dot product in the   */
/*       memory loaction Pointed by max_index. The maximum dot product      */
/*       value is returned by the function.                                 */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The inner loop is totally unrolled.                                 */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      errCoefs must be Double word aligned.                               */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MINERR_ASM_H_
#define DSPF_SP_MINERR_ASM_H_ 1

float DSPF_sp_minerr(const     float* GSP0_TABLE, const float* errCoefs, int *restrict max_index);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_minerr_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_minerr./1117057370  2599  0     0       1761      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minerr -- Searching for a pair of numbers producing maximum      *
*      dot product                                                         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_minerr

* ======================================================================== *
*  End of file: DSPF_sp_minerr_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_q15tofl.h/ 1117057371  0     0     0       3921      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       */
/*      format                                                              */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      float DSPF_q15tofl(short *x, float *r, int nx);                          */
/*                                                                          */
/*      x     : Input array containing shorts in Q15 format                 */
/*      r     : Output array containing equivalent floats                   */
/*      nx    : Number of values in the x vector                            */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine converts data in the Q15 format into IEEE Single Preci */
/*      floating point.                                                     */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*  void DSPF_q15tofl(short    *x, float *r, int nx)                             */
/*     {                                                                    */
/*      int i;                                                              */
/*      for (i=0;i<nx;i++)                                                  */
/*           r[i]=(float)x[i]/0x8000;                                       */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_Q15TOFL_ASM_H_
#define DSPF_Q15TOFL_ASM_H_ 1

void DSPF_q15tofl(const     short * x, float * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_q15tofl_h.asm                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_q15tofl.h6/1117057371  2619  0     0       1759      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       *
*      format                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_q15tofl

* ======================================================================== *
*  End of file: DSPF_q15tofl_h.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_lms.h/  1117057372  0     0     0       9134      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_lms -- Double Precision floating point LMS algorithm             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine is C callable, and has the following C prototype:       */
/*                                                                          */
/*     double DSPF_dp_lms (double *x,                                            */
/*                    double *h,                                             */
/*                    double *desired,                                      */
/*                    double *r,                                            */
/*                    double adaptrate,                                     */
/*                    double error,                                         */
/*                    int nh,                                               */
/*                    int nr                                                */
/*                    )                                                     */
/*                                                                          */
/*      x        :  Pointer to input samples                                */
/*      h        :  Pointer to the coefficient array                        */
/*      desired  :  Pointer to the desired output array                     */
/*      r        :  Pointer to filtered output array                        */
/*      adaptrate:  Adaptation rate                                         */
/*      error    :  Initial error                                           */
/*      nh       :  Number of coefficients                                  */
/*      nr       :  Number of output samples                                */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*     The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  */
/*     signal and a desired input signal, the filter produces an output     */
/*     signal, the final coefficient values and returns the final output    */
/*     error signal.                                                        */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*   1. The inner loop is unrolled Two times to allow update of             */
/*      two coefficients in the kernel.                                     */
/*                                                                          */
/*   2. The 'error' term needs to be computed in the outer loop             */
/*      before a new iteration of the inner loop can start. As a            */
/*      result the prolog cannot be placed in parallel with epilog          */
/*      (after the loop kernel).                                            */
/*                                                                          */
/*  3. Register sharing is used to make optimal use of available            */
/*      registers.                                                          */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*   1. The inner loop counter must be a multiple of 2 and >=2.             */
/*   2. Little endianness is assumed.                                       */
/*   3. Extraneous loads are allowed in the program.                        */
/*   4. The coefficient array is assumed to be in reverse order,            */
/*      i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*   This is the C equivalent of the Assembly Code without                  */
/*   restrictions.                                                          */
/*                                                                          */
/*   Note that the assembly code is hand optimized and restrictions         */
/*   may apply.                                                             */
/*                                                                          */
/*   double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou *e
/*        int nr, double error)                                             */
/*   {                                                                      */
/*       int i,j;                                                           */
/*       double sum;                                                        */
/*                                                                          */
/*       for (i = 0; i < nr; i++)                                           */
/*       {                                                                  */
/*        for (j = 0; j < nh; j++)                                          */
/*        {                                                                 */
/*           h[j] = h[j] + (ar*error*x[i+j-1]);                             */
/*        }                                                                 */
/*                                                                          */
/*       sum = 0.0f;                                                        */
/*        for (j = 0; j < nh; j++)                                          */
/*        {                                                                 */
/*          sum += h[j] * x[i+j];                                           */
/*        }                                                                 */
/*       y[i] = sum;                                                        */
/*       error = d[i] - sum;                                                */
/*      }                                                                   */
/*      return error;                                                       */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt-tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*    (4*nh + 47) nr + 27                                                   */
/*    eg. for nh = 24 and nr = 36                                           */
/*    cycles = 5175                                                         */
/*                                                                          */
/* CODESIZE                                                                 */
/*     640 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_LMS_H_
#define DSPF_DP_LMS_H_ 1

double DSPF_dp_lms     (double *x,
              double *h,
               double *desired,
               double *r,
               double adaptrate,
               double error,
               int nh,
               int nr
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_lms.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_lms.h67/1117057372  0     0     0       9057      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_lms -- Double Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C callable, and has the following C prototype:       *
*                                                                           *
*      double DSPF_dp_lms (double *x,                                            *
*                     double *h,                                             *
*                     double *desired,                                      *
*                     double *r,                                            *
*                     double adaptrate,                                     *
*                     double error,                                         *
*                     int nh,                                               *
*                     int nr                                                *
*                     )                                                     *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  *
*      signal and a desired input signal, the filter produces an output     *
*      signal, the final coefficient values and returns the final output    *
*      error signal.                                                        *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*    1. The inner loop is unrolled Two times to allow update of             *
*       two coefficients in the kernel.                                     *
*                                                                           *
*    2. The 'error' term needs to be computed in the outer loop             *
*       before a new iteration of the inner loop can start. As a            *
*       result the prolog cannot be placed in parallel with epilog          *
*       (after the loop kernel).                                            *
*                                                                           *
*   3. Register sharing is used to make optimal use of available            *
*       registers.                                                          *
*                                                                           *
*    ASSUMPTIONS                                                            *
*    1. The inner loop counter must be a multiple of 2 and >=2.             *
*    2. Little endianness is assumed.                                       *
*    3. Extraneous loads are allowed in the program.                        *
*    4. The coefficient array is assumed to be in reverse order,            *
*       i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    This is the C equivalent of the Assembly Code without                  *
*    restrictions.                                                          *
*                                                                           *
*    Note that the assembly code is hand optimized and restrictions         *
*    may apply.                                                             *
*                                                                           *
*    double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou *e
*         int nr, double error)                                             *
*    {                                                                      *
*        int i,j;                                                           *
*        double sum;                                                        *
*                                                                           *
*        for (i = 0; i < nr; i++)                                           *
*        {                                                                  *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*            h[j] = h[j] + (ar*error*x[i+j-1]);                             *
*         }                                                                 *
*                                                                           *
*        sum = 0.0f;                                                        *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*           sum += h[j] * x[i+j];                                           *
*         }                                                                 *
*        y[i] = sum;                                                        *
*        error = d[i] - sum;                                                *
*       }                                                                   *
*       return error;                                                       *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
*  CYCLES                                                                   *
*     (4*nh + 47) nr + 27                                                   *
*     eg. for nh = 24 and nr = 36                                           *
*     cycles = 5175                                                         *
*                                                                           *
*  CODESIZE                                                                 *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_lms

*  ======================================================================== *
*   End of file:  DSPF_dp_lms.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_autocor/1117057373  2637  0     0       8210      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_autocor -- double Precision autocorrelation                      */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void DSPF_dp_autocor                                                     */
/*      (                                                                   */
/*          double    *  restrict r,                                        */
/*          double    *  restrict x,                                        */
/*          int       nx,                                                   */
/*          int       nr                                                    */
/*      )                                                                   */
/*                                                                          */
/*      r  = Pointer to output array of autocorrelation of length nr        */
/*      x  = Pointer to input array of length nx+nr. Input data must        */
/*           be padded with nr consecutive zeros at the beginning.          */
/*      nx = Length of autocorrelation vector.                              */
/*      nr = Length of lags.                                                */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine performs the autocorrelation of the input array x.     */
/*      is assumed that the length of the input array, x, is a              */
/*      multiple of 2 and the length of the output array, r, is a           */
/*      multiple of 4. The assembly routine computes 4 output samples       */
/*      at a time. It is assumed that input vector x is padded with nr      */
/*      no of zeros in the beginning.                                       */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled twice and the outer loop is unrolled  */
/*      four times.                                                         */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx is a multiple of 2 and greater than or equal to 4.            */
/*      2. nr is a multiple of 4 and greater than or equal to 4.            */
/*      3. nx is greater than or equal to nr                                */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      void DSPF_dp_autocor                                                     */
/*      (                                                                   */
/*          double    *  restrict r,                                        */
/*          double    *  restrict x,                                        */
/*          int       nx,                                                   */
/*          int       nr                                                    */
/*      )                                                                   */
/*      {                                                                   */
/*          int i,k;                                                        */
/*          double sum;                                                     */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              sum = 0;                                                    */
/*              for (k = nr; k < nx+nr; k++)                                */
/*                  sum += x[k] * x[k-i];                                   */
/*              r[i] = sum ;                                                */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*      interruptible.                                                      */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      2*nx*nr + 5/2*nr + 32                                               */
/*      For nx=32 and nr=64, cycles=4258                                    */
/*      For nx=24 and nr=32, cycles=1648                                    */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      576 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_AUTOCOR_H_
#define DSPF_DP_AUTOCOR_H_ 1

void DSPF_dp_autocor
(
    double    *  restrict r,
    double    *  restrict x,
    int       nx,
    int       nr
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_autocor.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_autocor/1117057373  2656  0     0       8264      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_autocor -- double Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*                                                                           *
*       r  = Pointer to output array of autocorrelation of length nr        *
*       x  = Pointer to input array of length nx+nr. Input data must        *
*            be padded with nr consecutive zeros at the beginning.          *
*       nx = Length of autocorrelation vector.                              *
*       nr = Length of lags.                                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs the autocorrelation of the input array x.     *
*       is assumed that the length of the input array, x, is a              *
*       multiple of 2 and the length of the output array, r, is a           *
*       multiple of 4. The assembly routine computes 4 output samples       *
*       at a time. It is assumed that input vector x is padded with nr      *
*       no of zeros in the beginning.                                       *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice and the outer loop is unrolled  *
*       four times.                                                         *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 2 and greater than or equal to 4.            *
*       2. nr is a multiple of 4 and greater than or equal to 4.            *
*       3. nx is greater than or equal to nr                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*       {                                                                   *
*           int i,k;                                                        *
*           double sum;                                                     *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (k = nr; k < nx+nr; k++)                                *
*                   sum += x[k] * x[k-i];                                   *
*               r[i] = sum ;                                                *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*       interruptible.                                                      *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       2*nx*nr + 5/2*nr + 32                                               *
*       For nx=32 and nr=64, cycles=4258                                    *
*       For nx=24 and nr=32, cycles=1648                                    *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       576 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_autocor

*  ======================================================================== *
*   End of file:  DSPF_dp_autocor.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_bitrev_/1117057374  2677  0     0       15918     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         */
/*     numbers                                                             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine is C Callable and can be called as:                     */
/*                                                                          */
/*     void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                */
/*                                                                          */
/*     x      : Complex input array to be bit-reversed.                     */
/*              Contains 2*nx doubles                                       */
/*     index  : Array of size ~sqrt(nx) created by the routine              */
/*              bitrev_index to allow the fast implementation of the        */
/*              bit-reversal.                                               */
/*     nx     : Number of elements in array x[]. Must be power of 2.        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine performs the bit-reversal of the input array x[],       */
/*     where x[] is a double array of length 2*nx containing Double         */
/*     precision floating point complex pairs of data. This routine         */
/*     requires the index array provided by the program below.              */
/*     This index should be generated at compile time not by the DSP.       */
/*                                                                          */
/*     authorizes the use of the bit-reversal code and related table        */
/*     generation code with TMS320-family DSPs manufactured by TI.          */
/*                                                                          */
/*     // ----------------------------------------------------------- //    */
/*     //  This routine calculates the index for bit reversal of      //    */
/*     //  an array of length nx.  The length of the index table is   //    */
/*     //  2^(2*ceil(k/2)) where nx = 2^k.                            //    */
/*     //                                                             //    */
/*     //  In other words, the length of the index table is:          //    */
/*     //      - for even power of radix: sqrt(nx)                    //    */
/*     //      - for odd  power of radix: sqrt(2*nx)                  //    */
/*     // ----------------------------------------------------------- //    */
/*     void bitrev_index(short *index, int nx)                              */
/*     {                                                                    */
/*         int   i, j, k, radix = 2;                                        */
/*         short nbits, nbot, ntop, ndiff, n2, raddiv2;                     */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*             i = i >> 1;                                                  */
/*             nbits++;                                                     */
/*         }                                                                */
/*                                                                          */
/*         raddiv2 = radix >> 1;                                            */
/*         nbot    = nbits >> raddiv2;                                      */
/*         nbot    = nbot << raddiv2 - 1;                                   */
/*         ndiff   = nbits & raddiv2;                                       */
/*         ntop    = nbot + ndiff;                                          */
/*         n2      = 1 << ntop;                                             */
/*                                                                          */
/*         index[0] = 0;                                                    */
/*         for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  */
/*         {                                                                */
/*             index[i] = j - 1;                                            */
/*                                                                          */
/*             for (k = n2/radix; k*(radix-1) < j; k /= radix)              */
/*                 j -= k*(radix-1);                                        */
/*                                                                          */
/*             j += k;                                                      */
/*         }                                                                */
/*         index[n2 - 1] = n2 - 1;                                          */
/*     }                                                                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*     1. nx must be a power of 2.                                          */
/*     2. The table from bitrev_index is already created.                   */
/*     3. The array x is actually an array of 2*nx doubles.                 */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                */
/*      {                                                                   */
/*         int    i;                                                        */
/*         short  i0, i1, i2;                                               */
/*         short  j0, j1, j2;                                               */
/*         double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       */
/*         double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       */
/*         short  t;                                                        */
/*         int    a, b, ia, ib, ibs;                                        */
/*         int    mask;                                                     */
/*         int    nbits, nbot, ntop, ndiff, n2, halfn;                      */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*            i = i >> 1;                                                   */
/*            nbits++;                                                      */
/*         }                                                                */
/*                                                                          */
/*         nbot    = nbits >> 1;                                            */
/*         ndiff   = nbits & 1;                                             */
/*         ntop    = nbot + ndiff;                                          */
/*         n2       = 1 << ntop;                                            */
/*         mask    = n2 - 1;                                                */
/*         halfn   = nx >> 1;                                               */
/*                                                                          */
/*         for (i0 = 0; i0 < halfn; i0 += 2)                                */
/*         {                                                                */
/*             b       = i0 & mask;                                         */
/*             a       = i0 >> nbot;                                        */
/*             if (!b) ia = index[a];                                       */
/*             ib      = index[b];                                          */
/*             ibs     = ib << nbot;                                        */
/*                                                                          */
/*             j0      = ibs + ia;                                          */
/*             t       = i0 < j0;                                           */
/*             xi0r     = x[2*i0];                                          */
/*             xi0i     = x[2*i0+1];                                        */
/*             xj0r     = x[2*j0];                                          */
/*             xj0i     = x[2*j0+1];                                           */
/*             if (t)                                                       */
/*             {                                                            */
/*                x[2*i0]   = xj0r;                                         */
/*                x[2*i0+1] = xj0i;                                         */
/*                x[2*j0]   = xi0r;                                         */
/*                x[2*j0+1] = xi0i;                                         */
/*              }                                                           */
/*                                                                          */
/*             i1      = i0 + 1;                                            */
/*             j1      = j0 + halfn;                                        */
/*             xi1r    = x[2*i1];                                           */
/*             xi1i    = x[2*i1+1];                                         */
/*             xj1r    = x[2*j1];                                           */
/*             xj1i    = x[2*j1+1];                                         */
/*                                                                          */
/*             x[2*i1]   = xj1r;                                            */
/*             x[2*i1+1] = xj1i;                                            */
/*             x[2*j1]   = xi1r;                                            */
/*             x[2*j1+1] = xi1i;                                            */
/*                                                                          */
/*             i2      = i1 + halfn;                                        */
/*             j2      = j1 + 1;                                            */
/*                                                                          */
/*             xi2r    = x[2*i2];                                           */
/*             xi2i    = x[2*i2+1];                                         */
/*             xj2r    = x[2*j2];                                           */
/*             xj2i    = x[2*j2+1];                                         */
/*             if (t)                                                       */
/*             {                                                            */
/*             x[2*i2]   = xj2r;                                            */
/*             x[2*i2+1] = xj2i;                                            */
/*             x[2*j2]   = xi2r;                                            */
/*             x[2*j2+1] = xi2i;                                            */
/*             }                                                            */
/*           }                                                              */
/*                                                                          */
/*         }                                                                */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*     1. The index table can be generated using the bitrev_index           */
/*        function provided in the dsplib\support\fft directory.            */
/*     2. If nx <= 4K one can use the char (8-bit) data type for            */
/*        the "index" variable. This would require changing the LDH when    */
/*        loading index values in the assembly routine to LDB. This would   */
/*        further reduce the size of the Index Table by half its size.      */
/*                                                                          */
/*     3. Endian: LITTLE ENDIAN configuration used.                         */
/*                                                                          */
/*     4. Interruptibility: This code is interrupt tolerant, but not        */
/*        interruptible.                                                    */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*     5*nx + 33                                                            */
/*     e.g. nx = 128, cycles = 673                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     736 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BITREV_CPLX_H_
#define DSPF_DP_BITREV_CPLX_H_ 1

void DSPF_dp_bitrev_cplx(double     *x, short *index, int nx);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_bitrev_cplx.h                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_bitrev_/1117057374  2700  0     0       15933     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C Callable and can be called as:                     *
*                                                                           *
*      void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                *
*                                                                           *
*      x      : Complex input array to be bit-reversed.                     *
*               Contains 2*nx doubles                                       *
*      index  : Array of size ~sqrt(nx) created by the routine              *
*               bitrev_index to allow the fast implementation of the        *
*               bit-reversal.                                               *
*      nx     : Number of elements in array x[]. Must be power of 2.        *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine performs the bit-reversal of the input array x[],       *
*      where x[] is a double array of length 2*nx containing Double         *
*      precision floating point complex pairs of data. This routine         *
*      requires the index array provided by the program below.              *
*      This index should be generated at compile time not by the DSP.       *
*                                                                           *
*      authorizes the use of the bit-reversal code and related table        *
*      generation code with TMS320-family DSPs manufactured by TI.          *
*                                                                           *
*      /* ----------------------------------------------------------- */    *
*      /*  This routine calculates the index for bit reversal of      */    *
*      /*  an array of length nx.  The length of the index table is   */    *
*      /*  2^(2*ceil(k/2)) where nx = 2^k.                            */    *
*      /*                                                             */    *
*      /*  In other words, the length of the index table is:          */    *
*      /*      - for even power of radix: sqrt(nx)                    */    *
*      /*      - for odd  power of radix: sqrt(2*nx)                  */    *
*      /* ----------------------------------------------------------- */    *
*      void bitrev_index(short *index, int nx)                              *
*      {                                                                    *
*          int   i, j, k, radix = 2;                                        *
*          short nbits, nbot, ntop, ndiff, n2, raddiv2;                     *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*              i = i >> 1;                                                  *
*              nbits++;                                                     *
*          }                                                                *
*                                                                           *
*          raddiv2 = radix >> 1;                                            *
*          nbot    = nbits >> raddiv2;                                      *
*          nbot    = nbot << raddiv2 - 1;                                   *
*          ndiff   = nbits & raddiv2;                                       *
*          ntop    = nbot + ndiff;                                          *
*          n2      = 1 << ntop;                                             *
*                                                                           *
*          index[0] = 0;                                                    *
*          for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  *
*          {                                                                *
*              index[i] = j - 1;                                            *
*                                                                           *
*              for (k = n2/radix; k*(radix-1) < j; k /= radix)              *
*                  j -= k*(radix-1);                                        *
*                                                                           *
*              j += k;                                                      *
*          }                                                                *
*          index[n2 - 1] = n2 - 1;                                          *
*      }                                                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*      1. nx must be a power of 2.                                          *
*      2. The table from bitrev_index is already created.                   *
*      3. The array x is actually an array of 2*nx doubles.                 *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                *
*       {                                                                   *
*          int    i;                                                        *
*          short  i0, i1, i2;                                               *
*          short  j0, j1, j2;                                               *
*          double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       *
*          double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       *
*          short  t;                                                        *
*          int    a, b, ia, ib, ibs;                                        *
*          int    mask;                                                     *
*          int    nbits, nbot, ntop, ndiff, n2, halfn;                      *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*             i = i >> 1;                                                   *
*             nbits++;                                                      *
*          }                                                                *
*                                                                           *
*          nbot    = nbits >> 1;                                            *
*          ndiff   = nbits & 1;                                             *
*          ntop    = nbot + ndiff;                                          *
*          n2       = 1 << ntop;                                            *
*          mask    = n2 - 1;                                                *
*          halfn   = nx >> 1;                                               *
*                                                                           *
*          for (i0 = 0; i0 < halfn; i0 += 2)                                *
*          {                                                                *
*              b       = i0 & mask;                                         *
*              a       = i0 >> nbot;                                        *
*              if (!b) ia = index[a];                                       *
*              ib      = index[b];                                          *
*              ibs     = ib << nbot;                                        *
*                                                                           *
*              j0      = ibs + ia;                                          *
*              t       = i0 < j0;                                           *
*              xi0r     = x[2*i0];                                          *
*              xi0i     = x[2*i0+1];                                        *
*              xj0r     = x[2*j0];                                          *
*              xj0i     = x[2*j0+1];                                           *
*              if (t)                                                       *
*              {                                                            *
*                 x[2*i0]   = xj0r;                                         *
*                 x[2*i0+1] = xj0i;                                         *
*                 x[2*j0]   = xi0r;                                         *
*                 x[2*j0+1] = xi0i;                                         *
*               }                                                           *
*                                                                           *
*              i1      = i0 + 1;                                            *
*              j1      = j0 + halfn;                                        *
*              xi1r    = x[2*i1];                                           *
*              xi1i    = x[2*i1+1];                                         *
*              xj1r    = x[2*j1];                                           *
*              xj1i    = x[2*j1+1];                                         *
*                                                                           *
*              x[2*i1]   = xj1r;                                            *
*              x[2*i1+1] = xj1i;                                            *
*              x[2*j1]   = xi1r;                                            *
*              x[2*j1+1] = xi1i;                                            *
*                                                                           *
*              i2      = i1 + halfn;                                        *
*              j2      = j1 + 1;                                            *
*                                                                           *
*              xi2r    = x[2*i2];                                           *
*              xi2i    = x[2*i2+1];                                         *
*              xj2r    = x[2*j2];                                           *
*              xj2i    = x[2*j2+1];                                         *
*              if (t)                                                       *
*              {                                                            *
*              x[2*i2]   = xj2r;                                            *
*              x[2*i2+1] = xj2i;                                            *
*              x[2*j2]   = xi2r;                                            *
*              x[2*j2+1] = xi2i;                                            *
*              }                                                            *
*            }                                                              *
*                                                                           *
*          }                                                                *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1. The index table can be generated using the bitrev_index           *
*         function provided in the dsplib\support\fft directory.            *
*      2. If nx <= 4K one can use the char (8-bit) data type for            *
*         the "index" variable. This would require changing the LDH when    *
*         loading index values in the assembly routine to LDB. This would   *
*         further reduce the size of the Index Table by half its size.      *
*                                                                           *
*      3. Endian: LITTLE ENDIAN configuration used.                         *
*                                                                           *
*      4. Interruptibility: This code is interrupt tolerant, but not        *
*         interruptible.                                                    *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      5*nx + 33                                                            *
*      e.g. nx = 128, cycles = 673                                          *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      736 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_bitrev_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_bitrev_cplx.h67                                        *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_cfftr4_/1117057375  2725  0     0       14391     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      */
/*     Frequency radix-4 FFT with complex input                            */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*  This routine is C Callable and can be called as:                        */
/*                                                                          */
/*  void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       */
/*                                                                          */
/*  x : Pointer to an array holding the input and output floating           */
/*      point array which contains 'n' complex points                       */
/*  w : Pointer to an array holding the coefficient floating point          */
/*      array which contains 3*n/4 complex numbers                          */
/*  n : Number of complex points in x                                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*  This routine implements the DIF (decimation in frequency)               */
/*  complex radix 4 FFT with digit-reversed output and normal               */
/*  order input.  The number of points, 'n', must be a power                */
/*  of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   */
/*  in-place routine in the sense that the output is written                */
/*  over the input.  It is not an in-place routine in the                   */
/*  sense that the input is in normal order and the output is               */
/*  in digit-reversed order.                                                */
/*                                                                          */
/*  There must be n complex points (2*n values), and 3*n/4 complex          */
/*  coefficients (3*n/2 values).                                            */
/*                                                                          */
/*  Each real and imaginary input value is interleaved in the               */
/*  'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             */
/*  are in normal order.  Each real and imaginary output value              */
/*  is interleaved in the 'x' array and the complex numbers are             */
/*  in digit-reversed  order {rx0, ix0, ...}.  The real and                 */
/*  imaginary values of the coefficients are interleaved in the             */
/*  'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           */
/*  are in normal order.                                                    */
/*                                                                          */
/*  Note that the imaginary coefficients are negated                        */
/*  {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           */
/*  {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       */
/*  where d = 2*PI/n.  The value of w(n,k) is usually written               */
/*  w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                */
/*                                                                          */
/*  The routine can be used to implement an inverse FFT by                  */
/*  performing the complex conjugate on the input complex numbers           */
/*  (negating the imaginary value), and dividing the result by n.           */
/*  Another method to use the FFT to perform an inverse FFT, is to          */
/*  swap the real and imaginary values of the input and the result,         */
/*  and divide the result by n.  In either case, the input is still         */
/*  in normal order and the output is still in digit-reversed order.        */
/*                                                                          */
/*  Note that you can not make the radix 4 FFT into an inverse              */
/*  FFT by using the complex conjugate of the coefficients as               */
/*  you can do with the complex radix 2 FFT.                                */
/*                                                                          */
/*  If you label the input locations from 0 to (n-1) (normal order),        */
/*  the digit-reversed locations can be calculated by reversing the         */
/*  order of the bit pairs of the labels.  For example, for a 1024          */
/*  point FFT, the digit reversed location for                              */
/*  617d = 1001101001b = 10 01 10 10 01  is                                 */
/*  422d = 0110100110b = 01 10 10 01 10  and visa versa.                    */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*  1.  All the three loops are executed as one loop with                   */
/*      conditional instructions.                                           */
/*  2.  The outer loop counter is used as load counterto prevent            */
/*      extraneous loads.                                                   */
/*  3.  If more registers were available, the inner loop could              */
/*      probably be as small as 28 cycles,but the loop was extended         */
/*      to 56 cycles to allow more variables to share registers.            */
/*  4.  The pointer for X and W are maintianed  on both register sides      */
/*      to avoid crosspath Conflicts.                                       */
/*  5.  Variable tctr is used as innerloop Counter.                          */
/*  6.  The variable, K, is used as the outer loop counter.We are           */
/*      finished when n2b = 0.                                              */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*  1.  There are no special alignment requirements.                        */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent for the assembly code.  Note that              */
/*  the assembly code is hand optimized and restrictions may                */
/*  apply.                                                                  */
/*                                                                          */
/*  void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       */
/*  {                                                                       */
/*      short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              */
/*      double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               */
/*      double si1, si2, si3;                                               */
/*      n2 = n;                                                             */
/*      ie = 1;                                                             */
/*      for(k=n; k>1; k>>=2)                                                */
/*      {                                                                   */
/*         n1 = n2;                                                         */
/*         n2 >>= 2;                                                        */
/*         ia1 = 0;                                                         */
/*         for(j=0; j<n2; j++)                                              */
/*         {                                                                */
/*             ia2 = ia1 + ia1;                                             */
/*             ia3 = ia1 + ia2;                                             */
/*             co1 = w[ia1*2];                                              */
/*             si1 = w[ia1*2 + 1];                                          */
/*             co2 = w[ia2*2];                                              */
/*             si2 = w[ia2*2 + 1];                                          */
/*             co3 = w[ia3*2];                                              */
/*             si3 = w[ia3*2 + 1];                                          */
/*             ia1 += ie;                                                   */
/*             for(i0=j; i0<n; i0+=n1)                                      */
/*             {                                                            */
/*                 i1 = i0 + n2;                                            */
/*                 i2 = i1 + n2;                                            */
/*                 i3 = i2 + n2;                                            */
/*                 r1 = x[i0*2]   + x[i2*2];                                */
/*                 r3 = x[i0*2]   - x[i2*2];                                */
/*                 s1 = x[i0*2+1] + x[i2*2+1];                              */
/*                 s3 = x[i0*2+1] - x[i2*2+1];                              */
/*                 r2 = x[i1*2]   + x[i3*2];                                */
/*                 r4 = x[i1*2]   - x[i3*2];                                */
/*                 s2 = x[i1*2+1] + x[i3*2+1];                              */
/*                 s4 = x[i1*2+1] - x[i3*2+1];                              */
/*                 x[i0*2]   = r1 + r2;                                     */
/*                 r2        = r1 - r2;                                     */
/*                 r1        = r3 - s4;                                     */
/*                 r3        = r3 + s4;                                     */
/*                 x[i0*2+1] = s1 + s2;                                     */
/*                 s2        = s1 - s2;                                     */
/*                 s1        = s3 + r4;                                     */
/*                 s3        = s3 - r4;                                     */
/*                 x[i1*2]   = co1*r3 + si1*s3;                             */
/*                 x[i1*2+1] = co1*s3 - si1*r3;                             */
/*                 x[i2*2]   = co2*r2 + si2*s2;                             */
/*                 x[i2*2+1] = co2*s2 - si2*r2;                             */
/*                 x[i3*2]   = co3*r1 + si3*s1;                             */
/*                 x[i3*2+1] = co3*s1 - si3*r1;                             */
/*            }                                                             */
/*         }                                                                */
/*         ie <<= 2;                                                        */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. The twiddle factor array w can be generated by the tw_r4fft       */
/*        function provided in dsplib\support\fft\tw_r4fft.c. The exe       */
/*        file for this function, dsplib\bin\tw_r4fft.exe, can be           */
/*        used dump the twiddle factor array into a file.                   */
/*     2. The function bit_rev in dsplib\support\fft can be used to         */
/*        bit-reverse the output array to convert it into normal order.     */
/*     3. Endian: This code is LITTLE  ENDIAN.                              */
/*     4. Interruptibility: This code is interrupt tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*    14*n*log4(n) + 46                                                     */
/*    eg. if n = 256, cycles = 14382.                                       */
/*                                                                          */
/*  CODESIZE                                                                */
/*      1344 bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CFFTR4_DIF_H_
#define DSPF_DP_CFFTR4_DIF_H_ 1

void DSPF_dp_cfftr4_dif(double*     x, double* w, short n);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_cfftr4_dif.h                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_cfftr4_/1117057375  2747  0     0       14429     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      *
*      Frequency radix-4 FFT with complex input                            *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*   This routine is C Callable and can be called as:                        *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*                                                                           *
*   x : Pointer to an array holding the input and output floating           *
*       point array which contains 'n' complex points                       *
*   w : Pointer to an array holding the coefficient floating point          *
*       array which contains 3*n/4 complex numbers                          *
*   n : Number of complex points in x                                       *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*   This routine implements the DIF (decimation in frequency)               *
*   complex radix 4 FFT with digit-reversed output and normal               *
*   order input.  The number of points, 'n', must be a power                *
*   of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   *
*   in-place routine in the sense that the output is written                *
*   over the input.  It is not an in-place routine in the                   *
*   sense that the input is in normal order and the output is               *
*   in digit-reversed order.                                                *
*                                                                           *
*   There must be n complex points (2*n values), and 3*n/4 complex          *
*   coefficients (3*n/2 values).                                            *
*                                                                           *
*   Each real and imaginary input value is interleaved in the               *
*   'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             *
*   are in normal order.  Each real and imaginary output value              *
*   is interleaved in the 'x' array and the complex numbers are             *
*   in digit-reversed  order {rx0, ix0, ...}.  The real and                 *
*   imaginary values of the coefficients are interleaved in the             *
*   'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           *
*   are in normal order.                                                    *
*                                                                           *
*   Note that the imaginary coefficients are negated                        *
*   {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           *
*   {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       *
*   where d = 2*PI/n.  The value of w(n,k) is usually written               *
*   w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                *
*                                                                           *
*   The routine can be used to implement an inverse FFT by                  *
*   performing the complex conjugate on the input complex numbers           *
*   (negating the imaginary value), and dividing the result by n.           *
*   Another method to use the FFT to perform an inverse FFT, is to          *
*   swap the real and imaginary values of the input and the result,         *
*   and divide the result by n.  In either case, the input is still         *
*   in normal order and the output is still in digit-reversed order.        *
*                                                                           *
*   Note that you can not make the radix 4 FFT into an inverse              *
*   FFT by using the complex conjugate of the coefficients as               *
*   you can do with the complex radix 2 FFT.                                *
*                                                                           *
*   If you label the input locations from 0 to (n-1) (normal order),        *
*   the digit-reversed locations can be calculated by reversing the         *
*   order of the bit pairs of the labels.  For example, for a 1024          *
*   point FFT, the digit reversed location for                              *
*   617d = 1001101001b = 10 01 10 10 01  is                                 *
*   422d = 0110100110b = 01 10 10 01 10  and visa versa.                    *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*   1.  All the three loops are executed as one loop with                   *
*       conditional instructions.                                           *
*   2.  The outer loop counter is used as load counterto prevent            *
*       extraneous loads.                                                   *
*   3.  If more registers were available, the inner loop could              *
*       probably be as small as 28 cycles,but the loop was extended         *
*       to 56 cycles to allow more variables to share registers.            *
*   4.  The pointer for X and W are maintianed  on both register sides      *
*       to avoid crosspath Conflicts.                                       *
*   5.  Variable tctr is used as innerloop Counter.                          *
*   6.  The variable, K, is used as the outer loop counter.We are           *
*       finished when n2b = 0.                                              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*   1.  There are no special alignment requirements.                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent for the assembly code.  Note that              *
*   the assembly code is hand optimized and restrictions may                *
*   apply.                                                                  *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*   {                                                                       *
*       short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              *
*       double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               *
*       double si1, si2, si3;                                               *
*       n2 = n;                                                             *
*       ie = 1;                                                             *
*       for(k=n; k>1; k>>=2)                                                *
*       {                                                                   *
*          n1 = n2;                                                         *
*          n2 >>= 2;                                                        *
*          ia1 = 0;                                                         *
*          for(j=0; j<n2; j++)                                              *
*          {                                                                *
*              ia2 = ia1 + ia1;                                             *
*              ia3 = ia1 + ia2;                                             *
*              co1 = w[ia1*2];                                              *
*              si1 = w[ia1*2 + 1];                                          *
*              co2 = w[ia2*2];                                              *
*              si2 = w[ia2*2 + 1];                                          *
*              co3 = w[ia3*2];                                              *
*              si3 = w[ia3*2 + 1];                                          *
*              ia1 += ie;                                                   *
*              for(i0=j; i0<n; i0+=n1)                                      *
*              {                                                            *
*                  i1 = i0 + n2;                                            *
*                  i2 = i1 + n2;                                            *
*                  i3 = i2 + n2;                                            *
*                  r1 = x[i0*2]   + x[i2*2];                                *
*                  r3 = x[i0*2]   - x[i2*2];                                *
*                  s1 = x[i0*2+1] + x[i2*2+1];                              *
*                  s3 = x[i0*2+1] - x[i2*2+1];                              *
*                  r2 = x[i1*2]   + x[i3*2];                                *
*                  r4 = x[i1*2]   - x[i3*2];                                *
*                  s2 = x[i1*2+1] + x[i3*2+1];                              *
*                  s4 = x[i1*2+1] - x[i3*2+1];                              *
*                  x[i0*2]   = r1 + r2;                                     *
*                  r2        = r1 - r2;                                     *
*                  r1        = r3 - s4;                                     *
*                  r3        = r3 + s4;                                     *
*                  x[i0*2+1] = s1 + s2;                                     *
*                  s2        = s1 - s2;                                     *
*                  s1        = s3 + r4;                                     *
*                  s3        = s3 - r4;                                     *
*                  x[i1*2]   = co1*r3 + si1*s3;                             *
*                  x[i1*2+1] = co1*s3 - si1*r3;                             *
*                  x[i2*2]   = co2*r2 + si2*s2;                             *
*                  x[i2*2+1] = co2*s2 - si2*r2;                             *
*                  x[i3*2]   = co3*r1 + si3*s1;                             *
*                  x[i3*2+1] = co3*s1 - si3*r1;                             *
*             }                                                             *
*          }                                                                *
*          ie <<= 2;                                                        *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. The twiddle factor array w can be generated by the tw_r4fft       *
*         function provided in dsplib\support\fft\tw_r4fft.c. The exe       *
*         file for this function, dsplib\bin\tw_r4fft.exe, can be           *
*         used dump the twiddle factor array into a file.                   *
*      2. The function bit_rev in dsplib\support\fft can be used to         *
*         bit-reverse the output array to convert it into normal order.     *
*      3. Endian: This code is LITTLE  ENDIAN.                              *
*      4. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     14*n*log4(n) + 46                                                     *
*     eg. if n = 256, cycles = 14382.                                       *
*                                                                           *
*   CODESIZE                                                                *
*       1344 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_cfftr4_dif

*  ======================================================================== *
*   End of file:  DSPF_dp_cfftr4_dif.h67                                         *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_cfftr2./1117057376  2771  0     0       19475     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_cfftr2 -- Double Precision Cache Optimized radix 2 forward FFT    */
/*     with complex input                                                  */
/*                                                                         */
/* USAGE                                                                    */
/*        This routine is C-callable and can be called as:                  */
/*                                                                          */
/*        void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          */
/*                                                                          */
/*        x : input and output sequences (dim-n)      (input/output)        */
/*            x has n complex numbers (2*n DP values).                      */
/*            The real and imaginary values are interleaved in memory.      */
/*            The input is in normal order and output is in bit-reversed    */
/*            Order.                                                        */
/*        w : FFT coefficients (dim-n)                (input)               */
/*            w has n complex numbers (n DP values).                        */
/*            FFT coeficients are in a special sequence so that FFT can     */
/*            be called on smaller input sets multiple times to avoid       */
/*            cache thrashing.                                              */
/*            The real and imaginary values are interleaved in memory.      */
/*        n : FFT size which is a power of 2 and > 4  (input)               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      This routine is used to compute the Complex, Radix-2, Fast          */
/*      Fourier Transform of a double precision complex sequence of size    */
/*      n, and a power of 2 in a Cache-friendly way. The routine requires   */
/*      normal order input and normal order coefficents (twiddle factors)   */
/*      in a special sequence and produces results that are in              */
/*      bit-reversed order.                                                 */
/*                                                                          */
/*      The input can be broken into smaller parts and called multiple      */
/*      times to avoid cache thrashing.                                     */
/*                                                                          */
/*      How to use                                                          */
/*                                                                          */
/*      void main(void)                                                     */
/*      {                                                                   */
/*         gen_w_r2(w, N);         // Generate coefficient table            */
/*                                 // in normal order                       */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in      */
/*                                 // order bit-reversed                    */
/*                                                                          */
/*        bit_rev(x, N)           // Bit reverse the output if              */
/*                                 // normal order output is needed         */
/*                                 // Function is given in C-CODE section   */
/*      }                                                                   */
/*                                                                          */
/*      main fft of size N can be divided into several steps (where         */
/*      number of steps is a power of 2), allowing as much data             */
/*      reuse as possible.                                                  */
/*                                                                          */
/*      For example the following function                                  */
/*      DSPF_dp_cfftr2(N, x, w, 1);                                              */
/*                                                                          */
/*      is equivalent to:                                                   */
/*                                                                          */
/*      DSPF_dp_cfftr2(N, x, w, N/4);                                            */
/*                                                                          */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                  */
/*                                                                          */
/*      Notice how the 1st fft function is called on the entire data set.   */
/*      It covers the 1st pass of the fft until the butterfly size is       */
/*      N/4. The following 4 ffts do N/4 point ffts, 25% of the original    */
/*      size. These continue down to the end when the buttly is of size     */
/*      2. We use an index of 2* 3/4 *N to the main twiddle factor array    */
/*      for the last 4 calls. This is because the twiddle factor array      */
/*      is composed of successively decimated versions of the main array.   */
/*                                                                          */
/*      The twiddle factor array is composed of log2(N) sets of twiddle     */
/*      factors of size N, N/2, N/4, N/8 etc. The index into this array     */
/*      for each stage of the fft can be calculated by summing these        */
/*      indices up appropriately. For example, if we are dividing the       */
/*      input into 2 parts then index into this array should be N, if we    */
/*      are dividing into 4 parts then index into this array should be      */
/*      N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   */
/*                                                                          */
/*      For multiple ffts they can share the same table by calling the      */
/*      small ffts from further down in the twiddle factor array, in the    */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      The functions for creating this special sequence of twiddle         */
/*      factors and bit-reversal are provided in the C CODE section.        */
/*                                                                          */
/*      In general if divide the input into NO_OF_DIV parts we can call     */
/*      the function as follows:                                            */
/*                                                                          */
/*      // Divide the input into NO_OF_DIV parts                            */
/*      DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                    */
/*                                                                          */
/*                                                                          */
/*      // Find out the index into twiddle factor array                     */
/*      for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       */
/*      {                                                                   */
/*         w_index += j;                                                    */
/*      }                                                                   */
/*      w_index = N * w_index / NO_OF_DIV;                                  */
/*                                                                          */
/*      // Call the Function a subset of inputs                             */
/*      for(i=0; i<NO_OF_DIV; i++)                                          */
/*      {                                                                   */
/*         DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);   */
/*      }                                                                   */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*      1. Outer loop instructions are executed in parallel with the        */
/*         inner loop epilog.                                               */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*      1. Both input x and coefficient w should be aligned on double       */
/*         word boundary.                                                   */
/*      2. n should be greater than 4 and a power of 2.                     */
/*                                                                          */
/* C CODE                                                                   */
/*        This is the C equivalent of the assembly code without             */
/*        restrictions. Note that the assembly code is hand optimized       */
/*        and restrictions may apply.                                       */
/*                                                                          */
/*        void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          */
/*        {                                                                 */
/*             int n2, ie, ia, i, j, k, m;                                  */
/*             double rtemp, itemp, c, s;                                   */
/*                                                                          */
/*             n2 = n;                                                      */
/*             ie = 1;                                                      */
/*                                                                          */
/*             for(k = n; k > n_min; k >>= 1)                               */
/*              {                                                           */
/*                n2 >>= 1;                                                 */
/*                ia = 0;                                                   */
/*                for(j=0; j < ie; j++)                                     */
/*                {                                                         */
/*                 for(i=0; i < n2; i++)                                    */
/*                   {                                                      */
/*                      c = w[2*i];                                         */
/*                      s = w[2*i+1];                                       */
/*                      m = ia + n2;                                        */
/*                      rtemp     = x[2*ia]   - x[2*m];                     */
/*                      x[2*ia]   = x[2*ia]   + x[2*m];                     */
/*                      itemp     = x[2*ia+1] - x[2*m+1];                   */
/*                      x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   */
/*                      x[2*m]    = c*rtemp   - s*itemp;                    */
/*                      x[2*m+1]  = c*itemp   + s*rtemp;                    */
/*                      ia++;                                               */
/*                     }                                                    */
/*                  ia += n2;                                               */
/*                 }                                                        */
/*                ie <<= 1;                                                 */
/*                w = w + k;                                                */
/*             }                                                            */
/*         }                                                                */
/*                                                                          */
/*         The follwoing C code is used to generate the coefficient table.  */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*          //  table of size n complex numbers (or 2*n numbers)            */
/*                                                                          */
/*          void gen_w_r2(double* w, int n)                                 */
/*          {                                                               */
/*               int i, j=1;                                                */
/*               double pi = 4.0*atan(1.0);                                 */
/*               double e = pi*2.0/n;                                       */
/*               for(j=1; j < n; j <<= 1)                                   */
/*               {                                                          */
/*               for(i=0; i < ( n>>1 ); i += j)                             */
/*                  {                                                       */
/*                  *w++   = cos(i*e);                                      */
/*                  *w++   = -sin(i*e);                                     */
/*                  }                                                       */
/*               }                                                          */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*          The follwoing C code is used to bit-reverse the output.         */
/*                                                                          */
/*          bit_rev(double* x, int n)                                       */
/*          {                                                               */
/*            int i, j, k;                                                  */
/*            double rtemp, itemp;                                          */
/*                                                                          */
/*            j = 0;                                                        */
/*            for(i=1; i < (n-1); i++)                                      */
/*            {                                                             */
/*              k = n >> 1;                                                 */
/*               while(k <= j)                                              */
/*               {                                                          */
/*                  j -= k;                                                 */
/*                  k >>= 1;                                                */
/*               }                                                          */
/*               j += k;                                                    */
/*               if(i < j)                                                  */
/*               {                                                          */
/*                  rtemp    = x[j*2];                                      */
/*                  x[j*2]   = x[i*2];                                      */
/*                  x[i*2]   = rtemp;                                       */
/*                  itemp    = x[j*2+1];                                    */
/*                  x[j*2+1] = x[i*2+1];                                    */
/*                  x[i*2+1] = itemp;                                       */
/*               }                                                          */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. The special sequence of twiddle factor array w can be generated  */
/*        using the gen_w_r2 function provided in the previous section.     */
/*                                                                          */
/*      2. Endian:This code is LITTLE ENDIAN.                               */
/*                                                                          */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       4 * n * lg(n) + 16 * lg(n) + 34                                    */
/*       eg. IF n = 64,  cycles = 1666                                      */
/*       eg. IF n = 32,  cycles = 754                                       */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       1408 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CFFTR2_H_
#define DSPF_DP_CFFTR2_H_ 1

void DSPF_dp_cfftr2(int     n, double * x, double * w, int n_min);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_cfftr2.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_cfftr2./1117057376  2789  0     0       19447     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr2 -- Double Precision Cache Optimized radix 2 forward FFT    *
*      with complex input                                                  *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Feb-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*         This routine is C-callable and can be called as:                  *
*                                                                           *
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          *
*                                                                           *
*         x : input and output sequences (dim-n)      (input/output)        *
*             x has n complex numbers (2*n DP values).                      *
*             The real and imaginary values are interleaved in memory.      *
*             The input is in normal order and output is in bit-reversed    *
*             Order.                                                        *
*         w : FFT coefficients (dim-n)                (input)               *
*             w has n complex numbers (n DP values).                        *
*             FFT coeficients are in a special sequence so that FFT can     *
*             be called on smaller input sets multiple times to avoid       *
*             cache thrashing.                                              *
*             The real and imaginary values are interleaved in memory.      *
*         n : FFT size which is a power of 2 and > 4  (input)               *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*       This routine is used to compute the Complex, Radix-2, Fast          *
*       Fourier Transform of a double precision complex sequence of size    *
*       n, and a power of 2 in a Cache-friendly way. The routine requires   *
*       normal order input and normal order coefficents (twiddle factors)   *
*       in a special sequence and produces results that are in              *
*       bit-reversed order.                                                 *
*                                                                           *
*       The input can be broken into smaller parts and called multiple      *
*       times to avoid cache thrashing.                                     *
*                                                                           *
*       How to use                                                          *
*                                                                           *
*       void main(void)                                                     *
*       {                                                                   *
*          gen_w_r2(w, N);         // Generate coefficient table            *
*                                  // in normal order                       *
*                                  // Function is given in C-CODE section   *
*                                                                           *
*         DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in      *
*                                  // order bit-reversed                    *
*                                                                           *
*         bit_rev(x, N)           // Bit reverse the output if              *
*                                  // normal order output is needed         *
*                                  // Function is given in C-CODE section   *
*       }                                                                   *
*                                                                           *
*       main fft of size N can be divided into several steps (where         *
*       number of steps is a power of 2), allowing as much data             *
*       reuse as possible.                                                  *
*                                                                           *
*       For example the following function                                  *
*       DSPF_dp_cfftr2(N, x, w, 1);                                              *
*                                                                           *
*       is equivalent to:                                                   *
*                                                                           *
*       DSPF_dp_cfftr2(N, x, w, N/4);                                            *
*                                                                           *
*       DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                  *
*                                                                           *
*       Notice how the 1st fft function is called on the entire data set.   *
*       It covers the 1st pass of the fft until the butterfly size is       *
*       N/4. The following 4 ffts do N/4 point ffts, 25% of the original    *
*       size. These continue down to the end when the buttly is of size     *
*       2. We use an index of 2* 3/4 *N to the main twiddle factor array    *
*       for the last 4 calls. This is because the twiddle factor array      *
*       is composed of successively decimated versions of the main array.   *
*                                                                           *
*       The twiddle factor array is composed of log2(N) sets of twiddle     *
*       factors of size N, N/2, N/4, N/8 etc. The index into this array     *
*       for each stage of the fft can be calculated by summing these        *
*       indices up appropriately. For example, if we are dividing the       *
*       input into 2 parts then index into this array should be N, if we    *
*       are dividing into 4 parts then index into this array should be      *
*       N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array, in the    *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       The functions for creating this special sequence of twiddle         *
*       factors and bit-reversal are provided in the C CODE section.        *
*                                                                           *
*       In general if divide the input into NO_OF_DIV parts we can call     *
*       the function as follows:                                            *
*                                                                           *
*       // Divide the input into NO_OF_DIV parts                            *
*       DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                    *
*                                                                           *
*                                                                           *
*       // Find out the index into twiddle factor array                     *
*       for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       *
*       {                                                                   *
*          w_index += j;                                                    *
*       }                                                                   *
*       w_index = N * w_index / NO_OF_DIV;                                  *
*                                                                           *
*       // Call the Function a subset of inputs                             *
*       for(i=0; i<NO_OF_DIV; i++)                                          *
*       {                                                                   *
*          DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);   *
*       }                                                                   *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*       1. Outer loop instructions are executed in parallel with the        *
*          inner loop epilog.                                               *
*                                                                           *
*  ASSUMPTIONS                                                              *
*       1. Both input x and coefficient w should be aligned on double       *
*          word boundary.                                                   *
*       2. n should be greater than 4 and a power of 2.                     *
*                                                                           *
*  C CODE                                                                   *
*         This is the C equivalent of the assembly code without             *
*         restrictions. Note that the assembly code is hand optimized       *
*         and restrictions may apply.                                       *
*                                                                           *
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          *
*         {                                                                 *
*              int n2, ie, ia, i, j, k, m;                                  *
*              double rtemp, itemp, c, s;                                   *
*                                                                           *
*              n2 = n;                                                      *
*              ie = 1;                                                      *
*                                                                           *
*              for(k = n; k > n_min; k >>= 1)                               *
*               {                                                           *
*                 n2 >>= 1;                                                 *
*                 ia = 0;                                                   *
*                 for(j=0; j < ie; j++)                                     *
*                 {                                                         *
*                  for(i=0; i < n2; i++)                                    *
*                    {                                                      *
*                       c = w[2*i];                                         *
*                       s = w[2*i+1];                                       *
*                       m = ia + n2;                                        *
*                       rtemp     = x[2*ia]   - x[2*m];                     *
*                       x[2*ia]   = x[2*ia]   + x[2*m];                     *
*                       itemp     = x[2*ia+1] - x[2*m+1];                   *
*                       x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   *
*                       x[2*m]    = c*rtemp   - s*itemp;                    *
*                       x[2*m+1]  = c*itemp   + s*rtemp;                    *
*                       ia++;                                               *
*                      }                                                    *
*                   ia += n2;                                               *
*                  }                                                        *
*                 ie <<= 1;                                                 *
*                 w = w + k;                                                *
*              }                                                            *
*          }                                                                *
*                                                                           *
*          The follwoing C code is used to generate the coefficient table.  *
*                                                                           *
*           #include <math.h>                                               *
*           // generate real and imaginary twiddle                          *
*           //  table of size n complex numbers (or 2*n numbers)            *
*                                                                           *
*           void gen_w_r2(double* w, int n)                                 *
*           {                                                               *
*                int i, j=1;                                                *
*                double pi = 4.0*atan(1.0);                                 *
*                double e = pi*2.0/n;                                       *
*                for(j=1; j < n; j <<= 1)                                   *
*                {                                                          *
*                for(i=0; i < ( n>>1 ); i += j)                             *
*                   {                                                       *
*                   *w++   = cos(i*e);                                      *
*                   *w++   = -sin(i*e);                                     *
*                   }                                                       *
*                }                                                          *
*           }                                                               *
*                                                                           *
*                                                                           *
*           The follwoing C code is used to bit-reverse the output.         *
*                                                                           *
*           bit_rev(double* x, int n)                                       *
*           {                                                               *
*             int i, j, k;                                                  *
*             double rtemp, itemp;                                          *
*                                                                           *
*             j = 0;                                                        *
*             for(i=1; i < (n-1); i++)                                      *
*             {                                                             *
*               k = n >> 1;                                                 *
*                while(k <= j)                                              *
*                {                                                          *
*                   j -= k;                                                 *
*                   k >>= 1;                                                *
*                }                                                          *
*                j += k;                                                    *
*                if(i < j)                                                  *
*                {                                                          *
*                   rtemp    = x[j*2];                                      *
*                   x[j*2]   = x[i*2];                                      *
*                   x[i*2]   = rtemp;                                       *
*                   itemp    = x[j*2+1];                                    *
*                   x[j*2+1] = x[i*2+1];                                    *
*                   x[i*2+1] = itemp;                                       *
*                }                                                          *
*             }                                                             *
*           }                                                               *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. The special sequence of twiddle factor array w can be generated  *
*         using the gen_w_r2 function provided in the previous section.     *
*                                                                           *
*       2. Endian:This code is LITTLE ENDIAN.                               *
*                                                                           *
*       3. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*        4 * n * lg(n) + 16 * lg(n) + 34                                    *
*        eg. IF n = 64,  cycles = 1666                                      *
*        eg. IF n = 32,  cycles = 754                                       *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*        1408 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_cfftr2

*  ======================================================================== *
*   End of file:  DSPF_dp_cfftr2.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_icfftr2/1117057378  2809  0     0       21572     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      */
/*      FFT with complex input                                              */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*        This routine is C-callable and can be called as:                  */
/*                                                                          */
/*        void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)         */
/*                                                                          */
/*        x : input and output sequences (dim-n)      (input/output)        */
/*            x has n complex numbers (2*n DP values).                      */
/*            The real and imaginary values are interleaved in memory.      */
/*            The input is in normal order and output is in bit-reversed    */
/*            Order.                                                        */
/*        w : FFT coefficients (dim-n)                (input)               */
/*            w has n complex numbers (n DP values).                        */
/*            FFT coeficients are in a special sequence so that FFT can     */
/*            be called on smaller input sets multiple times to avoid       */
/*            cache thrashing.                                              */
/*            The real and imaginary values are interleaved in memory.      */
/*        n : FFT size which is a power of 2 and > 4  (input)               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine is used to compute the Inverse Complex, Radix-2, Fast  */
/*      Fourier Transform of a double precision complex sequence of size    */
/*      n, and a power of 2 in a Cache-friendly way. The routine requires   */
/*      normal order input and normal order coefficents (twiddle factors)   */
/*      in a special sequence and produces results that are in              */
/*      bit-reversed order.                                                 */
/*                                                                          */
/*      The input can be broken into smaller parts and called multiple      */
/*      times to avoid cache thrashing.                                     */
/*                                                                          */
/*      How to use                                                          */
/*                                                                          */
/*      void main(void)                                                     */
/*      {                                                                   */
/*         gen_w_r2(w, N);         // Generate coefficient table            */
/*                                 // in normal order                       */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        DSPF_dp_icfftr2(N, x, w, 1);  // input in normal order, output in      */
/*                                 // order bit-reversed                    */
/*                                                                          */
/*        bit_rev(x, N)            // Bit reverse the output if             */
/*                                 // normal order output is needed         */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        divide(x, N);            // scale inverse FFT output              */
/*                                 // result is the same as original        */
/*                                 // input                                 */
/*                                                                          */
/*     }                                                                    */
/*                                                                          */
/*      main Inverse fft of size N can be divided into several steps (where */
/*      number of steps is a power of 2), allowing as much data             */
/*      reuse as possible.                                                  */
/*                                                                          */
/*      For example the following function                                  */
/*      DSPF_dp_icfftr2(N, x, w, 1);                                             */
/*                                                                          */
/*      is equivalent to:                                                   */
/*                                                                          */
/*      DSPF_dp_icfftr2(N, x, w, N/4);                                           */
/*                                                                          */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                 */
/*                                                                          */
/*      Notice how the 1st icfft function is called on the entire data set. */
/*      It covers the 1st pass of the fft until the butterfly size is       */
/*      N/4. The following 4 ffts do N/4 point ffts, 25% of the original    */
/*      size. These continue down to the end when the buttly is of size     */
/*      2. We use an index of 2* 3/4 *N to the main twiddle factor array    */
/*      for the last 4 calls. This is because the twiddle factor array      */
/*      is composed of successively decimated versions of the main array.   */
/*                                                                          */
/*      The twiddle factor array is composed of log2(N) sets of twiddle     */
/*      factors of size N, N/2, N/4, N/8 etc. The index into this array     */
/*      for each stage of the fft can be calculated by summing these        */
/*      indices up appropriately. For example, if we are dividing the       */
/*      input into 2 parts then index into this array should be N, if we    */
/*      are dividing into 4 parts then index into this array should be      */
/*      N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   */
/*                                                                          */
/*      For multiple iffts they can share the same table by calling the     */
/*      small iffts from further down in the twiddle factor array, in the   */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      The functions for creating this special sequence of twiddle         */
/*      factors and bit-reversal are provided in the C CODE section.        */
/*                                                                          */
/*      In general if divide the input into NO_OF_DIV parts we can call     */
/*      the function as follows:                                            */
/*                                                                          */
/*      // Divide the input into NO_OF_DIV parts                            */
/*      DSPF_dp_icfftr2(N, x, w, N/NO_OF_DIV);                                   */
/*                                                                          */
/*                                                                          */
/*      // Find out the index into twiddle factor array                     */
/*      for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       */
/*      {                                                                   */
/*         w_index += j;                                                    */
/*      }                                                                   */
/*      w_index = N * w_index / NO_OF_DIV;                                  */
/*                                                                          */
/*      // Call the Function a subset of inputs                             */
/*      for(i=0; i<NO_OF_DIV; i++)                                          */
/*      {                                                                   */
/*         DSPF_dp_icfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);  */
/*      }                                                                   */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*      1. Outer loop instructions are executed in parallel with the        */
/*         inner loop epilog.                                               */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*      1. Both input x and coefficient w should be aligned on double       */
/*         word boundary.                                                   */
/*      2. n should be greater than 4 and a power of 2.                     */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*        This is the C equivalent of the assembly code without             */
/*        restrictions. Note that the assembly code is hand optimized       */
/*        and restrictions may apply.                                       */
/*                                                                          */
/*        void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)         */
/*        {                                                                 */
/*             int n2, ie, ia, i, j, k, m;                                  */
/*             double rtemp, itemp, c, s;                                   */
/*                                                                          */
/*             n2 = n;                                                      */
/*             ie = 1;                                                      */
/*                                                                          */
/*             for(k = n; k > n_min; k >>= 1)                               */
/*              {                                                           */
/*                n2 >>= 1;                                                 */
/*                ia = 0;                                                   */
/*                for(j=0; j < ie; j++)                                     */
/*                {                                                         */
/*                 for(i=0; i < n2; i++)                                    */
/*                   {                                                      */
/*                      c = w[2*i];                                         */
/*                      s = w[2*i+1];                                       */
/*                      m = ia + n2;                                        */
/*                      rtemp     = x[2*ia]   - x[2*m];                     */
/*                      x[2*ia]   = x[2*ia]   + x[2*m];                     */
/*                      itemp     = x[2*ia+1] - x[2*m+1];                   */
/*                      x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   */
/*                      x[2*m]    = c*rtemp   + s*itemp;                    */
/*                      x[2*m+1]  = c*itemp   - s*rtemp;                    */
/*                      ia++;                                               */
/*                     }                                                    */
/*                  ia += n2;                                               */
/*                 }                                                        */
/*                ie <<= 1;                                                 */
/*                w = w + k;                                                */
/*             }                                                            */
/*         }                                                                */
/*                                                                          */
/*         The follwoing C code is used to generate the coefficient table.  */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*          // table of size n complex numbers (or 2*n numbers)             */
/*                                                                          */
/*          void gen_w_r2(double* w, int n)                                 */
/*          {                                                               */
/*               int i, j=1;                                                */
/*               double pi = 4.0*atan(1.0);                                 */
/*               double e = pi*2.0/n;                                       */
/*               for(j=1; j < n; j <<= 1)                                   */
/*               {                                                          */
/*               for(i=0; i < ( n>>1 ); i += j)                             */
/*                  {                                                       */
/*                  *w++   = cos(i*e);                                      */
/*                  *w++   = -sin(i*e);                                     */
/*                  }                                                       */
/*               }                                                          */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*          The follwoing C code is used to bit-reverse the output.         */
/*                                                                          */
/*          bit_rev(double* x, int n)                                       */
/*          {                                                               */
/*            int i, j, k;                                                  */
/*            double rtemp, itemp;                                          */
/*                                                                          */
/*            j = 0;                                                        */
/*            for(i=1; i < (n-1); i++)                                      */
/*            {                                                             */
/*              k = n >> 1;                                                 */
/*               while(k <= j)                                              */
/*               {                                                          */
/*                  j -= k;                                                 */
/*                  k >>= 1;                                                */
/*               }                                                          */
/*               j += k;                                                    */
/*               if(i < j)                                                  */
/*               {                                                          */
/*                  rtemp    = x[j*2];                                      */
/*                  x[j*2]   = x[i*2];                                      */
/*                  x[i*2]   = rtemp;                                       */
/*                  itemp    = x[j*2+1];                                    */
/*                  x[j*2+1] = x[i*2+1];                                    */
/*                  x[i*2+1] = itemp;                                       */
/*               }                                                          */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to perform the final scaling           */
/*      of the IFFT:                                                        */
/*                                                                          */
/*      // divide each element of x by n                                    */
/*                                                                          */
/*      divide(double* x, int n)                                            */
/*      {                                                                   */
/*        int i;                                                            */
/*        double inv = 1.0 / n;                                             */
/*                                                                          */
/*         for(i=0; i < n; i++)                                             */
/*          {                                                               */
/*              x[2*i] = inv * x[2*i];                                      */
/*              x[2*i+1] = inv * x[2*i+1];                                  */
/*            }                                                             */
/*       }                                                                  */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. The special sequence of twiddle factor array w can be generated  */
/*        using the gen_w_r2 function provided in the previous section.     */
/*                                                                          */
/*      2. Endian:This code is LITTLE ENDIAN.                               */
/*                                                                          */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       4 * n * lg(n) + 16 * lg(n) + 34                                    */
/*       eg. IF n = 64,  cycles = 1666                                      */
/*       eg. IF n = 32,  cycles = 754                                       */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       1408 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_ICFFTR2_ASM_H_
#define DSPF_DP_ICFFTR2_ASM_H_ 1

void DSPF_dp_icfftr2(int     n, double * x, double * w, int n_min);

#endif
/* ======================================================================== */
/*  End of file: DSPF_dp_icfftr2_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2004 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_icfftr2/1117057377  2828  0     0       1762      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      *
*      FFT with complex input                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      12-Feb-2004                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_dp_icfftr2

* ======================================================================== *
*  End of file: DSPF_dp_icfftr2_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_fir_cpl/1117057379  2849  0     0       8398      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     */
/*     Filter                                                              */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_fir_cplx(                                                  */
/*                        const double * restrict x,                        */
/*                        const double * restrict h,                        */
/*                        double *       restrict r,                        */
/*                        int   nh,                                         */
/*                        int   nr                                          */
/*                       )                                                  */
/*                                                                          */
/*            x[2*(nr+nh-1)]: Pointer to complex input array.               */
/*                            The input data pointer x must point to the    */
/*                           (nh)th complex element, i.e. element 2*(nh-1). */
/*            h[2*nh]       : Pointer to complex coefficient array          */
/*                            (in normal order).                            */
/*            r[2*nr]       : Pointer to complex output array.              */
/*            nh            : Number of complex coefficients in vector h.   */
/*            nr            : Number of complex output samples to           */
/*                           calculate.                                     */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*       This function implements the FIR filter for complex input data.    */
/*       The filter has nr output samples and nh coefficients. Each array   */
/*       consists of an even and odd term with even terms representing the  */
/*       real part and the odd terms the imaginary part of the element.     */
/*       The coefficients are expected in normal order.                     */
/*                                                                          */
/*                                                                          */
/*     TECHNIQUES                                                           */
/*                                                                          */
/*    1. The outer loop is unrolled twice.                                  */
/*    2. Outer loop instructions are executed in parallel with inner loop.  */
/*    3. Register Sharing is used to make optimal use of available register *
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    1. nr is a multiple of 2 and greater than or equal to 2.              */
/*    2. nh is greater than or equal to 4.                                  */
/*    3. x points to 2*(nh-1)th input element.                              */
/*                                                                          */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*  void DSPF_dp_fir_cplx(const double * x, const double * h,                    */
/*                   double * restrict r, int nh, int nr)                   */
/*  {                                                                       */
/*       int i,j;                                                           */
/*       double imag, real;                                                 */
/*       for (i = 0; i < 2*nr; i += 2)                                      */
/*       {                                                                  */
/*           imag = 0;                                                      */
/*           real = 0;                                                      */
/*           for (j = 0; j < 2*nh; j += 2)                                  */
/*           {                                                              */
/*               real += h[j] * x[i-j] - h[j+1] * x[i+1-j];                 */
/*               imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];                 */
/*           }                                                              */
/*           r[i] = real;                                                   */
/*           r[i+1] = imag;                                                 */
/*       }                                                                  */
/*  }                                                                       */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt-tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*  8*nh*nr + 5*nr + 30                                                     */
/*  For nh=24 and nr=48, cycles=9486                                        */
/*  For nh=16 and nr=36, cycles=4818                                        */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*  608 bytes                                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_CPLX_H_
#define DSPF_DP_FIR_CPLX_H_ 1

void DSPF_dp_fir_cplx(
                 const double * restrict x,
                 const double * restrict h,
                 double *       restrict r,
                 int   nh,
                 int   nr
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_cplx.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_fir_cpl/1117057378  2869  0     0       8343      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_cplx(                                                  *
*                         const double * restrict x,                        *
*                         const double * restrict h,                        *
*                         double *       restrict r,                        *
*                         int   nh,                                         *
*                         int   nr                                          *
*                        )                                                  *
*                                                                           *
*             x[2*(nr+nh-1)]: Pointer to complex input array.               *
*                             The input data pointer x must point to the    *
*                            (nh)th complex element, i.e. element 2*(nh-1). *
*             h[2*nh]       : Pointer to complex coefficient array          *
*                             (in normal order).                            *
*             r[2*nr]       : Pointer to complex output array.              *
*             nh            : Number of complex coefficients in vector h.   *
*             nr            : Number of complex output samples to           *
*                            calculate.                                     *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        This function implements the FIR filter for complex input data.    *
*        The filter has nr output samples and nh coefficients. Each array   *
*        consists of an even and odd term with even terms representing the  *
*        real part and the odd terms the imaginary part of the element.     *
*        The coefficients are expected in normal order.                     *
*                                                                           *
*                                                                           *
*      TECHNIQUES                                                           *
*                                                                           *
*     1. The outer loop is unrolled twice.                                  *
*     2. Outer loop instructions are executed in parallel with inner loop.  *
*     3. Register Sharing is used to make optimal use of available register *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. nr is a multiple of 2 and greater than or equal to 2.              *
*     2. nh is greater than or equal to 4.                                  *
*     3. x points to 2*(nh-1)th input element.                              *
*                                                                           *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_cplx(const double * x, const double * h,                    *
*                    double * restrict r, int nh, int nr)                   *
*   {                                                                       *
*        int i,j;                                                           *
*        double imag, real;                                                 *
*        for (i = 0; i < 2*nr; i += 2)                                      *
*        {                                                                  *
*            imag = 0;                                                      *
*            real = 0;                                                      *
*            for (j = 0; j < 2*nh; j += 2)                                  *
*            {                                                              *
*                real += h[j] * x[i-j] - h[j+1] * x[i+1-j];                 *
*                imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];                 *
*            }                                                              *
*            r[i] = real;                                                   *
*            r[i+1] = imag;                                                 *
*        }                                                                  *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*   8*nh*nr + 5*nr + 30                                                     *
*   For nh=24 and nr=48, cycles=9486                                        *
*   For nh=16 and nr=36, cycles=4818                                        *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   608 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_cplx.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fir_gen/1117057379  2891  0     0       8125      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*   This routine is C Callable and can be called as:                       */
/*                                                                          */
/*       void DSPF_dp_fir_gen(const double *x, const double *h,                  */
/*                              double * restrict r,int nh, int nr);        */
/*                                                                          */
/*       x : Pointer to array holding the input floating point array        */
/*       h : Pointer to array holding the coefficient floating point        */
/*           array                                                          */
/*       r : Pointer to output array                                        */
/*       nh: Number of coefficents                                          */
/*       nr: Number of output values                                        */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine implements a block FIR filter.  There are "nh"        */
/*       filter coefficients, "nr" output samples, and "nh+nr-1"            */
/*       input samples.    The coefficients need to be placed in the "h"    */
/*       array in reverse order {h(nh-1), ... , h(1), h(0)} and the         */
/*       array "x" starts at x(-nh+1) and ends at x(nr-1).  The             */
/*       routine calculates y(0) through y(nr-1) using the following        */
/*       formula:                                                           */
/*                                                                          */
/*       r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           */
/*                                                                          */
/*       where n = {0, 1, ... , nr-1}.                                      */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*       1.  The outer loop is unrolled 4 times.                            */
/*       2.  The inner loop is unrolled 2 times and software pipelined.     */
/*       3.  Register sharing is used to make optimum utilisation of        */
/*           available registers                                            */
/*       4.  Outerlop instructions and Prolog for next stage are scheduled  */
/*           in parallel with last iteration of kernel                      */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*       1.  Little Endian is assumed for LDDW instructions.                */
/*       2.  The number of coefficients must be greater than                */
/*           or equal to 4.                                                 */
/*       3.  The number of outputs must be greater than or equal to 4       */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*       This is the C equivalent for the assembly code.  Note that         */
/*       the assembly code is hand optimized and restrictions may           */
/*       apply.                                                             */
/*                                                                          */
/*       void DSPF_dp_fir_gen(const double *x, const double *h,                  */
/*                   double * restrict r, int nh, int nr)                   */
/*       {                                                                  */
/*          int i, j;                                                       */
/*          double sum;                                                     */
/*                                                                          */
/*          for(i=0; i < nr; i++)                                           */
/*          {                                                               */
/*             sum = 0;                                                     */
/*             for(j=0; j < nh; j++)                                        */
/*             {                                                            */
/*                 sum += x[i+j] * h[j];                                    */
/*             }                                                            */
/*             r[i] = sum;                                                  */
/*          }                                                               */
/*       }                                                                  */
/*                                                                          */
/*                                                                          */
/*   NOTES                                                                  */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/*   CYCLES                                                                 */
/*                                                                          */
/*   (16*floor((nh+1)/2)+10)*(ceil(nr/4)) + 32                              */
/*    for nh=26, nr=42, cycles=2430 cycles.                                 */
/*                                                                          */
/*   CODESIZE                                                               */
/*                                                                          */
/*    672 bytes                                                             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_GEN_H_
#define DSPF_DP_FIR_GEN_H_ 1

void DSPF_dp_fir_gen(const     double *x, const double *h,
                       double * restrict r,int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_gen.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fir_gen/1117057379  2910  0     0       8185      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*    This routine is C Callable and can be called as:                       *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                               double * restrict r,int nh, int nr);        *
*                                                                           *
*        x : Pointer to array holding the input floating point array        *
*        h : Pointer to array holding the coefficient floating point        *
*            array                                                          *
*        r : Pointer to output array                                        *
*        nh: Number of coefficents                                          *
*        nr: Number of output values                                        *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine implements a block FIR filter.  There are "nh"        *
*        filter coefficients, "nr" output samples, and "nh+nr-1"            *
*        input samples.    The coefficients need to be placed in the "h"    *
*        array in reverse order {h(nh-1), ... , h(1), h(0)} and the         *
*        array "x" starts at x(-nh+1) and ends at x(nr-1).  The             *
*        routine calculates y(0) through y(nr-1) using the following        *
*        formula:                                                           *
*                                                                           *
*        r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           *
*                                                                           *
*        where n = {0, 1, ... , nr-1}.                                      *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*        1.  The outer loop is unrolled 4 times.                            *
*        2.  The inner loop is unrolled 2 times and software pipelined.     *
*        3.  Register sharing is used to make optimum utilisation of        *
*            available registers                                            *
*        4.  Outerlop instructions and Prolog for next stage are scheduled  *
*            in parallel with last iteration of kernel                      *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*        1.  Little Endian is assumed for LDDW instructions.                *
*        2.  The number of coefficients must be greater than                *
*            or equal to 4.                                                 *
*        3.  The number of outputs must be greater than or equal to 4       *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*        This is the C equivalent for the assembly code.  Note that         *
*        the assembly code is hand optimized and restrictions may           *
*        apply.                                                             *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                    double * restrict r, int nh, int nr)                   *
*        {                                                                  *
*           int i, j;                                                       *
*           double sum;                                                     *
*                                                                           *
*           for(i=0; i < nr; i++)                                           *
*           {                                                               *
*              sum = 0;                                                     *
*              for(j=0; j < nh; j++)                                        *
*              {                                                            *
*                  sum += x[i+j] * h[j];                                    *
*              }                                                            *
*              r[i] = sum;                                                  *
*           }                                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*    NOTES                                                                  *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*    CYCLES                                                                 *
*                                                                           *
*    (16*floor((nh+1)/2)+10)*(ceil(nr/4)) + 32                              *
*     for nh=26, nr=42, cycles=2430 cycles.                                 *
*                                                                           *
*    CODESIZE                                                               *
*                                                                           *
*     672 bytes                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_gen

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_gen.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fir_r2./1117057380  2931  0     0       7895      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       */
/*     Filter                                                              */
/*                                                                         */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_fir_r2(                                                    */
/*                     const double * restrict x,                           */
/*                     const double * restrict h,                           */
/*                     double      * restrict r,                            */
/*                     int   nh,                                            */
/*                     int   nr                                             */
/*                     )                                                    */
/*            x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           */
/*            h[nh]     : Pointer to coefficient array of size nh.          */
/*                        (in reverse order).                               */
/*            r[nr]     : Pointer to output array of size nr.               */
/*            nh        : Number of coefficients                            */
/*            nr        : Number of output samples.                         */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*       Computes a real FIR filter (direct-form) using coefficients        */
/*       stored in vector h[]. The real data input is stored in vector      */
/*       x[]. The filter output result is stored in vector r[]. The         */
/*       filter calculates nr output samples using nh coefficients.         */
/*       The coefficients are expected to be in reverse order.              */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       1. The outer loop is unrolled four times and inner loop is         */
/*          unrolled twice.                                                 */
/*       2. Register sharing is used to make optimum utilisation of         */
/*          available Registers                                             */
/*       3. Outer loop instructions are executed in parallel with           */
/*          inner loop.                                                     */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nr is a multiple of 2 and greater than or equal to 2.           */
/*       2. nh is a multiple of 2 and greater than or equal to 8.           */
/*       3. Coefficients in array h are expected to be in reverse order.    */
/*       4. x and h should be padded with 4 words at the end.               */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*  void DSPF_dp_fir_r2(const double * x, const double * h,                      */
/*                     double *restrict r, int nh, int nr)                  */
/*  {                                                                       */
/*      int i, j;                                                           */
/*      double sum;                                                         */
/*                                                                          */
/*      for (i = 0; i < nr; i++)                                            */
/*      {                                                                   */
/*          sum = 0;                                                        */
/*                                                                          */
/*          for (j = 0; j < nh; j++)                                        */
/*             sum += x[i + j] * h[j];                                      */
/*             r[i] = sum;                                                  */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*   (8*nh + 10)*ceil(nr/4) + 32                                            */
/*    For nh=24 and nr=62, cycles=3264                                      */
/*                                                                          */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*  672 bytes                                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_R2_H_
#define DSPF_DP_FIR_R2_H_ 1

void DSPF_dp_fir_r2(
              const double * restrict x,
              const double * restrict h,
              double      * restrict r,
              int   nh,
              int   nr
              );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_r2.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fir_r2./1117057380  2949  0     0       7867      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_r2(                                                    *
*                      const double * restrict x,                           *
*                      const double * restrict h,                           *
*                      double      * restrict r,                            *
*                      int   nh,                                            *
*                      int   nr                                             *
*                      )                                                    *
*             x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           *
*             h[nh]     : Pointer to coefficient array of size nh.          *
*                         (in reverse order).                               *
*             r[nr]     : Pointer to output array of size nr.               *
*             nh        : Number of coefficients                            *
*             nr        : Number of output samples.                         *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        Computes a real FIR filter (direct-form) using coefficients        *
*        stored in vector h[]. The real data input is stored in vector      *
*        x[]. The filter output result is stored in vector r[]. The         *
*        filter calculates nr output samples using nh coefficients.         *
*        The coefficients are expected to be in reverse order.              *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*        1. The outer loop is unrolled four times and inner loop is         *
*           unrolled twice.                                                 *
*        2. Register sharing is used to make optimum utilisation of         *
*           available Registers                                             *
*        3. Outer loop instructions are executed in parallel with           *
*           inner loop.                                                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*        1. nr is a multiple of 2 and greater than or equal to 2.           *
*        2. nh is a multiple of 2 and greater than or equal to 8.           *
*        3. Coefficients in array h are expected to be in reverse order.    *
*        4. x and h should be padded with 4 words at the end.               *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_r2(const double * x, const double * h,                      *
*                      double *restrict r, int nh, int nr)                  *
*   {                                                                       *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*           sum = 0;                                                        *
*                                                                           *
*           for (j = 0; j < nh; j++)                                        *
*              sum += x[i + j] * h[j];                                      *
*              r[i] = sum;                                                  *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*    (8*nh + 10)*ceil(nr/4) + 32                                            *
*     For nh=24 and nr=62, cycles=3264                                      *
*                                                                           *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   672 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_r2

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_r2.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fircirc/1117057381  2969  0     0       9001      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine has following C prototype:                               */
/*                                                                          */
/*    void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          */
/*                     int csize, int nh, int nr)                           */
/*                                                                          */
/*            x[]     :     Input array (circular buffer of 2^(csize+1)     */
/*                          bytes)                                          */
/*                          Must be aligned at 2^(csize+1) byte boundary    */
/*            h[nh]   :     Filter coefficients array                       */
/*                          Must be double-word aligned                     */
/*            r[nr]   :     Output array                                    */
/*            index   :     Offset by which to start reading from the       */
/*                          input array. Must be multiple of 2              */
/*            csize   :     Size of circular buffer x[] is 2^(csize+1)      */
/*                          bytes. Must be 2 <= csize <= 31.                */
/*            nh      :     Number of filter coefficients                   */
/*                          Must be multiple of 2 and >= 4                  */
/*            nr      :     Size of output array                            */
/*                          Must be multiple of 4                           */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*    This routine implements a circularly addressed FIR filter.            */
/*    'nh' is the number of filter coefficients. 'nr' is the number         */
/*    of the output samples.                                                */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*    1. The outer loop is unrolled 4 times.                                */
/*    2. The inner loop is unrolled 2 times.                                */
/*    3. Regiter sharing is udes to make optimal utilisation of the         */
/*       available registers.                                               */
/*    4. Outerloop instructions and Prolog for next stage are               */
/*       scheduled in the last cycle of Kernel.                             */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*    1. The circular input buffer x[] must be aligned at a 2^(csize+1)     */
/*       byte boundary. csize must lie in the range 2 <= csize <= 31.       */
/*    2. The number of coefficients  (nh) must be a multiple of 2           */
/*       and greater than or equal to 4.                                    */
/*    3. The number of outputs (nr) must be a multiple of 4 and             */
/*       greater than or equal to 4.                                        */
/*    4. The 'index' (offset to start reading input array) must be          */
/*       mutiple of 2 and less than or equal to (2^(csize-2) - 6)           */
/*    5. The coefficient array is assumed to be in reverse order,           */
/*       i.e. h(nh-1) to h(0) hold coeffs. h0, h1, h2 etc.                  */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*    This is the C equivalent for the assembly code.  Note that            */
/*    the assembly code is hand optimized and restrictions may              */
/*    apply.                                                                */
/*                                                                          */
/*    void DSPF_dp_fircirc  (double x[], double h[], double r[], int index,      */
/*                                  int csize, int nh, int nr)              */
/*      {                                                                   */
/*        int i, j;                                                         */
/*        //Circular Buffer block size = ((2^(csize + 1)) / 8)              */
/*        //floating point numbers                                          */
/*        int mod = (1 << (csize - 2));                                     */
/*        double r0;                                                        */
/*                                                                          */
/*        for (i = 0; i < nr; i++)                                          */
/*        {                                                                 */
/*            r0 = 0;                                                       */
/*            for (j = 0; j < nh; j++)                                      */
/*            {                                                             */
/*             //Operation "% mod" is equivalent to "& (mod -1)"            */
/*             //r0 += x[(i + j + index) % mod] * h[j];                     */
/*                                                                          */
/*               r0 += x[(i + j + index) & (mod - 1)] * h[j];               */
/*            }                                                             */
/*            r[i] = r0;                                                    */
/*        }                                                                 */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt-tolerant but not          */
/*       interruptible.                                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*    (2*nh + 2) nr + 38                                                    */
/*     For nh = 36 & nr=64, cycles = 4774                                   */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*     640 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIRCIRC_H_
#define DSPF_DP_FIRCIRC_H_ 1

void DSPF_dp_fircirc     (double *x, double *h, double *r, int index,
                 int csize, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fircirc.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fircirc/1117057381  2988  0     0       9054      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      30-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          *
*                      int csize, int nh, int nr)                           *
*                                                                           *
*             x[]     :     Input array (circular buffer of 2^(csize+1)     *
*                           bytes)                                          *
*                           Must be aligned at 2^(csize+1) byte boundary    *
*             h[nh]   :     Filter coefficients array                       *
*                           Must be double-word aligned                     *
*             r[nr]   :     Output array                                    *
*             index   :     Offset by which to start reading from the       *
*                           input array. Must be multiple of 2              *
*             csize   :     Size of circular buffer x[] is 2^(csize+1)      *
*                           bytes. Must be 2 <= csize <= 31.                *
*             nh      :     Number of filter coefficients                   *
*                           Must be multiple of 2 and >= 4                  *
*             nr      :     Size of output array                            *
*                           Must be multiple of 4                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This routine implements a circularly addressed FIR filter.            *
*     'nh' is the number of filter coefficients. 'nr' is the number         *
*     of the output samples.                                                *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*     1. The outer loop is unrolled 4 times.                                *
*     2. The inner loop is unrolled 2 times.                                *
*     3. Regiter sharing is udes to make optimal utilisation of the         *
*        available registers.                                               *
*     4. Outerloop instructions and Prolog for next stage are               *
*        scheduled in the last cycle of Kernel.                             *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The circular input buffer x[] must be aligned at a 2^(csize+1)     *
*        byte boundary. csize must lie in the range 2 <= csize <= 31.       *
*     2. The number of coefficients  (nh) must be a multiple of 2           *
*        and greater than or equal to 4.                                    *
*     3. The number of outputs (nr) must be a multiple of 4 and             *
*        greater than or equal to 4.                                        *
*     4. The 'index' (offset to start reading input array) must be          *
*        mutiple of 2 and less than or equal to (2^(csize-2) - 6)           *
*     5. The coefficient array is assumed to be in reverse order,           *
*        i.e. h(nh-1) to h(0) hold coeffs. h0, h1, h2 etc.                  *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*     This is the C equivalent for the assembly code.  Note that            *
*     the assembly code is hand optimized and restrictions may              *
*     apply.                                                                *
*                                                                           *
*     void DSPF_dp_fircirc  (double x[], double h[], double r[], int index,      *
*                                   int csize, int nh, int nr)              *
*       {                                                                   *
*         int i, j;                                                         *
*         //Circular Buffer block size = ((2^(csize + 1)) / 8)              *
*         //floating point numbers                                          *
*         int mod = (1 << (csize - 2));                                     *
*         double r0;                                                        *
*                                                                           *
*         for (i = 0; i < nr; i++)                                          *
*         {                                                                 *
*             r0 = 0;                                                       *
*             for (j = 0; j < nh; j++)                                      *
*             {                                                             *
*              //Operation "% mod" is equivalent to "& (mod -1)"            *
*              //r0 += x[(i + j + index) % mod] * h[j];                     *
*                                                                           *
*                r0 += x[(i + j + index) & (mod - 1)] * h[j];               *
*             }                                                             *
*             r[i] = r0;                                                    *
*         }                                                                 *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*     (2*nh + 2) nr + 38                                                    *
*      For nh = 36 & nr=64, cycles = 4774                                   *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fircirc

*  ======================================================================== *
*   End of file:  DSPF_dp_fircirc.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_biquad./1117057382  3009  0     0       7714      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine has following C prototype:                               */
/*                                                                          */
/*    void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        */
/*                   double *r, int nx)                                     */
/*                                                                          */
/*           x       :  Pointer to input samples                            */
/*           b       :  Pointer to Nr coefs b0, b1, b2                      */
/*           a       :  Pointer to Dr coefs a1, a2                          */
/*           delay   :  Pointer to filter delays                            */
/*           r       :  Pointer to output samples                           */
/*           nx      :  Number of input/output samples                      */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine implements a DF 2 transposed structure of the biquad   */
/*      filter. The transfer function of a biquad can be written            */
/*      as:                                                                 */
/*                                                                          */
/*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)         */
/*                       H(Z) =     _________________________________       */
/*                                    1 + a(1)z^(-1) + a(2)z^(-2)           */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*        1.  Register sharing has been used to optimize on the use of      */
/*            registers.                                                    */
/*        2.  x[i] is loaded on both sides to avoid crosspath conflict         */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*        1. The value of nx is >=4.                                        */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*   void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,         */
/*                                                double *r,  int nx)       */
/*      {                                                                   */
/*       int i;                                                             */
/*       double a1, a2, b0, b1, b2, d0, d1, x_i;                            */
/*                                                                          */
/*       a1 = a[0];                                                         */
/*       a2 = a[1];                                                         */
/*                                                                          */
/*       b0 = b[0];                                                         */
/*       b1 = b[1];                                                         */
/*       b2 = b[2];                                                         */
/*                                                                          */
/*       d0 = delay[0];                                                     */
/*       d1 = delay[1];                                                     */
/*                                                                          */
/*       for (i = 0; i < nx; i++)                                           */
/*       {                                                                  */
/*           x_i = x[i];                                                    */
/*           r[i] = b0 * x_i + d0;                                          */
/*           d0 = b1 * x_i - a1 * r[i] + d1;                                */
/*           d1 = b2 * x_i - a2 * r[i];                                     */
/*       }                                                                  */
/*       delay[0] = d0;                                                     */
/*       delay[1] = d1;                                                     */
/*  }                                                                       */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       16 * nx + 49                                                       */
/*       For nx = 64,  cycles = 1073                                        */
/*       For nx = 48,  cycles = 817.                                        */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       576 bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BIQUAD_H_
#define DSPF_DP_BIQUAD_H_ 1

void DSPF_dp_biquad(double     *x, double *b, double *a, double *delay,
               double *r, int nx);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_biquad.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_biquad./1117057382  3027  0     0       7792      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      03-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        *
*                    double *r, int nx)                                     *
*                                                                           *
*            x       :  Pointer to input samples                            *
*            b       :  Pointer to Nr coefs b0, b1, b2                      *
*            a       :  Pointer to Dr coefs a1, a2                          *
*            delay   :  Pointer to filter delays                            *
*            r       :  Pointer to output samples                           *
*            nx      :  Number of input/output samples                      *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*       This routine implements a DF 2 transposed structure of the biquad   *
*       filter. The transfer function of a biquad can be written            *
*       as:                                                                 *
*                                                                           *
*                                    b(0) + b(1)z^(-1) + b(2)z^(-2)         *
*                        H(Z) =     _________________________________       *
*                                     1 + a(1)z^(-1) + a(2)z^(-2)           *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*         1.  Register sharing has been used to optimize on the use of      *
*             registers.                                                    *
*         2.  x[i] is loaded on both sides to avoid crosspath conflict         *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*         1. The value of nx is >=4.                                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*    void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,         *
*                                                 double *r,  int nx)       *
*       {                                                                   *
*        int i;                                                             *
*        double a1, a2, b0, b1, b2, d0, d1, x_i;                            *
*                                                                           *
*        a1 = a[0];                                                         *
*        a2 = a[1];                                                         *
*                                                                           *
*        b0 = b[0];                                                         *
*        b1 = b[1];                                                         *
*        b2 = b[2];                                                         *
*                                                                           *
*        d0 = delay[0];                                                     *
*        d1 = delay[1];                                                     *
*                                                                           *
*        for (i = 0; i < nx; i++)                                           *
*        {                                                                  *
*            x_i = x[i];                                                    *
*            r[i] = b0 * x_i + d0;                                          *
*            d0 = b1 * x_i - a1 * r[i] + d1;                                *
*            d1 = b2 * x_i - a2 * r[i];                                     *
*        }                                                                  *
*        delay[0] = d0;                                                     *
*        delay[1] = d1;                                                     *
*   }                                                                       *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*        16 * nx + 49                                                       *
*        For nx = 64,  cycles = 1073                                        *
*        For nx = 48,  cycles = 817.                                        *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*        576 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_biquad

*  ======================================================================== *
*   End of file:  DSPF_dp_biquad.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_iir.h/  1117057383  0     0     0       8557      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*   This routine is C callable, and has the following C prototype:         */
/*                                                                          */
/*      void DSPF_dp_iir    (double* restrict r1,                                */
/*                      const double*    x,                                 */
/*                      double* restrict r2,                                */
/*                      const double*    h2,                                */
/*                      const double*    h1,                                */
/*                      int nr                                              */
/*                     );                                                   */
/*                                                                          */
/*           r1[nr+4]   :  Delay element values (i/p and o/p)               */
/*           x[nr]      :  Pointer to the input array                       */
/*           r2[nr+4]   :  Pointer to the output array                      */
/*           h2[5]      :  Auto-regressive filter coefficients              */
/*           h1[5]      :  Moving average filter coefficients               */
/*           nr         :  Number of output samples                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    The IIR performs an auto-regressive moving-average (ARMA)             */
/*    filter with 4 auto-regressive filter coefficients and 5               */
/*    moving-average filter coefficients for nr output samples.             */
/*    The output vector is stored in two locations. This routine            */
/*    is used as a high pass filter in the VSELP vocoder. The               */
/*    4 values in the r1 vector store the initial values of the             */
/*    delays.                                                               */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*    1. The inner loop is completely unrolled so that two loops            */
/*       become one loop.                                                   */
/*    2. Register Sharing is used to make Optimum Utilisation of            */
/*       available registers.                                               */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    1. The value of 'nr' must be > 0.                                     */
/*    2. Extraneous loads are allowed in the program.                       */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the Assembly Code without                   */
/*  restrictions.                                                           */
/*                                                                          */
/*  Note that the assembly code is hand optimized and restrictions          */
/*  may apply.                                                              */
/*                                                                          */
/*  void DSPF_dp_iir (double* restrict r1,                                       */
/*               const double*    x,                                        */
/*               double* restrict r2,                                       */
/*               const double*    h2,                                       */
/*               const double*    h1,                                       */
/*               int nr                                                     */
/*               )                                                          */
/*   {                                                                      */
/*      int i, j;                                                           */
/*      double sum;                                                         */
/*                                                                          */
/*      for (i = 0; i < nr; i++)                                            */
/*      {                                                                   */
/*         sum = h2[0] * x[4+i];                                            */
/*         for (j = 1; j <= 4; j++)                                         */
/*            sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];                  */
/*                                                                          */
/*         r1[4+i] = sum;                                                   */
/*         r2[i] = r1[4+i];                                                 */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. Endian: The code is LITTLE ENDIAN.                                */
/*     2. Interruptibility: This code is interrupt-tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     24*nr + 48                                                           */
/*     eg. for nr = 32, cycles = 816.                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     608 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_IIR_H_
#define DSPF_DP_IIR_H_ 1

void DSPF_dp_iir        (double* restrict r1,
                const double*    x,
                double* restrict r2,
                const double*    h2,
                const double*    h1,
                int nr
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_iir.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_iir.h67/1117057383  0     0     0       8497      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*    This routine is C callable, and has the following C prototype:         *
*                                                                           *
*       void DSPF_dp_iir    (double* restrict r1,                                *
*                       const double*    x,                                 *
*                       double* restrict r2,                                *
*                       const double*    h2,                                *
*                       const double*    h1,                                *
*                       int nr                                              *
*                      );                                                   *
*                                                                           *
*            r1[nr+4]   :  Delay element values (i/p and o/p)               *
*            x[nr]      :  Pointer to the input array                       *
*            r2[nr+4]   :  Pointer to the output array                      *
*            h2[5]      :  Auto-regressive filter coefficients              *
*            h1[5]      :  Moving average filter coefficients               *
*            nr         :  Number of output samples                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*     The IIR performs an auto-regressive moving-average (ARMA)             *
*     filter with 4 auto-regressive filter coefficients and 5               *
*     moving-average filter coefficients for nr output samples.             *
*     The output vector is stored in two locations. This routine            *
*     is used as a high pass filter in the VSELP vocoder. The               *
*     4 values in the r1 vector store the initial values of the             *
*     delays.                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*     1. The inner loop is completely unrolled so that two loops            *
*        become one loop.                                                   *
*     2. Register Sharing is used to make Optimum Utilisation of            *
*        available registers.                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. The value of 'nr' must be > 0.                                     *
*     2. Extraneous loads are allowed in the program.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the Assembly Code without                   *
*   restrictions.                                                           *
*                                                                           *
*   Note that the assembly code is hand optimized and restrictions          *
*   may apply.                                                              *
*                                                                           *
*   void DSPF_dp_iir (double* restrict r1,                                       *
*                const double*    x,                                        *
*                double* restrict r2,                                       *
*                const double*    h2,                                       *
*                const double*    h1,                                       *
*                int nr                                                     *
*                )                                                          *
*    {                                                                      *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*          sum = h2[0] * x[4+i];                                            *
*          for (j = 1; j <= 4; j++)                                         *
*             sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];                  *
*                                                                           *
*          r1[4+i] = sum;                                                   *
*          r2[i] = r1[4+i];                                                 *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. Endian: The code is LITTLE ENDIAN.                                *
*      2. Interruptibility: This code is interrupt-tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      24*nr + 48                                                           *
*      eg. for nr = 32, cycles = 816.                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      608 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_iir

*  ======================================================================== *
*   End of file:  DSPF_dp_iir.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_iirlat./1117057384  3047  0     0       8538      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*        This routine has following C prototype:                           */
/*                                                                          */
/*            void DSPF_dp_iirlat(                                               */
/*                          double *x,                                      */
/*                          int nx,                                         */
/*                          const double * restrict k,                      */
/*                          int nk,                                         */
/*                          double * restrict b,                            */
/*                          double * r                                      */
/*                          )                                               */
/*         x[nx]   : Input vector                                           */
/*         nx      : Length of input vector.                                */
/*         k[nk]   : Reflection coefficients                                */
/*         nk      : Number of reflection coefficients/lattice stages       */
/*                   Must be multiple of 2 and >=6.                         */
/*         b[nk+1] : Delay line elements from previous call. Should be      */
/*                   initialized to all zeros prior to the first call.      */
/*         r[nx]   : Output vector                                          */
/*                                                                          */
/*     DESCRIPTION                                                          */
/*                                                                          */
/*         This routine implements a real all-pole IIR filter in lattice    */
/*     structure (AR lattice). The filter consists of nk lattice stages.    */
/*     Each  stage  requires one  reflection coefficient  k and one delay   */
/*     element b. The routine takes an input vector x[] and returns the     */
/*     filter output in r[]. Prior to the first call of the outine the      */
/*     delay elements in b[]  should be set to zero. The input data may     */
/*     have to be pre-scaled to avoid overflow or achieve better SNR. The   */
/*     reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     */
/*     order of the coefficients is such that k[nk-1] corresponds to the    */
/*     first lattice stage after the input and k[0] Corresponds to the      */
/*     last stage.                                                          */
/*                                                                          */
/*    TECHNIQUES                                                            */
/*                                                                          */
/*         1.  The loop has been unrolled by 4 times.                       */
/*                                                                          */
/*         2.  Register sharing has been used to optimize on the            */
/*             use of registers.                                            */
/*                                                                          */
/*    ASSUMPTIONS                                                           */
/*                                                                          */
/*        1. nk is a multiple of 2 and >=6.                                 */
/*        2. Extraneous loads are allowed (80 bytes) before the start of    */
/*           array.                                                         */
/*                                                                          */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*   void DSPF_dp_iirlat(double * x, int nx, const double * restrict k, int nk,  */
/*                   double * restrict b, double * r)                       */
/*   {                                                                      */
/*                                                                          */
/*      double rt;     // output       //                                   */
/*      int i, j;                                                           */
/*                                                                          */
/*      for (j = 0; j < nx; j++)                                            */
/*      {                                                                   */
/*         rt = x[j];                                                       */
/*                                                                          */
/*         for (i = nk - 1; i >= 0; i--)                                    */
/*         {                                                                */
/*             rt = rt - b[i] * k[i];                                       */
/*             b[i + 1] = b[i] + rt * k[i];                                 */
/*         }                                                                */
/*                                                                          */
/*         b[0] = rt;                                                       */
/*         r[j] = rt;                                                       */
/*      }                                                                   */
/*    }                                                                     */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      (24*Ceil(nk/4) + 19)* nx + 33                                       */
/*       For nk = 14, nx = 64 cycles = 7393                                 */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*        832 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_IIRLAT_H_
#define DSPF_DP_IIRLAT_H_ 1

void DSPF_dp_iirlat(
              double *x,
              int nx,
              const double * restrict k,
              int nk,
              double * restrict b,
              double * r
              );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_iirlat.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_iirlat./1117057384  3065  0     0       8500      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*         This routine has following C prototype:                           *
*                                                                           *
*             void DSPF_dp_iirlat(                                               *
*                           double *x,                                      *
*                           int nx,                                         *
*                           const double * restrict k,                      *
*                           int nk,                                         *
*                           double * restrict b,                            *
*                           double * r                                      *
*                           )                                               *
*          x[nx]   : Input vector                                           *
*          nx      : Length of input vector.                                *
*          k[nk]   : Reflection coefficients                                *
*          nk      : Number of reflection coefficients/lattice stages       *
*                    Must be multiple of 2 and >=6.                         *
*          b[nk+1] : Delay line elements from previous call. Should be      *
*                    initialized to all zeros prior to the first call.      *
*          r[nx]   : Output vector                                          *
*                                                                           *
*      DESCRIPTION                                                          *
*                                                                           *
*          This routine implements a real all-pole IIR filter in lattice    *
*      structure (AR lattice). The filter consists of nk lattice stages.    *
*      Each  stage  requires one  reflection coefficient  k and one delay   *
*      element b. The routine takes an input vector x[] and returns the     *
*      filter output in r[]. Prior to the first call of the outine the      *
*      delay elements in b[]  should be set to zero. The input data may     *
*      have to be pre-scaled to avoid overflow or achieve better SNR. The   *
*      reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     *
*      order of the coefficients is such that k[nk-1] corresponds to the    *
*      first lattice stage after the input and k[0] Corresponds to the      *
*      last stage.                                                          *
*                                                                           *
*     TECHNIQUES                                                            *
*                                                                           *
*          1.  The loop has been unrolled by 4 times.                       *
*                                                                           *
*          2.  Register sharing has been used to optimize on the            *
*              use of registers.                                            *
*                                                                           *
*     ASSUMPTIONS                                                           *
*                                                                           *
*         1. nk is a multiple of 2 and >=6.                                 *
*         2. Extraneous loads are allowed (80 bytes) before the start of    *
*            array.                                                         *
*                                                                           *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    void DSPF_dp_iirlat(double * x, int nx, const double * restrict k, int nk,  *
*                    double * restrict b, double * r)                       *
*    {                                                                      *
*                                                                           *
*       double rt;     // output       //                                   *
*       int i, j;                                                           *
*                                                                           *
*       for (j = 0; j < nx; j++)                                            *
*       {                                                                   *
*          rt = x[j];                                                       *
*                                                                           *
*          for (i = nk - 1; i >= 0; i--)                                    *
*          {                                                                *
*              rt = rt - b[i] * k[i];                                       *
*              b[i + 1] = b[i] + rt * k[i];                                 *
*          }                                                                *
*                                                                           *
*          b[0] = rt;                                                       *
*          r[j] = rt;                                                       *
*       }                                                                   *
*     }                                                                     *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (24*Ceil(nk/4) + 19)* nx + 33                                       *
*        For nk = 14, nx = 64 cycles = 7393                                 *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_iirlat

*  ======================================================================== *
*   End of file:  DSPF_dp_iirlat.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_convol./1117057385  3085  0     0       8817      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_convol -- Double Precision convolution                           */
/*                                                                         */
/* USAGE                                                                    */
/*    This routine has the following C prototype:                           */
/*                                                                          */
/*    void DSPF_dp_convol                                                        */
/*         (                                                                */
/*               double *x, //x: Pointer to input samples//                 */
/*               double *h, //h: Pointer to impulse response samples//      */
/*               double *r, //r: Pointer to output samples//                */
/*               int   nh, //nh: Number of impulse response samples//       */
/*               int   nr  //nr: Number of output samples//                 */
/*         )                                                                */
/*                                                                          */
/*          x = pointer to real input vector of size = nr+nh-1              */
/*          a typically contains input data (x) padded with                 */
/*          consecutive nh - 1  zeros at the beginning and end.             */
/*          h = pointer to real input vector of size nh in forward order.   */
/*          h typically contains the filter coefs.                          */
/*          r = Pointer to real output vector of size nr                    */
/*          nh= Number of elements in vector b. NOTE: nh <= nr  nh is       */
/*          typically noted as m in convol formulas. nh must be a           */
/*          MULTIPLE of 2                                                   */
/*          nr= Number of elements in vector r. nr must be a MULTIPLE of 4  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*          This function calculates the full-length convolution of real    */
/*          vectors x and h using time-domain techniques. The result is     */
/*          placed in real vector r.                                        */
/*                                                                          */
/*          It is assumed that input vector x is padded with nh-1 no of     */
/*          zeros in the beginning and end.                                 */
/*                                                                          */
/*          It is assumed that the length of the input vector h, nh, is a   */
/*          multiple of 2 and the length of the output vector r, nr, is a   */
/*          multiple of 4. nh is greater than or equal to 4 and nr is       */
/*          greater than or equal to nh. The routine computes 4 output      */
/*          samples at a time.                                              */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*          1. The inner loop is unrolled twice and the outer loop is       */
/*             unrolled four times.                                         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*          1. nh is a multiple of 2 and greater than or equal to 4         */
/*          2. nr is a multiple of 4                                        */
/*                                                                          */
/*  C CODE                                                                  */
/*          This is the C equivalent of the assembly code.  Note that       */
/*          the assembly code is hand optimized and restrictions may        */
/*          apply.                                                          */
/*                                                                          */
/*                                                                          */
/*          void DSPF_dp_convol(double *x, double *h, double *r, short nh,       */
/*                         short nr)                                        */
/*          {                                                               */
/*            short   octr, ictr;                                           */
/*            double  acc ;                                                 */
/*                                                                          */
/*            for (octr = nr ; octr > 0 ; octr--)                           */
/*            {                                                             */
/*              acc = 0 ;                                                   */
/*                                                                          */
/*              for (ictr = nh ; ictr > 0 ; ictr--)                         */
/*              {                                                           */
/*             acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       */
/*              }                                                           */
/*              r[nr-octr] = acc;                                           */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*          1. Endian: This code is LITTLE ENDIAN.                          */
/*          2. Interruptibility: This code is interrupt tolerant but not    */
/*                       interruptible.                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*          2*(nh*nr) + 5/2*nr + 32                                         */
/*          For nh=24 and nr=48, cycles=2456                                */
/*          For nh=20 and nr=32, cycles=1392                                */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*          544 bytes                                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CONVOL_H_
#define DSPF_DP_CONVOL_H_ 1

void DSPF_dp_convol
     (
           double *x, //x: Pointer to input samples//
           double *h, //h: Pointer to impulse response samples//
           double *r, //r: Pointer to output samples//
           int   nh, //nh: Number of impulse response samples//
           int   nr  //nr: Number of output samples//
     );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_convol.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_convol./1117057385  3103  0     0       8658      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_convol -- Double Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*     This routine has the following C prototype:                           *
*                                                                           *
*     void DSPF_dp_convol                                                        *
*          (                                                                *
*                double *x, //x: Pointer to input samples//                 *
*                double *h, //h: Pointer to impulse response samples//      *
*                double *r, //r: Pointer to output samples//                *
*                int   nh, //nh: Number of impulse response samples//       *
*                int   nr  //nr: Number of output samples//                 *
*          )                                                                *
*                                                                           *
*           x = pointer to real input vector of size = nr+nh-1              *
*           a typically contains input data (x) padded with                 *
*           consecutive nh - 1  zeros at the beginning and end.             *
*           h = pointer to real input vector of size nh in forward order.   *
*           h typically contains the filter coefs.                          *
*           r = Pointer to real output vector of size nr                    *
*           nh= Number of elements in vector b. NOTE: nh <= nr  nh is       *
*           typically noted as m in convol formulas. nh must be a           *
*           MULTIPLE of 2                                                   *
*           nr= Number of elements in vector r. nr must be a MULTIPLE of 4  *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*           This function calculates the full-length convolution of real    *
*           vectors x and h using time-domain techniques. The result is     *
*           placed in real vector r.                                        *
*                                                                           *
*           It is assumed that input vector x is padded with nh-1 no of     *
*           zeros in the beginning and end.                                 *
*                                                                           *
*           It is assumed that the length of the input vector h, nh, is a   *
*           multiple of 2 and the length of the output vector r, nr, is a   *
*           multiple of 4. nh is greater than or equal to 4 and nr is       *
*           greater than or equal to nh. The routine computes 4 output      *
*           samples at a time.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*           1. The inner loop is unrolled twice and the outer loop is       *
*              unrolled four times.                                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*           1. nh is a multiple of 2 and greater than or equal to 4         *
*           2. nr is a multiple of 4                                        *
*                                                                           *
*   C CODE                                                                  *
*           This is the C equivalent of the assembly code.  Note that       *
*           the assembly code is hand optimized and restrictions may        *
*           apply.                                                          *
*                                                                           *
*                                                                           *
*           void DSPF_dp_convol(double *x, double *h, double *r, short nh,       *
*                          short nr)                                        *
*           {                                                               *
*             short   octr, ictr;                                           *
*             double  acc ;                                                 *
*                                                                           *
*             for (octr = nr ; octr > 0 ; octr--)                           *
*             {                                                             *
*               acc = 0 ;                                                   *
*                                                                           *
*               for (ictr = nh ; ictr > 0 ; ictr--)                         *
*               {                                                           *
*              acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       *
*               }                                                           *
*               r[nr-octr] = acc;                                           *
*             }                                                             *
*           }                                                               *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*           1. Endian: This code is LITTLE ENDIAN.                          *
*           2. Interruptibility: This code is interrupt tolerant but not    *
*                        interruptible.                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*           2*(nh*nr) + 5/2*nr + 32                                         *
*           For nh=24 and nr=48, cycles=2456                                *
*           For nh=20 and nr=32, cycles=1392                                *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*           544 bytes                                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_convol

*  ======================================================================== *
*   End of file:  DSPF_dp_convol.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_dotp_sq/1117057386  3123  0     0       7174      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_dotp_sqr(                                                */
/*                       double G,                                          */
/*                       const double * x,                                  */
/*                       const double * y,                                  */
/*                       double *  restrict r,                              */
/*                       int   nx                                           */
/*                       )                                                  */
/*            G:      Sum of y-squared initial value.                       */
/*            x[nx]:  Pointer to First input array.                         */
/*            y[nx]:  Pointer to Second input array.                        */
/*            r:      Pointer to Output for Accumulation of x[]*y[].        */
/*            nx:     Length of input vectors.                              */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine computes the dot product of x[] and y[] arrays,       */
/*   adding it to the value in the location pointed to by r.                */
/*   Additionally, it computes the sum of the squares of the terms          */
/*   in the y array,adding it to the argument G. The final value of         */
/*   G is given as the return value of the function.                        */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*     1. Multiple Assignment was used to reduce loop carry path.           */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*     1. There are no special alignment requirements.                      */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    */
/*                        double *restrict r, int nx)                       */
/*      {                                                                   */
/*                                                                          */
/*         int i;                                                           */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         {                                                                */
/*               *r += x[i] * y[i];     // Compute Dot Product //           */
/*               G += y[i] * y[i];      // Compute Square  //               */
/*         }                                                                */
/*                                                                          */
/*         return G;                                                        */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*    NOTES                                                                 */
/*                                                                          */
/*        1. Endian : This code is LITTLE ENDIAN .                          */
/*        2. Interruptibility: This code is interrupt-tolerant but not      */
/*                             interruptible.                               */
/*                                                                          */
/*    CYCLES                                                                */
/*                                                                          */
/*      4*nx + 26                                                           */
/*                                                                          */
/*       For nx=64, cycles=282.                                             */
/*       For nx=30, cycles=146.                                             */
/*                                                                          */
/*    CODESIZE                                                              */
/*                                                                          */
/*      244 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTP_SQR_H_
#define DSPF_DP_DOTP_SQR_H_ 1

double DSPF_dp_dotp_sqr(
                double G,
                const double * x,
                const double * y,
                double *  restrict r,
                int   nx
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_dotp_sqr.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_dotp_sq/1117057386  3143  0     0       7159      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_dotp_sqr(                                                *
*                        double G,                                          *
*                        const double * x,                                  *
*                        const double * y,                                  *
*                        double *  restrict r,                              *
*                        int   nx                                           *
*                        )                                                  *
*             G:      Sum of y-squared initial value.                       *
*             x[nx]:  Pointer to First input array.                         *
*             y[nx]:  Pointer to Second input array.                        *
*             r:      Pointer to Output for Accumulation of x[]*y[].        *
*             nx:     Length of input vectors.                              *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine computes the dot product of x[] and y[] arrays,       *
*    adding it to the value in the location pointed to by r.                *
*    Additionally, it computes the sum of the squares of the terms          *
*    in the y array,adding it to the argument G. The final value of         *
*    G is given as the return value of the function.                        *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*      1. Multiple Assignment was used to reduce loop carry path.           *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*      1. There are no special alignment requirements.                      *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    *
*                         double *restrict r, int nx)                       *
*       {                                                                   *
*                                                                           *
*          int i;                                                           *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          {                                                                *
*                *r += x[i] * y[i];     /* Compute Dot Product */           *
*                G += y[i] * y[i];      /* Compute Square  */               *
*          }                                                                *
*                                                                           *
*          return G;                                                        *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*         1. Endian : This code is LITTLE ENDIAN .                          *
*         2. Interruptibility: This code is interrupt-tolerant but not      *
*                              interruptible.                               *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*       4*nx + 26                                                           *
*                                                                           *
*        For nx=64, cycles=282.                                             *
*        For nx=30, cycles=146.                                             *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*       244 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_dotp_sqr

*  ======================================================================== *
*   End of file:  DSPF_dp_dotp_sqr.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_dotprod/1117057387  3165  0     0       4097      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      double DSPF_dp_dotprod(const double *x, const double *y, const int nx);  */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      nx    : Number of values in the x & y vectors                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 Double precision       */
/*  float vectors.                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      double DSPF_dp_dotprod(const double *x, const double *y, const int nx)   */
/*      {                                                                   */
/*         int i;                                                           */
/*         double sum = 0;                                                  */
/*                                                                          */
/*         for (i=0; i < nx; i++)                                           */
/*         {                                                                */
/*            sum += x[i] * y[i];                                           */
/*         }                                                                */
/*         return sum;                                                      */
/*      }                                                                   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTPROD_ASM_H_
#define DSPF_DP_DOTPROD_ASM_H_ 1

double DSPF_dp_dotprod(const     double * x, const double * y, const int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_dp_dotprod_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_dotprod/1117057387  3184  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_dp_dotprod

* ======================================================================== *
*  End of file: DSPF_dp_dotprod_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_dotp_cp/1117057388  3205  0     0       6940      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         */
/*     product                                                             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double * */
/*                        restrict re, double * restrict im);               */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      n     : Number of values in the x & y vectors                       */
/*      re    : Pointer to the location storing the real                    */
/*              part of the result.                                         */
/*      im    : Pointer to the location storing the imaginary part of       */
/*              the result                                                  */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine calculates the dot product of 2 Double   precision     */
/*  complex float vectors. The even numbered locations hold the real parts  */
/*  of the complex numbers while the odd numbered locations contain the     */
/*  imaginary portions.                                                     */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*      1.  The value of nx must be  > 0.                                   */
/*                                                                          */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_dp_dotp_cplx(const double* x, const double* y, int n,          */
/*                    double* restrict re, double* restrict im)             */
/*      {                                                                   */
/*                                                                          */
/*          double real=0, imag=0;                                          */
/*          int i=0;                                                        */
/*                                                                          */
/*          for(i=0; i<n; i++)                                              */
/*          {                                                               */
/*              real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  */
/*              imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  */
/*          }                                                               */
/*                                                                          */
/*          *re=real;                                                       */
/*          *im=imag;                                                       */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*  1. Endian: This code is LITTLE ENDIAN.                                  */
/*  2. Interruptibility: This code is interrupt tolerant but not            */
/*     interruptible.                                                       */
/*                                                                          */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*     8*N + 29                                                             */
/*     eg. for N = 128, cycles = 1053.                                      */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*     352 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTP_CPLX_H_
#define DSPF_DP_DOTP_CPLX_H_ 1

void DSPF_dp_dotp_cplx(const     double *x, const double *y, int n, double *
                  restrict re, double * restrict im);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_dotp_cplx.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_dotp_cp/1117057388  3226  0     0       7001      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine is C Callable and can be called as:                      *
*                                                                           *
*       void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double * *
*                         restrict re, double * restrict im);               *
*                                                                           *
*       x     : Pointer to array holding the first floating point vector    *
*       y     : Pointer to array holding the second floating point vector   *
*       n     : Number of values in the x & y vectors                       *
*       re    : Pointer to the location storing the real                    *
*               part of the result.                                         *
*       im    : Pointer to the location storing the imaginary part of       *
*               the result                                                  *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*       This routine calculates the dot product of 2 Double   precision     *
*   complex float vectors. The even numbered locations hold the real parts  *
*   of the complex numbers while the odd numbered locations contain the     *
*   imaginary portions.                                                     *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*       1.  The value of nx must be  > 0.                                   *
*                                                                           *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_dotp_cplx(const double* x, const double* y, int n,          *
*                     double* restrict re, double* restrict im)             *
*       {                                                                   *
*                                                                           *
*           double real=0, imag=0;                                          *
*           int i=0;                                                        *
*                                                                           *
*           for(i=0; i<n; i++)                                              *
*           {                                                               *
*               real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  *
*               imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  *
*           }                                                               *
*                                                                           *
*           *re=real;                                                       *
*           *im=imag;                                                       *
*      }                                                                    *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*   1. Endian: This code is LITTLE ENDIAN.                                  *
*   2. Interruptibility: This code is interrupt tolerant but not            *
*      interruptible.                                                       *
*                                                                           *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      8*N + 29                                                             *
*      eg. for N = 128, cycles = 1053.                                      *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*      352 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_dotp_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_dotp_cplx.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_maxval./1117057389  3249  0     0       6903      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_maxval -- Maximum Element of Double Precision Vector             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_maxval(                                                  */
/*                       const double* x,                                   */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out the maximum number in the                   */
/*   input array.This code returns the maximum value                        */
/*   in the array.                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*     1. The loop is unrolled six times.                                   */
/*     2. Six maximums are maintained in each iteration.                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx should be multiple of 2 and >= 2.                             */
/*      2. NAN( Not a Number in Double Precision format) in the input is    */
/*         disregarded.                                                     */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      double DSPF_dp_maxval(const double* x, int nx)                           */
/*      {                                                                   */
/*         int i;                                                           */
/*         double max;                                                      */
/*         *((int *)&max) = 0x00000000;                                     */
/*         *((int *)&max+1) = 0xfff00000;                                   */
/*                                                                          */
/*          for (i = 0; i < nx; i++)                                        */
/*          if (x[i] > max)                                                 */
/*           {                                                              */
/*            max = x[i];                                                   */
/*           }                                                              */
/*                                                                          */
/*          return max;                                                     */
/*       }                                                                  */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. NAN( Not a Number in Double Precision format) in the input are   */
/*         disregarded.                                                     */
/*      2. Endian: This code is LITTLE ENDIAN.                              */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*                           interruptible.                                 */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      7*ceil(nx/6) + 31                                                   */
/*      For nx=60, cycles=101.                                              */
/*      For nx=34, cycles=73.                                               */
/*                                                                          */
/*  CODESIZE                                                                */
/*      672 bytes                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAXVAL_H_
#define DSPF_DP_MAXVAL_H_ 1

double DSPF_dp_maxval(
                const double* x,
                int nx
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_maxval.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_maxval./1117057389  3267  0     0       6999      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxval -- Maximum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_maxval(                                                  *
*                        const double* x,                                   *
*                        int nx                                             *
*                       )                                                   *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the maximum number in the                   *
*    input array.This code returns the maximum value                        *
*    in the array.                                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*      1. The loop is unrolled six times.                                   *
*      2. Six maximums are maintained in each iteration.                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx should be multiple of 2 and >= 2.                             *
*       2. NAN( Not a Number in Double Precision format) in the input is    *
*          disregarded.                                                     *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       double DSPF_dp_maxval(const double* x, int nx)                           *
*       {                                                                   *
*          int i;                                                           *
*          double max;                                                      *
*          *((int *)&max) = 0x00000000;                                     *
*          *((int *)&max+1) = 0xfff00000;                                   *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           if (x[i] > max)                                                 *
*            {                                                              *
*             max = x[i];                                                   *
*            }                                                              *
*                                                                           *
*           return max;                                                     *
*        }                                                                  *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. NAN( Not a Number in Double Precision format) in the input are   *
*          disregarded.                                                     *
*       2. Endian: This code is LITTLE ENDIAN.                              *
*       3. Interruptibility: This code is interrupt-tolerant but not        *
*                            interruptible.                                 *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       7*ceil(nx/6) + 31                                                   *
*       For nx=60, cycles=101.                                              *
*       For nx=34, cycles=73.                                               *
*                                                                           *
*   CODESIZE                                                                *
*       672 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_maxval

*  ======================================================================== *
*   End of file:  DSPF_dp_maxval.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_maxidx./1117057390  3287  0     0       6496      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       int DSPF_dp_maxidx(                                                     */
/*                      const double* x,                                    */
/*                      int nx                                              */
/*                    )                                                     */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out the index of maximum number in the input    */
/*       array. This function returns the index of the greatest value.      */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The loop is unrolled three times.                                */
/*      2. Three maximums are maintained in each iteration.                 */
/*      3. MPY instructions are  used for move.                             */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx is a multiple of 3.                                           */
/*      2. nx >= 3, and nx <= 2^16-1.                                       */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      int DSPF_dp_maxidx(const double* x, int nx)                              */
/*      {                                                                   */
/*         int index, i;                                                    */
/*         double max;                                                      */
/*                                                                          */
/*         *((int *)&max) = 0x00000000;                                     */
/*         *((int *)&max+1) = 0xfff00000;                                   */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         if (x[i] > max)                                                  */
/*         {                                                                */
/*            max = x[i];                                                   */
/*            index = i;                                                    */
/*         }                                                                */
/*         return index;                                                    */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. Endian: This code is LITTLE ENDIAN.                               */
/*     2. Interruptibility: This code is interrupt tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      4*nx/3 + 22                                                         */
/*      For nx=60, cycles=102.                                              */
/*      For nx=30, cycles=62.                                               */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      448 bytes                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAXIDX_H_
#define DSPF_DP_MAXIDX_H_ 1

int DSPF_dp_maxidx(
               const double* x,
               int nx
             );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_maxidx.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_maxidx./1117057390  3305  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      16-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        int DSPF_dp_maxidx(                                                     *
*                       const double* x,                                    *
*                       int nx                                              *
*                     )                                                     *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the index of maximum number in the input    *
*        array. This function returns the index of the greatest value.      *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled three times.                                *
*       2. Three maximums are maintained in each iteration.                 *
*       3. MPY instructions are  used for move.                             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 3.                                           *
*       2. nx >= 3, and nx <= 2^16-1.                                       *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       int DSPF_dp_maxidx(const double* x, int nx)                              *
*       {                                                                   *
*          int index, i;                                                    *
*          double max;                                                      *
*                                                                           *
*          *((int *)&max) = 0x00000000;                                     *
*          *((int *)&max+1) = 0xfff00000;                                   *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] > max)                                                  *
*          {                                                                *
*             max = x[i];                                                   *
*             index = i;                                                    *
*          }                                                                *
*          return index;                                                    *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. Endian: This code is LITTLE ENDIAN.                               *
*      2. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       4*nx/3 + 22                                                         *
*       For nx=60, cycles=102.                                              *
*       For nx=30, cycles=62.                                               *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       448 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_maxidx

*  ======================================================================== *
*   End of file:  DSPF_dp_maxidx.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_minval./1117057391  3325  0     0       6503      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_minval -- Minimum Element of Double Precision Vector             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_minval(                                                  */
/*                       const double* x,                                   */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out and returns the minimum number              */
/*   in the input array.                                                    */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The loop is unrolled six times.                                  */
/*      2. Six minimums are maintained in each iteration.                   */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx should be multiple of 2 and >= 2.                             */
/*      2. NAN( Not a Number in Double Precision format) in the input are   */
/*         disregarded.                                                     */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*      double DSPF_dp_minval(const double* x, int nx)                           */
/*      {                                                                   */
/*         int i;                                                           */
/*         double min;                                                      */
/*         *((int *)&min) = 0x00000000;                                     */
/*         *((int *)&min+1) = 0x7ff00000;                                   */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         if (x[i] < min)                                                  */
/*         {                                                                */
/*            min = x[i];                                                   */
/*           }                                                              */
/*                                                                          */
/*         return min;                                                      */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*  1. NAN( Not a Number in Double Precision format) in the input are       */
/*     disregarded.                                                         */
/*  2. Endian: This code is LITTLE ENDIAN.                                  */
/*  3. Interruptibility: This code is interrupt tolerant but not            */
/*     interruptible.                                                       */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      7*ceil(nx/6) + 31                                                   */
/*      For nx=60 cycles=101                                                */
/*      For nx=34 cycles=73                                                 */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      640 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MINVAL_H_
#define DSPF_DP_MINVAL_H_ 1

double DSPF_dp_minval(
                const double* x,
                int nx
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_minval.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_minval./1117057391  3343  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_minval -- Minimum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_minval(                                                  *
*                        const double* x,                                   *
*                        int nx                                             *
*                       )                                                   *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out and returns the minimum number              *
*    in the input array.                                                    *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled six times.                                  *
*       2. Six minimums are maintained in each iteration.                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx should be multiple of 2 and >= 2.                             *
*       2. NAN( Not a Number in Double Precision format) in the input are   *
*          disregarded.                                                     *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       double DSPF_dp_minval(const double* x, int nx)                           *
*       {                                                                   *
*          int i;                                                           *
*          double min;                                                      *
*          *((int *)&min) = 0x00000000;                                     *
*          *((int *)&min+1) = 0x7ff00000;                                   *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] < min)                                                  *
*          {                                                                *
*             min = x[i];                                                   *
*            }                                                              *
*                                                                           *
*          return min;                                                      *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*   1. NAN( Not a Number in Double Precision format) in the input are       *
*      disregarded.                                                         *
*   2. Endian: This code is LITTLE ENDIAN.                                  *
*   3. Interruptibility: This code is interrupt tolerant but not            *
*      interruptible.                                                       *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       7*ceil(nx/6) + 31                                                   *
*       For nx=60 cycles=101                                                *
*       For nx=34 cycles=73                                                 *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       640 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_minval

*  ======================================================================== *
*   End of file:  DSPF_dp_minval.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_vecreci/1117057392  3363  0     0       6942      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecrecip -- Double Precision vector reciprocal                   */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void  DSPF_dp_vecrecip(const double *x,                                  */
/*                        double * restrict r,                              */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_dp_vecrecip module calculates the reciprocal of each element    */
/*  in the array x and returns the output in array r. It uses 3             */
/*  iterations of the Newton-Raphson method to improve the accuracy         */
/*  of the output generated by the RCPDP instruction of the C67x.           */
/*  Each iteration doubles the accuracy. The initial output generated       */
/*  by RCPDP is 8 bits.So after the first iteration it is 16 bits and       */
/*  after the second it is the  23 bits and after third it is full 52 bits. */
/*  The formula used is:                                                    */
/*                                                                          */
/*               r[n+1] = r[n](2 - v*r[n])                                  */
/*                                                                          */
/*      where v = the number whose reciprocal is to be found.               */
/*      x[0], the seed value for the algorithm, is given by RCPDP.          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled four times to allow calculation of    */
/*         four reciprocals in the kernel. However the stores are executed  */
/*         conditionally to allow 'n' to be any number > 0.                 */
/*                                                                          */
/*      2. Register sharing is used to make optimal use of available        */
/*         registers.                                                       */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. There are no alignment requirements.                             */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*    void DSPF_dp_vecrecip(const double* x, double* restrict r, int n)          */
/*    {                                                                     */
/*     int i;                                                               */
/*     for(i = 0; i < n; i++)                                               */
/*        r[i] = 1 / x[i];                                                  */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt tolerant                */
/*         but not interruptible.                                           */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     78*ceil(n/4) + 24                                                    */
/*     eg. for n = 54, cycles = 1116                                        */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     448 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECRECIP_H_
#define DSPF_DP_VECRECIP_H_ 1

void  DSPF_dp_vecrecip(const     double *x,
                  double * restrict r,
                  int n
                 );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecrecip.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_vecreci/1117057392  3383  0     0       7006      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecrecip -- Double Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void  DSPF_dp_vecrecip(const double *x,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_dp_vecrecip module calculates the reciprocal of each element    *
*   in the array x and returns the output in array r. It uses 3             *
*   iterations of the Newton-Raphson method to improve the accuracy         *
*   of the output generated by the RCPDP instruction of the C67x.           *
*   Each iteration doubles the accuracy. The initial output generated       *
*   by RCPDP is 8 bits.So after the first iteration it is 16 bits and       *
*   after the second it is the  23 bits and after third it is full 52 bits. *
*   The formula used is:                                                    *
*                                                                           *
*                r[n+1] = r[n](2 - v*r[n])                                  *
*                                                                           *
*       where v = the number whose reciprocal is to be found.               *
*       x[0], the seed value for the algorithm, is given by RCPDP.          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled four times to allow calculation of    *
*          four reciprocals in the kernel. However the stores are executed  *
*          conditionally to allow 'n' to be any number > 0.                 *
*                                                                           *
*       2. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. There are no alignment requirements.                             *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*     void DSPF_dp_vecrecip(const double* x, double* restrict r, int n)          *
*     {                                                                     *
*      int i;                                                               *
*      for(i = 0; i < n; i++)                                               *
*         r[i] = 1 / x[i];                                                  *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant                *
*          but not interruptible.                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      78*ceil(n/4) + 24                                                    *
*      eg. for n = 54, cycles = 1116                                        *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      448 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecrecip

*  ======================================================================== *
*   End of file:  DSPF_dp_vecrecip.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_vecsum_/1117057393  3405  0     0       6101      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecsum_sq -- Double Precision sum of squares                     */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      double DSPF_dp_vecsum_sq(const double *x,                                */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs a sum of squares of the elements of the      */
/*       array x and returns the sum.                                       */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled twice. Hence, 2 registers are used    */
/*         to hold the sum of squares. ADDDPs are staggered.                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. Since loads of 4 doubles beyond the array occur,                 */
/*         a pad must be provided.                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions. Note that the assembly code is hand optimized          */
/*     and restrictions may apply.                                          */
/*                                                                          */
/*     double DSPF_dp_vecsum_sq(const double *x,int n)                           */
/*     {                                                                    */
/*         int i;                                                           */
/*         double sum=0;                                                    */
/*                                                                          */
/*         for(i = 0;  i < n; i++ )                                         */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*    1. Endian: This code is ENDIAN NEUTRAL.                               */
/*    2. Interruptibility: This code is interrupt tolerant                  */
/*                            but not interruptible.                        */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*    4*Ceil(n/2) + 33                                                      */
/*    eg. for n = 100, cycles = 233                                         */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*    288 bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECSUM_SQ_H_
#define DSPF_DP_VECSUM_SQ_H_ 1

double DSPF_dp_vecsum_sq(const     double *x,
                  int n
                 );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecsum_sq.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_vecsum_/1117057392  3426  0     0       6212      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecsum_sq -- Double Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       double DSPF_dp_vecsum_sq(const double *x,                                *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs a sum of squares of the elements of the      *
*        array x and returns the sum.                                       *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice. Hence, 2 registers are used    *
*          to hold the sum of squares. ADDDPs are staggered.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Since loads of 4 doubles beyond the array occur,                 *
*          a pad must be provided.                                          *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions. Note that the assembly code is hand optimized          *
*      and restrictions may apply.                                          *
*                                                                           *
*      double DSPF_dp_vecsum_sq(const double *x,int n)                           *
*      {                                                                    *
*          int i;                                                           *
*          double sum=0;                                                    *
*                                                                           *
*          for(i = 0;  i < n; i++ )                                         *
*              sum += x[i]*x[i];                                            *
*                                                                           *
*          return sum;                                                      *
*      }                                                                    *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*     1. Endian: This code is ENDIAN NEUTRAL.                               *
*     2. Interruptibility: This code is interrupt tolerant                  *
*                             but not interruptible.                        *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     4*Ceil(n/2) + 33                                                      *
*     eg. for n = 100, cycles = 233                                         *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     288 bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecsum_sq

*  ======================================================================== *
*   End of file:  DSPF_dp_vecsum_sq.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_w_vec.h/1117057394  0     0     0       6417      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_w_vec -- Double Precision weighted sum of vectors                */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void DSPF_dp_w_vec(const double* x,                                    */
/*                      const double* y,                                    */
/*                      double m,                                           */
/*                      double * restrict r,                                */
/*                      int     nr                                          */
/*                     )                                                    */
/*                                                                          */
/*             x    :  Pointer to first input array                         */
/*             y    :  Pointer to second input array                        */
/*             m    :  Weight factor                                        */
/*             r    :  Output array pointer                                 */
/*             nr   :  Number of elements in arrays                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine is used to obtain the weighted vector sum.              */
/*     Both the inputs and output are Double precision floating             */
/*     point numbers.                                                       */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*     1. The inner loop is unrolled twice.                                 */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The value of nr must be > 0.                                     */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_dp_w_vec( const double * x,const double * y, double  m,         */
/*                    double * restrict r,int nr)                           */
/*                                                                          */
/*    {                                                                     */
/*        int i;                                                            */
/*        for (i = 0; i < nr; i++)                                          */
/*            r[i] = (m * x[i]) + y[i];                                     */
/*    }                                                                     */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt tolerant but not          */
/*                         interruptible.                                   */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     4*Ceil(n/2) + 32                                                     */
/*     eg. for n = 100, cycles = 232.                                       */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*    352 bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_W_VEC_H_
#define DSPF_DP_W_VEC_H_ 1

void DSPF_dp_w_vec(const     double* x,
              const double* y,
              double m,
              double * restrict r,
              int     nr
             );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_w_vec.h                                                */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_w_vec.h/1117057393  3449  0     0       6445      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_w_vec -- Double Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void DSPF_dp_w_vec(const double* x,                                    *
*                       const double* y,                                    *
*                       double m,                                           *
*                       double * restrict r,                                *
*                       int     nr                                          *
*                      )                                                    *
*                                                                           *
*              x    :  Pointer to first input array                         *
*              y    :  Pointer to second input array                        *
*              m    :  Weight factor                                        *
*              r    :  Output array pointer                                 *
*              nr   :  Number of elements in arrays                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine is used to obtain the weighted vector sum.              *
*      Both the inputs and output are Double precision floating             *
*      point numbers.                                                       *
*   TECHNIQUES                                                              *
*                                                                           *
*      1. The inner loop is unrolled twice.                                 *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The value of nr must be > 0.                                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_w_vec( const double * x,const double * y, double  m,         *
*                     double * restrict r,int nr)                           *
*                                                                           *
*     {                                                                     *
*         int i;                                                            *
*         for (i = 0; i < nr; i++)                                          *
*             r[i] = (m * x[i]) + y[i];                                     *
*     }                                                                     *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt tolerant but not          *
*                          interruptible.                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      4*Ceil(n/2) + 32                                                     *
*      eg. for n = 100, cycles = 232.                                       *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     352 bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_w_vec

*  ======================================================================== *
*   End of file:  DSPF_dp_w_vec.h67                                              *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_vecmul./1117057395  3468  0     0       6570      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecmul -- Double Precision vector multiplication                 */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void DSPF_dp_vecmul   (const double *x,                                  */
/*                        const double *y,                                  */
/*                        double * restrict r,                              */
/*                        int n                                             */
/*                        )                                                 */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             y        :  Pointer to second input array                    */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs an element by element Double Precision       */
/*       floating point  multiplication of the vectors x[] and y[] and      */
/*       returns the values in r[].                                         */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*      1. The inner loop is unrolled twice to allow calculation of         */
/*         2 outputs in the kernel. However the stores are executed         */
/*         conditionally to allow 'n' to be any number > 0.                 */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*      1. The value of n > 0.                                              */
/*                                                                          */
/*                                                                          */
/*    C CODE                                                                */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_dp_vecmul(const double * x, const double * y,                   */
/*                           double * restrict r, int n)                    */
/*      {                                                                   */
/*        int i;                                                            */
/*                                                                          */
/*        for(i = 0; i < n; i++)                                            */
/*             r[i] = x[i] * y[i];                                          */
/*                                                                          */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*    NOTES                                                                 */
/*                                                                          */
/*       1. Endian: This code is LITTLE ENDIAN.                             */
/*       2. Interruptibility: The code is interrupt tolerant but not        */
/*          interruptible.                                                  */
/*                                                                          */
/*    CYCLES                                                                */
/*                                                                          */
/*         4*Ceil(n/2) + 13                                                 */
/*         eg. for n = 100, cycles = 213                                    */
/*                                                                          */
/*    CODESIZE                                                              */
/*                                                                          */
/*         256 bytes                                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECMUL_H_
#define DSPF_DP_VECMUL_H_ 1

void DSPF_dp_vecmul       (const double *x,
                  const double *y,
                  double * restrict r,
                  int n
                  );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecmul.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_vecmul./1117057394  3486  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecmul -- Double Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void DSPF_dp_vecmul   (const double *x,                                  *
*                         const double *y,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                         )                                                 *
*                                                                           *
*              x        :  Pointer to first input array                     *
*              y        :  Pointer to second input array                    *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in arrays                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs an element by element Double Precision       *
*        floating point  multiplication of the vectors x[] and y[] and      *
*        returns the values in r[].                                         *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*       1. The inner loop is unrolled twice to allow calculation of         *
*          2 outputs in the kernel. However the stores are executed         *
*          conditionally to allow 'n' to be any number > 0.                 *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*       1. The value of n > 0.                                              *
*                                                                           *
*                                                                           *
*     C CODE                                                                *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_vecmul(const double * x, const double * y,                   *
*                            double * restrict r, int n)                    *
*       {                                                                   *
*         int i;                                                            *
*                                                                           *
*         for(i = 0; i < n; i++)                                            *
*              r[i] = x[i] * y[i];                                          *
*                                                                           *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*        1. Endian: This code is LITTLE ENDIAN.                             *
*        2. Interruptibility: The code is interrupt tolerant but not        *
*           interruptible.                                                  *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*          4*Ceil(n/2) + 13                                                 *
*          eg. for n = 100, cycles = 213                                    *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*          256 bytes                                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecmul

*  ======================================================================== *
*   End of file:  DSPF_dp_vecmul.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_mul/1117057395  3506  0     0       8271      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine has following C prototype:                              */
/*     void DSPF_dp_mat_mul(double *x, int r1, int c1,                           */
/*                     double *y, int c2, double *r)                        */
/*                                                                          */
/*     x      : Pointer to r1 by c1 input matrix.                           */
/*     r1     : Number of rows in x.                                        */
/*     c1     : Number of columns in x.  Also number of rows in y.          */
/*     y      : Pointer to c1 by c2 input matrix.                           */
/*     c2     : Number of columns in y.                                     */
/*     r      : Pointer to r1 by c2 output matrix.                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*     This function computes the expression "r = x * y" for the matrices   */
/*     x and y.  The column dimension of x must match the row dimension     */
/*     of y.  The resulting matrix has the same number of rows as x and     */
/*     the same number of columns as y.                                     */
/*                                                                          */
/*     The values stored in the matrices are assumed to be Double           */
/*     precision floating point values.                                     */
/*                                                                          */
/*     This code is suitable for dense matrices.  No optimizations are      */
/*     made for sparse matrices.                                            */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*     1.    All three loops are unrolled two times                         */
/*     2.    All the prolog stages of the innermost loop (kLoop) are        */
/*           Scheduled in Parallel with outer loop.                         */
/*     3.    Extraneous Loads are allowed in Program                        */
/*     4.    Outer most Loop Instructions are scheduled in Parallel with In *r
/*           Loop Instructions.                                                   */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*     1.    The arrays 'x', 'y', and 'r' are stored in distinct arrays.    */
/*           That is, in-place processing is not allowed.                   */
/*     2.    All r1, c1, c2 are assumed to be > 1                           */
/*     3.   If r1 is odd, one extra row of x[] matrix is loaded             */
/*     4.   If c2 is odd, one extra col of y[] matrix is loaded.            */
/*     5.   If c1 is odd, one extra col of x[] and  one extra row of        */
/*          y[] array is loaded                                             */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*    void DSPF_dp_mat_mul(double *x, int r1, int c1,                            */
/*                    double *y, int c2, double *r)                         */
/*    {                                                                     */
/*        int i, j, k;                                                      */
/*        double sum;                                                       */
/*                                                                          */
/*     //  Multiply each row in x by each column in y.                      */
/*     //  The product of row m in x and column n in y is placed            */
/*     //  in position (m,n) in the result.                                 */
/*                                                                          */
/*        for (i = 0; i < r1; i++)                                          */
/*            for (j = 0; j < c2; j++)                                      */
/*            {                                                             */
/*                sum = 0;                                                  */
/*                for (k = 0; k < c1; k++)                                  */
/*                    sum += x[k + i*c1] * y[j + k*c2];                     */
/*                                                                          */
/*                r[j + i*c2] = sum;                                        */
/*            }                                                             */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*     1.   Endian: This code is LITTLE ENDIAN .                            */
/*     2.   Interruptibility: This code is interrupt-tolerant but not       */
/*          interruptible.                                                  */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*    (2 * r1' * c1 * c2') + 18*( c2'/2 * r1'/2) + 40                       */
/*    where                                                                 */
/*           r1' = r1 + (r1&1)                                              */
/*           c2' = c2 + (c2&1)                                              */
/*    For r1 = 12, c1 = 14 and c2 = 12,     cycles = 4720                   */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*    960 Bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_MUL_H_
#define DSPF_DP_MAT_MUL_H_ 1

void DSPF_dp_mat_mul(double     *x, int r1, int c1,
                double *y, int c2, double *r);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_mul.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_mat_mul/1117057395  3525  0     0       8350      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine has following C prototype:                              *
*      void DSPF_dp_mat_mul(double *x, int r1, int c1,                           *
*                      double *y, int c2, double *r)                        *
*                                                                           *
*      x      : Pointer to r1 by c1 input matrix.                           *
*      r1     : Number of rows in x.                                        *
*      c1     : Number of columns in x.  Also number of rows in y.          *
*      y      : Pointer to c1 by c2 input matrix.                           *
*      c2     : Number of columns in y.                                     *
*      r      : Pointer to r1 by c2 output matrix.                          *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      This function computes the expression "r = x * y" for the matrices   *
*      x and y.  The column dimension of x must match the row dimension     *
*      of y.  The resulting matrix has the same number of rows as x and     *
*      the same number of columns as y.                                     *
*                                                                           *
*      The values stored in the matrices are assumed to be Double           *
*      precision floating point values.                                     *
*                                                                           *
*      This code is suitable for dense matrices.  No optimizations are      *
*      made for sparse matrices.                                            *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*      1.    All three loops are unrolled two times                         *
*      2.    All the prolog stages of the innermost loop (kLoop) are        *
*            Scheduled in Parallel with outer loop.                         *
*      3.    Extraneous Loads are allowed in Program                        *
*      4.    Outer most Loop Instructions are scheduled in Parallel with In *r
*            Loop Instructions.                                                   *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*      1.    The arrays 'x', 'y', and 'r' are stored in distinct arrays.    *
*            That is, in-place processing is not allowed.                   *
*      2.    All r1, c1, c2 are assumed to be > 1                           *
*      3.   If r1 is odd, one extra row of x[] matrix is loaded             *
*      4.   If c2 is odd, one extra col of y[] matrix is loaded.            *
*      5.   If c1 is odd, one extra col of x[] and  one extra row of        *
*           y[] array is loaded                                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*     void DSPF_dp_mat_mul(double *x, int r1, int c1,                            *
*                     double *y, int c2, double *r)                         *
*     {                                                                     *
*         int i, j, k;                                                      *
*         double sum;                                                       *
*                                                                           *
*      //  Multiply each row in x by each column in y.                      *
*      //  The product of row m in x and column n in y is placed            *
*      //  in position (m,n) in the result.                                 *
*                                                                           *
*         for (i = 0; i < r1; i++)                                          *
*             for (j = 0; j < c2; j++)                                      *
*             {                                                             *
*                 sum = 0;                                                  *
*                 for (k = 0; k < c1; k++)                                  *
*                     sum += x[k + i*c1] * y[j + k*c2];                     *
*                                                                           *
*                 r[j + i*c2] = sum;                                        *
*             }                                                             *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1.   Endian: This code is LITTLE ENDIAN .                            *
*      2.   Interruptibility: This code is interrupt-tolerant but not       *
*           interruptible.                                                  *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*     (2 * r1' * c1 * c2') + 18*( c2'/2 * r1'/2) + 40                       *
*     where                                                                 *
*            r1' = r1 + (r1&1)                                              *
*            c2' = c2 + (c2&1)                                              *
*     For r1 = 12, c1 = 14 and c2 = 12,     cycles = 4720                   *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*     960 Bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_mul

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_mul.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_tra/1117057396  3546  0     0       6180      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_trans -- Double Precision matrix transpose                   */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_mat_trans(const double *restrict x,                        */
/*                         int rows,                                        */
/*                         int cols,                                        */
/*                         double *restrict r                               */
/*                         )                                                */
/*                                                                          */
/*          x       :  Input matrix containing rows*cols Double Precision   */
/*                     floating point numbers.                              */
/*          rows    :  No. of rows in matrix x.                             */
/*                     Also no. of columns in matrix r                      */
/*          cols    :  No. of columns in matrix x.                          */
/*                     Also no. of rows in matrix r.                        */
/*          r       :  Output matrix containing cols*rows Double Precision  */
/*                     floating point numbers.                              */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*    This function transposes the input matrix x[] and writes the          */
/*    result to matrix r[].                                                 */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*    1. The number of rows and columns is > 0.                             */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*       This is the C equivalent of the assembly code.  Note that          */
/*       the assembly code is hand optimized and restrictions may apply.    */
/*                                                                          */
/*       void DSPF_dp_mat_trans(const double *restrict x, int rows,              */
/*       int cols, double *restrict r)                                      */
/*       {                                                                  */
/*          int i,j;                                                        */
/*                                                                          */
/*          for(i=0; i<cols; i++)                                           */
/*             for(j=0; j<rows; j++)                                        */
/*                r[i * rows + j] = x[i + cols * j];                        */
/*       }                                                                  */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt-tolerant but not          */
/*       interruptible.                                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*      2 * rows * cols + 15                                                */
/*      For rows=10 and cols=20, cycles=415                                 */
/*      For rows=15 and cols=20, cycles=615                                 */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*      256  bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_TRANS_H_
#define DSPF_DP_MAT_TRANS_H_ 1

void DSPF_dp_mat_trans(const     double *restrict x,
                  int rows,
                  int cols,
                  double *restrict r
                  );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_trans.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_mat_tra/1117057396  3567  0     0       6212      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_trans -- Double Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x,                        *
*                          int rows,                                        *
*                          int cols,                                        *
*                          double *restrict r                               *
*                          )                                                *
*                                                                           *
*           x       :  Input matrix containing rows*cols Double Precision   *
*                      floating point numbers.                              *
*           rows    :  No. of rows in matrix x.                             *
*                      Also no. of columns in matrix r                      *
*           cols    :  No. of columns in matrix x.                          *
*                      Also no. of rows in matrix r.                        *
*           r       :  Output matrix containing cols*rows Double Precision  *
*                      floating point numbers.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This function transposes the input matrix x[] and writes the          *
*     result to matrix r[].                                                 *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The number of rows and columns is > 0.                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*        This is the C equivalent of the assembly code.  Note that          *
*        the assembly code is hand optimized and restrictions may apply.    *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x, int rows,              *
*        int cols, double *restrict r)                                      *
*        {                                                                  *
*           int i,j;                                                        *
*                                                                           *
*           for(i=0; i<cols; i++)                                           *
*              for(j=0; j<rows; j++)                                        *
*                 r[i * rows + j] = x[i + cols * j];                        *
*        }                                                                  *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2 * rows * cols + 15                                                *
*       For rows=10 and cols=20, cycles=415                                 *
*       For rows=15 and cols=20, cycles=615                                 *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       256  bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_trans

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_trans.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_mul/1117057397  3590  0     0       9807      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_mat_mul_cplx(                                              */
/*                              const double* x,                            */
/*                              int r1,                                     */
/*                              int c1,                                     */
/*                              const double* y,                            */
/*                              int c2,                                     */
/*                              double* restrict r                          */
/*                           )                                              */
/*                                                                          */
/*            x[2*r1*c1]:   Input matrix containing r1*c1 complex           */
/*                          floating point numbers having r1 rows and c1    */
/*                          columns of complex numbers.                     */
/*            r1        :   No. of rows in matrix x.                        */
/*            c1        :   No. of columns in matrix x.                     */
/*                          Also no. of rows in matrix y.                   */
/*            y[2*c1*c2]:   Input matrix containing c1*c2 complex           */
/*                          floating point numbers having c1 rows and c2    */
/*                          columns of complex numbers.                     */
/*            c2        :   No. of columns in matrix y.                     */
/*            r[2*r1*c2]:   Output matrix of c1*c2 complex floating         */
/*                          point numbers having c1 rows and c2 columns of  */
/*                          complex numbers.                                */
/*                                                                          */
/*                          Complex numbers are stored consecutively with   */
/*                          real values stored in even positions and        */
/*                          imaginary values in odd positions.              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*        This function computes the expression "r = x * y" for the         */
/*        matrices x and y. The columnar dimension of x must match the row  */
/*        dimension of y. The resulting matrix has the same number of rows  */
/*        as x and the same number of columns as y.                         */
/*                                                                          */
/*        Each element of the matrix is assumed to be complex numbers with  */
/*        Real values are stored in even positions and imaginary            */
/*        values in odd positions.                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*        1. Innermost loop is unrolled twice.                              */
/*        2. Outermost loop is executed in parallel with innner loops.      */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*        1. r1,r2>=1,c1 should be a multiple of 2 and >=2.                 */
/*        2. x should be padded with 6 words                                */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*   the assembly code is hand optimized and restrictions may apply.        */
/*                                                                          */
/*        void DSPF_dp_mat_mul_cplx(const double* x, int r1, int c1,             */
/*          const double* y, int c2, double* restrict r)                    */
/*        {                                                                 */
/*            double real, imag;                                            */
/*            int i, j, k;                                                  */
/*                                                                          */
/*            for(i = 0; i < r1; i++)                                       */
/*            {                                                             */
/*              for(j = 0; j < c2; j++)                                     */
/*              {                                                           */
/*                real=0;                                                   */
/*                imag=0;                                                   */
/*                                                                          */
/*                for(k = 0; k < c1; k++)                                   */
/*                {                                                         */
/*                real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j]                  */
/*                -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);              */
/*                                                                          */
/*                imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1]              */
/*                   + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);              */
/*                }                                                         */
/*                r[i*2*c2 + 2*j] = real;                                   */
/*                r[i*2*c2 + 2*j + 1] = imag;                               */
/*              }                                                           */
/*            }                                                             */
/*        }                                                                 */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*        1. Real values are stored in even word positions and imaginary    */
/*           values in odd positions.                                       */
/*        2. Endian: This code is LITTLE ENDIAN.                            */
/*        3. Interruptibility: This code is interrupt tolerant but not      */
/*           interruptible.                                                 */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*        8*r1*c1*c2'+ 18*(r1*c2)+40 WHERE c2'=2*ceil(c2/2)                 */
/*        When r1=3, c1=4, c2=4, cycles = 640                               */
/*        When r1=4, c1=4, c2=5, cycles = 1040                              */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*        832 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_MUL_CPLX_H_
#define DSPF_DP_MAT_MUL_CPLX_H_ 1

void DSPF_dp_mat_mul_cplx(
                       const double* x,
                       int r1,
                       int c1,
                       const double* y,
                       int c2,
                       double* restrict r
                    );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_mul_cplx.h                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_mat_mul/1117057397  3614  0     0       9691      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_mul_cplx(                                              *
*                               const double* x,                            *
*                               int r1,                                     *
*                               int c1,                                     *
*                               const double* y,                            *
*                               int c2,                                     *
*                               double* restrict r                          *
*                            )                                              *
*                                                                           *
*             x[2*r1*c1]:   Input matrix containing r1*c1 complex           *
*                           floating point numbers having r1 rows and c1    *
*                           columns of complex numbers.                     *
*             r1        :   No. of rows in matrix x.                        *
*             c1        :   No. of columns in matrix x.                     *
*                           Also no. of rows in matrix y.                   *
*             y[2*c1*c2]:   Input matrix containing c1*c2 complex           *
*                           floating point numbers having c1 rows and c2    *
*                           columns of complex numbers.                     *
*             c2        :   No. of columns in matrix y.                     *
*             r[2*r1*c2]:   Output matrix of c1*c2 complex floating         *
*                           point numbers having c1 rows and c2 columns of  *
*                           complex numbers.                                *
*                                                                           *
*                           Complex numbers are stored consecutively with   *
*                           real values stored in even positions and        *
*                           imaginary values in odd positions.              *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*         This function computes the expression "r = x * y" for the         *
*         matrices x and y. The columnar dimension of x must match the row  *
*         dimension of y. The resulting matrix has the same number of rows  *
*         as x and the same number of columns as y.                         *
*                                                                           *
*         Each element of the matrix is assumed to be complex numbers with  *
*         Real values are stored in even positions and imaginary            *
*         values in odd positions.                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*         1. Innermost loop is unrolled twice.                              *
*         2. Outermost loop is executed in parallel with innner loops.      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*         1. r1,r2>=1,c1 should be a multiple of 2 and >=2.                 *
*         2. x should be padded with 6 words                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*    the assembly code is hand optimized and restrictions may apply.        *
*                                                                           *
*         void DSPF_dp_mat_mul_cplx(const double* x, int r1, int c1,             *
*           const double* y, int c2, double* restrict r)                    *
*         {                                                                 *
*             double real, imag;                                            *
*             int i, j, k;                                                  *
*                                                                           *
*             for(i = 0; i < r1; i++)                                       *
*             {                                                             *
*               for(j = 0; j < c2; j++)                                     *
*               {                                                           *
*                 real=0;                                                   *
*                 imag=0;                                                   *
*                                                                           *
*                 for(k = 0; k < c1; k++)                                   *
*                 {                                                         *
*                 real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j]                  *
*                 -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);              *
*                                                                           *
*                 imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1]              *
*                    + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);              *
*                 }                                                         *
*                 r[i*2*c2 + 2*j] = real;                                   *
*                 r[i*2*c2 + 2*j + 1] = imag;                               *
*               }                                                           *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*         1. Real values are stored in even word positions and imaginary    *
*            values in odd positions.                                       *
*         2. Endian: This code is LITTLE ENDIAN.                            *
*         3. Interruptibility: This code is interrupt tolerant but not      *
*            interruptible.                                                 *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*         8*r1*c1*c2'+ 18*(r1*c2)+40 WHERE c2'=2*ceil(c2/2)                 *
*         When r1=3, c1=4, c2=4, cycles = 640                               *
*         When r1=4, c1=4, c2=5, cycles = 1040                              *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_mul_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_mul_cplx.h67                                       *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_blk_mov/1117057398  3640  0     0       5756      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_blk_move -- DSPF_dp_blk_move                                          */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_blk_move(                                                  */
/*                        const double *   x,                               */
/*                        double *restrict r,                               */
/*                        int nx                                            */
/*                       )                                                  */
/*                                                                          */
/*            x[nx]: Pointer to source data to be moved.                    */
/*            r[nx]: Pointer to destination array.                          */
/*            nx:    Number of floats to move.                              */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*   This routine moves nx doubles from one memory location                 */
/*       pointed to by x to another pointed to by r.                        */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*       1. nx is greater than 0.                                           */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*       void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     */
/*       {                                                                  */
/*           int i;                                                         */
/*           for (i = 0 ; i < nx; i++)                                      */
/*               r[i] = x[i];                                               */
/*       }                                                                  */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. Endian: This implementation is Little-Endian.                    */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*                           interruptible.                                 */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*      2*nx+ 8                                                             */
/*      For nx=64, cycles=136.                                              */
/*      For nx=25, cycles=58.                                               */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*      96 bytes                                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BLK_MOVE_H_
#define DSPF_DP_BLK_MOVE_H_ 1

void DSPF_dp_blk_move(
                 const double *   x,
                 double *restrict r,
                 int nx
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_blk_move.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_blk_mov/1117057398  3660  0     0       5821      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_blk_move -- DSPF_dp_blk_move                                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_blk_move(                                                  *
*                         const double *   x,                               *
*                         double *restrict r,                               *
*                         int nx                                            *
*                        )                                                  *
*                                                                           *
*             x[nx]: Pointer to source data to be moved.                    *
*             r[nx]: Pointer to destination array.                          *
*             nx:    Number of floats to move.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*    This routine moves nx doubles from one memory location                 *
*        pointed to by x to another pointed to by r.                        *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*        1. nx is greater than 0.                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*        void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     *
*        {                                                                  *
*            int i;                                                         *
*            for (i = 0 ; i < nx; i++)                                      *
*                r[i] = x[i];                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. Endian: This implementation is Little-Endian.                    *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*                            interruptible.                                 *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2*nx+ 8                                                             *
*       For nx=64, cycles=136.                                              *
*       For nx=25, cycles=58.                                               *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       96 bytes                                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_blk_move

*  ======================================================================== *
*   End of file:  DSPF_dp_blk_move.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

