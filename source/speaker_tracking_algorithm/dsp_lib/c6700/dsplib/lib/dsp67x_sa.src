!<arch>
<filenames>/    0           1     0     0       3588      `

DSPF_sp_autocor.sa/
DSPF_sp_bitrev_cplx.sa/
DSPF_sp_cfftr4_dif.sa/
DSPF_sp_cfftr2_dit.sa/
DSPF_sp_fftSPxSP.sa/
DSPF_sp_ifftSPxSP.sa/
DSPF_sp_icfftr2_dif.sa/
DSPF_sp_fir_cplx.sa/
DSPF_sp_fir_gen.sa/
DSPF_sp_fir_r2.sa/
DSPF_sp_fircirc.sa/
DSPF_sp_biquad.sa/
DSPF_sp_iirlat.sa/
DSPF_sp_convol.sa/
DSPF_sp_dotp_sqr.sa/
DSPF_sp_dotprod.sa/
DSPF_sp_dotp_cplx.sa/
DSPF_sp_maxval.sa/
DSPF_sp_maxidx.sa/
DSPF_sp_minval.sa/
DSPF_sp_vecrecip.sa/
DSPF_sp_vecsum_sq.sa/
DSPF_sp_w_vec.sa/
DSPF_sp_vecmul.sa/
DSPF_sp_mat_mul.sa/
DSPF_sp_mat_trans.sa/
DSPF_sp_mat_mul_cplx.sa/
DSPF_sp_blk_move.sa/
DSPF_blk_eswap16.sa/
DSPF_blk_eswap32.sa/
DSPF_blk_eswap64.sa/
DSPF_sp_minerr.sa/
DSPF_dp_autocor.sa/
DSPF_dp_bitrev_cplx.sa/
DSPF_dp_cfftr4_dif.sa/
DSPF_dp_cfftr2.sa/
DSPF_dp_icfftr2.sa/
DSPF_dp_fir_cplx.sa/
DSPF_dp_fir_gen.sa/
DSPF_dp_fir_r2.sa/
DSPF_dp_fircirc.sa/
DSPF_dp_biquad.sa/
DSPF_dp_iirlat.sa/
DSPF_dp_convol.sa/
DSPF_dp_dotp_sqr.sa/
DSPF_dp_dotprod.sa/
DSPF_dp_dotp_cplx.sa/
DSPF_dp_maxval.sa/
DSPF_dp_maxidx.sa/
DSPF_dp_minval.sa/
DSPF_dp_vecrecip.sa/
DSPF_dp_vecsum_sq.sa/
DSPF_dp_w_vec.sa/
DSPF_dp_vecmul.sa/
DSPF_dp_mat_mul.sa/
DSPF_dp_mat_trans.sa/
DSPF_dp_mat_mul_cplx.sa/
DSPF_dp_blk_move.sa/
DSPF_sp_autocor.h/
DSPF_sp_autocor.h67/
DSPF_sp_bitrev_cplx.h/
DSPF_sp_bitrev_cplx.h67/
DSPF_sp_cfftr4_dif.h/
DSPF_sp_cfftr4_dif.h67/
DSPF_sp_cfftr2_dit.h/
DSPF_sp_cfftr2_dit.h67/
DSPF_sp_fftSPxSP.h/
DSPF_sp_fftSPxSP.h67/
DSPF_sp_ifftSPxSP.h/
DSPF_sp_ifftSPxSP.h67/
DSPF_sp_icfftr2_dif.h/
DSPF_sp_icfftr2_dif.h67/
DSPF_sp_fir_cplx.h/
DSPF_sp_fir_cplx.h67/
DSPF_sp_fir_gen.h/
DSPF_sp_fir_gen.h67/
DSPF_sp_fir_r2.h/
DSPF_sp_fir_r2.h67/
DSPF_sp_fircirc.h/
DSPF_sp_fircirc.h67/
DSPF_sp_biquad.h/
DSPF_sp_biquad.h67/
DSPF_sp_iirlat.h/
DSPF_sp_iirlat.h67/
DSPF_sp_convol.h/
DSPF_sp_convol.h67/
DSPF_sp_dotp_sqr.h/
DSPF_sp_dotp_sqr.h67/
DSPF_sp_dotprod.h/
DSPF_sp_dotprod.h67/
DSPF_sp_dotp_cplx.h/
DSPF_sp_dotp_cplx.h67/
DSPF_sp_maxval.h/
DSPF_sp_maxval.h67/
DSPF_sp_maxidx.h/
DSPF_sp_maxidx.h67/
DSPF_sp_minval.h/
DSPF_sp_minval.h67/
DSPF_sp_vecrecip.h/
DSPF_sp_vecrecip.h67/
DSPF_sp_vecsum_sq.h/
DSPF_sp_vecsum_sq.h67/
DSPF_sp_w_vec.h67/
DSPF_sp_vecmul.h/
DSPF_sp_vecmul.h67/
DSPF_sp_mat_mul.h/
DSPF_sp_mat_mul.h67/
DSPF_sp_mat_trans.h/
DSPF_sp_mat_trans.h67/
DSPF_sp_mat_mul_cplx.h/
DSPF_sp_mat_mul_cplx.h67/
DSPF_sp_blk_move.h/
DSPF_sp_blk_move.h67/
DSPF_blk_eswap16.h/
DSPF_blk_eswap16.h67/
DSPF_blk_eswap32.h/
DSPF_blk_eswap32.h67/
DSPF_blk_eswap64.h/
DSPF_blk_eswap64.h67/
DSPF_fltoq15.h67/
DSPF_sp_minerr.h/
DSPF_sp_minerr.h67/
DSPF_q15tofl.h67/
DSPF_dp_autocor.h/
DSPF_dp_autocor.h67/
DSPF_dp_bitrev_cplx.h/
DSPF_dp_bitrev_cplx.h67/
DSPF_dp_cfftr4_dif.h/
DSPF_dp_cfftr4_dif.h67/
DSPF_dp_cfftr2.h/
DSPF_dp_cfftr2.h67/
DSPF_dp_icfftr2.h/
DSPF_dp_icfftr2.h67/
DSPF_dp_fir_cplx.h/
DSPF_dp_fir_cplx.h67/
DSPF_dp_fir_gen.h/
DSPF_dp_fir_gen.h67/
DSPF_dp_fir_r2.h/
DSPF_dp_fir_r2.h67/
DSPF_dp_fircirc.h/
DSPF_dp_fircirc.h67/
DSPF_dp_biquad.h/
DSPF_dp_biquad.h67/
DSPF_dp_iirlat.h/
DSPF_dp_iirlat.h67/
DSPF_dp_convol.h/
DSPF_dp_convol.h67/
DSPF_dp_dotp_sqr.h/
DSPF_dp_dotp_sqr.h67/
DSPF_dp_dotprod.h/
DSPF_dp_dotprod.h67/
DSPF_dp_dotp_cplx.h/
DSPF_dp_dotp_cplx.h67/
DSPF_dp_maxval.h/
DSPF_dp_maxval.h67/
DSPF_dp_maxidx.h/
DSPF_dp_maxidx.h67/
DSPF_dp_minval.h/
DSPF_dp_minval.h67/
DSPF_dp_vecrecip.h/
DSPF_dp_vecrecip.h67/
DSPF_dp_vecsum_sq.h/
DSPF_dp_vecsum_sq.h67/
DSPF_dp_w_vec.h67/
DSPF_dp_vecmul.h/
DSPF_dp_vecmul.h67/
DSPF_dp_mat_mul.h/
DSPF_dp_mat_mul.h67/
DSPF_dp_mat_trans.h/
DSPF_dp_mat_trans.h67/
DSPF_dp_mat_mul_cplx.h/
DSPF_dp_mat_mul_cplx.h67/
DSPF_dp_blk_move.h/
DSPF_dp_blk_move.h67/
DSPF_sp_lms.sa/ 1117057335  0     0     0       14366     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_lms -- Single Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       );                                                                  *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       *
*       input signal and a desired input signal, the filter produces an     *
*       output signal, the final coefficient values, and returns the final  *
*       output error signal.                                                *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled six times to allow update of          *
*          six coefficients in the kernel.                                  *
*       2. The outer loop has been unrolled twice to enable use of LDDW     *
*          for loading the input coefficients.                              *
*       3. LDDW instruction is used to load in the coefficients.            *
*       4. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*       5. The outer loop instructions are scheduled in parallel with       *
*          epilog and prolog wherever possible.                             *
*       6. The 'error' term needs to be computed in the outer loop          *
*          before a new iteration of the inner loop can start. As a         *
*          result the prolog cannot be placed in parallel with epilog       *
*          (after the loop kernel).                                         *
*       7. Pushing and popping variables from the stack does not            *
*          really add any overhead except increase stack size. This         *
*          is because the pops and pushes are done in the delay slots       *
*          of the outer loop instructions.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The inner loop counter must be a multiple of 6 and >=6.          *
*       2. Little endianness is assumed.                                    *
*       3. Extraneous loads are allowed in the program.                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions      *
*       may apply.                                                          *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i,j;                                                        *
*                                                                           *
*           float sum, temp, ae;                                            *
*           temp = 0.0f;                                                    *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0.0f;                                                 *
*               ae = adaptrate * error;                                     *
*                                                                           *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   h[j] = h[j] + (ae * temp);                              *
*                   sum += h[j] * x[i+j];                                   *
*                   temp = x[i + j];                                        *
*               }                                                           *
*                                                                           *
*               r[i] = sum;                                                 *
*               error = desired[i] - sum;                                   *
*               temp = x[i];                                                *
*           }                                                               *
*           /* return the final error */                                    *
*           return error;                                                   *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_lms
_DSPF_sp_lms   .cproc  x, h, desired, r, adaptrate, error, nh, nr

* ======================================================================== *
* ======================================================================== *
             .reg       h1:h0, h3:h2
             .reg       x0,    x1,   x2,   x3
             .reg       ae
             .reg       temp
             .reg       d
             .reg       sh
             .reg       j
             .reg       s0,    s1,   s2,   s3
             .reg       p, nh_copy

;========================================================================

            ZERO       x3                      ; init overlapping input
            MV         nh,         nh_copy
oloop:

            ZERO       s0                      ; init the sums
            ZERO       s1
            ZERO       s2
            ZERO       s3

            MV         nh,         j           ; init inner loop ctr
            MPYSP      adaptrate,         error,   ae ; get the ar*er product

iloop:
            MPYSP      ae,         x3,      temp; calc error in h0

            LDW        *x++,   x0           ; load the input values
            LDW        *x++,   x1
            LDW        *x++,   x2
            LDW        *x++,   x3
            LDDW       *h,     h1:h0        ; get the first pair of h's

            ADDSP      h0,         temp,    sh  ; calc the new h0
            STW        sh,         *h++     ; store new h0
            MPYSP      sh,         x0,      p   ;
            ADDSP      p,          s0,      s0  ; multiply with x0 and add



            MPYSP      ae,         x0,      temp; calc error in h1
            ADDSP      h1,         temp,    sh  ; calc the new h1
            STW        sh,         *h++     ; store the new h1
            MPYSP      sh,         x1,      p   ;
            ADDSP      p,          s1,      s1  ; multiply with x1 and add



            LDDW       *h,     h1:h0        ; get the second pair of h's
                                                ; h1:h0 now has h3:h2
            MPYSP      ae,         x1,      temp; calc error in h2
            ADDSP      h0,         temp,    sh  ; calc new h2
            STW        sh,        *h++      ; store new h2
            MPYSP      sh,        x2,       p   ;
            ADDSP      p,         s2,       s2  ; multiply with x2 and add



            MPYSP      ae,         x2,      temp; calc error in h3
            ADDSP      h1,         temp,    sh  ; calc new h3
            STW        sh,        *h++      ; store new h3
            MPYSP      sh,        x3,       p   ;
            ADDSP      p,         s3,       s3  ; multiply with x3 and add



            SUB        j,          4,       j   ; decrement inner loop ctr
        [j] B          iloop                    ; branch to top of inner loop

            ADDSP      s0,         s1,      s0  ; accumulate the 4 split sums
            ADDSP      s2,         s3,      s2
            ADDSP      s0,         s2,      s0

            STW        s0,         *r++         ; store the sum into o/p array
            LDW        *desired++, d            ; load the desired o/p
            SUBSP      d,          s0,      error ; find the error
            SUBAW      x,      nh,      x ; reset the x value
            LDW        *x,     x3             ; load x3 for next outer loop
            ADDAW      x,      1,       x ; adv x for next outer loop
            SUBAW      h,      nh_copy,      h ; reset the h value

            SUB        nr,         1,       nr    ; decrement the outer loop ctr
        [nr]B          oloop                      ; branch to top of outer loop

            .return error
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_lms.sa                                                  *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_autocor/1117057336  1     0     0       8638      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_autocor -- Single Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      20-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_sp_autocor                                                    *
*                      (                                                    *
*                          float       *  restrict r,                       *
*                          const short *  restrict x,                       *
*                          int            nx,                               *
*                          int            nr                                *
*                      )                                                    *
*             r  = pointer to output array of autocorrelation of length nr  *
*             x  = pointer to input array of length nx+nr. Input data must  *
*                  be padded with nr consecutive zeros at the beginning.    *
*             nx = Length of Autocorrelation vector.                        *
*             nr = Length of lags.                                          *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*        This routine performs the autocorrelation of the input array inp.  *
*        It is assumed that the length of the input array, x, is a multiple *
*        of 2 and the length of the output array, r, is a multiple of 4.    *
*        The assembly routine computes 4 output samples at a time.          *
*                                                                           *
*        It is assumed that input vector x is padded with nr no of zeros in *
*        the beginning.                                                     *
*                                                                           *
*        x is to be aligned on a double word boundary.                      *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_autocor
_DSPF_sp_autocor   .cproc  r, x, nx, nr

* ======================================================================== *
* ======================================================================== *
                  .reg icntr, ocntr, icntr_temp
                  .reg sum1, sum2, sum3, sum4
                  .reg sum5, sum6, sum7, sum8
                  .reg temp1, temp2
                  .reg x_k_1:x_k, x_k_i_3
                  .reg x_k_i_1:x_k_i_2, x_k_i_p1:x_k_i
                  .reg xk_ptr, xki_ptr, xk_ptr_temp
                  .reg store_ptr
                  .no_mdep


          MV      nr, ocntr                                ; Set up outer loop counter
          ADDAD   x, nr, xk_ptr_temp                       ; Pointer for accessing
          SUB     xk_ptr_temp, 16, xk_ptr_temp             ; x[k] & x[k+1]
          SUB     nx, nr, icntr_temp                       ;
          ADD     icntr_temp, 4, icntr_temp                ; Initial inner loop counter
          ADDAW   r, nr, store_ptr                         ; Pointer for storing

oloop:    .trip 1
          ZERO    sum1                                     ; Zero the accumulator
          ZERO    sum2                                     ; Zero the accumulator
          ZERO    sum3                                     ; Zero the accumulator
          ZERO    sum4                                     ; Zero the accumulator
          ZERO    sum5                                     ; Zero the accumulator
          ZERO    sum6                                     ; Zero the accumulator
          ZERO    sum7                                     ; Zero the accumulator
          ZERO    sum8                                     ; Zero the accumulator

          MV      icntr_temp,  icntr                       ; Set up Inner loop counter
          ADD     icntr_temp,  4,              icntr_temp  ; Find out next inner loop ctr
          MV      xk_ptr_temp, xk_ptr                      ; Pointer for accessing
          SUB     xk_ptr_temp, 16,             xk_ptr_temp ; x[k] & x[k+1]
          ADDAW   x,           nr,             xki_ptr     ; Pointer for accessing
          SUB     xki_ptr,     8,              xki_ptr     ; x[k-i] & ...

iloop:    .trip 2
          LDDW    *xk_ptr++,   x_k_1:x_k
          LDW     *xki_ptr[-1],x_k_i_3
          LDDW    *xki_ptr++,  x_k_i_1:x_k_i_2
          LDDW    *xki_ptr,    x_k_i_p1:x_k_i

          MPYSP   x_k,         x_k_i,          temp1
          ADDSP   sum1,        temp1,          sum1        ; sum1 += x[k]*x[k-i]

          MPYSP   x_k_1,       x_k_i_p1,       temp2
          ADDSP   sum5,        temp2,          sum5        ; sum5 += x[k+1] * x[k-i+1]

          MPYSP   x_k,         x_k_i_1,        temp1
          ADDSP   sum2,        temp1,          sum2        ; sum2 += x[k] * x[k-i-1]

          MPYSP   x_k_1,       x_k_i,          temp2
          ADDSP   sum6,        temp2,          sum6        ; sum6 += x[k+1] * x[k-i]

          MPYSP   x_k,         x_k_i_2,        temp1
          ADDSP   sum3,        temp1,          sum3        ; sum3 += x[k] * x[k-i-2]

          MPYSP   x_k_1,       x_k_i_1,        temp2
          ADDSP   sum7,        temp2,          sum7        ; sum7 += x[k+1] * x[k-i-1]

          MPYSP   x_k,         x_k_i_3,        temp1
          ADDSP   sum4,        temp1,          sum4        ; sum4 += x[k] * x[k-i-3]

          MPYSP   x_k_1,       x_k_i_2,        temp2
          ADDSP   sum8,        temp2,          sum8        ; sum8 += x[k-1] * x[k-i-2]

   [icntr]SUB     icntr,       2,              icntr       ; update inner loop ctr
   [icntr]B       iloop
          ; BRANCH TO INNER LOOP OCCURS HERE

          ADDSP   sum1,        sum5,           sum1
          STW     sum1,        *store_ptr[-4]              ; Store sum1+sum5

          ADDSP   sum2,        sum6,           sum2
          STW     sum2,        *store_ptr[-3]              ; Store sum2+sum6

          ADDSP   sum3,        sum7,           sum3
          STW     sum3,        *store_ptr[-2]              ; Store sum3+sum7

          ADDSP   sum4,        sum8,           sum4
          STW     sum4,        *store_ptr[-1]              ; Store sum4+sum8

          SUBAW   store_ptr,   4,              store_ptr   ; Update store pointer

   [ocntr]SUB     ocntr,       4,              ocntr       ; Update outer loop ctr
   [ocntr]B       oloop
          ; BRANCH TO OUTER LOOP OCCURS HERE

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_autocor.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_bitrev_/1117057337  21    0     0       17315     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_bitrev_cplx -- Bit-reversal for Single-Precision complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      20-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*      This routine is C Callable and can be called as:                     *
*                                                                           *
*      void DSPF_sp_bitrev_cplx(double *x, short *index, int nx);                *
*                                                                           *
*      x      : Complex input array to be bit-reversed.                     *
*               Contains 2*nx floats                                        *
*      index  : Array of size ~sqrt(nx) created by the routine              *
*               bitrev_index to allow the fast implementation of the        *
*               bit-reversal.                                               *
*      nx     : Number of elements in array x[]. Must be power of 2.        *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine performs the bit-reversal of the input array x[],       *
*      where x[] is an integer array of length nx containing 16-bit         *
*      complex pairs of data.  This routine requires the index array        *
*      provided by the program below.  This index should be generated at    *
*      compile time not by the DSP.                                         *
*                                                                           *
*      TI retains all rights, title and interest in this code and only      *
*      authorizes the use of the bit-reversal code and related table        *
*      generation code with TMS320-family DSPs manufactured by TI.          *
*                                                                           *
*      /* ----------------------------------------------------------- */    *
*      /*  This routine calculates the index for bit reversal of      */    *
*      /*  an array of length nx.  The length of the index table is   */    *
*      /*  2^(2*ceil(k/2)) where nx = 2^k.                            */    *
*      /*                                                             */    *
*      /*  In other words, the length of the index table is:          */    *
*      /*      - for even power of radix: sqrt(nx)                    */    *
*      /*      - for odd  power of radix: sqrt(2*nx)                  */    *
*      /* ----------------------------------------------------------- */    *
*      void bitrev_index(short *index, int nx)                              *
*      {                                                                    *
*          int   i, j, k, radix = 2;                                        *
*          short nbits, nbot, ntop, ndiff, n2, raddiv2;                     *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*              i = i >> 1;                                                  *
*              nbits++;                                                     *
*          }                                                                *
*                                                                           *
*          raddiv2 = radix >> 1;                                            *
*          nbot    = nbits >> raddiv2;                                      *
*          nbot    = nbot << raddiv2 - 1;                                   *
*          ndiff   = nbits & raddiv2;                                       *
*          ntop    = nbot + ndiff;                                          *
*          n2      = 1 << ntop;                                             *
*                                                                           *
*          index[0] = 0;                                                    *
*          for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  *
*          {                                                                *
*              index[i] = j - 1;                                            *
*                                                                           *
*              for (k = n2/radix; k*(radix-1) < j; k /= radix)              *
*                  j -= k*(radix-1);                                        *
*                                                                           *
*              j += k;                                                      *
*          }                                                                *
*          index[n2 - 1] = n2 - 1;                                          *
*      }                                                                    *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*       void DSPF_sp_bitrev_cplx(double* x, short* index, int n)                 *
*       {                                                                   *
*          int    i;                                                        *
*          short  i0, i1, i2, i3;                                           *
*          short  j0, j1, j2, j3;                                           *
*          double xi0, xi1, xi2, xi3;                                       *
*          double xj0, xj1, xj2, xj3;                                       *
*          short  t;                                                        *
*          int    a, b, ia, ib, ibs;                                        *
*          int    mask;                                                     *
*          int    nbits, nbot, ntop, ndiff, n2, halfn;                      *
*                                                                           *
*          nbits = 0;                                                       *
*          i = n;                                                           *
*          while (i > 1)                                                    *
*          {                                                                *
*             i = i >> 1;                                                   *
*             nbits++;                                                      *
*          }                                                                *
*                                                                           *
*          nbot    = nbits >> 1;                                            *
*          ndiff   = nbits & 1;                                             *
*          ntop    = nbot + ndiff;                                          *
*          n2       = 1 << ntop;                                            *
*          mask    = n2 - 1;                                                *
*          halfn   = n >> 1;                                                *
*                                                                           *
*          for (i0 = 0; i0 < halfn; i0 += 2)                                *
*          {                                                                *
*              b       = i0 & mask;                                         *
*              a       = i0 >> nbot;                                        *
*              if (!b) ia = index[a];                                       *
*              ib      = index[b];                                          *
*              ibs     = ib << nbot;                                        *
*                                                                           *
*              j0      = ibs + ia;                                          *
*              t       = i0 < j0;                                           *
*              xi0     = x[i0];                                             *
*              xj0     = x[j0];                                             *
*                                                                           *
*              if (t)                                                       *
*              {                                                            *
*               x[i0] = xj0;                                                *
*               x[j0] = xi0;                                                *
*              }                                                            *
*                                                                           *
*              i1      = i0 + 1;                                            *
*              j1      = j0 + halfn;                                        *
*              xi1     = x[i1];                                             *
*              xj1     = x[j1];                                             *
*              x[i1] = xj1;                                                 *
*              x[j1] = xi1;                                                 *
*                                                                           *
*              i3      = i1 + halfn;                                        *
*              j3      = j1 + 1;                                            *
*              xi3     = x[i3];                                             *
*              xj3     = x[j3];                                             *
*              if (t)                                                       *
*              {                                                            *
*               x[i3] = xj3;                                                *
*               x[j3] = xi3;                                                *
*              }                                                            *
*            }                                                              *
*                                                                           *
*          }                                                                *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. If nx <= 4K one can use the char (8-bit) data type for            *
*         the "index" variable. This would require changing the LDH when    *
*         loading index values in the assembly routine to LDB. This would   *
*         further reduce the size of the Index Table by half its size.      *
*                                                                           *
*      2. This code is interrupt tolerant, but not interruptible.           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_bitrev_cplx
_DSPF_sp_bitrev_cplx   .cproc  x, index, n

* ======================================================================== *
* ======================================================================== *
                     .reg nbits, nbot, ndiff, ntop
                     .reg temp,halfn, i0, b, a, n2
                     .reg mask, ia, ibs, ib, j0, j1, j3
                     .reg i1, i3, t
                     .reg x1, x2, ex
                     .reg xi02:xi01,xj02:xj01
                     .reg xi12:xi11,xj12:xj11
                     .reg xi32:xi31,xj32:xj31
                     .reg x_copy, xj12temp

       LMBD           1,          n,        nbits ; to find log of n base to 2
       MVK            31,         temp
       SUB            temp,       nbits,    nbits ; log(n)= 31-nbits

       SHR            nbits,      1,        nbot  ; nbot = nbits>>1
       AND            nbits,      1,        ndiff ; ndiff=nbits&1

       ADD            nbot,       ndiff,    ntop  ; ntop=nbot+ndiff

       MVK            1,          temp            ; find mask
       SHL            temp,       ntop,     n2
       SUB            n2,         1,        mask  ; mask=2^ntop-1
       SHR            n,          1,        halfn ; loop count

       ZERO           i0                          ; init counter
       MV             x,          x_copy

loop:
       AND            i0,         mask,     b     ; b=i0&mask
       SHR            i0,         nbot,     a     ; a=i0>>nbot
  [!b] LDHU           *index[a],  ia              ; if(!b)ia=index[a]
       LDHU           *index[b],  ib              ; ib=index[b]

       SHL            ib,         nbot,     ibs   ; ibs=ib<<nbot

       ADD            ibs,        ia,       j0    ; j0=ibs+ia
       CMPLT          i0,         j0,       t     ; t=i0<j0
       LDDW           *x[i0],     xi02:xi01       ; load x[i0]
       LDDW           *x_copy[j0],xj02:xj01       ; load x[j0]

       SHL            i0,         3,        temp  ; init store ptr
       ADD            x,          temp,     x1

  [t]  STW            xj01,       *x1++           ; if(t) do bit reversal
  [t]  STW            xj02,       *x1++           ; swap bit-reversed locns

       SHL            j0,         3,        temp  ; init store ptr
       ADD            x,          temp,     x2    ;

  [t]  STW            xi01,       *x2++           ; if(t) do bit reversal
  [t]  STW            xi02,       *x2++
  [!t] ADD            x1,         8,        x1    ; store ptr

       ADD            i0,         1,        i1    ; i1=i0+1
       ADD            j0,         halfn,    j1    ; j1=j0+halfn
       LDDW           *x[i1],     xi12:xi11       ; load x[i1]
       LDDW           *x[j1],     xj12:xj11       ; load x[j1]

       STW            xj11,       *x1++           ; store at bit-reversed locs
       MV             xj12,       xj12temp
       STW            xj12temp,   *x1             ;

       SHL            j1,         3,        temp  ; init store ptr
       ADD            x,          temp,     x2

       STW            xi11,       *x2++           ; store at bit-reversed locs
       STW            xi12,       *x2++

       ADD            j1,         1,        j3    ; j3=j1+1
       ADD            i1,         halfn,    i3    ; i3=i1+halfn
       LDDW           *x[i3],     xi32:xi31       ; load x[i3]
       LDDW           *x[j3],     xj32:xj31       ; load x[j3]

  [t]  STW            xi31,       *x2++           ; store at bit-reversed locns
  [t]  STW            xi32,       *x2

       SHL            i3,         3,        temp  ; init store ptr
       ADD            x,          temp,     x2

  [t]  STW            xj31,       *x2++           ; store at bit-reversed locns
  [t]  STW            xj32,       *x2++

       ADD            i0,         2,        i0    ; incr counter
       CMPEQ          i0,         halfn,    ex    ; jump if not true
  [!ex]B              loop

                .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_bitrev_cplx.sa                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_cfftr4_/1117057338  45    0     0       16756     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      20-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       void DSPF_sp_cfftr4_dif(float *x, float *y, short n);                    *
*                                                                           *
*       x     : Pointer to array holding the input and output floating      *
*               point array which contains n complex points                 *
*       y     : Pointer to array holding the coefficient floating point     *
*               array which contains 3*n/4 complex numbers                  *
*       n     : Number of complex point in x                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine implements a DIF (Decimation in Frequency) complex     *
*       radix-4 FFT wiht digit-reversed output and normal order input. The  *
*       number of points, n, must be a power of 4. This routine in an       *
*       in-place routine in the sense that the output is written over the   *
*       input. It is not an in-place routine in the sense that the input    *
*       is in normal order and the output is in digit-reversed order.       *
*                                                                           *
*       There must be n complex points (2*n floating point values) in the   *
*       input array and 3*n/4 complex coefficients (3*n/2 floating point    *
*       values) in the coefficient array.                                   *
*                                                                           *
*       Each real and imaginary input value is interleaved in the x array   *
*       and the complex numbers are in normal order. Each real and          *
*       imaginary output value is interleaved in the x array and the        *
*       complex numbers are in digit-reversed order. The real and           *
*       imaginary values of the coefficients are interleaved in the w       *
*       array and the complex numbers are in normal order.                  *
*                                                                           *
*       Note that the imaginary coefficients are negated                    *
*       {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than       *
*       {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                   *
*       where d = 2*PI/n.  The value of w(n,k) is usually written           *
*       w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).            *
*                                                                           *
*       The routine can be used to implement an inverse FFT by performing   *
*       the complex conjugate on the input complex numbers (negating the    *
*       imaginary part) and dividing the result by n. Another method to     *
*       use the FFT to perform an inverse FFT is to swap the real and       *
*       imaginary values of the input and the result and then divide the    *
*       result by n. In either case, the input is still in normal order     *
*       and the output is still in digit-reversed order.                    *
*                                                                           *
*       Note that you can not make the radix-4 FFT into an inverse FFT by   *
*       using the complex conjugate of the coefficients as you are able to  *
*       do with the complex radix-2 FFT.                                    *
*                                                                           *
*       If you label the input locations from 0 to n-1 (normal order), the  *
*       digit-reversed locations can be calculated by reversing the order   *
*       of the bit pairs of the lables. For example, for a 1024 point       *
*       complex FFt, the digit reversed location for                        *
*       617d = 1001101001b = 10 01 10 10 01 is                              *
*       422d = 0110100110b = 01 10 10 01 10 and vice versa.                 *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void cfftr4_dif(float  x, float  w, short n)                        *
*       {                                                                   *
*           short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;          *
*           float r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3, si1, si2,  *3
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for(k=n; k>1; k>>=2)                                            *
*           {                                                               *
*              n1 = n2;                                                     *
*              n2 >>= 2;                                                    *
*              ia1 = 0;                                                     *
*              for(j=0; j<n2; j++)                                          *
*              {                                                            *
*                 ia2 = ia1 + ia1;                                          *
*                 ia3 = ia1 + ia2;                                          *
*                 co1 = w[ia1 2];                                           *
*                 si1 = w[ia1 2 + 1];                                       *
*                 co2 = w[ia2 2];                                           *
*                 si2 = w[ia2 2 + 1];                                       *
*                 co3 = w[ia3 2];                                           *
*                 si3 = w[ia3 2 + 1];                                       *
*                 ia1 += ie;                                                *
*                 for(i0=j; i0<n; i0+=n1)                                   *
*                 {                                                         *
*                     i1 = i0 + n2;                                         *
*                     i2 = i1 + n2;                                         *
*                     i3 = i2 + n2;                                         *
*                     r1 = x[i0 2]   + x[i2 2];                             *
*                     r3 = x[i0 2]   - x[i2 2];                             *
*                     s1 = x[i0 2+1] + x[i2 2+1];                           *
*                     s3 = x[i0 2+1] - x[i2 2+1];                           *
*                     r2 = x[i1 2]   + x[i3 2];                             *
*                     r4 = x[i1 2]   - x[i3 2];                             *
*                     s2 = x[i1 2+1] + x[i3 2+1];                           *
*                     s4 = x[i1 2+1] - x[i3 2+1];                           *
*                     x[i0 2]   = r1 + r2;                                  *
*                     r2        = r1 - r2;                                  *
*                     r1        = r3 - s4;                                  *
*                     r3        = r3 + s4;                                  *
*                     x[i0 2+1] = s1 + s2;                                  *
*                     s2        = s1 - s2;                                  *
*                     s1        = s3 + r4;                                  *
*                     s3        = s3 - r4;                                  *
*                     x[i1 2]   = co1 r3 + si1 s3;                          *
*                     x[i1 2+1] = co1 s3 - si1 r3;                          *
*                     x[i2 2]   = co2 r2 + si2 s2;                          *
*                     x[i2 2+1] = co2 s2 - si2 r2;                          *
*                     x[i3 2]   = co3 r1 + si3 s1;                          *
*                     x[i3 2+1] = co3 s1 - si3 r1;                          *
*                 }                                                         *
*              }                                                            *
*              ie <<= 2;                                                    *
*           }                                                               *
*       }                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_cfftr4_dif
_DSPF_sp_cfftr4_dif   .cproc  x, w, n

* ======================================================================== *
* ======================================================================== *
                 .reg k, ie, n2, n1
                 .reg si1:co1, si2:co2, si3:co3
                 .reg si0, i, i0, i1, i2, i3, cnt
                 .reg xi01:xi00, xi11:xi10, xi21:xi20, xi31:xi30
                 .reg r1, s1, r2, s2, r3, s3, r4, s4, r5, s5, r6, s6, r7, s7
                 .reg p1, p2, p3, p4
                 .reg xi00s, xi01s, xi10s, xi11s, xi20s, xi21s, xi31s, xi30s
                 .reg ia1, ia2, ia3, icntr
                 .reg xs, stcntr

                 MV n, n2                 ; init n2
                 MVK 1, ie                ; init ie
                 SHR n, 2, stcntr         ; store for counter
                 MV stcntr, k             ; init outer loop cntr

oloop:
                 MV   n2, n1              ; init n1
                 SHR  n2, 2, n2           ; n2>>2
                 ZERO ia1                 ; init ia1
                 MV   ie, i               ; init i
                 MV   stcntr, cnt         ; init icntr
                 ZERO si0                 ; store for i0
                 ZERO i0                  ; init i0
                 SHL    ia1, 1, ia2       ; ia2=ia1<<1
                 ADD    ia2, ia1, ia3     ; ia3=ia1+ia2
                 LDDW   *w[ia1], si1:co1  ; load si1:co1
                 LDDW   *w[ia2], si2:co2  ; load si2:co2
                 LDDW   *w[ia3], si3:co3  ; load si3:co3
                 ADD    ia1, ie, ia1      ; update ia1

loop:

       [!i] SHL    ia1, 1, ia2            ; update after inner most loop
       [!i] ADD    ia2, ia1, ia3          ; ia3=ia1+ia2
       [!i] LDDW   *w[ia1], si1:co1       ; load si1:co1
       [!i] LDDW   *w[ia2], si2:co2       ; load si2:co2
       [!i] LDDW   *w[ia3], si3:co3       ; load si3:co3
       [!i] ADD    ia1, ie, ia1           ; ia1+=ie
       [!i] ADD    si0, 1, si0            ; si0++
       [!i] MV     si0,  i0               ; update i0
       [!i] MV     ie, i                  ; inner most loop cntr update

              ADD    i0, n2, i1           ; i1=i0+n2
              ADD    i1, n2, i2           ; i2=i1+n2
              ADD    i2, n2, i3           ; i3=i2+n2

              LDDW   *x[i0], xi01:xi00    ; load xi01:xi00
              LDDW   *x[i1], xi11:xi10    ; load xi11:xi10
              LDDW   *x[i2], xi21:xi20    ; load xi21:xi20
              LDDW   *x[i3], xi31:xi30    ; load xi31:xi30

              ADDSP   xi00, xi20, r1      ; r1=xi00+xi20
              SUBSP   xi00, xi20, r3      ; r3=xi00-xi20

              ADDSP   xi01, xi21, s1      ; s1=xi00+xi20
              SUBSP   xi01, xi21, s3      ; s3=xi00-xi20

              ADDSP   xi10, xi30, r2      ; r2=xi10+xi30
              SUBSP   xi10, xi30, r4      ; r4=xi10-xi30

              ADDSP   xi11, xi31, s2      ; s2=xi11+xi31
              SUBSP   xi11, xi31, s4      ; s4=xi11-xi31

              ADDSP   r1, r2, xi00s       ; xi00s=r1+r2
              ADDSP   s1, s2, xi01s       ; xi01s=s1+s2

              ADDAD   x,  i0, xs          ; generate store ptr

              STW     xi00s, *xs++        ; store results
              STW     xi01s, *xs

              SUBSP   r1, r2, r6          ; new r2
              SUBSP   r3, s4, r5          ; new r1
              ADDSP   r3, s4, r7          ; new r3

              SUBSP   s1, s2, s6          ; new s2
              ADDSP   s3, r4, s5          ; new s1
              SUBSP   s3, r4, s7          ; new s3

              MPYSP   co1, r7, p1         ; p1=co1*r7
              MPYSP   si1, s7, p2         ; p2=si1*s7
                  ADDSP   p1, p2, xi10s       ; xi10=p1+p2
                  ADDAD   x,  i1, xs          ; generate store addr
                  STW     xi10s, *xs++        ; store xi10

              MPYSP   co1, s7, p1         ; p1=co1*s7
              MPYSP   si1, r7, p2         ; p2=si1*r7
                  SUBSP   p1, p2, xi11s       ; xi11=p1-p2
              STW     xi11s, *xs          ; store xi11

              MPYSP   co2, r6, p3         ; p3=co2*r6
              MPYSP   si2, s6, p4         ; p4=si2*s6
              ADDSP   p3, p4, xi20s       ; xi20=p3+p4
                  ADDAD   x,  i2, xs          ; gen store addr
                  STW     xi20s, *xs++        ; store xi20

              MPYSP   co2, s6, p1         ; p1=co2*s6
              MPYSP   si2, r6, p2         ; p2=si2*r6
              SUBSP   p1, p2,  xi21s      ; xi21=p1-p2
              STW     xi21s, *xs

              MPYSP   co3, r5, p3         ; p3=co3*r5
              MPYSP   si3, s5, p4         ; p4=si3*s5
              ADDSP   p3, p4,  xi30s      ; xi30=p3+p4
                  ADDAD   x,  i3, xs          ; gen store addr
                  STW     xi30s, *xs++        ; store xi30

              MPYSP   co3, s5, p1         ; p1=co3*s5
              MPYSP   si3, r5, p2         ; p2=si3*r5
              SUBSP   p1, p2, xi31s       ; xi30=p1-p2
              STW     xi31s, *xs++          ; store xi30

              ADD     i0, n1, i0          ; update i0
              SUB     i, 1, i
                  SUB     cnt, 1, cnt

 [cnt]            B       loop

                  SHL     ie, 2, ie           ; ie<<=2
                  SHR     k,  2, k            ; k>>=2
         [k]      B       oloop

              .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_cfftr4_dif.sa                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr2_/1117057339  68    0     0       11331     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr2_dit -- DSPF_sp_cfftr2_dit                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      20-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       void DSPF_sp_cfftr2_dit(float *x, float *y, short n);                    *
*                                                                           *
*       x : Pointer to complex data input and output                        *
*       y : Pointer to complex twiddle factors in bit-reversed order        *
*       n : Length of FFT in complex samples, power of 2 such that n>=3     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs a Decimation-in-Time (DIT) Radix-2 FFT of     *
*       the input array x.                                                  *
*                                                                           *
*       x has N complex floating point numbers arranged as successive real  *
*       and imaginary number pairs. Input array x contains N complex        *
*       points (2*N elements). The coefficients for the FFT are passed to   *
*       the function in the array w which contains N/2 complex numbers (N   *
*       elements) as successive real and imaginary number pairs.            *
*                                                                           *
*       The FFT coefficients in w are in N/2 bit-reversed order. The        *
*       elements of the input array x are in normal order.                  *
*                                                                           *
*       Note that the bit-reversed coefficient for higher order FFT (1024   *
*       point) can be used unchanged as coefficients for a lower order      *
*       FFT (512, 256, 128, ..., 2).                                        *
*                                                                           *
*       The routine can be used to implement an inverse FFT by any one      *
*       of the following methods:                                           *
*                                                                           *
*       1. Inputs x are replaced by their complex-conjugate values.         *
*          Output values are divided by n.                                  *
*       2. FFT coefficients in w are replaced by their complex-conjugates.  *
*          Output values are divided by n.                                  *
*       3. Swap the real and imaginary values of the input.                 *
*       4. Swap the real and imaginary values of the output.                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_cfftr2_dit(float  x, float  w, short n)                     *
*       {                                                                   *
*          short n2, ie, ia, i, j, k, m;                                    *
*          float rtemp, itemp, c, s;                                        *
*                                                                           *
*          n2 = n;                                                          *
*          ie = 1;                                                          *
*                                                                           *
*          for(k=n; k > 1; k >>= 1)                                         *
*          {                                                                *
*             n2 >>= 1;                                                     *
*             ia = 0;                                                       *
*             for(j=0; j < ie; j++)                                         *
*             {                                                             *
*                c = w[2 j];                                                *
*                s = w[2 j+1];                                              *
*                for(i=0; i < n2; i++)                                      *
*                {                                                          *
*                   m = ia + n2;                                            *
*                   rtemp     = c   x[2 m]   + s   x[2 m+1];                *
*                   itemp     = c   x[2 m+1] - s   x[2 m];                  *
*                   x[2 m]    = x[2 ia]   - rtemp;                          *
*                   x[2 m+1]  = x[2 ia+1] - itemp;                          *
*                   x[2 ia]   = x[2 ia]   + rtemp;                          *
*                   x[2 ia+1] = x[2 ia+1] + itemp;                          *
*                   ia++;                                                   *
*                }                                                          *
*                ia += n2;                                                  *
*             }                                                             *
*             ie <<= 1;                                                     *
*          }                                                                *
*       }                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_cfftr2_dit
_DSPF_sp_cfftr2_dit   .cproc  A_xptr, B_wptr, A_n

* ======================================================================== *
* ======================================================================== *
                .reg A_n2, A_icntr, A_cnt
                .reg B_s:B_c
                .reg B_w, B_x, A_xs, B_xs
                .reg A_i, A_8n2
                .reg A_c, A_x
                .reg A_x2mp1:A_x2m
                .reg A_p1, A_p2, A_p3, B_p4
                .reg A_rtemp, B_itemp
                .reg B_x2iap1:B_x2ia
                .reg A_x2ms, A_x2ias, B_x2mp1s, B_x2iap1s
                .no_mdep

                MV       A_n,     A_n2          ; init n2
                SHR      A_n,     1,     A_n    ; outer loop cntr
                MV       A_n,     A_cnt         ; inner loop cntr

oloop:
                SHR      A_n2,    1,     A_n2   ; n2>>1
                LDDW     *B_wptr, B_s:B_c       ; load s:c
                ADD      B_wptr,  8,     B_w    ; init w ptr
                MV       A_n2,    A_i           ; init ia
                MV       A_cnt,   A_icntr       ; init loop cntr
                SHL      A_n2,    3,     A_8n2  ; n2<<3
                ADDAD    A_xptr,  A_n2,  A_x    ; init load ptr
                ADDAD    A_xptr,  A_n2,  A_xs   ; init store ptr
                MV       A_xptr,  B_x           ; init load ptr
                MV       B_x,     B_xs          ; init store ptr
loop:
         [!A_i] ADD      A_x,     A_8n2, A_x    ; if(!i) A_x+=8n2
         [!A_i] ADD      B_x,     A_8n2, B_x    ; if(!i) B_x+=8n2
         [!A_i] LDDW     *B_w++,  B_s:B_c       ; if(!i) load s:c
         [!A_i] ADD      A_xs,    A_8n2,       A_xs   ; reset store ptr
         [!A_i] ADD      B_xs,    A_8n2,       B_xs   ; reset store ptr

                LDDW     *A_x++,  A_x2mp1:A_x2m ; load x[2m+1]:x[2m]

         [!A_i] MV       A_n2,    A_i           ; reset ia
         [A_i]  SUB      A_i,      1,          A_i    ; decr ia

                MPYSP    A_x2m,   B_c,   A_p1    ; p1=c*x[2m]
                MPYSP    A_x2m,   B_s,   B_p4   ; p4=s*x[2m]
                MPYSP    A_x2mp1, B_s,   A_p2    ; p2=s*x[2m+1]
                MPYSP    A_x2mp1, B_c,   A_p3    ; p3=c*x[2m+1]


                ADDSP    A_p1,    A_p2,  A_rtemp; rtemp=p1+p1
                SUBSP    A_p3,    B_p4,  B_itemp; itemp=p3-p4

                LDDW     *B_x++,  B_x2iap1:B_x2ia; load x[2ia+1]:x[2ia]

                 SUBSP    B_x2ia,  A_rtemp,     A_x2ms; x[2m]=x[2ia]-rtemp
                ADDSP    B_x2ia,  A_rtemp,     A_x2ias; x[2ia]=x[2ia]+rtemp

                SUBSP    B_x2iap1,B_itemp,     B_x2mp1s; x[2m+1]=x[2ia+1]-itemp
                ADDSP    B_x2iap1,B_itemp,     B_x2iap1s;x[2ia+1]=x[2ia+1]+itemp


                STW      A_x2ms,  *A_xs++             ; perform all stores
                STW      A_x2ias, *B_xs++
                STW      B_x2mp1s,*A_xs++
                STW      B_x2iap1s,*B_xs++



     [A_icntr]  SUB      A_icntr,  1,          A_icntr ; decr loop cntr
     [A_icntr]  B        loop                          ; branch inner

                SHR      A_n,      1,          A_n     ; half outer loop cntr
         [A_n]  B        oloop                         ; branch outer loop


                .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_cfftr2_dit.sa                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fftSPxS/1117057341  91    0     0       47826     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          *
*      forwards FFT with complex input                                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of fft in complex samples, power of 2 such that    *
*                    N >=8 and N<= 16385.                                   *
*       ptr_x  :  Pointer to complex data input.                            *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data.                           *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest fft butterfly used in computation used for       *
*                 decomposing fft into subffts, see notes.                  *
*       offset :  Index in complex samples of sub-fft from start of main    *
*                 fft.                                                      *
*       n_max  :  size of main fft in complex samples.                      *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards fft using a special   *
*       sequece of coefficients generated in the following way:             *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the fft  *
*       producing the frequency domain data in the Y array.                 *
*       As the fft allows every input point to effect every output point    *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main fft of size N to  *
*       be divided into several steps, allowing as much data reuse as       *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           *
*                                                                           *
*       Notice how the 1st fft function is called on the entire 1K data     *
*       set it covers the 1st pass of the fft until the butterfly size is   *
*       256. The following 4 ffts do 256 pt ffts 25% of the size. These     *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the fft the following would be needed :                   *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the fft is calculated by summing these      *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array. In the    *
*       smae way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the FFT, four other calls are required to        *
*       perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 FFTs in         *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the FFT with one function call invocation as shown    *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the fft. This collapses the inner 2 loops in the        *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised FFT uses a redundant sequence of twiddle factors to  *
*          allow a linear access through the data. This linear access       *
*          enables data and instruction level parallelism.                  *
*                                                                           *
*       3. The data produced by the fftSPxSP fft is in normal form, the     *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The fftSPxSP butterfly is bit reversed, i.e. the inner 2 points  *
*          of the butterfly are corssed over, this has the effect of        *
*          making the data come out in bit reversed rather than fftSPxSP    *
*          digit reversed order. This simplifies the last pass of the       *
*          loop. A simple table is used to do the bit reversal out of       *
*          place.                                                           *
*                                                                           *
*              unsigned char brev[64] =                                     *
*              {                                                            *
*                    0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,          *
*                    0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,          *
*                    0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,          *
*                    0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,          *
*                    0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,          *
*                    0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,          *
*                    0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,          *
*                    0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f           *
*              };                                                           *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on double  *
*          word boundares. Real values are stored in even word positions    *
*          and imaginary values in odd positions.                           *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on entry  *
*          to each loop and reanlbed on exit out of the loop.               *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       )                                                                   *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, fft_jmp;                                *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               fft_jmp = stride + (stride>>1);                             *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - fft_jmp);                                  *
*                   if (!predj) x += fft_jmp;                               *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 + xl21;                                       *
*                   yt2 = xl1 + xl20;                                       *
*                   xt2 = xl0 - xl21;                                       *
*                   yt1 = xl1 - xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += fft_jmp;                                       *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of fft */                 *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1472 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_fftSPxSP
_DSPF_sp_fftSPxSP   .cproc  N, ptr_x, ptr_w, ptr_y, brev, n_min, offset, n_max

* ======================================================================== *
* ======================================================================== *

                    .reg    j, h2, l1, l2, predj, w_copy
                    .reg    Ltmp, ftmp1, ftmp2, ftmp3, ftmp4, ptr_x2, x, w
                    .reg    prod0, prod1, prod2, prod3
                    .reg    prod4, prod5, prod6, prod7
                    .reg    x_1:x_0, x_l1p1:x_l1, x_h2p1:x_h2, x_l2p1:x_l2
                    .reg    si1:co1, si2:co2, si3:co3
                    .reg    xh0, xh1, xl0, xl1, xh20, xh21, xl20, xl21
                    .reg    xt0, xt1, xt2, yt0, yt1, yt2, h2p1, l1p1, l2p1
                    .reg    h2_ind, l1_ind, l2_ind, ptr_x_h2, ptr_x_l2, p_x
                    .reg    whileFlag, radix, n_copy, x_copy, st_index, x2_copy
                    .reg    fft_jmp, tw_offset, stride, ptr_x_copy
                    .reg    k0, k1, y1, temp, j0, j1, ptr_x0, y0, l0, gtflag
                    .reg    x1:x0, x3:x2, x5:x4, x7:x6
                    .reg    xh0_0, xh1_0, xh0_1, xh1_1
                    .reg    xl0_0, xl1_0, xl0_1, xl1_1
                    .reg    yt3, yt4, yt5, yt6, yt7, eqflag, nmax, flag

                    .no_mdep

                    MV        ptr_x,          ptr_x_copy
                    MV        N,                stride
                    ;radix = n_min
                    MV        n_min,          radix
                    ZERO    tw_offset
whileLoop:
                    ZERO    j

                    ;fft_jmp = stride + stride>>1
                    SHRU    stride,         1,          Ltmp
                    ADD     stride,         Ltmp,       fft_jmp

                    ;Have Copies of ptr_x for load and store
                    MV      ptr_x,          x
                    MV      ptr_x_copy,     ptr_x2

                    ;Twiddle factor array accessed using 'tw_offset' index
                    ADDAW   ptr_w,          tw_offset,  w
                    MV      w,              w_copy

                    ;h2, l1, l2 are at 'Ltmp = srtide>>1' apart
                    MV        Ltmp,            st_index

                    ;Offset to be used with LDDW
                    SHR     Ltmp,           1,          Ltmp
                    MV        N,              n_copy

iLoop:              .trip   2

                    ;Load twiddle facotrs
                    ADDAW   w_copy,         j,          w
                    LDDW    *w,             si1:co1
                    LDDW    *+w[1],         si2:co2
                    LDDW    *+w[2],         si3:co3

                    ;Load input complex data, which are 'Ltmp' apart
                    MV        x,              x_copy
                    LDDW    *x_copy++[Ltmp],x_1:x_0
                    LDDW    *x_copy++[Ltmp],x_h2p1:x_h2
                    LDDW    *x_copy++[Ltmp],x_l1p1:x_l1
                    LDDW    *x_copy++[Ltmp],x_l2p1:x_l2

                    ADDSP   x_0,            x_l1,       xh0
                    ADDSP   x_1,            x_l1p1,     xh1
                    SUBSP   x_0,            x_l1,       xl0
                    SUBSP   x_1,            x_l1p1,     xl1

                    ADDSP   x_h2,           x_l2,       xh20
                    ADDSP   x_h2p1,         x_l2p1,     xh21
                    SUBSP   x_h2,           x_l2,       xl20
                    SUBSP   x_h2p1,         x_l2p1,     xl21

                    ADDSP   xh0,            xh20,       ftmp1
                    ADDSP   xh1,            xh21,       ftmp2

                    ;Store the values from butterfly calculation
                    MV        ptr_x2,            x2_copy
                    STW     ftmp2,          *+x2_copy[1]
                    STW     ftmp1,          *x2_copy++[st_index]

                    ADD     x,              8,          x
                    ADD     j,              6,          j
                    SUB     j,              fft_jmp,    predj
        [!predj]    ADDAW   x,              fft_jmp,    x
        [!predj]    ZERO    j

                    SUBSP   xh0,            xh20,       xt0
                    SUBSP   xh1,            xh21,       yt0
                    ADDSP   xl0,            xl21,       xt1
                    ADDSP   xl1,            xl20,       yt2
                    SUBSP   xl0,            xl21,       xt2
                    SUBSP   xl1,            xl20,       yt1

                    MPYSP   xt1,            co1,        prod0
                    MPYSP   yt1,            si1,        prod1
                    MPYSP   yt1,            co1,        prod2
                    MPYSP   xt1,            si1,        prod3
                    MPYSP   xt0,            co2,        prod4
                    MPYSP   yt0,            si2,        prod5
                    MPYSP   yt0,            co2,        prod6
                    MPYSP   xt0,            si2,        prod7

                    ADDSP   prod0,          prod1,      ftmp1
                    SUBSP   prod2,          prod3,      ftmp2
                    ADDSP   prod4,          prod5,      ftmp3
                    SUBSP   prod6,          prod7,      ftmp4

                    ;Store the values from butterfly calculation
                    STW     ftmp4,          *+x2_copy[1]
                    STW     ftmp3,          *x2_copy++[st_index]
                    STW     ftmp2,          *+x2_copy[1]
                    STW     ftmp1,          *x2_copy++[st_index]

                    MPYSP   xt2,            co3,        prod0
                    MPYSP   yt2,            si3,        prod1
                    MPYSP   yt2,            co3,        prod2
                    MPYSP   xt2,            si3,        prod3
                    ADDSP   prod0,          prod1,      ftmp1
                    SUBSP   prod2,          prod3,      ftmp2

                    ;Store the values from butterfly calculation
                    STW     ftmp2,          *+x2_copy[1]
                    STW     ftmp1,          *x2_copy++[st_index]

                    ADD     ptr_x2,         8,          ptr_x2
        [!predj]    ADDAW   ptr_x2,         fft_jmp,    ptr_x2

                    SUB     n_copy,         4,          n_copy
        [n_copy]    B       iLoop

                    ADD     tw_offset,      fft_jmp,    tw_offset
                    SHR     stride,         2,          stride
                    CMPGT   stride,         radix,      whileFlag
        [whileFlag] B       whileLoop

;--------------------End of While Loop---------------------------------------

                    SHR     offset,         2,          j
                    MV      ptr_x,          ptr_x0
                    MV      ptr_y,          y0

                    ;get size of fft -> l0 = _norm(n_max) - 17
                    NORM    n_max,          l0
                    SUB     l0,             17,         l0

                    ;find if radix is 2 or 4 and set the flag
                    CMPEQ   n_min,          2,          eqflag
        [eqflag]    MVK     1,              flag
        [!eqflag]   ZERO    flag
                    MV      n_max,          nmax

                    CMPGT   n_min,          4,          gtflag

                    ;Jump to end of Function if radix is neither 2 nor 4
        [gtflag]    B       retFunc

                    SHR     nmax,           1,          nmax
                    SUB     nmax,           1,          nmax

                    ;reversal computation
top:                .trip 2

                    ;j0 = j & 0x3F
                    EXTU    j,              26,         26,   j0
                    SHR     j,              6,          j1

                    ;Load bit reverse array using j0 and j1 as index
                    LDBU    *brev[j0],      k0
                    LDBU    *brev[j1],      k1

                    SHL     k0,             6,          k0
                    ADD     k0,             k1,         k0
                    SHRU    k0,             l0,         k0

                    ADDAW   y0,             k0,         y1

                    ADDK    1,              j

                    LDDW    *ptr_x0++,      x1:x0
                    LDDW    *ptr_x0++,      x3:x2
                    LDDW    *ptr_x0++,      x5:x4
                    LDDW    *ptr_x0++,      x7:x6

                    ADDSP   x0,x4,          xh0_0
                    ADDSP   x1,x5,          xh1_0
                    ADDSP   x2,x6,          xh0_1
                    ADDSP   x3,x7,          xh1_1

         [flag]     MV      x0,             xh0_0
         [flag]     MV      x1,             xh1_0
         [flag]     MV      x2,             xh0_1
         [flag]     MV      x3,             xh1_1

                    ADDSP   xh0_0,          xh0_1,      yt0
                    SUBSP   xh0_0,          xh0_1,      yt4
                    SUBSP   xh1_0,          xh1_1,      yt5
                    ADDSP   xh1_0,          xh1_1,      yt1

                    SUBSP   x0,x4,          xl0_0
                    SUBSP   x1,x5,          xl1_0
                    SUBSP   x2,x6,          xl0_1
                    SUBSP   x3,x7,          xl1_1

         [flag]     MV      x4,             xl0_0
         [flag]     MV      x5,             xl1_0
         [flag]     MV      x6,             xl1_1
         [flag]     MV      x7,             xl0_1

                    ADDSP   xl0_0,          xl1_1,      yt2
                    SUBSP   xl1_0,          xl0_1,      yt3
                    SUBSP   xl0_0,          xl1_1,      yt6
                    ADDSP   xl1_0,          xl0_1,      yt7

         [flag]     MV      yt3,            temp
         [flag]     MV      yt7,            yt3
         [flag]     MV      temp,           yt7

                    ;Store appropriate values at appropriate offsets in output
                    STW     yt0,            *y1++
                    STW     yt1,            *y1++[nmax]

                    STW     yt2,            *y1++
                    STW     yt3,            *y1++[nmax]

                    STW     yt4,            *y1++
                    STW     yt5,            *y1++[nmax]

                    STW     yt6,            *y1++
                    STW     yt7,            *y1

                    SUB     N,              4,          N

           [N]      B       top

retFunc:
                    .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_fftSPxSP.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_ifftSPx/1117057342  112   0     0       48096     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         *
*      inverse FFT with complex input                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of ifft in complex samples, power of 2 such that   *
*                 N >=8 and N<= 16385.                                      *
*       ptr_x  :  Pointer to complex data input (normal order).             *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data (normal order).            *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest ifft butterfly used in computation used for      *
*                 decomposing ifft into sub iffts, see notes.               *
*       offset :  Index in complex samples of sub-ifft from start of main   *
*                 ifft.                                                     *
*       n_max  :  size of main ifft in complex samples.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards ifft using a special  *
*       sequence of coefficients generated in the following way:            *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the      *
*       ifft producing the time domain data in the Y array. The output is   *
*       scaled by a scaling factor of 1/N.                                  *
*                                                                           *
*       As the ifft allows every input point to effect every output point   *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main ifft of size N    *
*       to be divided into several steps, allowing as much data reuse as    *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          *
*                                                                           *
*       Notice how the 1st ifft function is called on the entire 1K data    *
*       set it covers the 1st pass of the ifft until the butterfly size is  *
*       256. The following 4 iffts do 256 pt iffts 25% of the size. These   *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the ifft the following would be needed :                  *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the ifft is calculated by summing these     *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple iffts they can share the same table by calling the     *
*       small iffts from further down in the twiddle factor array. In the   *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the IFFT, four other calls are required to       *
*       perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 IFFTs in        *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the IFFT with one function call invocation as shown   *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the ifft. This collapses the inner 2 loops in the       *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised IFFT uses a redundant sequence of twiddle            *
*          factors to allow a linear access through the data. This linear   *
*          access enables data and instruction level parallelism.           *
*                                                                           *
*       3.The data produced by the ifftSPxSP ifft is in normal form, the    *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The ifftSPxSP butterfly is bit reversed, i.e. the inner 2        *
*          points of the butterfly are corssed over, this has the effect    *
*          of making the data come out in bit reversed rather than          *
*          ifftSPxSP digit reversed order. This simplifies the last pass    *
*          of the loop. A simple table is used to do the bit reversal out   *
*          of place.                                                        *
*                                                                           *
*       unsigned char brev[64] =                                            *
*       {                                                                   *
*           0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,                   *
*           0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,                   *
*           0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,                   *
*           0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,                   *
*           0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,                   *
*           0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,                   *
*           0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,                   *
*           0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f                    *
*       };                                                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on         *
*          double word boundares. Real values are stored in even word       *
*          positions and imaginary values in odd positions.                 *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on        *
*          entry to each loop and reanlbed on exit out of the loop.         *
*                                                                           *
*       5. x must be padded with 16 words at the end.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, ifft_jmp;                               *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               ifft_jmp = stride + (stride>>1);                            *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - ifft_jmp);                                 *
*                   if (!predj) x += ifft_jmp;                              *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 - xl21;                                       *
*                   yt2 = xl1 - xl20;                                       *
*                   xt2 = xl0 + xl21;                                       *
*                   yt1 = xl1 + xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 - yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 + xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 - yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 + xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 - yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 + xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += ifft_jmp;                                      *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of ifft */                *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*       1504 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_ifftSPxSP
_DSPF_sp_ifftSPxSP   .cproc  N, ptr_x, ptr_w, ptr_y, brev, n_min, offset, n_max

* ======================================================================== *
* ======================================================================== *
               .reg    j, h2, l1, l2, predj, w_copy
               .reg    Ltmp, ftmp1, ftmp2, ftmp3, ftmp4, ptr_x2, x, w
               .reg    prod0, prod1, prod2, prod3, prod4, prod5, prod6, prod7
               .reg    x_1:x_0, x_l1p1:x_l1, x_h2p1:x_h2, x_l2p1:x_l2
               .reg    si1:co1, si2:co2, si3:co3
               .reg    xh0, xh1, xl0, xl1, xh20, xh21, xl20, xl21
               .reg    xt0, xt1, xt2, yt0, yt1, yt2, h2p1, l1p1, l2p1
               .reg    h2_ind, l1_ind, l2_ind, ptr_x_h2, ptr_x_l2, p_x
               .reg    whileFlag, radix, n_copy, x_copy, st_index, x2_copy
               .reg    fft_jmp, tw_offset, stride, ptr_x_copy
               .reg    k0, k1, y1, temp, j0, j1, ptr_x0, y0, l0, gtflag
               .reg    x1:x0, x3:x2, x5:x4, x7:x6
               .reg    xh0_0, xh1_0, xh0_1, xh1_1
               .reg    xl0_0, xl1_0, xl0_1, xl1_1
               .reg    yt3, yt4, yt5, yt6, yt7, eqflag, nmax, flag
               .reg    scale

               .no_mdep

                   MV        ptr_x,      ptr_x_copy
                   MV        N,            stride
                   ;radix = n_min
                   MV        n_min,      radix
                ZERO    tw_offset
whileLoop:
                   ZERO    j

                   ;fft_jmp = stride + stride>>1
                   SHRU    stride,     1,            Ltmp
                   ADD        stride,     Ltmp,        fft_jmp

                   ;Have Copies of ptr_x for load and store
                   MV        ptr_x,      x
                   MV        ptr_x_copy,    ptr_x2

                   ;Twiddle factor array accessed using 'tw_offset' index
                   ADDAW    ptr_w,      tw_offset,  w
                   MV        w,            w_copy

                   ;h2, l1, l2 are at 'Ltmp = srtide>>1' apart
                   MV        Ltmp,        st_index

                   ;Offset to be used with LDDW
                   SHR        Ltmp,        1,        Ltmp
                   MV        N,            n_copy

iLoop:             .trip    2

                   ;Load twiddle facotrs
                   ADDAW         w_copy,              j,      w
                   LDDW .2      *w,                  si1:co1
                   LDDW .2      *+w[1],              si2:co2
                   LDDW .D2T1   *+w[2],              si3:co3

                   ;Load input complex data, which are 'Ltmp' apart
                   MV          x,                      x_copy
                   LDDW .1   *x_copy++[Ltmp],        x_1:x_0
                   LDDW .1   *x_copy++[Ltmp],        x_h2p1:x_h2
                   LDDW .1   *x_copy++[Ltmp],        x_l1p1:x_l1
                   LDDW .1   *x_copy++[Ltmp],        x_l2p1:x_l2

                   ADDSP .1  x_0,        x_l1,       xh0
                   ADDSP .1  x_1,        x_l1p1,     xh1
                   SUBSP .1  x_0,        x_l1,       xl0
                   SUBSP .1  x_1,        x_l1p1,     xl1

                   ADDSP      x_h2,       x_l2,       xh20
                   ADDSP .2  x_h2p1,      x_l2p1,     xh21
                   SUBSP .2  x_h2,       x_l2,       xl20
                   SUBSP .2  x_h2p1,      x_l2p1,     xl21

                   ADDSP      xh0,        xh20,       ftmp1
                   ADDSP .1  xh1,        xh21,       ftmp2

                   ;Store the values from butterfly calculation
                   MV          ptr_x2,       x2_copy
                   STW          ftmp2,        *+x2_copy[1]
                   STW          ftmp1,        *x2_copy++[st_index]

                   ADD          x,          8,          x
                   ADD          j,          6,          j
                   SUB          j,          fft_jmp,    predj
   [!predj]     ADDAW     x,          fft_jmp,    x
   [!predj]     ZERO      j

                SUBSP .1  xh0,        xh20,       xt0
                SUBSP .2  xh1,        xh21,       yt0
                SUBSP .1  xl0,        xl21,       xt1
                SUBSP .2  xl1,        xl20,       yt2
                ADDSP .2  xl0,        xl21,       xt2
                ADDSP .1  xl1,        xl20,       yt1

                MPYSP .1  xt1,        co1,        prod0
                MPYSP .1  yt1,        si1,        prod1
                MPYSP .1  yt1,        co1,        prod2
                MPYSP .1  xt1,        si1,        prod3
                MPYSP .2  xt0,        co2,        prod4
                MPYSP .2  yt0,        si2,        prod5
                MPYSP .2  yt0,        co2,        prod6
                MPYSP .1  xt0,        si2,        prod7

                SUBSP .1  prod0,      prod1,      ftmp1
                ADDSP .1  prod2,      prod3,      ftmp2
                SUBSP .2  prod4,      prod5,      ftmp3
                ADDSP .1  prod6,      prod7,      ftmp4

                ;Store the values from butterfly calculation
                STW          ftmp4,        *+x2_copy[1]
                STW          ftmp3,        *x2_copy++[st_index]
                STW          ftmp2,        *+x2_copy[1]
                STW          ftmp1,        *x2_copy++[st_index]

                MPYSP      xt2,          co3,          prod0
                MPYSP      yt2,          si3,          prod1
                MPYSP      yt2,          co3,          prod2
                MPYSP .1  xt2,        si3,        prod3
                SUBSP      prod0,        prod1,      ftmp1
                ADDSP      prod2,        prod3,      ftmp2

                ;Store the values from butterfly calculation
                STW          ftmp2,        *+x2_copy[1]
                STW          ftmp1,        *x2_copy++[st_index]

                ADD          ptr_x2,       8,          ptr_x2
   [!predj]     ADDAW      ptr_x2,       fft_jmp,    ptr_x2

                SUB          n_copy,       4,          n_copy
   [n_copy]     B          iLoop

                ADD          tw_offset,  fft_jmp,    tw_offset
                SHR          stride,       2,          stride
                CMPGT      stride,       radix,      whileFlag
   [whileFlag]  B         whileLoop

;--------------------End of While Loop---------------------------------------

                SHR          offset,       2,          j
                MV          ptr_x,        ptr_x0
                MV          ptr_y,        y0

                ;get size of fft -> l0 = _norm(n_max) - 17
                NORM      n_max,        l0
                SUB          l0,          17,          l0

                ;find if radix is 2 or 4 and set the flag
                CMPEQ      n_min,        2,          eqflag
   [eqflag]     MVK       1,          flag
   [!eqflag]    ZERO      flag
                MV        n_max,      nmax

                CMPGT     n_min,      4,          gtflag

                ;Jump to end of Function if radix is neither 2 nor 4
   [gtflag]     B         retFunc

                INTSP     nmax,       scale
                RCPSP     scale,      scale

                SHR          nmax,          1,          nmax
                SUB          nmax,          1,          nmax

                 ;reversal computation
top:            .trip 2

                ;j0 = j & 0x3F
                EXTU .2   j,          26,          26,    j0
                SHR  .2   j,          6,          j1

                ;Load bit reverse array using j0 and j1 as index
                LDBU      *brev[j0],  k0
                LDBU      *brev[j1],  k1

                SHL          k0,          6,          k0
                ADD          k0,          k1,          k0
                SHRU      k0,          l0,          k0

                ADDAW      y0,          k0,          y1

                ADDK      1,          j

                LDDW      *ptr_x0++,  x1:x0
                LDDW      *ptr_x0++,  x3:x2
                LDDW      *ptr_x0++,  x5:x4
                LDDW      *ptr_x0++,  x7:x6

                ADDSP      x0,         x4,            xh0_0
                ADDSP      x1,         x5,            xh1_0
                ADDSP      x2,         x6,            xh0_1
                ADDSP      x3,         x7,            xh1_1

   [flag]       MV          x0,          xh0_0
   [flag]       MV          x1,          xh1_0
   [flag]       MV          x2,          xh0_1
   [flag]       MV          x3,          xh1_1

                ADDSP      xh0_0,        xh0_1,      yt0
                SUBSP      xh0_0,        xh0_1,      yt4
                SUBSP      xh1_0,        xh1_1,      yt5
                ADDSP      xh1_0,        xh1_1,      yt1

                SUBSP      x0,         x4,            xl0_0
                SUBSP      x1,         x5,            xl1_0
                SUBSP      x2,         x6,            xl0_1
                SUBSP      x7,         x3,            xl1_1

   [flag]       MV          x4,          xl0_0
   [flag]       MV          x5,          xl1_0
   [flag]       MV          x6,          xl1_1
   [flag]       MV          x7,          xl0_1

                ADDSP      xl0_0,        xl1_1,      yt2
                ADDSP     xl1_0,        xl0_1,      yt3
                SUBSP      xl0_0,        xl1_1,      yt6
                SUBSP      xl1_0,        xl0_1,      yt7

                ;Store appropriate values at appropriate offsets in output
                MPYSP     yt0,        scale,      yt0
                MPYSP     yt1,        scale,      yt1
                MPYSP     yt2,        scale,      yt2
                MPYSP     yt3,        scale,      yt3
                MPYSP     yt4,        scale,      yt4
                MPYSP     yt5,        scale,      yt5
                MPYSP     yt6,        scale,      yt6
                MPYSP     yt7,        scale,      yt7

                STW          yt0,          *y1++
                STW          yt1,          *y1++[nmax]

                STW          yt2,          *y1++
                STW          yt3,          *y1++[nmax]

                STW          yt4,          *y1++
                STW          yt5,          *y1++[nmax]

                STW          yt6,          *y1++
                STW          yt7,          *y1

                SUB          N,          4,        N

   [N]          B          top

retFunc:
                .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_ifftSPxSP.sa                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_icfftr2/1117057344  134   0     0       18734     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSPF_sp_icfftr2_dif(                                            *
*                               float* x,                                   *
*                               float* w,                                   *
*                               short n                                     *
*                              );                                           *
*                                                                           *
*           x : input and output sequences (dim-n)      (input/output)      *
*               x has n complex numbers (2*n SP values).                    *
*               The real and imaginary values are interleaved in memory.    *
*               The input is in Bit reversed order nad output is in Normal  *
*               Order.                                                      *
*           w : FFT coefficients (dim-n/2)              (input)             *
*               w has n/2 complex numbers (n SP values).                    *
*               FFT coeficients must be in bit-reversed order               *
*               The real and imaginary values are interleaved in memory     *
*           n : FFT size                                (input)             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine is used to compute the Inverse, Complex, Radix-2,      *
*       Decimation-in-Frequency Fast Fourier Transform of a single          *
*       precision complex sequence of size n, and a power of 2. The         *
*       routine requires bit-reversed input and bit-reversed coefficents    *
*       (twiddle factors) and produces results that are in normal order.    *
*       Final scaling by 1/N is not done in this function.                  *
*                                                                           *
*       How To Use                                                          *
*                                                                           *
*           void main(void)                                                 *
*           {                                                               *
*               gen_w_r2(w, N);      // Generate coefficient table          *
*               bit_rev(w, N>>1);    // Bit-reverse coefficient table       *
*               cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   *
*                                    // from TI available                   *
*                                    // input in normal order, output in    *
*                                    // order bit-reversed                  *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 *
*                                    // input in bit-reversed order,        *
*                                    // order output in normal              *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               divide(x, N);        // scale inverse FFT output            *
*                                    // result is same as original input    *
*           }                                                               *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. Loading input x as well as coefficient w in double word.         *
*       2. mpy was used to perform a mv.  EX. mpy x, 1, y <=> mv x, y       *
*       3. Because the data loads are 1 itteration ahead of the             *
*          coefficent loads, counter i was copied so that the actual        *
*          count could live longer for the coefficent loads.                *
*       4. 2 Inner loops are callapsed into one loop.                       *
*       5. prolog and epilog are done in parallel with the outermost loop.  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Both input x and coefficient w should be aligned on double word  *
*          boundary.                                                        *
*       2. x should be padded with 4 words.                                 *
*       3. n should be greater than 8.                                      *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions. Note that the assembly code is hand optimized         *
*       and restrictions may apply.                                         *
*                                                                           *
*           void icfftr2_dif(float* x, float* w, short n)                   *
*           {                                                               *
*               short n2, ie, ia, i, j, k, m;                               *
*               float rtemp, itemp, c, s;                                   *
*                                                                           *
*               n2 = 1;                                                     *
*               ie = n;                                                     *
*               for(k=n; k > 1; k >>= 1)                                    *
*               {                                                           *
*                   ie >>= 1;                                               *
*                   ia = 0;                                                 *
*                   for(j=0; j < ie; j++)                                   *
*                   {                                                       *
*                       c = w[2*j];                                         *
*                       s = w[2*j+1];                                       *
*                       for(i=0; i < n2; i++)                               *
*                       {                                                   *
*                           m = ia + n2;                                    *
*                           rtemp     = x[2*ia]   - x[2*m];                 *
*                           x[2*ia]   = x[2*ia]   + x[2*m];                 *
*                           itemp     = x[2*ia+1] - x[2*m+1];               *
*                           x[2*ia+1] = x[2*ia+1] + x[2*m+1];               *
*                           x[2*m]    = c*rtemp   - s*itemp;                *
*                           x[2*m+1]  = c*itemp   + s*rtemp;                *
*                           ia++;                                           *
*                       }                                                   *
*                       ia += n2;                                           *
*                   }                                                       *
*                   n2 <<= 1;                                               *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to generate the coefficient table      *
*       (non-bit reversed).                                                 *
*                                                                           *
*           #include <math.h>                                               *
*           /* generate real and imaginary twiddle                          *
*              table of size n/2 complex numbers */                         *
*                                                                           *
*           gen_w_r2(float* w, int n)                                       *
*           {                                                               *
*               int i;                                                      *
*               float pi = 4.0*atan(1.0);                                   *
*               float e = pi*2.0/n;                                         *
*                                                                           *
*               for(i=0; i < ( n>>1 ); i++)                                 *
*               {                                                           *
*                   w[2*i]   = cos(i*e);                                    *
*                   w[2*i+1] = sin(i*e);                                    *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to bit-reverse the coefficents.        *
*                                                                           *
*           bit_rev(float* x, int n)                                        *
*           {                                                               *
*               int i, j, k;                                                *
*               float rtemp, itemp;                                         *
*                                                                           *
*               j = 0;                                                      *
*               for(i=1; i < (n-1); i++)                                    *
*               {                                                           *
*                   k = n >> 1;                                             *
*                   while(k <= j)                                           *
*                   {                                                       *
*                       j -= k;                                             *
*                       k >>= 1;                                            *
*                   }                                                       *
*                   j += k;                                                 *
*                   if(i < j)                                               *
*                   {                                                       *
*                       rtemp    = x[j*2];                                  *
*                       x[j*2]   = x[i*2];                                  *
*                       x[i*2]   = rtemp;                                   *
*                       itemp    = x[j*2+1];                                *
*                       x[j*2+1] = x[i*2+1];                                *
*                       x[i*2+1] = itemp;                                   *
*                   }                                                       *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to perform the final scaling           *
*       of the IFFT.                                                        *
*                                                                           *
*           /* divide each element of x by n */                             *
*           divide(float* x, int n)                                         *
*           {                                                               *
*               int i;                                                      *
*               float inv = 1.0 / n;                                        *
*                                                                           *
*               for(i=0; i < n; i++)                                        *
*               {                                                           *
*                   x[2*i]   = inv * x[2*i];                                *
*                   x[2*i+1] = inv * x[2*i+1];                              *
*               }                                                           *
*           }                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_icfftr2_dif
_DSPF_sp_icfftr2_dif   .cproc  x, w, n

* ======================================================================== *
* ======================================================================== *
          .reg n2, ie, i, j, k, i1, i2, n2_mul8
          .reg rtemp, itemp, cr, si, sr, ci
          .reg x_temp, x_temp1, w_ptr
          .reg w_prr, x_ptr, x_ptr1
          .reg xm1:xm, xa1:xa, s:c
          .reg str1, str2
          .no_mdep

          MVK   1,         n2                ;n2 = 1
          MV    n,         ie                ; ie = n
          SHR   n,         1,        k       ; k=n/2

LOOP1:
          SHR   ie,        1,        ie      ; ie >>= 1
          MV    x,         x_temp            ; x_temp=x
          MV    x,         x_ptr             ; x_ptr=x
          MPY   n2,        8,        n2_mul8 ; 8*n2
          ADD   x,         n2_mul8,  x_ptr1  ;x_ptr1=x+2*n2
          ADD   x,         n2_mul8,  x_temp1 ;x_temp1=x+2*n2
          MV    w,         w_ptr             ; w_ptr=w
          LDDW  *w_ptr++,  s:c               ; load sin:cos

          MV    n2_mul8,   i                 ; i=8*n2

          SHR   n,         1, j              ; j=ie*n2 (=n/2)
LOOP:
          LDDW  *x_ptr++,  xa1:xa            ; load xa1:xa
          LDDW  *x_ptr1++, xm1:xm            ; load xm1:xm

          ADDSP xm,        xa,       str1    ; str1 = xm + xa
          ADDSP xm1,       xa1,      str2    ; str2 = xm1 + xa1
          STW   str1,      *x_temp++         ; store str1
          STW   str2,      *x_temp++         ; store str2

          SUBSP xa,        xm,       rtemp   ; rtemp = xa -xm
          SUBSP xa1,       xm1,      itemp   ; itemp = xa1 -xm1

          MPYSP c,         rtemp,    cr      ; cr = cos * rtemp
          MPYSP s,         itemp,    si      ; si = sin * itemp
          SUBSP cr,        si,       str1    ; str1 = cr - si
          STW   str1,      *x_temp1++        ; Store str1

          MPYSP c,         itemp,    ci      ; ci = cos * itemp
          MPYSP s,         rtemp,    sr      ; sr = sin * rtemp
          ADDSP ci,        sr,       str2    ; str2 = ci + sr
          STW   str2,      *x_temp1++        ; store str2

          SUB   i,         8,        i       ; i = i - 8
      [!i]ADD   x_ptr,     n2_mul8,  x_ptr   ; x_ptr = x_ptr + 2*n2
      [!i]ADD   x_ptr,     n2_mul8,  x_ptr1  ; x_ptr1 = x_ptr + 2*n2
      [!i]LDDW  *w_ptr++,  s:c               ; load cos:sin


      [!i]ADD   x_temp,    n2_mul8,  x_temp  ; x_temp = x_temp + 2*n2
      [!i]ADD   x_temp1,   n2_mul8,  x_temp1 ; x_temp1 = x_temp1 + 2*n2
      [!i]MV    n2_mul8,   i                 ; i=8*n2

      [j]SUB   j,         1,        j       ; j = j - 1
      [j]B     LOOP
         ; Branch to Inner Loop takes place here

         MPY   n2,        2,        n2      ; n2 <<= 1
         SHR   k,         1,        k       ; k >>= 1
      [k]B     LOOP1
         ; Branch to Outer Loop takes place here


                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_icfftr2_dif.sa                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_fir_cpl/1117057345  158   0     0       7125      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_sp_fir_cplx(                                                  *
*                         const float * restrict x,                         *
*                         const float * restrict h,                         *
*                         float *       restrict r,                         *
*                         int   nh,                                         *
*                         int   nr                                          *
*                        )                                                  *
*             x[2*(nr+nh-1)]:Pointer to complex Input array.                *
*                            The input data pointer x must point to the     *
*                            (nh)th complex element, i.e. element 2*(nh-1). *
*             h[2*nh]:       Pointer to complex Coefficient array           *
*                            (in normal order).                             *
*             r[2*nr]:       Pointer to complex Output array.               *
*             nh:            Number of complex coefficients in vector h.    *
*             nr:            Number of complex output samples to calculate. *
*                                                                           *
*  DESCRIPTION                                                              *
*        This function implements the FIR filter for complex input data.    *
*        The filter has nr output samples and nh coefficients. Each array   *
*        consists of an even and odd term with even terms representing the  *
*        real part and the odd terms the imaginary part of the element.     *
*        The coefficients are expected in normal order.                     *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_fir_cplx
_DSPF_sp_fir_cplx   .cproc  x, h, r, nh, nr

* ======================================================================== *
* ======================================================================== *

                  .reg x_ptr, h_ptr, icnt
                  .reg h1:h0, x1:x0, x3:x2
                  .reg prod1, prod2
                  .reg sum1,  sum2,  sum3,  sum4
                  .reg real,  imag,  real1, imag1, real2, imag2, real3, imag3
                  .no_mdep

oloop:
        MV    x,           x_ptr        ; Get x pointer
        ADD   x,           16,    x     ; Update x pointer
        MV    h,           h_ptr        ; Get h pointer

        ZERO  real                      ; Zero accumulator
        ZERO  imag                      ; Zero accumulator
        ZERO  real1                     ; Zero accumulator
        ZERO  imag1                     ; Zero accumulator
        ZERO  real2                     ; Zero accumulator
        ZERO  imag2                     ; Zero accumulator
        ZERO  real3                     ; Zero accumulator
        ZERO  imag3                     ; Zero accumulator

        MV    nh,          icnt         ; Get inner loop counter

iloop:
        LDDW  *x_ptr++,    x1:x0        ; load x[i-j+1]:x[i-j]
        LDDW  *x_ptr--[2], x3:x2        ; load x[i-j+3]:x[i-j+2]
        LDDW  *h_ptr++,    h1:h0        ; load h[j+1]:h[j]

        MPYSP h0,          x0,    prod1 ; h[j] * x[i-j]
        MPYSP h1,          x1,    prod2        ; h[j+1] * x[i+1-j]
        ADDSP real,        prod1, real  ; real += (h[j] * x[i-j])
        ADDSP real1,       prod2, real1 ; real1+= (h[j+1] * x[i+1-j])

        MPYSP h0,          x1,    prod1 ; h[j] * x[i+1-j]
        MPYSP h1,          x0,    prod2 ; h[j+1] * x[i-j]
        ADDSP imag,        prod1, imag  ; imag += (h[j] * x[i+1-j])
        ADDSP imag1,       prod2, imag1 ; imag1+= (h[j+1] * x[i-j])

        MPYSP h0,          x2,    prod1 ; real2 += (h[j] * x[i-j+2])
        MPYSP h1,          x3,    prod2 ; real3 += (h[j+1] * x[i+1-j+2])
        ADDSP real2,       prod1, real2 ; h[j] * x[i-j+2]
        ADDSP real3,       prod2, real3 ; h[j+1] * x[i+1-j+2]


        MPYSP h0,          x3,    prod1 ; h[j] * x[i+1-j+2]
        MPYSP h1,          x2,    prod2 ; h[j+1] * x[i-j+2]
        ADDSP imag2,       prod1, imag2 ; imag2 += (h[j] * x[i+1-j+2])
        ADDSP imag3,       prod2, imag3 ; imag3 += (h[j+1] * x[i-j+2])

  [icnt]SUB   icnt,        1,     icnt  ; Update Inner loop Counter
  [icnt]B     iloop
        ; Branch to inner loop occurs here

        SUBSP real,        real1, real
        STW   real,        *r++         ; r[i] = real-real1

        ADDSP imag,        imag1, imag
        STW   imag,        *r++         ; r[i+1] = imag+imag1

        SUBSP real2,       real3, real2
        STW   real2,       *r++         ; r[i+2] = real2-real3

        ADDSP imag2,       imag3, imag2
        STW   imag2,       *r++         ; r[i+3] = imag2+imag3

    [nr]SUB   nr,          2, nr        ; Update outer loop counter
    [nr]B     oloop
        ; Branch to outer loop occurs here

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_fir_cplx.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fir_gen/1117057345  179   0     0       10347     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*    This routine is C Callable and can be called as:                       *
*                                                                           *
*        void DSPF_sp_fir_gen(const float *x, const float *h, float * restrict y *
*                   int nh, int nr);                                        *
*                                                                           *
*        x : Pointer to array holding the input floating point array        *
*        h : Pointer to array holding the coefficient floating point        *
*            array                                                          *
*        y : Pointer to array holding the output floating point array       *
*        nh: Number of coefficents                                          *
*        nr: Number of output values                                        *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine implements a block FIR filter.  There are "nh"        *
*        filter coefficients, "nr" output samples, and "nh+nr-1"            *
*        input samples.    The coefficients need to be placed in the "h"    *
*        array in reverse order {h(nh-1), ... , h(1), h(0)} and the         *
*        array "x" starts at x(-nh+1) and ends at x(nr-1).  The             *
*        routine calculates y(0) through y(nr-1) using the following        *
*        formula:                                                           *
*                                                                           *
*        y(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           *
*                                                                           *
*        where n = {0, 1, ... , nr-1}.                                      *
*    C CODE                                                                 *
*        This is the C equivalent for the assembly code.  Note that         *
*        the assembly code is hand optimized and restrictions may           *
*        apply.                                                             *
*                                                                           *
*        void DSPF_sp_fir_gen(const float *x, const float *h, float * restrict r *
*                    int nh, int nr)                                        *
*        {                                                                  *
*           int i, j;                                                       *
*           float sum;                                                      *
*                                                                           *
*           for(j=0; j < nh; j++)                                           *
*           {                                                               *
*              sum = 0;                                                     *
*              for(i=0; i < nr; i++)                                        *
*              {                                                            *
*                  sum += x[i+j] * h[i];                                    *
*              }                                                            *
*              r[j] = sum;                                                  *
*           }                                                               *
*        }                                                                  *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_fir_gen
_DSPF_sp_fir_gen   .cproc  x, h, r, nh, nr

* ======================================================================== *
* ======================================================================== *
              .reg      h1:h0,     x1:x0,     x3:x2,       x4
              .reg      acc1,      acc2,      acc3,        acc4
              .reg      sum,       temp1,     temp2, temp3
              .reg      ocntr,     icntr
              .reg      acc5,      acc6,      acc7,        acc8
              .reg      nh_is_odd
              .reg      nr_mod_four
              .no_mdep

              MV        nr,        ocntr
              MV        x,         temp3
              AND       nh,        1,         nh_is_odd
              SUB       nh,        nh_is_odd, nh

              AND       nr,        3,         nr_mod_four
 [nr_mod_four]ADD       nr,        4,         nr
 [nr_mod_four]SUB       nr,        nr_mod_four,nr
 [!nr_mod_four]MVK      4,         nr_mod_four

              ;Outer loop Unrolled 4 times
oloop:           .trip 1

              ZERO      acc1                        ;Zero the accumulator
              ZERO      acc2                        ;Zero the accumulator
              ZERO      acc3                        ;Zero the accumulator
              ZERO      acc4                        ;Zero the accumulator
              ZERO      acc5                        ;Zero the accumulator
              ZERO      acc6                        ;Zero the accumulator
              ZERO      acc7                        ;Zero the accumulator
              XOR       acc8,      acc8,     acc8   ;Zero the accumulator

              SHR       nh,        1,        icntr  ;Set the counter for loop
              MV        temp3,     temp1            ;Set pointer for array x
              MV        h,         temp2

              ;Inner loop Unrolled 2 times
iloop:        .trip 2

              LDDW      *temp2++,  h1:h0          ;load h0 and h1
              LDDW      *temp1,    x1:x0          ;load x0 and x1
              LDDW      *++temp1,  x3:x2          ;load x2 and x3
              LDW       *+temp1(8),x4              ;load x4
              MPYSP     x0,       h0,      sum
              ADDSP     acc1,      sum,      acc1   ;acc1+=x0*h0
              MPYSP     x1,       h1,      sum
              ADDSP     acc2,      sum,      acc2   ;acc2+=x1*h1
              MPYSP     x1,       h0,      sum
              ADDSP     acc3,      sum,      acc3   ;acc3+=x1*h0
              MPYSP     x2,       h1,      sum
              ADDSP     acc4,      sum,      acc4   ;acc4+=x2*h1
              MPYSP     x2,       h0,      sum
              ADDSP     acc5,      sum,      acc5   ;acc5+=x2*h0
              MPYSP     x3,       h1,      sum
              ADDSP     acc6,      sum,      acc6   ;acc6+=x3*h1
              MPYSP     x3,       h0,      sum
              ADDSP     acc7,      sum,      acc7   ;acc7+=x3*h0
              MPYSP     x4,       h1,      sum
              ADDSP     acc8,      sum,      acc8   ;acc8+=x4*h1
              SUB       icntr,     1,        icntr
  [icntr]     B         iloop
              ;BRANCH TO INNER LOOP OCCURS HERE
  [nh_is_odd] LDW       *temp2 ,   h0          ;load h0 and h1
  [nh_is_odd] LDDW      *temp1,    x1:x0          ;load x0 and x1
  [nh_is_odd] LDDW      *++temp1,  x3:x2          ;load x2 and x3

  [nh_is_odd] MPYSP     h0,        x0,       sum
  [nh_is_odd] ADDSP     acc1,      sum,      acc1

  [nh_is_odd] MPYSP     h0,        x1,       sum
  [nh_is_odd] ADDSP     acc3,      sum,      acc3

  [nh_is_odd] MPYSP     h0,        x2,       sum
  [nh_is_odd] ADDSP     acc5,      sum,      acc5

  [nh_is_odd] MPYSP     h0,        x3,       sum
  [nh_is_odd] ADDSP     acc7,      sum,      acc7

              ADDSP     acc1,      acc2,     acc1
              STW       acc1,      *r++             ;store acc1+acc2
              SUB       ocntr,     1,        ocntr

              ADDSP     acc3,      acc4,     acc3
[ocntr ]      STW       acc3,      *r++             ;store acc3+acc4
[ocntr ]      SUB       ocntr,     1,        ocntr

              ADDSP     acc5,      acc6,     acc5
[ocntr]       STW       acc5,      *r++             ;store acc5+acc6
[ocntr]       SUB       ocntr,     1,        ocntr

              ADDSP     acc7,      acc8,     acc7
[ocntr]       STW       acc7,      *r++             ;store acc7+acc8
[ocntr]       SUB       ocntr,     1,        ocntr

              ADDAW     temp3,     4,        temp3  ;Set x pointer

  [ocntr]     B         oloop
              ;BRANCH TO OUTER LOOP OCCURS HERE
              .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_fir_gen.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fir_r2./1117057346  199   0     0       6715      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_sp_fir_r2(                                                    *
*                      const float * restrict x,                            *
*                      const float * restrict h,                            *
*                      float       * restrict r,                            *
*                      int   nh,                                            *
*                      int   nr                                             *
*                      )                                                    *
*             x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           *
*             h[nh]:      Pointer to Coefficient array of size nh.          *
*                         (in reverse order).                               *
*             r[nr]:      Pointer to Output array od size nr.               *
*             nh:         Number of coefficients                            *
*             nr:         Number of output samples.                         *
*                                                                           *
*  DESCRIPTION                                                              *
*        Computes a real FIR filter (direct-form) using coefficients        *
*        stored in vector h[]. The real data input is stored in vector      *
*        x[]. The filter output result is stored in vector r[]. The         *
*        filter calculates nr output samples using nh coefficients.         *
*        The coefficients are expected to be in reverse order.              *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_fir_r2
_DSPF_sp_fir_r2   .cproc  x, h, r, nh, nr

* ======================================================================== *
* ======================================================================== *
        .reg  x_ptr, h_ptr, ictr
        .reg  prod1, prod2
        .reg  sum1,  sum2,  sum3,  sum4, sum5, sum6, sum7, sum8
        .reg  x1:x0, h1:h0, x3:x2, x4

oloop:
        MV    x,          x_ptr        ; Set x ptr
        ADDAD x,          2, x         ; Update x pointer
        MV    h,          h_ptr        ; Set h ptr
        MV    nh,         ictr         ; Set inner loop counter

        ZERO  sum1                     ; Initialise accumulator
        ZERO  sum2                     ; Initialise accumulator
        ZERO  sum3                     ; Initialise accumulator
        ZERO  sum4                     ; Initialise accumulator
        ZERO  sum5                     ; Initialise accumulator
        ZERO  sum6                     ; Initialise accumulator
        ZERO  sum7                     ; Initialise accumulator
        ZERO  sum8                     ; Initialise accumulator
iloop:
        LDDW  *x_ptr++,   x1:x0        ; load x[i+j+1]:x[i+j]
        LDDW  *x_ptr,     x3:x2        ; load x[i+j+3]:x[i+j+2]
        LDDW  *h_ptr++,   h1:h0        ; load h[i+1]:h[i]
        LDW   *+x_ptr[2], x4           ; load x[i+j+4]

        MPYSP h0,         x0,    prod1
        ADDSP sum1,       prod1, sum1  ; sum1 += h[i] * x[i+j]

        MPYSP h1,         x1,    prod2
        ADDSP sum2,       prod2, sum2  ; sum2 += h[i+1] * x[i+j+1]

        MPYSP h0,         x1,    prod1
        ADDSP sum3,       prod1, sum3  ; sum3 += h[i] * x[i+j+1]

        MPYSP h1,         x2,    prod2
        ADDSP sum4,       prod2, sum4  ; sum4 += h[i+1] * x[i+j+2]

        MPYSP h0,         x2,    prod1
        ADDSP sum5,       prod1, sum5  ; sum5 += h[i] * x[i+j+2]

        MPYSP h1,         x3,    prod2
        ADDSP sum6,       prod2, sum6  ; sum6 += h[i+1] * x[i+j+3]

        MPYSP h0,         x3,    prod1
        ADDSP sum7,       prod1, sum7  ; sum7 += h[i] * x[i+j+3]

        MPYSP h1,         x4,    prod2
        ADDSP sum8,       prod2, sum8  ; sum8 += h[i+1] * x[i+j+4]

  [ictr]SUB   ictr,       2,     ictr  ; Update inner loop counter
  [ictr]B     iloop
        ; Branch to inner loop occurs here

        ADDSP sum1,       sum2,  sum1
        STW   sum1,       *r++         ; Store sum1 + sum2

        ADDSP sum3,       sum4,  sum3
        STW   sum3,       *r++         ; Store sum1 + sum2

        ADDSP sum5,       sum6,  sum5
        STW   sum5,       *r++         ; Store sum1 + sum2

        ADDSP sum7,       sum8,  sum7
        STW   sum7,       *r++         ; Store sum1 + sum2
  [nr]  SUB   nr,         4,     nr    ; Update outer loop counter
  [nr]  B     oloop
        ; Branch to outer loop takes place here

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_fir_r2.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fircirc/1117057347  218   0     0       14800     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has following C prototype                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        );                                                                 *
*                                                                           *
*       x[]     : Input array (circular buffer of 2^(csize+1) bytes)        *
*                 Must be aligned at 2^(csize+1) byte boundary              *
*       h[nh]   : Filter coefficients array                                 *
*                 Must be double-word aligned                               *
*       r[nr]   : Output array                                              *
*       index   : Offset by which to start reading from the input array     *
*                 Must be multiple of 2                                     *
*       csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         *
*                 Must be 2 <= csize <= 31.                                 *
*       nh      : Number of filter coefficients                             *
*                 Must be multiple of 2 and >= 4                            *
*       nr      : Size of output array                                      *
*                 Must be multiple of 4                                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine implements a circularly addressed FIR filter.          *
*       'nh' is the number of filter coefficients. 'nr' is the number       *
*       of the output samples.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. LDDW instructions are used to load two SP floating point         *
*          values simultaneously for the x and h arrays.                    *
*       2. The outer loop is unrolled 4 times.                              *
*       3. The inner loop is unrolled 2 times.                              *
*       4. The variables prod1, prod3, prod5 and prod7 share A9.            *
*          The variables prod0, prod2, prod4 and prod6 share B6.            *
*          The variables sum1, sum3, sum5 and sum7 share A7.                *
*          The variables sum0, sum2, sum4 and sum6 share B8.                *
*          This multiple assignment is possible since the variables         *
*          are always read just once on the first cycle that they are       *
*          avaliable.                                                       *
*       6. A load counter is used so that an epilog is not needed.  No      *
*          extraneous loads are performed.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The circular input buffer x[] must be aligned at a 2^(csize+1)   *
*          byte boundary. csize must lie in the range 2 <= csize <= 31.     *
*       2. The number of coefficients  (nh) must be a multiple of 2         *
*          and greater than or equal to 4.                                  *
*       3. The number of outputs (nr) must be a multiple of 4 and           *
*          greater than or equal to 4.                                      *
*       4. The 'index' (offset to start reading input array) must be        *
*          mutiple of 2 and less than or equal to (2^(csize-1) - 6)         *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        )                                                                  *
*       {                                                                   *
*           int i, j;                                                       *
*           //Circular Buffer block size = ((2^(csize + 1)) / 4)            *
*           //floating point numbers                                        *
*           int mod = (1 << (csize - 1));                                   *
*           float r0;                                                       *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               r0 = 0;                                                     *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   //Operation "% mod" is equivalent to "& (mod -1)"       *
*                   //r0 += x[(i + j + index) % mod] * h[j];                *
*                   r0 += x[(i + j + index) & (mod - 1)] * h[j];            *
*               }                                                           *
*           r[i] = r0;                                                      *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. This code is LITLLE ENDIAN.                                      *
*       2. This routine disables interupts for its entire duration.         *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_fircirc
_DSPF_sp_fircirc   .cproc  x, h, r, index, csize, nh, nr

* ======================================================================== *
* ======================================================================== *

                .reg    B_jflag, B_ftmp, B_ftmp0, B_ftmp1, B_ptr_h
                .reg    A_ftmp, A_ftmp0, A_ftmp1, A_r0, B_r1, A_r2, B_r3, B_r
                .reg    A_x_1:A_x_0, A_x_3:A_x_2, A_x_4, B_h_1:B_h_0, B_Ltmp, B_0
                .reg    A_ptr_x, A_index

                .no_mdep

                ; Move 'csize' parameter into BKO field of AMR
                SHL         csize,    16,         B_Ltmp

                ; Configure AMR for using A5 for circular addressing
                OR          B_Ltmp,     4,          B_Ltmp
                MVC         B_Ltmp,     AMR

                ; Move input buffer address into A5
                MV          x,        A5

                ; Add 'index' offset to cicular buffer pointer
                MV          index,    A_index
                ADDAW       A5,         A_index,    A5
                MV          A5,         A_ptr_x
                MV          r,        B_r

                ; Outer loop - Unrolled 4 times ('nr' assumed to be multiple of 4)
iLoop:          .trip   1

                ; Initialise filter sum for every iteration of outer loop
                ZERO        A_r0
                ZERO        B_r1
                ZERO        A_r2
                ZERO        B_r3

                MV          h,        B_ptr_h
                MV        nh,       B_jflag

                ; Inner loop - Unrolled 2 times  ('nh' assumed to be multiple of 2 & >=4)
jLoop:          .trip    2

                ; Load two filter coefficients ('h' assumed to be double word aligned)
                LDDW        *B_ptr_h++, B_h_1:B_h_0

                ; Load cicularly addressed input buffer
                ; 'index' assumed to be multiple of 2
                LDDW        *A5++,      A_x_1:A_x_0
                LDDW        *A5,        A_x_3:A_x_2
                LDW         *+A5[2],    A_x_4

                ; r0 += h_0 * x_0 + h_1 * x_1
                MPYSP       B_h_0,      A_x_0,      A_ftmp0
                MPYSP       B_h_1,      A_x_1,      A_ftmp1
                ADDSP       A_ftmp0,    A_ftmp1,    A_ftmp
                ADDSP       A_r0,       A_ftmp,     A_r0

                ; r1 += h_0 * x_1 + h_1 * x_2
                MPYSP       B_h_0,      A_x_1,      B_ftmp0
                MPYSP       B_h_1,      A_x_2,      B_ftmp1
                ADDSP       B_ftmp0,    B_ftmp1,    B_ftmp
                ADDSP       B_r1,       B_ftmp,     B_r1

                ; r2 += h_0 * x_2 + h_1 * x_3
                MPYSP       B_h_0,      A_x_2,      A_ftmp0
                MPYSP       B_h_1,      A_x_3,      A_ftmp1
                ADDSP       A_ftmp0,    A_ftmp1,    A_ftmp
                ADDSP       A_r2,       A_ftmp,     A_r2

                ; r3 += h_0 * x_3 + h_1 * x_4
                MPYSP       B_h_0,      A_x_3,      B_ftmp0
                MPYSP       B_h_1,      A_x_4,      B_ftmp1
                ADDSP       B_ftmp0,    B_ftmp1,    B_ftmp
                ADDSP       B_r3,       B_ftmp,     B_r3

                SUB        B_jflag,    2,          B_jflag
    [B_jflag]   B           jLoop

                ; Save 4 filtered outputs
                STW         A_r0,       *B_r++
                STW         B_r1,       *B_r++
                STW         A_r2,       *B_r++
                STW         B_r3,       *B_r++

                ; Advance circular buffer pointer A5 by 4 words
                MV          A_ptr_x,    A5
                ADDAW       A5,         4,          A5
                MV          A5,         A_ptr_x

            SUB        nr,       4,          nr
    [nr]    B           iLoop

                ; Reset AMR
                ZERO        B_0
                MVC         B_0,         AMR

                .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_fircirc.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_biquad./1117057348  238   0     0       9750      `
* ============================================================================= *
*                                                                               *
*  TEXAS INSTRUMENTS, INC.                                                      *
*                                                                               *
*  NAME                                                                         *
*      DSPF_sp_biquad: Biquad filter (IIR filter of 2nd order)                       *
*                                                                               *
*  USAGE                                                                        *
*      This routine has following C prototype:                                  *
*                                                                               *
*           void DSPF_sp_biquad (                                                    *
*                         float x[],    Pointer to input samples                *
*                         float b[],    Pointer to Nr coefs b0, b1, b2          *
*                         float a[],    Pointer to Dr coefs a1, a2              *
*                         float delay[] Pointer to filter delays                *
*                         float r[],    Pointer to output samples               *
*                         int   nx      Number of input/output samples          *
*                         )                                                     *
*                                                                               *
*                                                                               *
*                                                                               *
*  DESCRIPTION                                                                  *
*      This routine implements a DF 2 transposed structure of the biquad        *
*      filter. The transfer function of a biquad can be written                 *
*      as:                                                                      *
*                                                                               *
*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)              *
*                       H(Z) =     _________________________________            *
*                                    1 + a(1)z^(-1) + a(2)z^(-2)                *
*                                                                               *
* ============================================================================= *
*            Copyright (c) 2002 Texas Instruments, Incorporated.                *
*                           All Rights Reserved.                                *
* ============================================================================= *


        .global _DSPF_sp_biquad
        .text
        .global _DSPF_sp_biquad
_DSPF_sp_biquad:     .cproc   A_x,     B_b,     A_a,    B_delay,    A_r,   B_nx
           .reg    B_x,     r_a1,    r_a2,    r_b0,   r_b1,       r_b2
           .reg    d0,      d1
           .reg    xi,      xi1,     xi2
           .reg    temp1,   temp2
           .reg    a_12,    a1_sqr
           .reg    xi_coef, d0_coef, d1_coef, d0temp_coef
           .reg    store1,  store2
                
           .no_mdep
           .mdep   ld1,          st1
                
           LDW     *A_a,         r_a1                   ;load a1
           LDW     *A_a[1],      r_a2                   ;load a2
           LDW     *B_b,         r_b0                   ;load b0
           LDW     *B_b[1],      r_b1                   ;load b1
           LDW     *B_b[2],      r_b2                   ;load b2
           LDW     *B_delay{ld1},d0                     ;load delay
           LDW     *B_delay[1],  d1                     ;load delay
                
           MPYSP   r_a1,         r_a1,       a1_sqr     ;a1_sqr = a1 * a1
           MPYSP   r_a1,         r_a2,       a_12       ;a_12 = a1 * a2
           SUBSP   a1_sqr,       r_a2,       d1_coef    ;d1_c=a1_sqr - a2
           MPYSP   d1_coef,      r_a2,       d0temp_coef;d0temp_c=d1_c*a2
                
           ADDSP   a_12,         a_12,       temp1      ;temp1=2*a_12
           MPYSP   a1_sqr,       r_a1,       temp2      ;temp2=a1_sqr * a1
           SUBSP   temp1,        temp2,      d0_coef    ;d0_c=2*a_12-a1*a1*a1
                
           SUBSP   a1_sqr,       r_a2,       temp2      ;temp2=a1*a1-a2
           MPYSP   temp2,        r_b0,       temp1      ;temp1=b0*(a1*a1-a2)
           MPYSP   r_a1,         r_b1,       temp2      ;temp2=a1 * b1
           SUBSP   temp1,        temp2,      temp1      ;temp1=b0*(a1*a1-a2)-a1 * b1
           ADDSP   temp1,        r_b2,       xi_coef    ;xi_coef=temp1+b2
                
           MPYSP   r_a1,         r_b0,       temp1      ;temp1=a1*b0
           SUBSP   r_b1,         temp1,      temp1      ;temp1=b1-a1*b0
           STW     temp1,        *B_delay{st1}          ;store for future use
                                
           ADDAW   A_x,          2,          B_x        ;pointers for loading
                
loop:      
           LDW     *A_x++,       xi                     ;load x[i]
           LDW     *A_x++[2],    xi1                    ;load x[i+1]
           LDW     *B_x++[3],    xi2                    ;load x[i+2]
                  
           MPYSP   xi1,          r_b0,       store2     ;store2=xi1*b0
           LDW     *B_delay,     store1
           MPYSP   store1,       xi,         store1     ;store1=(b1-a1*b0)*xi
           ADDSP   store1,       store2,     temp1      ;temp1=store1+store2
                
           MPYSP   xi_coef,      xi,         store2     ;store2=xi_coef*xi
           MPYSP   r_b0,         xi2,        store1     ;store1=b0*xi2
           ADDSP   store1,       store2,     store1     ;store1=xi_coef*xi+b0*xi2
           LDW     *B_delay,     store2                 
           MPYSP   store2,       xi1,        store2     ;store2=xi1*(b1-a1*b0)
           ADDSP   store1,       store2,     temp2      ;temp2=store1+store2
                
           MPYSP   r_b0,         xi,         store1     ;store1=b0*xi
           ADDSP   store1,       d0,         store2     ;store2=b0*xi+d0
           STW     store2,       *A_r++                 ;store r[i]
                                
           MPYSP   r_a1,         d0,         store1     ;store1=a1*d0
           ADDSP   temp1,        d1,         store2     ;store2=temp1+d1
           SUBSP   store2,       store1,     store2     ;store2=temp1+d1-a1*d0
           STW     store2,       *A_r++                 ;store r[i+1]
                
           MPYSP   d1_coef,      d0,         store1     ;store1=d1_coef * d0
           MPYSP   r_a1,         d1,         store2     ;store2=a1 * d1
           ADDSP   temp2,        store1,     store1     ;store1=temp2+store1
           SUBSP   store1,       store2,     store2     ;store2=temp2+d1_coef*d0-a1*d1
           STW     store2,       *A_r++                 ;store r[i+2]
                
           MPYSP   r_b1,         xi2,        store1     ;store1=b1*xi2
           MPYSP   r_b2,         xi1,        store2     ;store2=b2*xi1
           ADDSP   store1,       store2,     store1     ;store1=b1*xi2+b2*xi1
           MPYSP   r_a1,         temp2,      store2     ;store2=a1*temp2
           SUBSP   store1,       store2,     store1     ;store1=store1-store2
           MPYSP   r_a2,         temp1,      store2     ;store2=a2*temp1
           SUBSP   store1,       store2,     store1     ;store1=store1-store2
           MPYSP   d0,           d0_coef,    store2     ;store2=d0_coef*d0
           ADDSP   store1,       store2,     store1     ;store1=store1+store2
           MPYSP   d1,           d1_coef,    store2     ;store2=d1_coef*d1
           MV      d0,           temp1                  ;store d0 for later use
           ADDSP   store2,       store1,     d0         ;update d0=store1+store2
                         
           MPYSP   r_b2,         xi2,        store1     ;store1=b2*xi2
           MPYSP   r_a2,         temp2,      store2     ;store2=a2*temp2
           SUBSP   store1,       store2,     store1     ;store1=b2*xi2-a2*temp2
           MPYSP   temp1,        d0temp_coef,store2     ;store2=d0temp_coef*d0
           SUBSP   store1,       store2,     store1     ;store1=store1-store2
           MPYSP   d1,           a_12,       store2     ;store2=a_12*d1
           ADDSP   store1,       store2,     d1         ;update d1=store1+store2
                                                           
           SUB     B_nx,         3,          B_nx       ;update loop counter
  [B_nx]   B       loop                                 ;loop ends
           ;BRANCH TO LOOP OCCURS HERE
          
           STW     d0,           *B_delay               ;update d0                      
           STW     d1,           *B_delay[1]            ;update d1
                
           .return
           .endproc
* ======================================================================== *
*  End of file:  DSPF_sp_biquad.sa                                              *
* ------------------------------------------------------------------------ *
*            Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                           All Rights Reserved.                           *
* ======================================================================== *
DSPF_sp_iir.sa/ 1117057349  0     0     0       9252      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iir -- Single Precision All-Pole IIR lattice filter              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*        This routine has following C prototype:                            *
*                                                                           *
*          void DSPF_sp_iirlat(                                                  *
*                        float * restrict r1,                               *
*                        const float * x,                                   *
*                        float * restrict r2,                               *
*                        const float * h2,                                  *
*                        const float * h1,                                  *
*                        int nr                                             *
*                        )                                                  *
*                                                                           *
*          r1      : Delay element values (i/p and o/p)                     *
*          x       : Pointer to the input array                             *
*          r2      : Pointer to the output array                            *
*          h2      : Auto-regressive filter coefficients                    *
*          h1      : Moving average filter coefficients                     *
*          nr      : Number of output samples                               *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*          The IIR performs an auto-regressive moving-average (ARMA)        *
*          filter with 4 auto-regressive filter coefficients and 5          *
*          moving-average filter coefficients for nr output samples. The    *
*          output vector is stored in two locations. This routine is used   *
*          as a high pass filter in the VSELP vocoder.                      *
*                                                                           *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*         void DSPF_sp_iir (float  restrict r1,                                  *
*                      const float     x,                                   *
*                      float  restrict r2,                                  *
*                      const float     h2,                                  *
*                      const float     h1,                                  *
*                      int nr                                               *
*                     )                                                     *
*         {                                                                 *
*            int i, j;                                                      *
*            float sum;                                                     *
*                                                                           *
*            for (i = 0; i < nr; i++)                                       *
*            {                                                              *
*                sum = h2[0]   x[4+i];                                      *
*                                                                           *
*                for (j = 1; j <= 4; j++)                                   *
*                    sum += h2[j]   x[4+i-j] - h1[j]   r1[4+i-j];           *
*                                                                           *
*                r1[4+i] = sum;                                             *
*                r2[i] = r1[4+i];                                           *
*            }                                                              *
*        }                                                                  *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_iir
_DSPF_sp_iir   .cproc  r1, x, r2, h2, h1, nr

* ======================================================================== *
* ======================================================================== *
                   .reg temp1, temp2, temp3, temp4
                   .reg temp11, temp21, temp31, sum
                   .reg h11, h12, h13, h14
                   .reg h20, h21, h22, h23, h24
                   .reg sum1, sum2, sum3, sum4
                   .reg sum5, sum6, sum7, sum8
                   .reg sum9
                   .reg xip4
                   .no_mdep

                   LDW *x++, temp1      ; temp1 = x[0]
                   LDW *x++, temp2      ; temp2 = x[1]
                   LDW *x++, temp3      ; temp3 = x[2]
                   LDW *x++, temp4      ; temp4 = x[3]

                   LDW *r1++, temp11    ; temp11 = r1[0]
                   LDW *r1++, temp21    ; temp21 = r1[1]
                   LDW *r1++, temp31    ; temp31 = r1[2]
                   LDW *r1++, sum       ; sum = r1[3]

                   LDW *h1[1], h11      ; load h1[1]
                   LDW *h1[2], h12      ; load h1[2]
                   LDW *h1[3], h13      ; load h1[3]
                   LDW *h1[4], h14      ; load h1[4]

                   LDW *h2[0], h20      ; load h2[0]
                   LDW *h2[1], h21      ; load h2[1]
                   LDW *h2[2], h22      ; load h2[2]
                   LDW *h2[3], h23      ; load h2[3]
                   LDW *h2[4], h24      ; load h2[4]

loop:
                   MPYSP h11, sum, sum9    ; sum9  = h1[1] * sum
                   MPYSP h12, temp31, sum8 ; sum8  = h1[2] * temp31;
                   MPYSP h13, temp21, sum7 ; sum7  = h1[3] * temp21;
                   MPYSP h14, temp11, sum6 ; sum6  = h1[4] * temp11;

                   MPYSP h24, temp1,  sum5 ; sum5  = h2[4] * temp1;
                   MPYSP h23, temp2,  sum4 ; sum4  = h2[3] * temp2;
                   MPYSP h22, temp3,  sum3 ; sum3  = h2[2] * temp3;
                   MPYSP h21, temp4,  sum2 ; sum2  = h2[1] * temp4;

                   LDW   *x++, xip4
                   MPYSP h20, xip4,   sum1 ; sum1  = h2[0] * x[i+4];

                   MV    temp2, temp1      ; temp1 = temp2;
                   MV    temp3, temp2      ; temp2 = temp3;
                   MV    temp4, temp3      ; temp3 = temp4;
                   MV    xip4,  temp4      ; temp4 = x[i+4];

                   MV    temp21, temp11    ; temp11 = temp21;
                   MV    temp31, temp21    ; temp21 = temp31;
                   MV    sum,    temp31    ; temp31 = sum;

                   ; add up component values
                   ADDSP sum5, sum4, sum5
                   ADDSP sum3, sum2, sum3
                   ADDSP sum3, sum5, sum3
                   ADDSP sum3, sum1, sum3

                   SUBSP sum3, sum6, sum3
                   SUBSP sum3, sum7, sum3
                   SUBSP sum3, sum8, sum3
                   SUBSP sum3, sum9, sum

                   STW   sum, *r2++        ; r2[i] = sum
                   STW   sum, *r1++        ; r1[4+i]=sum

                   SUB   nr, 1, nr
              [nr] B loop

                   .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_iir.sa                                                  *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_iirlat./1117057350  257   0     0       9982      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*        This routine has following C prototype:                            *
*                                                                           *
*             void DSPF_sp_iirlat(                                               *
*                           float *x,                                       *
*                           int nx,                                         *
*                           const float * restrict k,                       *
*                           int nk,                                         *
*                           float * restrict b,                             *
*                           float * r                                       *
*                           )                                               *
*          x[nx]   : Input vector                                           *
*          nx      : Length of input vector.                                *
*          k[nk]   : Reflection coefficients                                *
*          nk      : Number of reflection coefficients/lattice stages       *
*                    Must be multiple of 2 and >=6.                         *
*          b[nk+1] : Delay line elements from previous call. Should be      *
*                    initialized to all zeros prior to the first call.      *
*          r[nx]   : Output vector                                          *
*                                                                           *
*      DESCRIPTION                                                          *
*          This routine implements a real all-pole IIR filter in lattice    *
*          structure (AR lattice). The filter consists of nk lattice stages *
*          Each stage requires one reflection coefficient k and one delay   *
*          element b. The routine takes an input vector x[] and returns the *
*          filter output in r[]. Prior to the first call of the routine the *
*          delay elements in b[] should be set to zero. The input data may  *
*          have to be pre-scaled to avoid overflow or achieve better SNR. T *
*          reflections coefficients lie in the range -1.0 < k < 1.0. The    *
*          order of the coefficients is such that k[nk-1] corresponds to th *
*          first lattice stage after the input and k[0] corresponds to the  *
*          last stage.                                                      *
*     ASSUMPTIONS                                                           *
*         1. nk is a multiple of 4.                                         *
*    C CODE                                                                 *
*                                                                           *
*    void DSPF_sp_iirlat(float * x, int nx, const float * restrict k, int nk,    *
*                    float * restrict b, float * r)                         *
*    {                                                                      *
*                                                                           *
*      float rt;     // output       //                                     *
*      int i, j;                                                            *
*                                                                           *
*      for (j = 0; j < nx; j++)                                             *
*      {                                                                    *
*          rt = x[j];                                                       *
*                                                                           *
*          for (i = nk - 1; i >= 0; i--)                                    *
*          {                                                                *
*              rt = rt - b[i] * k[i];                                       *
*              b[i + 1] = b[i] + rt * k[i];                                 *
*          }                                                                *
*                                                                           *
*          b[0] = rt;                                                       *
*          r[j] = rt;                                                       *
*      }                                                                    *
*                                                                           *
*     }                                                                     *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_iirlat
_DSPF_sp_iirlat   .cproc  x, nx, k, nk, b, r

* ======================================================================== *
* ======================================================================== *
              .reg  rt, b_load, k_load,    icntr
              .reg  bi:bim1,    bim2:bim3
              .reg  ki:kim1,    kim2:kim3
              .reg  rt1,        rt2,       rt3
              .reg  temp1,      temp2,     temp3,    temp4
              .reg  bip1s,      bis,       bim1s,    bim2s
              .reg  rt1ki,      prod1,     prod2,    prod3
              .reg  rt2kim1,    rt3kim2,   rtkim3
              .reg  kiag:kim1ag
              .reg  biag:bim1ag

oloop:

       LDW            *x++,       rt               ; init rt
       ADDAW          b,          nk,       b_load ; init b to end of array
       SUB            b_load,     8,        b_load ; adjust b
       ADDAW          k,          nk,       k_load ; init k to end of array
       SUB            k_load,     8,        k_load ; adjust k
       MV             nk,         icntr            ; init icntr

iloop:
       LDDW           *b_load--,  bi:bim1          ; load b[i-1],b[i]
       LDDW           *k_load--,  ki:kim1          ; load k[i-1],k[i]

       MPYSP          bi,         ki,       temp1  ; temp1=bi*ki
       SUBSP          rt,         temp1,    rt1    ; rt1=rt-temp1
       LDDW           *k_load[1], kiag:kim1ag      ; load k[i-1],k[i] again

       MPYSP          rt1,        kiag,     rt1ki  ; rt1*ki
       LDDW           *b_load[1], biag:bim1ag      ; load b[i-1],b[i] again
       ADDSP          biag,       rt1ki,    bip1s  ; b[i+1]=b[i]+rt1*ki
       STW            bip1s,      *b_load[4]       ; store b[i+1]

       MPYSP          bim1,       kim1ag,   prod1  ; prod1=b[i-1]*k[i-1]
       ADDSP          temp1,      prod1,    temp2  ; temp2=temp1+prod1
       SUBSP          rt,         temp2,    rt2    ; rt2=rt-temp2
       MPYSP          rt2,        kim1,     rt2kim1; rt2*k[i-1]
       ADDSP          bim1ag,     rt2kim1,  bis    ; b[i]=b[i-1]+rt2*k[i-1]
       STW            bis,        *b_load[3]       ; store b[i]

       LDDW           *b_load--,  bim2:bim3        ; load b[i-2],b[i-3]
       LDDW           *k_load--,  kim2:kim3        ; load b[i-2],b[i-3]

       MPYSP          bim2,       kim2,     prod2  ; prod2=b[i-2]*k[i-2]
       ADDSP          temp2,      prod2,    temp3  ; temp3=temp2+prod2
       SUBSP          rt,         temp3,    rt3    ; rt3=rt-temp3
       MPYSP          rt3,        kim2,     rt3kim2; rt3*k[i-2]
       ADDSP          bim2,       rt3kim2,  bim1s  ; b[i-1]=b[i-2]+rt3*k[i-2]
       STW            bim1s,      *b_load[4]       ; store b[i-1]

       MPYSP          bim3,       kim3,     prod3  ; prod3=b[i-3]*k[i-3]
       ADDSP          temp3,      prod3,    temp4  ; temp4=temp3+prod3
       SUBSP          rt,         temp4,    rt     ; rt=rt-temp4
       MPYSP          rt,         kim3,     rtkim3 ; rt*k[i-3]
       ADDSP          bim3,       rtkim3,   bim2s  ; b[i-2]=b[i-3]+rt*k[i-3]
       STW            bim2s,      *b_load[3]       ; store b[i-2]

       SUB            icntr,      4,        icntr  ; decr icntr
  [icntr]B              iloop                      ; branch

       STW            rt,         *b               ; store b[0]
       STW            rt,         *r++             ; store r[j]

       SUB            nx,         1,        nx     ; decr ocntr
  [nx] B              oloop                        ; branch

             .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_iirlat.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_convol./1117057351  276   0     0       12566     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_convol -- Single Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*    This routine has the following C prototype:                            *
*                                                                           *
*    void DSPF_sp_convol                                                         *
*          (                                                                *
*                    float *x, //x: Pointer to input samples//              *
*                    float *h, //h: Pointer to impulse response samples//   *
*                    float *r, //r: Pointer to output samples//             *
*                    int   nh, //nh: Number of impulse response samples//   *
*                    int   nr  //nr: Number of output samples//             *
*          )                                                                *
*                                                                           *
*           x = pointer to real input vector of size = nr+nh-1              *
*               a typically contains input data (x) padded with             *
*               consecutive nh - 1  zeros at the beginning and end.         *
*           h = pointer to real input vector of size nh in forward order.   *
*               h typically contains the filter coefs.                      *
*           r = pointer to real output vector of size nr                    *
*           nh= number of elements in vector b. NOTE: nh <= nr  nh is       *
*               typically noted as m in convol formulas. nh must be a       *
*               MULTIPLE of 2                                               *
*           nr= number of elements in vector r. nr must be a MULTIPLE of 4  *
*                                                                           *
*   DESCRIPTION                                                             *
*           This function calculates the full-length convolution of real    *
*           vectors x and h using time-domain techniques. The result is     *
*           placed in real vector r.                                        *
*                                                                           *
*           It is assumed that input vector x is padded with nh-1 no of     *
*           zeros in the beginning and end.                                 *
*                                                                           *
*           It is assumed that the length of the input vector h, nh, is a   *
*           multiple of 2 and the length of the output vector r, nr, is a   *
*           multiple of 4. nh is greater thanor equal to 4 and nr is greate *
*           than or equal to nh. The routine computes 4 output              *
*           samples at a time.                                              *
*                                                                           *
*           x and h are assumed to be aligned on a double word boundary.    *
*                                                                           *
*           If routine is not to be used as a C callable function then      *
*           you need to initialize values for all of the values passed      *
*           as these are assumed to be in registers as defined by the       *
*           calling convention of the compiler, (refer to the C compiler    *
*           reference guide).                                               *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*           1. The inner loop is unrolled twice and the outer loop is       *
*              unrolled four times.                                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*           1. nh is a multiple of 2 and greater than or equal to 4         *
*           2. nr is a multiple of 4                                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*           void DSPF_sp_convol(float *x, float *h, float *r, short nh, short nr *
*           {                                                               *
*                   short   ocntr, icntr;                                   *
*                   float   acc ;                                           *
*                                                                           *
*                   for (ocntr = nr ; ocntr > 0 ; ocntr--)                  *
*                   {                                                       *
*                           acc = 0 ;                                       *
*                                                                           *
*                           for (icntr = nh ; icntr > 0 ; icntr--)          *
*                           {                                               *
*                               acc += x[nr-ocntr+nh-icntr]*h[(icntr-1)];   *
*                           }                                               *
*                           r[nr-ocntr] = acc;                              *
*                   }                                                       *
*                                                                           *
*           }                                                               *
*                                                                           *
*           This is the C equivalent of the assembly code.  Note that       *
*           the assembly code is hand optimized and restrictions may        *
*           apply.                                                          *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*           (nh/2)*nr + (nr/2)*5 + 9                                        *
*           For nh=24 and nr=64, cycles=937                                 *
*           For nh=20 and nr=32, cycles=409                                 *
*                                                                           *
*   CODESIZE                                                                *
*           480 bytes                                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_convol
_DSPF_sp_convol   .cproc  x, h, r, nh, nr

* ======================================================================== *
* ======================================================================== *
              .reg      xb0:xb1,   xa1:xa0,   xa3:xa2,     xa4
              .reg      acc1,      acc2,      acc3,        acc4
              .reg      sum,       temp1,     temp2,       temp3
              .reg      ocntr,     icntr
              .reg      acc5,      acc6,      acc7,        acc8
              .no_mdep

              MV        nr,        ocntr
              MV        x,         temp3
              ;Outer loop Unrolled 4 times
oloop:           .trip 1

              ZERO      acc1                        ;Zero the accumulator
              ZERO      acc2                        ;Zero the accumulator
              ZERO      acc3                        ;Zero the accumulator
              ZERO      acc4                        ;Zero the accumulator
              ZERO      acc5                        ;Zero the accumulator
              ZERO      acc6                        ;Zero the accumulator
              ZERO      acc7                        ;Zero the accumulator
              XOR       acc8,      acc8,     acc8   ;Zero the accumulator

              SHR       nh,        1,        icntr  ;Set the counter for loop
              MV        temp3,     temp1            ;Set pointer for array x
              ADDAW     h,         nh,       temp2  ;Set pointer for array h

              ;Inner loop Unrolled 2 times
iloop:        .trip 2

              LDDW      *--temp2,  xb0:xb1          ;load h0 and h1
              LDDW      *temp1,    xa1:xa0          ;load x0 and x1
              LDDW      *++temp1,  xa3:xa2          ;load x2 and x3
              LDW       *+temp1(8),xa4              ;load x4
              MPYSP     xa0,       xb0,      sum
              ADDSP     acc1,      sum,      acc1   ;acc1+=x0*h0
              MPYSP     xa1,       xb1,      sum
              ADDSP     acc2,      sum,      acc2   ;acc2+=x1*h1
              MPYSP     xa1,       xb0,      sum
              ADDSP     acc3,      sum,      acc3   ;acc3+=x1*h0
              MPYSP     xa2,       xb1,      sum
              ADDSP     acc4,      sum,      acc4   ;acc4+=x2*h1
              MPYSP     xa2,       xb0,      sum
              ADDSP     acc5,      sum,      acc5   ;acc5+=x2*h0
              MPYSP     xa3,       xb1,      sum
              ADDSP     acc6,      sum,      acc6   ;acc6+=x3*h1
              MPYSP     xa3,       xb0,      sum
              ADDSP     acc7,      sum,      acc7   ;acc7+=x3*h0
              MPYSP     xa4,       xb1,      sum
              ADDSP     acc8,      sum,      acc8   ;acc8+=x4*h1
              SUB       icntr,     1,        icntr
  [icntr]     B         iloop
              ;BRANCH TO INNER LOOP OCCURS HERE

              ADDSP     acc1,      acc2,     acc1
              STW       acc1,      *r++             ;store acc1+acc2
              ADDSP     acc3,      acc4,     acc3
              STW       acc3,      *r++             ;store acc3+acc4
              ADDSP     acc5,      acc6,     acc5
              STW       acc5,      *r++             ;store acc5+acc6
              ADDSP     acc7,      acc8,     acc7
              STW       acc7,      *r++             ;store acc7+acc8

              ADDAW     temp3,     4,        temp3  ;Set x pointer

              SUB       ocntr,     4,        ocntr
  [ocntr]     B         oloop
              ;BRANCH TO OUTER LOOP OCCURS HERE

              .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_convol.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_dotp_sq/1117057352  295   0     0       9574      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*      USAGE                                                                *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_sp_dotp_sqr(                                                  *
*                        float G,                                           *
*                        const float * x,                                   *
*                        const float * y,                                   *
*                        float *  restrict r,                               *
*                        int   nx                                           *
*                        )                                                  *
*             G:      Sum of y-squared initial value.                       *
*             x[nx]:  Pointer to First input array.                         *
*             y[nx]:  Pointer to Second input array.                        *
*             r:      Pointer to Output for Accumulation of x[]*y[].        *
*             nx:     Length of input vectors.                              *
*                                                                           *
*                                                                           *
*      DESCRIPTION                                                          *
*        This routine computes the dot product of x[] and y[] arrays,adding *
*        it to the value in the location pointed to by r. Additionally, it  *
*        computes the sum of the squares of the terms in the y array,adding *
*        it to the argument G. The final value of G is given as the return  *
*        value of the function.                                             *
*                                                                           *
*                                                                           *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*                                                                           *
*      Multiple Assignment was used to reduce loop carry path.              *
*                                                                           *
*      ASSUMPTIONS                                                          *
*                                                                           *
*      C CODE                                                               *
*                                                                           *
*       float DSPF_sp_dotp_sqr(float G, const float * x, const float * y,           *
*                          float *restrict r, int nx)                                      *
*             {                                                                *
*                                                                           *
*                int i;                                                              *
*                                                                           *
*                for (i = 0; i < nx; i++)                                            *
*                {                                                                   *
*                    *r += x[i] * y[i];     /* Compute Dot Product */                *
*                    G += y[i] * y[i];      /* Compute Square  */                    *
*                }                                                                   *
*                                                                           *
*                return G;                                                           *
*            }                                                                 *
*                                                                                                      *
*       This is the C equivalent of the assembly code.  Note that              *
*       the assembly code is hand optimized and restrictions may apply.                          *
*                                                                                                   *
*     NOTES                                                                 *
*     CYCLES                                                                                        *
*       nx+23                                                                  *
*       For nx=64 cycles=87                                                    *
*       For nx=30 cycles=53                                                                *
*                                                                           *
*     CODESIZE                                                                                                                 *
*       288 bytes                                                                                *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_dotp_sqr
_DSPF_sp_dotp_sqr   .cproc  G, x, y, r, nx

* ======================================================================== *
* ======================================================================== *
                .reg x_i2:x_i1,x_i4:x_i3
                .reg y_i2:y_i1,y_i4:y_i3
                .reg prod1, prod2
                .reg sum1, sum2, sum3, sum4, sum5, sum6, sum7, sum8


      LDW   *r, sum1                    ; load *r

      ZERO sum2                         ; Initialise accumulator

      ZERO sum3                         ; Initialise accumulator

      ZERO sum4                         ; Initialise accumulator

      MV   G, sum5                      ; load G

      ZERO sum6                         ; Initialise accumulator

      ZERO sum7                         ; Initialise accumulator

      ZERO sum8                         ; Initialise accumulator

loop:

      LDDW  *x++, x_i2:x_i1             ; load x[i+1]:x[i]

      LDDW  *x++, x_i4:x_i3             ; load x[i+3]:x[i+2]

      LDDW  *y++, y_i2:y_i1             ; load y[i+1]:y[i]

      LDDW  *y++, y_i4:y_i3             ; load y[i+3]:y[i+2]

      MPYSP x_i1, y_i1, prod1           ; prod1=x[i]*y[i]
      ADDSP prod1, sum1, sum1           ; sum1 += prod1

      MPYSP x_i2, y_i2, prod1           ; prod1=x[i+1]*y[i+1]
      ADDSP prod1, sum2, sum2           ; sum2 += prod1

      MPYSP x_i3, y_i3, prod1           ; prod1=x[i+2]*y[i+2]
      ADDSP prod1, sum3, sum3           ; sum3 += prod1

      MPYSP x_i4, y_i4, prod1           ; prod1=x[i+3]*y[i+3]
      ADDSP prod1, sum4, sum4           ; sum4 += prod1

      MPYSP y_i1, y_i1, prod2           ; prod2=x[i]*y[i]
      ADDSP prod2, sum5, sum5           ; sum5 += prod2

      MPYSP y_i2, y_i2, prod2           ; prod2=x[i+1]*y[i+1]
      ADDSP prod2, sum6, sum6           ; sum6 += prod2

      MPYSP y_i3, y_i3, prod2           ; prod2=x[i+2]*y[i+2]
      ADDSP prod2, sum7, sum7           ; sum7 += prod2

      MPYSP y_i4, y_i4, prod2           ; prod2=x[i+3]*y[i+3]
      ADDSP prod2, sum8, sum8           ; sum8 += prod2

  [nx]SUB   nx, 4, nx                   ; update counter
  [nx]B     loop
      ; Branch to the loop occurs here

      ADDSP sum1, sum2, sum1

      ADDSP sum3, sum4, sum3

      ADDSP sum1, sum3, sum1            ; Accumulate the four sums

      STW   sum1, *r                    ; Store the dot product

      ADDSP sum5, sum6, sum5

      ADDSP sum7, sum8, sum7            ; Accumulate the four sums

      ADDSP sum5, sum7, G               ; Return the sum of squares

                .return G
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_dotp_sqr.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_dotprod/1117057353  316   0     0       7133      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       float DSPF_sp_dotprod(const float *x, const float *y, const int nx);     *
*                                                                           *
*       x     : Pointer to array holding the first floating point vector    *
*       y     : Pointer to array holding the second floating point vector   *
*       nx    : Number of values in the x & y vectors                       *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine calculates the dot product of 2 single precision       *
*       float vectors.                                                      *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       float dotp(const float *x, const float *y, const int nx)            *
*       {                                                                   *
*          int i;                                                           *
*          float sum = 0;                                                   *
*                                                                           *
*          for (i=0; i < nx; i++)                                           *
*          {                                                                *
*             sum += x[i] * y[i];                                           *
*          }                                                                *
*          return sum;                                                      *
*       }                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_dotprod
_DSPF_sp_dotprod   .cproc  x, y, nx

* ======================================================================== *
* ======================================================================== *
                .reg sum1,sum2,sum3,sum4,sum5,sum6,sum7,sum8
                .reg x1:x0,y1:y0,prod0
                .reg index


       ; initialize all sums to zero

       ZERO           sum1
       ZERO           sum2
       ZERO           sum3
       ZERO           sum4
       ZERO           sum5
       ZERO           sum6
       ZERO           sum7
       ZERO           sum8

       ZERO           index

loop:
       LDDW           *x++,       x1:x0          ; load x1:x0
       LDDW           *y++,       y1:y0          ; load y1:y0
       MPYSP          x0,         y0,       prod0; prod0=x0*y0
       ADDSP          sum1,       prod0,    sum1 ; sum1+=prod0
       MPYSP          x1,         y1,       prod0; prod0=x1*y1
       ADDSP          sum2,       prod0,    sum2 ; sum2+=prod0

       LDDW           *x++,       x1:x0          ; load x3:x2
       LDDW           *y++,       y1:y0          ; load y3:y2
       MPYSP          x0,         y0,       prod0; prod0=x2*y2
       ADDSP          sum3,       prod0,    sum3 ; sum3+=prod0
       MPYSP          x1,         y1,       prod0; prod0=x3*y3
       ADDSP          sum4,       prod0,    sum4 ; sum4+=prod0

       LDDW           *x++,       x1:x0          ; load x5:x4
       LDDW           *y++,       y1:y0          ; load y5:y4
       MPYSP          x0,         y0,       prod0; prod0=x4*y4
       ADDSP          sum5,       prod0,    sum5 ; sum5+=prod0
       MPYSP          x1,         y1,       prod0; prod0=x5*y5
       ADDSP          sum6,       prod0,    sum6 ; sum6+=prod0

       LDDW           *x++,       x1:x0          ; load x7:x6
       LDDW           *y++,       y1:y0          ; load y7:y6
       MPYSP          x0,         y0,       prod0; prod0=x6*y6
       ADDSP          sum7,       prod0,    sum7 ; sum7+=prod0
       MPYSP          x1,         y1,       prod0; prod0=x7*y7
       ADDSP          sum8,       prod0,    sum8 ; sum8+=prod0

       SUB            nx,         8,        nx   ; dec loop cntr
  [nx] B            loop

       ADDSP          sum1,       sum2,     sum1 ; accmulate all sums
       ADDSP          sum3,       sum4,     sum3
       ADDSP          sum5,       sum6,     sum5
       ADDSP          sum7,       sum8,     sum7

       ADDSP          sum1,       sum3,     sum1
       ADDSP          sum5,       sum7,     sum5

       ADDSP          sum1,       sum5,     sum1

                .return sum1                     ; return final sum

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_dotprod.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_dotp_cp/1117057354  336   0     0       9850      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_cplx -- Complex Single Precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       void DSPF_sp_dotp_cplx(                                                  *
*                         const float *x,                                   *
*                         const float *y,                                   *
*                         int n,                                            *
*                         float * restrict re,                              *
*                         float * restrict im                               *
*                        )                                                  *
*                                                                           *
*       x     : Pointer to array holding the first floating point vector    *
*       y     : Pointer to array holding the second floating point vector   *
*       n     : Number of values in the x & y vectors                       *
*       re    : Pointer to location storing the real part of the result     *
*       im    : Pointer to location storing the imag part of the result     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine calculates the dot product of 2 single precision       *
*       complex float vectors. The even numbered locations hold the real    *
*       parts of the complex numbers while the odd numbered locations       *
*       contain the imaginary portions.                                     *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       1.  The loop unrolled 4 times because the loop carry dependency     *
*           bound is 4.                                                     *
*       2.  LDDW instructions are used to load two SP floating point        *
*           values at a time for the x and y arrays.                        *
*       3.  A load counter avoids all extraneous loads.                     *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1.  Little Endian is assumed for LDDW instructions.                 *
*       2.  Since single assignment of registers is not used,               *
*           interrupts should be disabled before this function is           *
*           called.                                                         *
*       3.  Loop counter must be > 0.                                       *
*       4.  The x and y arrays must be double word aligned.                 *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_dotp_cplx_cn(const float  x, const float  y,                *
*                            int n, float  restrict re,                     *
*                            float  restrict im)                            *
*       {                                                                   *
*                                                                           *
*           float real=0, imag=0;                                           *
*           int i=0;                                                        *
*                                                                           *
*           for(i=0; i<n; i++)                                              *
*           {                                                               *
*               real+=(x[2 i] y[2 i] - x[2 i+1] y[2 i+1]);                  *
*               imag+=(x[2 i] y[2 i+1] + x[2 i+1] y[2 i]);                  *
*           }                                                               *
*                                                                           *
*           re=real;                                                        *
*           im=imag;                                                        *
*       }                                                                   *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_dotp_cplx
_DSPF_sp_dotp_cplx   .cproc  x, y, n, re, im

* ======================================================================== *
* ======================================================================== *
                 .reg real1, real2
                 .reg imag1, imag2
                 .reg real3, real4
                 .reg imag3, imag4

                 .reg xim1:xre1
                 .reg yim1:yre1
                 .reg xim2:xre2
                 .reg yim2:yre2
                 .reg p1, p2
                 .reg p3, p4
                 .reg t1, t2

                 ; initialize the sums
                 ZERO real1
                 ZERO imag1
                 ZERO real2
                 ZERO imag2

                 ZERO real3
                 ZERO imag3
                 ZERO real4
                 ZERO imag4

loop:
                LDDW   *x++, xim1:xre1 ; load xi:xr
                LDDW   *y++, yim1:yre1 ; load yi:yr

                MPYSP  xre1, yre1, p1  ; xr*yr
                MPYSP  xim1, yim1, p2  ; xi*yi

                ADDSP  real1, p1, real1; real1+=p1
                ADDSP  real2, p2, real2; real2+=p2

                MPYSP  xre1, yim1, p3  ; xr*yi
                MPYSP  xim1, yre1, p4  ; xi*yr

                ADDSP  imag1, p3, imag1; imag1+=p3
                ADDSP  imag2, p4, imag2; imag2+=p4

                LDDW   *x++, xim2:xre2 ; load xi:xr
                LDDW   *y++, yim2:yre2 ; load yi:yr

                MPYSP  xre2, yre2, p1  ; xr*yr
                MPYSP  xim2, yim2, p2  ; xi*yi

                ADDSP  real3, p1, real3; real3+=p1
                ADDSP  real4, p2, real4; real4+=p2

                MPYSP  xre2, yim2, p3  ; xr*yi
                MPYSP  xim2, yre2, p4  ; xi*yr

                ADDSP  imag3, p3, imag3; imag3+=p3
                ADDSP  imag4, p4, imag4; imag4+=p4

                SUB   n, 2, n          ; decr cntr
            [n] B loop                 ; branch

                ADDSP real1, real3, real1 ; accumulate all sums
                ADDSP real2, real4, real2
                SUBSP real1, real2, real1

                ADDSP imag1, imag3, imag1 ; accumulate all sums
                ADDSP imag2, imag4, imag2
                ADDSP imag1, imag2, imag1

                STW   real1, *re          ; store results
                STW   imag1, *im

                .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_dotp_cplx.sa                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_maxval./1117057355  358   0     0       6825      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       float DSPF_sp_maxval(                                                    *
*                       const float *x,                                     *
*                       int nx                                              *
*                      )                                                    *
*                                                                           *
*       x     : Pointer to input array                                      *
*       nx    : Number of inputs in input array                             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine returns the maximum value from the input array.        *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1.  The loop is unrolled three times.                               *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1.  nx is a multiple of 3 and >= 3.                                 *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       float DSPF_sp_maxval(const float  x, int nx)                             *
*       {                                                                   *
*          int i,index;                                                     *
*          float max;                                                       *
*           ((int  )&max) = 0xff800000;                                     *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] > max)                                                  *
*             {                                                             *
*             max = x[i];                                                   *
*             index = i;                                                    *
*             }                                                             *
*          printf("%d\n",index);                                            *
*          return max;                                                      *
*       }                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_maxval
_DSPF_sp_maxval   .cproc  x, nx

* ======================================================================== *
* ======================================================================== *
     .reg max1, max2, max3
     .reg x_i, x_i1, x_i2
     .reg flag

           MVKL    0xff800000, max1       ; max1 = -INF
           MVKH    0xff800000, max1       ; max1 = -INF

           MV      max1,       max2       ; max2 = -INF
           MV      max1,       max3       ; max3 = -INF

LOOP:
           LDW     *x++,       x_i        ; load xi
           LDW     *x++,       x_i1       ; load xi1
           LDW     *x++,       x_i2       ; load xi2

           CMPGTSP x_i,        max1, flag ; if xi > max1
     [flag]MV      x_i,        max1       ; max1 = xi

           CMPGTSP x_i1,       max2, flag ; if xi1 > max2
     [flag]MV      x_i1,       max2       ; max2 = xi1

           CMPGTSP x_i2,       max3, flag ; if xi2 > max3
     [flag]MV      x_i2,       max3       ; max3 = xi2

       [nx]SUB     nx,         3,    nx   ; Update Counter
       [nx]B       LOOP                   ; Branch To Loop
           ; Branch occurs here

           CMPGTSP max2,       max1, flag ; if max2 > max1
     [flag]MV      max2,       max1       ; Set max1 to maximum

           CMPGTSP max3,       max1, flag ; if max3 > max1
     [flag]MV      max3,       max1       ; Set max1 to maximum

           .return max1

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_maxval.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_maxidx./1117057355  377   0     0       8080      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       int DSPF_sp_maxidx(                                                      *
*                     const float *x,                                       *
*                     int nx                                                *
*                    )                                                      *
*                                                                           *
*       x     : Pointer to input array                                      *
*       nx    : Number of inputs in input array                             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine returns the index of the maximum value from the input  *
*   array.                                                                  *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1.  The loop is unrolled three times.                               *
*   2.  Three maximums are maintained in each iteration.                    *
*   3.  MPY instructions are used for moves.                                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1.  nx is a multiple of 3 and >= 3.                                 *
*   2.  nx <= 2^16-1.                                                       *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       int DSPF_sp_maxidx(const float  x, int nx)                               *
*       {                                                                   *
*          int index, i;                                                    *
*          float max;                                                       *
*           ((int  )&max) = 0xff800000;                                     *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] > max)                                                  *
*             {                                                             *
*             max = x[i];                                                   *
*             index = i;                                                    *
*             }                                                             *
*          return index;                                                    *
*       }                                                                   *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_maxidx
_DSPF_sp_maxidx   .cproc  x, nx

* ======================================================================== *
* ======================================================================== *
     .reg index1, index2, index3
     .reg max1, max2, max3
     .reg x1, x2, x3
     .reg flag, flag1, result
     .reg i

             ZERO    i                         ; Initialise i

             MVKL    0xff800000, max1          ; max1 = -INF
             MVKH    0xff800000, max1          ; max1 = -INF
             MVKL    0xff800000, max2          ; max2 = -INF
             MVKH    0xff800000, max2          ; max2 = -INF
             MVKL    0xff800000, max3          ; max3 = -INF
             MVKH    0xff800000, max3          ; max3 = -INF

loop:
             LDW     *x++,       x1            ; Load x1
             CMPGTSP x1,         max1,  flag   ; if x1 > max1
       [flag]MV      x1,         max1          ; max1 = x1
       [flag]MPY     i,          1,     index1 ; index1 = i

             LDW     *x++,       x2            ; Load x2
             CMPGTSP x2,         max2,  flag   ; if x2 > max2
       [flag]MV      x2,         max2          ; max2 = x2
       [flag]MPY     i,          1,     index2 ; index2 = i

             LDW     *x++,       x3            ; Load x3
             CMPGTSP x3,         max3,  flag   ; if x3 > max3
       [flag]MV      x3,         max3          ; max3 =x3
       [flag]MPY     i,          1,     index3 ; index3 = i

             ADD     i,          3,     i      ; i = i + 3
         [nx]SUB     nx,         3,     nx     ; nx = nx - 3
         [nx]B       loop

             CMPLTSP max1,       max2,  flag   ; if max1 < max2
      [!flag]CMPLTSP max1,       max3,  flag1  ; if max1 < max3
       [flag]CMPLTSP max2,       max3,  flag1  ; if max2 < max3
      [flag1]ADD     index3,     2,     result ; Here max3 is maximum
      [flag1]B       end                       ; Branch out of function
     [!flag1]CMPLTSP max1,       max2,  flag   ; if max1 < max2
      [!flag]MV      index1,     result        ; Here max1 is maximum
       [flag]ADD     index2,     1,     result ; Here max2 is maximum

end:
             .return result
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_maxidx.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_minval./1117057356  396   0     0       6790      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       float DSPF_sp_minval(                                                    *
*                       const float *x,                                     *
*                       int nx                                              *
*                      )                                                    *
*                                                                           *
*       x     : Pointer to input array                                      *
*       nx    : Number of inputs in input array                             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine returns the minimum value from the input array.        *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1.  The loop is unrolled three times.                               *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1.  nx is a multiple of 3 and >= 3.                                 *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       float DSPF_sp_minval(const float  x, int nx)                             *
*       {                                                                   *
*          int i,index;                                                     *
*          float min;                                                       *
*           ((int  )&min) = 0x7f800000;                                     *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] < min)                                                  *
*             {                                                             *
*             min = x[i];                                                   *
*             index = i;                                                    *
*             }                                                             *
*          printf("%d\n",index);                                            *
*          return min;                                                      *
*       }                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_minval
_DSPF_sp_minval   .cproc  x, nx

* ======================================================================== *
* ======================================================================== *
     .reg min1, min2, min3
     .reg x_i, x_i1, x_i2
     .reg flag

           MVKL    0x7f800000, min1       ; min1 = +INF
           MVKH    0x7f800000, min1       ; min1 = +INF

           MV      min1,       min2       ; min2 = +INF
           MV      min1,       min3       ; min3 = +INF

LOOP:
           LDW     *x++,       x_i        ; load xi
           LDW     *x++,       x_i1       ; load xi1
           LDW     *x++,       x_i2       ; load xi2

           CMPLTSP x_i,        min1, flag ; if xi < min1
     [flag]MV      x_i,        min1       ; min1 = xi

           CMPLTSP x_i1,       min2, flag ; if xi1 < min2
     [flag]MV      x_i1,       min2       ; min2 = xi1

           CMPLTSP x_i2,       min3, flag ; if xi2 < min3
     [flag]MV      x_i2,       min3       ; min3 = xi2

       [nx]SUB     nx,         3,    nx   ; nx = nx - 3
       [nx]B       LOOP
           ; Branch occurs here

           CMPLTSP min2,       min1, flag ; if min2 < min1
     [flag]MV      min2,       min1       ; Set min1 to minimum

           CMPLTSP min3,       min1, flag ; if min3 < min1
     [flag]MV      min3,       min1       ; Set min1 to minimum

                .return min1
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_minval.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_vecreci/1117057357  415   0     0       8667      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_vecrecip(const float *x,                                   *
*                         float * restrict r,                               *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_sp_vecrecip module calculates the reciprocal of each element in *h
*       array x and returns the output in array r. It uses 2 iterations     *
*       of the Newton-Raphson method to improve the accuracy of the output  *
*       generated by the RCPSP instruction of the C67x. Each iteration      *
*       doubles the accuracy. The initial output generated by RCPSP is 8 bi *.
*       So after the first iteration it is 16 bits and after the second it  *
*       the full 23 bits. The formula used is:                              *
*                                                                           *
*                r[n+1] = r[n](2 - v*r[n])                                  *
*                                                                           *
*       where v = the number whose reciprocal is to be found.               *
*       x[0], the seed value for the algorithm, is given by RCPSP.          *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*       1. The inner loop is unrolled four times to allow calculation of    *
*          four reciprocals in the kernel.                                  *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*                                                                           *
*     C CODE                                                                *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*   void DSPF_sp_vecrecip_cn(const float* x, float* restrict r, int n)           *
*       {                                                                   *
*           int i;                                                          *
*           for(i = 0; i < n; i++)                                          *
*               r[i] = 1 / x[i];                                            *
*       }                                                                   *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_vecrecip
_DSPF_sp_vecrecip   .cproc  x, r, n

* ======================================================================== *
* ======================================================================== *
            .reg num, rcp1, t1
            .no_mdep

loop:
       LDW            *x++,       num            ; load v=x[i]
       RCPSP          num,        rcp1           ; r[0]=1/v

       MPYSP          rcp1,       num,      t1   ; v*r[0]
       MPYSP          rcp1,       t1,       t1   ; v*r[0]*r[0]
       ADDSP          rcp1,       rcp1,     rcp1 ; 2*r[0]
       SUBSP          rcp1,       t1,       rcp1 ; 2*r[0]-v*r[0]*r[0]

       MPYSP          rcp1,       num,      t1   ; v*r[1]
       MPYSP          rcp1,       t1,       t1   ; v*r[1]*r[1]
       ADDSP          rcp1,       rcp1,     rcp1 ; 2*r[1]
       SUBSP          rcp1,       t1,       rcp1 ; 2*r[1]-v*r[1]*r[1]

       STW            rcp1,       *r++           ; store r[2]

       LDW            *x++,       num            ; load v=x[i+1]
       RCPSP          num,        rcp1           ; r[0]=1/v

       MPYSP          rcp1,       num,      t1   ; v*r[0]
       MPYSP          rcp1,       t1,       t1   ; v*r[0]*r[0]
       ADDSP          rcp1,       rcp1,     rcp1 ; 2*r[0]
       SUBSP          rcp1,       t1,       rcp1 ; 2*r[0]-v*r[0]*r[0]

       MPYSP          rcp1,       num,      t1   ; v*r[1]
       MPYSP          rcp1,       t1,       t1   ; v*r[1]*r[1]
       ADDSP          rcp1,       rcp1,     rcp1 ; 2*r[1]
       SUBSP          rcp1,       t1,       rcp1 ; 2*r[1]-v*r[1]*r[1]

       STW            rcp1,       *r++           ; store r[2]

       LDW            *x++,       num            ; load v=x[i+2]
       RCPSP          num,        rcp1           ; r[0]=1/v

       MPYSP          rcp1,       num,      t1   ; v*r[0]
       MPYSP          rcp1,       t1,       t1   ; v*r[0]*r[0]
       ADDSP          rcp1,       rcp1,     rcp1 ; 2*r[0]
       SUBSP          rcp1,       t1,       rcp1 ; 2*r[0]-v*r[0]*r[0]

       MPYSP          rcp1,       num,      t1   ; v*r[1]
       MPYSP          rcp1,       t1,       t1   ; v*r[1]*r[1]
       ADDSP          rcp1,       rcp1,     rcp1 ; 2*r[1]
       SUBSP          rcp1,       t1,       rcp1 ; 2*r[1]-v*r[1]*r[1]

       STW            rcp1,       *r++           ; store r[2]

       LDW            *x++,       num            ; load v=x[i+3]
       RCPSP          num,        rcp1           ; r[0]=1/v

       MPYSP          rcp1,       num,      t1   ; v*r[0]
       MPYSP          rcp1,       t1,       t1   ; v*r[0]*r[0]
       ADDSP          rcp1,       rcp1,     rcp1 ; 2*r[0]
       SUBSP          rcp1,       t1,       rcp1 ; 2*r[0]-v*r[0]*r[0]

       MPYSP          rcp1,       num,      t1   ; v*r[1]
       MPYSP          rcp1,       t1,       t1   ; v*r[1]*r[1]
       ADDSP          rcp1,       rcp1,     rcp1 ; 2*r[1]
       SUBSP          rcp1,       t1,       rcp1 ; 2*r[1]-v*r[1]*r[1]

       STW            rcp1,       *r++           ; store r[2]

       SUB            n,          4,        n
  [n]  B              loop
       ; branch occurs here

                .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_vecrecip.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecsum_/1117057360  436   0     0       6194      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_vecsum_sq(                                                 *
*                          const float *x,                                  *
*                          int n                                            *
*                         )                                                 *
*                                                                           *
*              x        :  Pointer to input array                           *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine returns the sum of squares of the elements of the      *
*       array x.                                                            *
*                                                                           *
*     C CODE                                                                *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*       float DSPF_sp_vecsum_sq_cn(const float  x,int n)                         *
*       {                                                                   *
*           int i;                                                          *
*           float sum=0;                                                    *
*                                                                           *
*           for(i=0; i<n; i++)                                              *
*               sum += x[i] x[i];                                           *
*                                                                           *
*           return sum;                                                     *
*       }                                                                   *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_vecsum_sq
_DSPF_sp_vecsum_sq   .cproc  x, n

* ======================================================================== *
* ======================================================================== *
          .reg x1:x0, x3:x2, x5:x4, x7:x6
          .reg s0, s1, s2, s3, s4, s5, s6, s7
          .reg p0, p1, p2, p3, p4, p5, p6, p7

          ; initialize the sums
          ZERO s0
          ZERO s1
          ZERO s2
          ZERO s3
          ZERO s4
          ZERO s5
          ZERO s6
          ZERO s7

loop:
          ; manually unrolled by 8
          LDDW *x++, x1:x0   ; load x1:x0
          MPYSP x0, x0, p0   ; x0*x0
          ADDSP s0, p0, s0   ; s0+=x0*x0

          MPYSP x1, x1, p1   ; x1*x1
          ADDSP s1, p1, s1   ; s1+=x1*x1

          LDDW *x++, x3:x2   ; load x3:x2
          MPYSP x2, x2, p2   ; x2*x2
          ADDSP s2, p2, s2   ; s2+=x2*x2

          MPYSP x3, x3, p3   ; x3*x3
          ADDSP s3, p3, s3   ; s3+=x3*x3

          LDDW *x++, x5:x4   ; load x5:x4
          MPYSP x4, x4, p4   ; x4*x4
          ADDSP s4, p4, s4   ; s4+=x4*x4

          MPYSP x5, x5, p5   ; x5*x5
          ADDSP s5, p5, s5   ; s5+=x5*x5

          LDDW *x++, x7:x6   ; load x7:x6

          MPYSP x6, x6, p6   ; x6*x6
          ADDSP s6, p6, s6   ; s6+=x6*x6

          MPYSP x7, x7, p7   ; x7*x7
          ADDSP s7, p7, s7   ; s7+=x7*x7

          SUB   n, 8, n      ; decr counter
      [n] B     loop

          ADDSP s0, s1, s0   ; accumulate the split sums
          ADDSP s2, s3, s2   ; in a inverted binary tree
          ADDSP s4, s5, s4   ; like approach
          ADDSP s6, s7, s6

          ADDSP s0, s2, s0
          ADDSP s4, s6, s4

          ADDSP s4, s0, s0

          .return s0

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_vecsum_sq.sa                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_w_vec.s/1117057361  458   0     0       6119      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_w_vec(                                                     *
*                      const float *x,                                      *
*                      const float *y,                                      *
*                      float m,                                             *
*                      float * restrict r,                                  *
*                      int nr                                               *
*                     )                                                     *
*                                                                           *
*              x        :  Pointer to first input array                     *
*              y        :  Pointer to second input array                    *
*              m        :  Weight factor                                    *
*              r        :  Output array pointer                             *
*              n        :  Number of elements in arrays                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine finds the weighted vector sum of two arrays. Both the  *
*       inputs and the output are arrays of single precision floating       *
*       point numbers.                                                      *
*                                                                           *
*     C CODE                                                                *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*       void DSPF_sp_w_vec(                                                      *
*                     const float   x,                                      *
*                     const float   y,                                      *
*                     float         m,                                      *
*                     float         restrict r,                             *
*                     int           nr                                      *
*                    )                                                      *
*                                                                           *
*       {                                                                   *
*           int i;                                                          *
*           for (i = 0; i < nr; i++)                                        *
*               r[i] = (m * x[i]) + y[i];                                   *
*       }                                                                   *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_w_vec
_DSPF_sp_w_vec   .cproc  x, y, m, r, nr

* ======================================================================== *
* ======================================================================== *
           .reg x1:x0, y1:y0, mcopy, s0, s1, p0, p1
           .reg rcopy

           MV m, mcopy      ; create a copy of weight factor
           ADD r, 4, rcopy  ; init store addr
loop:

         LDDW *x++, x1:x0   ; load x1:x0

         MPYSP m, x0, p0    ; m*x0
         MPYSP mcopy, x1, p1; m*x1

         LDDW *y++, y1:y0   ; load y1:y0

         ADDSP p0, y0, s0   ; s0=y0+p0
         ADDSP p1, y1, s1   ; s1=y1+p1

         STW s0, *r++[2]    ; store s0
         STW s1, *rcopy++[2]; store s1

         SUB nr, 2, nr      ; decr cntr
   [nr]  B loop             ; branch

            .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_w_vec.sa                                                *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecmul./1117057362  476   0     0       5271      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecmul -- DSPF_sp_vecmul                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_vecmul(                                                    *
*                       const float *x,                                     *
*                       const float *y,                                     *
*                       float * restrict r,                                 *
*                       int n                                               *
*                      )                                                    *
*                                                                           *
*              x        :  Pointer to first input array                     *
*              y        :  Pointer to second input array                    *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in arrays                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs an element by element floating point          *
*       multiply of the vectors x and y and returns the values in r.        *
*       point numbers.                                                      *
*                                                                           *
*     C CODE                                                                *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*       void DSPF_sp_vecmul_cn(const float   x, const float   y,                 *
*                         float   restrict r, int n)                        *
*       {                                                                   *
*           int i;                                                          *
*           for(i = 0; i < n; i++)                                          *
*               r[i] = x[i]   y[i];                                         *
*       }                                                                   *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_vecmul
_DSPF_sp_vecmul   .cproc  x, y, r, n

* ======================================================================== *
* ======================================================================== *
                  .reg x1:x0, y1:y0, ri, rip1
                  .no_mdep

loop:

           LDDW  *x++, x1:x0  ; load x1:x0
           LDDW  *y++, y1:y0  ; load y1:y0

           MPYSP x0, y0, ri   ; x0*y0
           MPYSP x1, y1, rip1 ; x1*y1

           STW ri, *r++       ; store products
           STW rip1, *r++

           SUB n, 2, n
        [n]B loop

                  .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_vecmul.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_mat_mul/1117057363  495   0     0       11871     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      14-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                    * 
*      This routine has following C prototype                               * 
*                                                                           * 
*          void DSPF_sp_mat_mul                                                  * 
*          (                                                                * 
*              float *x, int r1, int c1,                                    * 
*              float *y,         int c2,                                    * 
*              float *r,                                                    * 
*          );                                                               * 
*                                                                           * 
*      x[]  : Pointer to r1 by c1 input matrix.                             * 
*      r1   : Number of rows in x.                                          * 
*      c1   : Number of columns in x.  Also number of rows in y.            * 
*      y[]  : Pointer to c1 by c2 input matrix.                             * 
*      c2   : Number of columns in y.                                       * 
*      r[]  : Pointer to r1 by c2 output matrix.                            * 
*                                                                           * 
*  DESCRIPTION                                                              * 
*      This function computes the expression "r = x * y" for the matrices   * 
*      x and y.  The column dimension of x must match the row dimension     * 
*      of y.  The resulting matrix has the same number of rows as x and     * 
*      the same number of columns as y.                                     * 
*                                                                           * 
*      The values stored in the matrices are assumed to be single precision * 
*      floating point values.                                               * 
*                                                                           * 
*      This code is suitable for dense matrices.  No optimizations are      * 
*      made for sparse matrices.                                            * 
*                                                                           * 
*  C CODE                                                                   * 
*      The following is a C description of the algorithm.                   * 
*                                                                           * 
*      void DSPF_sp_mat_mul                                                      * 
*      (                                                                    * 
*          float *x, int r1, int c1,                                        * 
*          float *y,         int c2,                                        * 
*          float *r,                                                        * 
*      )                                                                    * 
*      {                                                                    * 
*          int i, j, k;                                                     * 
*          float sum;                                                       * 
*                                                                           * 
*          /* ---------------------------------------------------- */       * 
*          /*  Multiply each row in x by each column in y.  The    */       * 
*          /*  product of row m in x and column n in y is placed   */       * 
*          /*  in position (m,n) in the result.                    */       * 
*          /* ---------------------------------------------------- */       * 
*          for (i = 0; i < r1; i++)                                         * 
*              for (j = 0; j < c2; j++)                                     * 
*              {                                                            * 
*                  sum = 0;                                                 * 
*                                                                           * 
*                  for (k = 0; k < c1; k++)                                 * 
*                      sum += x[k + i*c1] * y[j + k*c2];                    * 
*                                                                           * 
*                  r[j + i*c2] = sum;                                       * 
*              }                                                            * 
*      }                                                                    * 
*                                                                           * 
* TECHNIQUES                                                                *
*     All three loops are unrolled two times                                *
*                                                                           *
*  ASSUMPTIONS                                                              * 
*      The arrays 'x', 'y', and 'r' are stored in distinct arrays.  That    * 
*      is, in-place processing is not allowed.                              * 
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

                
        .text
        .global _DSPF_sp_mat_mul
_DSPF_sp_mat_mul .cproc  A_x, B_r1, A_c1, B_y, A_c2, B_r

                .reg    iCnt, jCnt, A_kCnt, A_kLoopCnt, i, j
                .reg    A_sum, B_sum1, A_sum2, B_sum3, A_mac, B_mac1, A_mac2, B_mac3, A_index
                .reg    A_ptr_x, B_ptr_y, A_ptr_z, ptr_r, B_ptr_w, A_prod1, A_prod2 
                .reg    A_x1, A_x0, B_y1, B_y0, B_yc21, B_yc20, A_xc11, A_xc10, c2_p1
                .reg    ok_01, ok_10, ok_11, tmp, A_k_odd, B_prod1, B_prod2
                .reg    A_prod0, B_prod3, A_c1_odd, B_c2
                .no_mdep
                
                AND         A_c1,     1,       A_c1_odd
                SUB         A_c1,     A_c1_odd,  A_kLoopCnt
                ZERO        i
                MV          A_c2,     B_c2
iLoop:          .trip 1

                ZERO        j
                                
jLoop:          .trip 1

                ZERO        A_sum
                ZERO        B_sum1
                ZERO        A_sum2
                ZERO        B_sum3
                MPY         i,       A_c1,     A_index
                ADDAW       A_x,       A_index,  A_ptr_x
                ADDAW       B_y,       j,      B_ptr_y
                ADD         B_ptr_y,   4,      B_ptr_w
                ADD         A_c1,      A_index,  A_index
                ADDAW       A_x,       A_index,  A_ptr_z
                
                MV          A_kLoopCnt,        A_kCnt
                
kLoop:          .trip 1

               LDW         *A_ptr_x++,        A_x0
               LDW         *A_ptr_x++,        A_x1
               LDW         *B_ptr_y++[B_c2],    B_y0
               LDW         *B_ptr_w++[B_c2],    B_y1
               LDW         *B_ptr_y++[B_c2],    B_yc20
               LDW         *B_ptr_w++[B_c2],    B_yc21

               MPYSP       A_x0,      B_y0,     A_prod1
               MPYSP       A_x1,      B_yc20,   A_prod2
               ADDSP       A_prod1,   A_prod2,  A_mac
               ADDSP       A_sum,     A_mac,    A_sum

               MPYSP       A_x0,      B_y1,     B_prod1
               MPYSP       A_x1,      B_yc21,   B_prod2
               ADDSP       B_prod1,   B_prod2,  B_mac1
               ADDSP       B_sum1,    B_mac1,   B_sum1

               LDW         *A_ptr_z++,        A_xc10
               LDW         *A_ptr_z++,        A_xc11

               MPYSP       A_xc10,    B_y0,     A_prod1
               MPYSP       A_xc11,    B_yc20,   A_prod2
               ADDSP       A_prod1,   A_prod2,  A_mac2
               ADDSP       A_sum2,    A_mac2,   A_sum2

               MPYSP       A_xc10,    B_y1,     B_prod1
               MPYSP       A_xc11,    B_yc21,   B_prod2
               ADDSP       B_prod1,   B_prod2,  B_mac3
               ADDSP       B_sum3,    B_mac3,   B_sum3

               SUB         A_kCnt,    2,      A_kCnt
    [A_kCnt]     B           kLoop

               AND         A_c1,      1,      A_k_odd
    [A_k_odd]    LDW         *A_ptr_x,          A_x0
    [A_k_odd]    LDW         *B_ptr_y,          B_y0
    [A_k_odd]    LDW         *B_ptr_y[1],       B_y1
    [A_k_odd]    LDW         *A_ptr_z,          A_xc10
               MPYSP       A_x0,      B_y0,     A_prod0
               MPYSP       A_x0,      B_y1,     B_prod1
               MPYSP       A_xc10,    B_y0,     A_prod2
               MPYSP       A_xc10,    B_y1,     B_prod3
    [A_k_odd]    ADDSP       A_sum,     A_prod0,  A_sum
    [A_k_odd]    ADDSP       B_sum1,    B_prod1,  B_sum1
    [A_k_odd]    ADDSP       A_sum2,    A_prod2,  A_sum2
    [A_k_odd]    ADDSP       B_sum3,    B_prod3,  B_sum3
                
                MPY         i,       A_c2,     A_index
                ADD         A_index,   j,      A_index
                ADDAW       B_r,       A_index,  ptr_r
                
               ADD         j,       1,      tmp
               CMPLT       tmp,     A_c2,     ok_01
               ADD         i,       1,      tmp
               CMPLT       tmp,     B_r1,     ok_10
               AND         ok_01,   ok_10,  ok_11

               ADD         A_c2,      1,      c2_p1
               STW         A_sum,     *ptr_r
    [ok_01]    STW         B_sum1,    *ptr_r[1]
    [ok_10]    STW         A_sum2,    *ptr_r[A_c2]
    [ok_11]    STW         B_sum3,    *ptr_r[c2_p1]
                
                ADD         j,       2,      j
                CMPLT       j,       A_c2,     jCnt
     [jCnt]     B           jLoop
                
                ADD         i,       2,      i
                CMPLT       i,       B_r1,     iCnt
     [iCnt]     B           iLoop

                .return                
                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_mat_tra/1117057364  515   0     0       6308      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_trans -- Single Precision Matrix Transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*      This routine has following C prototype                               *
*                                                                           *
*          void DSPF_sp_mat_trans(                                               *
*                            const float * restrict x,                      *
*                            int rows,                                      *
*                            int cols,                                      *
*                            float * restrict r                             *
*                           )                                               *
*                                                                           *
*      x[r1*c1]   : Input matrix containing r1*c1 floating point numbers    *
*                   having r1 rows and c1 columns.                          *
*      rows       : Number of rows in x.                                    *
*      cols       : Number of columns in x.                                 *
*      r[c1*y1]   : Output matrix containing c1*r1 floatin point numbers    *
*                   having c1 rows and r1 columns.                          *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This function transposes the input matrix x and writews the result  *
*       to the output matrix r.                                             *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled twice.                                      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. rows > 0 and cols > 0.                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       The following is a C description of the algorithm.                  *
*                                                                           *
*       void DSPF_sp_mat_trans(const float restrict x, int rows,                 *
*                                           int cols, float restrict r)     *
*       {                                                                   *
*          int i,j;                                                         *
*                                                                           *
*          for(i=0; i<cols; i++)                                            *
*             for(j=0; j<rows; j++)                                         *
*                r[i  rows + j] = x[i + cols  j];                           *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_mat_trans
_DSPF_sp_mat_trans   .cproc  x, rows, cols, r

* ======================================================================== *
* ======================================================================== *
       .reg i, j, incr
       .reg r_ptr
       .reg offset, x_i
       .reg flag, max
       .no_mdep

       ZERO  j                ; j=0
       ZERO  incr             ; incr = 0
       MPY   rows, cols, i    ; i = rows*cols
       SUB   i,    rows, max  ; max=(cols-1)*rows

loop:
       LDW   *x++, x_i        ; load x_i
       STW   x_i,  *r[j]      ; store x_i

       CMPLT j,    max,  flag ; flag=(j<max)
[!flag]ADD   incr, 1,    incr ; ++incr
[!flag]MV    incr, j          ; j=++incr
 [flag]ADD   j,    rows, j    ; j+=rows
    [i]SUB   i,    1,    i    ; i = i - 1
    [i]B     loop             ; Branch to Loop


                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_mat_trans.sa                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_mat_mul/1117057365  537   0     0       11902     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul_cplx -- Single Precision Complex Matrix Multiplication   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*      This routine has following C prototype                               *
*                                                                           *
*                                                                           *
*          void DSPF_sp_mat_mul_cplx(                                            *
*                               const float * x,                            *
*                               int r1,                                     *
*                               int c1,                                     *
*                               const float * y,                            *
*                               int c2,                                     *
*                               float * restrict r                          *
*                              )                                            *
*                                                                           *
*           x[2*r1*c1]:   Input matrix containing r1*c1 complex             *
*                         floating point numbers having r1 rows and c1      *
*                         columns of complex numbers.                       *
*           r1        :   Number of rows in Matrix x.                       *
*           c1        :   No. of columns in Matrx x.                        *
*                         Also no. of rows in Matrix y.                     *
*           y[2*c1*c2]:   Input matrix containing c1*c2 complex             *
*                         floating point numbers having c1 rows and c2      *
*                         columns of complex numbers.                       *
*           c2        :   No. of columns in Matrix y.                       *
*           r[2*r1*c2]:   Output matrix of c1*c2 complex floating           *
*                         point numbers having c1 rows and c2 columns of    *
*                         complex numbers.                                  *
*                                                                           *
*                         Complex numbers are stored consecutively with     *
*                         Real values are stored in even word positions     *
*                         and imaginary values in odd positions.            *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This function computes the expression "r = x * y" for the matrices  *
*       x and y. The columnar dimension of x must match the row dimension   *
*       of y. The resulting matrix has the same number of rows as x and     *
*       the same number of columns as y.                                    *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The innermost loop is unrolled twice.                            *
*       2. The two inner loops are collapsed into one loop.                 *
*       3. The outermost loop is executed in parallel with the inner loop.  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. c1 >= 4 and r1, r2 >= 1.                                         *
*       2. x should be padded with 6 words.                                 *
*       3. x and y should be double-word aligned.                           *
*       4. c2 should be a multiple of 2.                                    *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*     The following is a C description of the algorithm.                    *
*                                                                           *
*         void DSPF_sp_mat_mul_cplx(const float  x, int r1, int c1,              *
*                              const float  y, int c2, float  restrict r)   *
*         {                                                                 *
*             float real, imag;                                             *
*             int i, j, k;                                                  *
*                                                                           *
*             for(i = 0; i < r1; i++)                                       *
*             {                                                             *
*               for(j = 0; j < c2; j++)                                     *
*               {                                                           *
*                 real=0;                                                   *
*                 imag=0;                                                   *
*                                                                           *
*                 for(k = 0; k < c1; k++)                                   *
*                 {                                                         *
*                 real += (x[i   2   c1 + 2   k]   y[k   2   c2 + 2   j]    *
*                 -x[i   2   c1 + 2   k + 1]   y[k   2   c2 + 2   j + 1]);  *
*                                                                           *
*                 imag+=(x[i   2   c1 + 2   k]   y[k   2   c2 + 2   j + 1]  *
*                    + x[i   2   c1 + 2   k + 1]   y[k   2   c2 + 2   j]);  *
*                 }                                                         *
*                 r[i   2   c2 + 2   j] = real;                             *
*                 r[i   2   c2 + 2   j + 1] = imag;                         *
*               }                                                           *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_mat_mul_cplx
_DSPF_sp_mat_mul_cplx   .cproc  x, r1, c1, y, c2, r

* ======================================================================== *
* ======================================================================== *
      .reg real1,      imag1, real2, imag2
      .reg i,          j,     k
      .reg x_ptr,      y_ptr
      .reg x0,         x1,    y0,    y1,    y2,   y3
      .reg sum,        prod1, prod2

      ZERO  real1                   ; Initialise accumulator
      ZERO  imag1                   ; Initialise accumulator
      ZERO  real2                   ; Initialise accumulator
      ZERO  imag2                   ; Initialise accumulator
      MPY   c2,        8,     k     ; k=c2*8
      MPY   r1,        c2,    i
      SHR   i,         1,     i     ; i=r1*c2/2 (Outer loop counter)
      MV    c1,        j            ; initialise inner loop counter
      MV    x,         x_ptr        ; x_ptr = x
      MV    y,         y_ptr
      ADD   y,         k,     y     ; y=y+2*c2
      SUB   y,         k,     y_ptr ; y_ptr=y-2*c2

LOOP:
      LDW   *x_ptr++,  x0           ; load x0
      LDW   *x_ptr++,  x1           ; load x1
      LDW   *y_ptr,    y0           ; load y0
      LDW   *y_ptr[1], y1           ; load y1
      LDW   *y_ptr[2], y2           ; load y2
      LDW   *y_ptr[3], y3           ; load y3
      ADDAD y_ptr,     c2,    y_ptr ; y_ptr = y_ptr+2*c2

      MPYSP x0,        y0,    prod1 ; p00 = x[0]*y[0]
      MPYSP x1,        y1,    prod2 ; p11 = x[1]*y[1]
      SUBSP prod1,     prod2, sum   ; s0011 = prod00 - prod11
      ADDSP real1,     sum,   real1 ; real1 += s0011

      MPYSP x0,        y1,    prod1 ; p01 = x[0]*y[1]
      MPYSP x1,        y0,    prod2 ; p10 = x[1]*y[0]
      ADDSP prod1,     prod2, sum   ; s0110 = prod01 + prod10
      ADDSP imag1,     sum,   imag1 ; imag1 += s0110

      MPYSP x0,        y2,    prod1 ; p02 = x[0] * y[2]
      MPYSP x1,        y3,    prod2 ; p13 = x[1] * y[3]
      SUBSP prod1,     prod2, sum   ; s0213 = p02 - p13
      ADDSP real2,     sum,   real2 ; real2 += s0213

      MPYSP x0,        y3,    prod1 ; p03 = x[0] * y[3]
      MPYSP x1,        y2,    prod2 ; p12 = x[1] * y[2]
      ADDSP prod1,     prod2, sum   ; s0312 = p03 + p12
      ADDSP imag2,     sum,   imag2 ; imag2 += s0312

   [j]SUB   j,         1, j         ; Update inner loop counter
   [j]B     LOOP
      ; branch for inner loop takes here

      STW   real1,     *r++         ; Store real1
      STW   imag1,     *r++         ; Store imag1
      STW   real2,     *r++         ; Store real2
      STW   imag2,     *r++         ; Store imag2

      ZERO  real1                   ; Initialise real1
      ZERO  imag1                   ; Initialise imag1
      ZERO  real2                   ; Initialise real2
      ZERO  imag2                   ; Initialise imag2

      SUB   k,         16,    k     ; To find out when to move to next row
  [!k]ADDAD x,         c1,    x     ; x = x + 2*c1
  [!k]MPY   c2,        8,     k     ; k = 8*c2

      SUB   y,         k,     y_ptr ; y_ptr = y - 2*c2
      MV    x,         x_ptr        ; x = x_ptr
      MV    c1,        j            ; Initialise inner loop counter
   [i]SUB   i,         1,     i     ; Update outer loop counter
   [i]B     LOOP
      ; Branch to outer loop takes place here

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul_cplx.sa                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_blk_mov/1117057365  562   0     0       5096      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_blk_move -- Single Precision Block Move                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_sp_blk_move                                                   *
*                      (                                                    *
*                          const float    *r,                               *
*                          const float *  restrict r,                       *
*                          int            nx,                               *
*                      )                                                    *
*                                                                           *
*        x[nx]:   Pointer to source data to be moved.                       *
*        r[nx]:   Pointer to destination array.                             *
*        nx:        Number of floats to move.                               *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*        This routine moves nx floats from memory location pointed to by x  *
*        to a separate memory location pointed to by r.                     *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_blk_move
_DSPF_sp_blk_move   .cproc  x, r, nx

* ======================================================================== *
* ======================================================================== *
                .reg  i,    j,   nx1
                .reg  x1:x0
                .no_mdep


            AND  nx,   0xFFFFFFFC, nx1  ; Find out nearest multiple of 4
            SUB  nx,   nx1,        j    ; Find out remainder of div.quot by 4
            MV   nx1,  i                ; Get counter
      [!nx1]B    LOOP1                     ; Jump out of Loop, if counter=0


LOOP:
            LDDW *x++, x1:x0            ; Load x1:x0
            STW  x0,   *r++             ; Store x1
            STW  x1,   *r++             ; Store x0

            LDDW *x++, x1:x0            ; Load x1:x0
            STW  x0,   *r++             ; Store x1
            STW  x1,   *r++             ; Store x0

         [i]SUB  i,    4,          i    ; Update counter
         [i]B    LOOP                   ; Branch to Loop
            ; Branch to Loop occurs here

LOOP1:
        [!j]B    END                    ; Return if Remainder=0
                                        ; Else complete remaining loads

         [j]LDW  *x++, x0               ; Load x0
         [j]STW  x0,   *r++             ; Store x0
         [j]SUB  j,    1,          j    ; Update j

         [j]LDW  *x++, x0               ; Load x0
         [j]STW  x0,   *r++             ; Store x0
         [j]SUB  j,    1,          j    ; Update j

         [j]LDW  *x++, x0               ; Load x0
         [j]STW  x0,   *r++             ; Store x0
         [j]SUB  j,    1,          j    ; Update j

END:



                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_blk_move.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_blk_eswap1/1117057366  583   0     0       7265      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_blk_eswap16                                                   *
*                      (                                                    *
*                          void * restrict x,                               *
*                          void * restrict r,                               *
*                          int             nx,                              *
*                      )                                                    *
*                                                                           *
*        x[nx]:   Pointer to source data.                                   *
*        r[nx]:   Pointer to destination array.                             *
*        nx:      Number of shorts (16-bit values) to endian-swap.          *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*          The date in the x array is endian swapped, meaning that the      *
*       byte-order of the bytest within wach half-word (short) of x is      *
*       reversed in the array r. This routine is used to facilitate moving  *
*       big-endian data to a little-endian system or vice-versa.            *
*                                                                           *
*       When the r pointer is non-NULL, the endian-swap occurs              *
*       out-of-place, similar to a block move. When the r pointer is NULL,  *
*       the endian-swap occurs in-place, allowing the swap to occure        *
*       without using any additional memory.                                *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_blk_eswap16
_DSPF_blk_eswap16   .cproc  x, r, nx

* ======================================================================== *
* ======================================================================== *
        .no_mdep
        .reg A_i, B_x, A_r, A_x, B_r
        .reg B_a, B_b, B_c, B_d, B_e, B_f, B_msk
        .reg A_a, A_b, A_c, A_d, A_e, A_f


        MV      .1    x,          A_x              ; Get x
        MV      .2    r,          B_r              ; Get r
        SHR           nx,         3,          A_i  ; i = nx/8
 [!B_r] MV      .2X   A_x,        B_r              ; Get B-side r Pointer
        ADD     .2X   A_x,        4,          B_x  ; Get B-side x pointer
        ADD     .1X   B_r,        4,          A_r  ; Get A_side r Pointer
        MVKL    .2    0xFF00FF00, B_msk            ; Mask = 0xFF00FF00
        MVKH    .2    0xFF00FF00, B_msk            ; Mask = 0xFF00FF00

        .mptr         A_x,        x + 0,      16
        .mptr         B_x,        x + 4,      16
        .mptr         B_r,        r + 0,      16
        .mptr         A_r,        r + 4,      16

loop:

        LDW     .D1T2 *A_x++[2],  B_a              ; Load B-side a
        LDW     .D2T1 *B_x++[2],  A_a              ; Load A-side a

        AND     .2    B_a,        B_msk,      B_b  ; b =  a & 0xFF00FF00
        SHL     .2    B_a,        8,          B_c  ; c =  a << 8
        SHRU    .2    B_b,        8,          B_d  ; d = (a & 0xFF00FF00)>>8
        AND     .2    B_c,        B_msk,      B_e  ; e = (a << 8)&0xFF00FF00
        ADD     .2    B_d,        B_e,        B_f  ; f = d | e

        AND     .1X   A_a,        B_msk,      A_b  ; b =  a & 0xFF00FF00
        SHL     .1    A_a,        8,          A_c  ; c =  a << 8
        SHRU    .1    A_b,        8,          A_d  ; d = (a & 0xFF00FF00)>>8
        AND     .1X   A_c,        B_msk,      A_e  ; e = (a << 8)&0xFF00FF00
        ADD     .1    A_d,        A_e,        A_f  ; f = d | e

        STW     .D2T2 B_f,        *B_r++[2]        ; Store B-side f
        STW     .D1T1 A_f,        *A_r++[2]        ; Store A-side f

        LDW     .D1T2 *A_x++[2],  B_a              ; Load B-side a
        LDW     .D2T1 *B_x++[2],  A_a              ; Load A-side a

        AND     .2    B_a,        B_msk,      B_b  ; b =  a & 0xFF00FF00
        SHL     .2    B_a,        8,          B_c  ; c =  a << 8
        SHRU    .2    B_b,        8,          B_d  ; d = (a & 0xFF00FF00)>>8
        AND     .2    B_c,        B_msk,      B_e  ; e = (a << 8)&0xFF00FF00
        ADD     .2    B_d,        B_e,        B_f  ; f = d | e

        AND     .1X   A_a,        B_msk,      A_b  ; b =  a & 0xFF00FF00
        SHL     .1    A_a,        8,          A_c  ; c =  a << 8
        SHRU    .1    A_b,        8,          A_d  ; d = (a & 0xFF00FF00)>>8
        AND     .1X   A_c,        B_msk,      A_e  ; e = (a << 8)&0xFF00FF00
        ADD     .1    A_d,        A_e,        A_f  ; f = d | e

        STW     .D2T2 B_f,        *B_r++[2]        ; Store B-side f
        STW     .D1T1 A_f,        *A_r++[2]        ; Store A-side f

        SUB           A_i,        1,          A_i  ; i = i - 1
 [A_i]  B             loop                         ; Branch to Loop
        ; Branch to Loop occurs here

                .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_blk_eswap16.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap3/1117057367  604   0     0       6944      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_blk_eswap32                                                   *
*                      (                                                    *
*                          float * restrict x,                              *
*                          float * restrict r,                              *
*                          int             nx,                              *
*                      )                                                    *
*                                                                           *
*        x[nx]:   Pointer to source data.                                   *
*        r[nx]:   Pointer to destination array.                             *
*        nx:      Number of words (32-bit values) to endian-swap.           *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*       The date in the x array is endian swapped, meaning that the         *
*       byte-order of the bytest within wach word of x is                   *
*       reversed in the array r. This routine is used to facilitate moving  *
*       big-endian data to a little-endian system or vice-versa.            *
*                                                                           *
*       When the r pointer is non-NULL, the endian-swap occurs              *
*       out-of-place, similar to a block move. When the r pointer is NULL,  *
*       the endian-swap occurs in-place, allowing the swap to occure        *
*       without using any additional memory.                                *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_blk_eswap32
_DSPF_blk_eswap32   .cproc  x, r, nx

* ======================================================================== *
* ======================================================================== *
            .no_mdep
            .reg  A_cnt, B_x, A_r, A_x, B_r
            .reg  B_a, B_b, B_c, B_d, B_e, B_f, B_g, B_h, B_i, B_msk
            .reg  A_a, A_b, A_c, A_d, A_e, A_f, A_g, A_h, A_i, A_k


            MV    .1    x,          A_x             ; Get x pointer
            MV    .2    r,          B_r             ; Get r potinter
            SHR         nx,         1,        A_cnt ; cnt = nx/2
     [!B_r] MV    .2X   A_x,        B_r             ; if(!r) r = x
            ADD   .2X   A_x,        4,        B_x   ; Copy to B-side x pointer
            ADD   .1X   B_r,        4,        A_r   ; Copy to A-side r pointer
            MVKL  .2    0xFF00FF00, B_msk           ; Mask 0xFF00FF00
            MVKH  .2    0xFF00FF00, B_msk           ; Mask 0xFF00FF00
            MVKL  .1    0x8000,     A_k             ; K for left shifting by 15
            MVKLH .1    1,          A_k             ; K for left shifting by 15

            .mptr       A_x,        x + 0,    8
            .mptr       B_x,        x + 4,    8
            .mptr       B_r,        r + 0,    8
            .mptr       A_r,        r + 4,    8
loop:

            LDW   .D1T2 *A_x++[2],  B_a             ; Load B-side a
            LDW   .D2T1 *B_x++[2],  A_a             ; Load A-side a

            AND   .2    B_a,        B_msk,    B_b   ; b =  a & 0xFF00FF00
            SHL   .2    B_a,        8,        B_c   ; c =  a << 8
            SHRU  .2    B_b,        8,        B_d   ; d = (a & 0xFF00FF00)>>8
            AND   .2    B_c,        B_msk,    B_e   ; e = (a << 8)&0xFF00FF00
            ADD   .2    B_d,        B_e,      B_f   ; f = d | e
            MPYHU .2X   B_f,        A_k,      B_g   ; g = f >> 16
            MPYU  .2    B_f,        A_k,      B_h   ; h = f << 15
            ADDAH .2    B_g,        B_h,      B_i   ; i = (f << 16)|(f >> 16)

            AND   .1X   A_a,        B_msk,    A_b   ; b =  a & 0xFF00FF00
            SHL   .1    A_a,        8,        A_c   ; c =  a << 8
            SHRU  .1    A_b,        8,        A_d   ; d = (a & 0xFF00FF00)>>8
            AND   .1X   A_c,        B_msk,    A_e   ; e = (a << 8)&0xFF00FF00
            ADD   .1    A_d,        A_e,      A_f   ; f = d | e
            MPYHU .1    A_f,        A_k,      A_g   ; g = f >> 16
            MPYU  .1    A_f,        A_k,      A_h   ; h = f << 15
            ADDAH .1    A_g,        A_h,      A_i   ; i = (f << 16)|(f >> 16)

            STW   .D2T2 B_i,        *B_r++[2]       ; Store B-side i
            STW   .D1T1 A_i,        *A_r++[2]       ; Store A-side i

            SUB         A_cnt,      1,        A_cnt ; cnt = cnt - 1
     [A_cnt]B           loop                        ; Branch to Loop
            ; Branch to Loop occurs here

            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_blk_eswap32.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_blk_eswap6/1117057368  625   0     0       6921      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_blk_eswap64                                                   *
*                      (                                                    *
*                          double * restrict x,                             *
*                          double * restrict r,                             *
*                          int             nx,                              *
*                      )                                                    *
*                                                                           *
*        x[nx]:   Pointer to source data.                                   *
*        r[nx]:   Pointer to destination array.                             *
*        nx:      Number of double words (64-bit values) to endian-swap.    *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*       The date in the x array is endian swapped, meaning that the         *
*       byte-order of the bytes within each double word of x is             *
*       reversed in the array r. This routine is used to facilitate moving  *
*       big-endian data to a little-endian system or vice-versa.            *
*                                                                           *
*       When the r pointer is non-NULL, the endian-swap occurs              *
*       out-of-place, similar to a block move. When the r pointer is NULL,  *
*       the endian-swap occurs in-place, allowing the swap to occure        *
*       without using any additional memory.                                *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_blk_eswap64
_DSPF_blk_eswap64   .cproc  x, r, nx

* ======================================================================== *
* ======================================================================== *
            .no_mdep
            .reg A_cnt, B_x, A_r, A_x, B_r
            .reg B_a, B_b, B_c, B_d, B_e, B_f, B_g, B_h, B_i, B_msk
            .reg A_a, A_b, A_c, A_d, A_e, A_f, A_g, A_h, A_i, A_k

            MV    .1    x,          A_x             ; Get x ponter
            MV    .2    r,          B_r             ; Get r pointer
            MV    .1    nx,         A_cnt           ; Get counter
      [!B_r]MV    .2X   A_x,        B_r             ; if(!r) r = x
            ADD   .2X   A_x,        4,        B_x   ; Copy to B-side x pointer
            ADD   .1X   B_r,        4,        A_r   ; Copy to A-side r pointer
            MVKL  .2    0xFF00FF00, B_msk           ; Mask = 0xFF00FF00
            MVKH  .2    0xFF00FF00, B_msk           ; Mask = 0xFF00FF00
            MVKL  .1    0x8000,     A_k             ; K for left shifting by 15
            MVKLH .1    1,          A_k             ; K for left shifting by 15

            .mptr       A_x,        x + 0,    8
            .mptr       B_x,        x + 4,    8
            .mptr       B_r,        r + 0,    8
            .mptr       A_r,        r + 4,    8

loop:
            LDW   .D1T2 *A_x++[2],            B_a   ; Load B-side a
            LDW   .D2T1 *B_x++[2],            A_a   ; Load A-side a

            AND   .2    B_a,        B_msk,    B_b   ; b =  a & 0xFF00FF00
            SHL   .2    B_a,        8,        B_c   ; c =  a << 8
            SHRU  .2    B_b,        8,        B_d   ; d = (a & 0xFF00FF00)>>8
            AND   .2    B_c,        B_msk,    B_e   ; e = (a << 8)&0xFF00FF00
            ADD   .2    B_d,        B_e,      B_f   ; f = d | e
            MPYHU .2X   B_f,        A_k,      B_g   ; g = f >> 16
            MPYU  .2    B_f,        A_k,      B_h   ; h = f << 15
            ADDAH .2    B_g,        B_h,      B_i   ; i = (f << 16)|(f >> 16)

            AND   .1X   A_a,        B_msk,    A_b   ; b =  a & 0xFF00FF00
            SHL   .1    A_a,        8,        A_c   ; c =  a << 8
            SHRU  .1    A_b,        8,        A_d   ; d = (a & 0xFF00FF00)>>8
            AND   .1X   A_c,        B_msk,    A_e   ; e = (a << 8)&0xFF00FF00
            ADD   .1    A_d,        A_e,      A_f   ; f = d | e
            MPYHU .1    A_f,        A_k,      A_g   ; g = f >> 16
            MPYU  .1    A_f,        A_k,      A_h   ; h = f << 15
            ADDAH .1    A_g,        A_h,      A_i   ; i = (f << 16)|(f >> 16)

            STW   .D1T2 B_i,        *A_r++[2]       ; Store B-side i
            STW   .D2T1 A_i,        *B_r++[2]       ; Store A-side i

            SUB         A_cnt,      1,        A_cnt ; cnt = cnt - 1
     [A_cnt]B           loop                        ; Branch to Loop
            ; Branch to Loop occurs here

                .endproc

* ======================================================================== *
*  End of file: DSPF_blk_eswap64.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_fltoq15.sa/1117057369  0     0     0       7545      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*      This routine is C-callable and can be called as:                     *
*                                                                           *
*      void DSPF_fltoq15                                                         *
*      (                                                                    *
*          const float* restrict x,                                         *
*          short*       restrict r,                                         *
*          int         nx                                                   *
*      );                                                                   *
*                                                                           *
*      x[nx] :  Input array contaning values of type float                  *
*      r[nx] :  Output array contains Q15 equivalents of x[nx]              *
*      nx    :  Number of elements in both arrays                           *
*                                                                           *
*   DESCRIPTION                                                             *
*      Convert the IEEE floating point numbers stored in vector x[] into    *
*      Q.15 format numbers stored in vector r[]. Results will be rounded    *
*      towards negative infinity. All values that exceed the size limit     *
*      will be saturated to 0x7fff if value is positive and 0x8000 if       *
*      value is negative.                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*      1. SSHL has been used to saturate the output of the instruction SPIN *
*      2. There are no write buffer fulls because one STH occurs per cycle. *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*      1. None                                                              *
*                                                                           *
*   C CODE                                                                  *
*      void DSPF_fltoq15                                                         *
*      (                                                                    *
*          const float* restrict x,                                         *
*          short*       restrict r,                                         *
*          int         nx                                                   *
*      )                                                                    *
*      {                                                                    *
*          int i, a;                                                        *
*                                                                           *
*          for(i = 0; i < nx; i++)                                          *
*          {                                                                *
*              a = floor(32768 * x[i]);                                     *
*                                                                           *
*              // saturate to 16-bit //                                     *
*              if (a>32767)  a =  32767;                                    *
*              if (a<-32768) a = -32768;                                    *
*                                                                           *
*              r[i] = (short) a;                                            *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*   NOTES                                                                   *
*      1. This code is interrupt-tolerant but not interruptible.            *
*      2. This implementation is ENDIAN NEUTRAL.                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_fltoq15
_DSPF_fltoq15   .cproc  A_x, B_r, A_nx

* ======================================================================== *
* ======================================================================== *
             .no_mdep

             .reg A_num1,A_x1:A_x0,A_p0,A_p1

             .reg A_t0,A_t1,B_s,B_temp, A_t2,B_t2,B_t3
             .reg B_t4, B_fadcrstore

       MVC            FADCR,      B_temp
       MV             B_temp,     B_fadcrstore
       SET            B_temp,     9,        10,     B_temp
       SET            B_temp,     25,       26,     B_temp
       MVC            B_temp,     FADCR

       ZERO           A_num1
       MVKH           0x47000000, A_num1

       MVK            1,          B_temp

loop:
       ; load float
       LDW            *A_x++,     A_x0
       ; multiply by 2^15
       MPYSP          A_x0,       A_num1,   A_p0
       ; convert to integer
       SPINT          A_p0,       A_t0
       ; shift left and sat if necessary
       SSHL           A_t0,       16,       B_t2
       ; tx upper 16 bits to lower
       MPYHLU         B_t2,       B_temp,   B_t3
       ; store the result
       STH            B_t3,       *B_r++
       ; decr cntr
       SUB            A_nx,       1,        A_nx
       ; branch
  [A_nx]B              loop

       MVC            B_fadcrstore,FADCR
             .return

                .endproc

* ======================================================================== *
*  End of file: DSPF_fltoq15.sa                                                 *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_minerr./1117057370  646   0     0       10854     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minerr -- DSPF_sp_minerr                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       float DSPF_sp_minerr(                                                    *
*                       const float * GSP0_TABLE,                           *
*                       const float * errCoefs,                             *
*                       int * restrict max_index                            *
*                      )                                                    *
*                                                                           *
*       GSP0_TABLE[256*9]:  GSP0 terms array.                               *
*       errCoefs[9]:        Array of error coefficients.                    *
*                           Must be double word aligned.                    *
*       max_index:          Index to GSP0_TABLE[max_index], the first       *
*                           element of the 9-element vector that resulted   *
*                           in the maximum dot product.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs a dot product on 256 pairs of 9 element       *
*       vectors and searches for the pair of vectors which produces the     *
*       maximum dot product result. This is a very large part of the VSELP  *
*       vocoder codebook search.                                            *
*                                                                           *
*       The function stores the index to the first element of the 9         *
*       element vector that resulted in the maximum dot product in the      *
*       memory location pointed to by max_index. The maximum dot product    *
*       value is returned by the function.                                  *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1.  The inner loop is completely unrolled.                          *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1.  errCoefs is double-word aligned.                                *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*         float DSPF_sp_minerr(const float  GSP0_TABLE, const float  errCoefs,   *
*                                                int  restrict max_index)   *
*         {                                                                 *
*                                                                           *
*                    float val, maxVal = -50;                               *
*                    int i, j;                                              *
*                                                                           *
*                    for (i = 0; i < GSP0_NUM; i++)                         *
*                        {                                                  *
*                        for (val = 0, j = 0; j < GSP0_TERMS; j++)          *
*                           val += GSP0_TABLE[i GSP0_TERMS+j] errCoefs[j];  *
*                        if (val > maxVal)                                  *
*                           {                                               *
*                           maxVal = val;                                   *
*                            max_index = i GSP0_TERMS;                      *
*                           }                                               *
*                        }                                                  *
*                    return (maxVal);                                       *
*         }                                                                 *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_sp_minerr
_DSPF_sp_minerr   .cproc  GSP0_TABLE, errCoefs, max_index

* ======================================================================== *
* ======================================================================== *
           .reg    err0, err1, err2, err3, err4, err5, err6, err7, err8
           .reg    g0, g1, g2, g3, g4, g5, g6, g7, g8
           .reg    m0, m1, m2, m3, m4, m5, m6, m7, m8
           .reg    m01, m23, m45, m67, m801, m67801, m2345, sum
           .reg    maxval, i , j, index, flag, GSP0_NUM, GSP0_TERMS

           MVK     9,             GSP0_TERMS         ; GSP0_TERMS = 9
           MVK     256,           GSP0_NUM           ; GSP0_NUM = 256
           MV      GSP0_NUM,      i                  ; i = GSP0_NUM
           MVKL    0xFF800000,    maxval
           MVKH    0xFF800000,    maxval             ; maxval = -INF

           LDW     *errCoefs++,   err0               ; load err0
           LDW     *errCoefs++,   err1               ; load err1
           LDW     *errCoefs++,   err2               ; load err2
           LDW     *errCoefs++,   err3               ; load err3
           LDW     *errCoefs++,   err4               ; load err4
           LDW     *errCoefs++,   err5               ; load err5
           LDW     *errCoefs++,   err6               ; load err6
           LDW     *errCoefs++,   err7               ; load err7
           LDW     *errCoefs++,   err8               ; load err8

           ZERO    j

LOOP:
           LDW     *GSP0_TABLE++, g0                 ; load g0
           LDW     *GSP0_TABLE++, g1                 ; load g1
           LDW     *GSP0_TABLE++, g2                 ; load g2
           LDW     *GSP0_TABLE++, g3                 ; load g3
           LDW     *GSP0_TABLE++, g4                 ; load g4
           LDW     *GSP0_TABLE++, g5                 ; load g5
           LDW     *GSP0_TABLE++, g6                 ; load g6
           LDW     *GSP0_TABLE++, g7                 ; load g7
           LDW     *GSP0_TABLE++, g8                 ; load g8

           MPYSP   g0,            err0,       m0     ; m0 = g0 * err0
           MPYSP   g1,            err1,       m1     ; m1 = g1 * err1
           MPYSP   g2,            err2,       m2     ; m2 = g2 * err2
           MPYSP   g3,            err3,       m3     ; m3 = g3 * err3
           MPYSP   g4,            err4,       m4     ; m4 = g4 * err4
           MPYSP   g5,            err5,       m5     ; m5 = g5 * err5
           MPYSP   g6,            err6,       m6     ; m6 = g6 * err6
           MPYSP   g7,            err7,       m7     ; m7 = g7 * err7
           MPYSP   g8,            err8,       m8     ; m8 = g8 * err8

           ADDSP   m0,            m1,         m01    ; m01 = m0 + m1
           ADDSP   m2,            m3,         m23    ; m23 = m2 + m3
           ADDSP   m4,            m5,         m45    ; m45 = m4 + m5
           ADDSP   m6,            m7,         m67    ; m67 = m6 + m7

           ADDSP   m8,            m01,        m801   ; m801 = m8 + m01
           ADDSP   m801,          m67,        m67801 ; m67801 = m801 + m67
           ADDSP   m23,           m45,        m2345  ; m2345 = m23 + m45
           ADDSP   m2345,         m67801,     sum    ; sum = m2345 + m67801

           CMPGTSP sum,           maxval,     flag   ; if sum > maxval
     [flag]MV      sum,           maxval             ; maxval = sum
     [flag]MV      j,             index              ; index = j

           ADD     j,             1,          j      ; j = j - 1
           SUB     i,             1,          i      ; i = i - 1
        [i]B       LOOP
           ; Branch to Loop takes place here

           MPY     index,         GSP0_TERMS, index  ; index=index*GSP0_TERMS
           STW     index,         *max_index         ; store index at max_index

           .return maxval

                .endproc

* ======================================================================== *
*  End of file: DSPF_sp_minerr.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_q15tofl.sa/1117057371  0     0     0       4759      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       *
*      format                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*     This routine is C Callable and can be called as:                      *
*                                                                           *
*       float DSPF_q15tofl(short *x, float *r, int nx);                          *
*                                                                           *
*       x     : Input array containing shorts in Q15 format                 *
*       r     : Output array containing equivalent floats                   *
*       nx    : Number of values in the x vector                            *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine converts data in the Q15 format into IEEE Single Preci *o
*       floating point.                                                     *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*   void DSPF_q15tofl_cn(short *x, float *r, int nx)                             *
*      {                                                                    *
*       int i;                                                              *
*       for (i = 0; i < nx; i++)                                            *
*            r[i] = (float)x[i] / 0x8000;                                   *
*      }                                                                    *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


* ======================================================================== *
* ======================================================================== *

        .text
        .global _DSPF_q15tofl
_DSPF_q15tofl   .cproc  x, r, nx

* ======================================================================== *
* ======================================================================== *
            .reg convert, temp, temp1

            ZERO convert
            MVKH 0x38000000,convert

loop:
            ldh *x++,temp
            intsp temp,temp
            mpysp temp,convert,temp
            stw temp,*r++
            sub nx,1,nx
        [nx]b loop

            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_q15tofl.sa                                                 *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_lms.sa/ 1117057372  0     0     0       12152     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_lms -- Double Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C callable, and has the following C prototype:       *
*                                                                           *
*      double DSPF_dp_lms (double *x,                                            *
*                     double *h,                                             *
*                     double *desired,                                      *
*                     double *r,                                            *
*                     double adaptrate,                                     *
*                     double error,                                         *
*                     int nh,                                               *
*                     int nr                                                *
*                     )                                                     *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  *
*      signal and a desired input signal, the filter produces an output     *
*      signal, the final coefficient values and returns the final output    *
*      error signal.                                                        *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*    1. The inner loop is unrolled Two times to allow update of             *
*       two coefficients in the kernel.                                     *
*                                                                           *
*    2. The 'error' term needs to be computed in the outer loop             *
*       before a new iteration of the inner loop can start. As a            *
*       result the prolog cannot be placed in parallel with epilog          *
*       (after the loop kernel).                                            *
*                                                                           *
*   3. Register sharing is used to make optimal use of available            *
*       registers.                                                          *
*                                                                           *
*    ASSUMPTIONS                                                            *
*    1. The inner loop counter must be a multiple of 2 and >=2.             *
*    2. Little endianness is assumed.                                       *
*    3. Extraneous loads are allowed in the program.                        *
*    4. The coefficient array is assumed to be in reverse order,            *
*       i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    This is the C equivalent of the Assembly Code without                  *
*    restrictions.                                                          *
*                                                                           *
*    Note that the assembly code is hand optimized and restrictions         *
*    may apply.                                                             *
*                                                                           *
*    double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou *e
*         int nr, double error)                                             *
*    {                                                                      *
*        int i,j;                                                           *
*        double sum;                                                        *
*                                                                           *
*        for (i = 0; i < nr; i++)                                           *
*        {                                                                  *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*            h[j] = h[j] + (ar*error*x[i+j-1]);                             *
*         }                                                                 *
*                                                                           *
*        sum = 0.0f;                                                        *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*           sum += h[j] * x[i+j];                                           *
*         }                                                                 *
*        y[i] = sum;                                                        *
*        error = d[i] - sum;                                                *
*       }                                                                   *
*       return error;                                                       *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
*  CYCLES                                                                   *
*     (4*nh + 47) nr + 27                                                   *
*     eg. for nh = 24 and nr = 36                                           *
*     cycles = 5175                                                         *
*                                                                           *
*  CODESIZE                                                                 *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_lms
_DSPF_dp_lms   .cproc  x, h, desired, r, arh:arl, erh:erl, nh, nr

            .reg    xa1:xa0, xb1:xb0, xa3:xa2,  xb3:xb2
            .reg    xa5:xa4, xb5:xb4, xa7:xa6,  xb7:xb6
            .reg    acc1:acc0,  acc3:acc2, xa9:xa8, xb9:xb8
            .reg    octr, ictr, xptr, rptr, dptr, hptr, temp


        MV      x,      temp                        ;Pointer For x[i]
        MV      nr,     octr                        ;Setting Outerloop counter
        MV      r,      rptr                        ;Pointer for r[i]
        MV      desired,dptr                        ;Pointer for d[i]

oloop:      .trip   1

        MV      temp,       xptr                    ;Setting Pointer for x[i+j]
        MV      h,          hptr                    ;Setting Pointer for h[j]
        MPYDP   erh:erl,    arh:arl,    erh:erl     ;error=error*ar
        MV      nh,         ictr                    ;Setting InnerLoop Counter
        ZERO    acc0                                ;Clearing Accumulators
        ZERO    acc1
        ZERO    acc2
        ZERO    acc3

        ;Inner Loop Unrolled twice

iloop:      .trip   2

        LDDW    *-xptr[01],     xa1:xa0             ;Load x[i+j-1]
        MPYDP   xa1:xa0,        erh:erl,    xa5:xa4 ;error*ar*x[i+j-1]
        LDDW    *xptr,          xa1:xa0             ;Load x[i+j]
        MPYDP   xa1:xa0,        erh:erl,    xb5:xb4 ;error*ar*x[i+j]
        LDDW    *hptr++[01],    xb1:xb0             ;Load h[j]
        ADDDP   xa5:xa4,        xb1:xb0,    xa7:xa6 ;h[j]+=error*ar*x[i+j-1]
        LDDW    *hptr++[01],    xb1:xb0             ;Load h[j+1]
        ADDDP   xb5:xb4,        xb1:xb0,    xb7:xb6 ;h[j+1]+=error*ar*x[i+j]
        STW     xa6,            *-hptr[04]          ;Storing h[j]
        STW     xa7,            *-hptr[03]
        STW     xb6,            *-hptr[02]          ;Storing h[j+1]
        STW     xb7,            *-hptr[01]
        MPYDP   xa1:xa0,        xa7:xa6,    xa9:xa8 ;P1=x[j]*h[j]
        ADDDP   acc1:acc0,      xa9:xa8,    acc1:acc0;S1+=P1
        LDDW    *++xptr[01],    xa1:xa0             ;Load x[i+j+1]
        MPYDP   xa1:xa0,        xb7:xb6,    xb9:xb8 ;P2=h[j+1]*x[i+j+1]
        ADDDP   acc3:acc2,      xb9:xb8,    acc3:acc2;S2+=P2
        ADDAD   xptr,           01,         xptr    ;Set Pointer for x
        SUB     ictr,           02,         ictr    ;Decrement InnerLoop Counter
  [ictr]B       iloop

        ; Inner Loop Branch Occurs here

        ADDDP   acc1:acc0,      acc3:acc2,  acc1:acc0;SUM=S1+S2
        LDDW    *dptr++[01],    xa5:xa4             ; Load d[i]
        SUBDP   xa5:xa4,        acc1:acc0,  erh:erl ;error=d[i]-sum
        STW     acc0,           *rptr++             ;Store SUM
        STW     acc1,           *rptr++
        ADDAD   temp,           1,          temp    ;Set Pointer for x
        SUB     octr,           01,         octr    ;Decrement innerLoop Counter
  [octr]B       oloop

        ;Outer Loop Branch Occurs here
        .return erh:erl             ;Return(error)
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_lms.sa                                                  *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_autocor/1117057373  665   0     0       9365      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_autocor -- double Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*                                                                           *
*       r  = Pointer to output array of autocorrelation of length nr        *
*       x  = Pointer to input array of length nx+nr. Input data must        *
*            be padded with nr consecutive zeros at the beginning.          *
*       nx = Length of autocorrelation vector.                              *
*       nr = Length of lags.                                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs the autocorrelation of the input array x.     *
*       is assumed that the length of the input array, x, is a              *
*       multiple of 2 and the length of the output array, r, is a           *
*       multiple of 4. The assembly routine computes 4 output samples       *
*       at a time. It is assumed that input vector x is padded with nr      *
*       no of zeros in the beginning.                                       *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice and the outer loop is unrolled  *
*       four times.                                                         *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 2 and greater than or equal to 4.            *
*       2. nr is a multiple of 4 and greater than or equal to 4.            *
*       3. nx is greater than or equal to nr                                *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_autocor
_DSPF_dp_autocor   .cproc  r, x, nx, nr

            .reg   xa1:xa0, xa3:xa2, xb1:xb0, xb3:xb2, xa5:xa4
            .reg   pa1:pa0, pa3:pa2, pa5:pa4, pa7:pa6
            .reg   acc1:acc0, acc3:acc2, acc5:acc4, acc7:acc6
            .reg   xptr, xiptr, ictr, octr, temp1, temp2
            .no_mdep

            ADDAD   x,      nx,     temp1
            ADDAD   temp1,  nr,     temp1
            MV      nr,     octr                                ; Set outerloop Counter
            MV      temp1,          temp2

            ; OuterLoop Unrolled 4 Times

oloop:      .trip   1

            ZERO    acc0                                        ; Zero the accumulator
            ZERO    acc1                                        ; Zero the accumulator
            ZERO    acc2                                        ; Zero the accumulator
            ZERO    acc3                                        ; Zero the accumulator
            ZERO    acc4                                        ; Zero the accumulator
            ZERO    acc5                                        ; Zero the accumulator
            ZERO    acc6                                        ; Zero the accumulator
            ZERO    acc7                                        ; Zero the accumulator
            MV      nx,     ictr                                ; Set innerloop Counter
            MV      temp1,  xiptr                               ; Set Pointer for array x[k-i]
            MV      temp2,  xptr                                ; Set Pointer for array x[k]

            ; Innerloop Unrolled 2 Times

iloop:      .trip   2

            LDDW    *--xiptr[01],   xa1:xa0                     ; Load  x[k-i]
            LDDW    *--xptr[01],    xb1:xb0                     ; Load  x[k]

            MPYDP   xa1:xa0,        xb1:xb0,        pa1:pa0     ; P11 =x[k-i]*x[k]
            ADDDP   acc1:acc0,      pa1:pa0,        acc1:acc0   ; S1+=P11

            LDDW    *--xiptr[01],   xa3:xa2                     ; Load  x[k-1-i]
            LDDW    *--xptr[01],    xb3:xb2                     ; Load  x[k-1]

            MPYDP   xa3:xa2,        xb1:xb0,        pa3:pa2     ; P12 =x[k-1-i]*x[k]
            ADDDP   acc3:acc2,      pa3:pa2,        acc3:acc2   ; S2+=P12

            LDDW    *-xiptr[01],    xa5:xa4                     ; Load  x[k-2-i]

            MPYDP   xa5:xa4,        xb1:xb0,        pa5:pa4     ; P13 =x[k-2-i]*x[k]
            ADDDP   acc5:acc4,      pa5:pa4,        acc5:acc4   ; S3+=P13

            LDDW    *-xiptr[02],    xa1:xa0                     ; Load  x[k-3-i]

            MPYDP   xa1:xa0,        xb1:xb0,        pa7:pa6     ; P14 =x[k-3-i]*x[k]
            ADDDP   acc7:acc6,      pa7:pa6,        acc7:acc6   ; S4+=P14

            MPYDP   xa3:xa2,        xb3:xb2,        pa1:pa0     ; P21 =x[k-1-i]*x[k-1]
            ADDDP   acc1:acc0,      pa1:pa0,        acc1:acc0   ; S1+=P21

            LDDW    *-xiptr[03],    xa3:xa2                     ; Load  x[k-4-i]

            MPYDP   xa5:xa4,        xb3:xb2,        pa3:pa2     ; P22 =x[k-2-i]*x[k-1]
            ADDDP   acc3:acc2,      pa3:pa2,        acc3:acc2   ; S2+=P22

            MPYDP   xa1:xa0,        xb3:xb2,        pa5:pa4     ; P23 =x[k-3-i]*x[k-1]
            ADDDP   acc5:acc4,      pa5:pa4,        acc5:acc4   ; S3+=P23

            MPYDP   xa3:xa2,        xb3:xb2,        pa7:pa6     ; P24 =x[k-4-i]*x[k-1]
            ADDDP   acc7:acc6,      pa7:pa6,        acc7:acc6   ; S4+=P24

    [ictr]  SUB     ictr,           02,             ictr        ;Decrement innerloop Counter

    [ictr]  B       iloop


            STW     acc0,           *r++                        ; Storing S1
            STW     acc1,           *r++

            STW     acc2,           *r++                        ; Storing S2
            STW     acc3,           *r++

            STW     acc4,           *r++                        ; Storing S3
            STW     acc5,           *r++

            STW     acc6,           *r++                        ; Storing S4
            STW     acc7,           *r++

            SUBAW   temp1,          8,              temp1       ; Set pointer for x[k-i]

            SUB     octr,           04,             octr        ; Decrement Outerloop Counter

    [octr]  B       oloop

            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_autocor.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_bitrev_/1117057374  685   0     0       22403     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C Callable and can be called as:                     *
*                                                                           *
*      void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                *
*                                                                           *
*      x      : Complex input array to be bit-reversed.                     *
*               Contains 2*nx doubles                                       *
*      index  : Array of size ~sqrt(nx) created by the routine              *
*               bitrev_index to allow the fast implementation of the        *
*               bit-reversal.                                               *
*      nx     : Number of elements in array x[]. Must be power of 2.        *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine performs the bit-reversal of the input array x[],       *
*      where x[] is a double array of length 2*nx containing Double         *
*      precision floating point complex pairs of data. This routine         *
*      requires the index array provided by the program below.              *
*      This index should be generated at compile time not by the DSP.       *
*                                                                           *
*      TI retains all rights, title and interest in this code and only      *
*      authorizes the use of the bit-reversal code and related table        *
*      generation code with TMS320-family DSPs manufactured by TI.          *
*                                                                           *
*      /* ----------------------------------------------------------- */    *
*      /*  This routine calculates the index for bit reversal of      */    *
*      /*  an array of length nx.  The length of the index table is   */    *
*      /*  2^(2*ceil(k/2)) where nx = 2^k.                            */    *
*      /*                                                             */    *
*      /*  In other words, the length of the index table is:          */    *
*      /*      - for even power of radix: sqrt(nx)                    */    *
*      /*      - for odd  power of radix: sqrt(2*nx)                  */    *
*      /* ----------------------------------------------------------- */    *
*      void bitrev_index(short *index, int nx)                              *
*      {                                                                    *
*          int   i, j, k, radix = 2;                                        *
*          short nbits, nbot, ntop, ndiff, n2, raddiv2;                     *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*              i = i >> 1;                                                  *
*              nbits++;                                                     *
*          }                                                                *
*                                                                           *
*          raddiv2 = radix >> 1;                                            *
*          nbot    = nbits >> raddiv2;                                      *
*          nbot    = nbot << raddiv2 - 1;                                   *
*          ndiff   = nbits & raddiv2;                                       *
*          ntop    = nbot + ndiff;                                          *
*          n2      = 1 << ntop;                                             *
*                                                                           *
*          index[0] = 0;                                                    *
*          for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  *
*          {                                                                *
*              index[i] = j - 1;                                            *
*                                                                           *
*              for (k = n2/radix; k*(radix-1) < j; k /= radix)              *
*                  j -= k*(radix-1);                                        *
*                                                                           *
*              j += k;                                                      *
*          }                                                                *
*          index[n2 - 1] = n2 - 1;                                          *
*      }                                                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*      1. nx must be a power of 2.                                          *
*      2. The table from bitrev_index is already created.                   *
*      3. The array x is actually an array of 2*nx doubles.                 *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                *
*       {                                                                   *
*          int    i;                                                        *
*          short  i0, i1, i2;                                               *
*          short  j0, j1, j2;                                               *
*          double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       *
*          double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       *
*          short  t;                                                        *
*          int    a, b, ia, ib, ibs;                                        *
*          int    mask;                                                     *
*          int    nbits, nbot, ntop, ndiff, n2, halfn;                      *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*             i = i >> 1;                                                   *
*             nbits++;                                                      *
*          }                                                                *
*                                                                           *
*          nbot    = nbits >> 1;                                            *
*          ndiff   = nbits & 1;                                             *
*          ntop    = nbot + ndiff;                                          *
*          n2       = 1 << ntop;                                            *
*          mask    = n2 - 1;                                                *
*          halfn   = nx >> 1;                                               *
*                                                                           *
*          for (i0 = 0; i0 < halfn; i0 += 2)                                *
*          {                                                                *
*              b       = i0 & mask;                                         *
*              a       = i0 >> nbot;                                        *
*              if (!b) ia = index[a];                                       *
*              ib      = index[b];                                          *
*              ibs     = ib << nbot;                                        *
*                                                                           *
*              j0      = ibs + ia;                                          *
*              t       = i0 < j0;                                           *
*              xi0r     = x[2*i0];                                          *
*              xi0i     = x[2*i0+1];                                        *
*              xj0r     = x[2*j0];                                          *
*              xj0i     = x[2*j0+1];                                           *
*              if (t)                                                       *
*              {                                                            *
*                 x[2*i0]   = xj0r;                                         *
*                 x[2*i0+1] = xj0i;                                         *
*                 x[2*j0]   = xi0r;                                         *
*                 x[2*j0+1] = xi0i;                                         *
*               }                                                           *
*                                                                           *
*              i1      = i0 + 1;                                            *
*              j1      = j0 + halfn;                                        *
*              xi1r    = x[2*i1];                                           *
*              xi1i    = x[2*i1+1];                                         *
*              xj1r    = x[2*j1];                                           *
*              xj1i    = x[2*j1+1];                                         *
*                                                                           *
*              x[2*i1]   = xj1r;                                            *
*              x[2*i1+1] = xj1i;                                            *
*              x[2*j1]   = xi1r;                                            *
*              x[2*j1+1] = xi1i;                                            *
*                                                                           *
*              i2      = i1 + halfn;                                        *
*              j2      = j1 + 1;                                            *
*                                                                           *
*              xi2r    = x[2*i2];                                           *
*              xi2i    = x[2*i2+1];                                         *
*              xj2r    = x[2*j2];                                           *
*              xj2i    = x[2*j2+1];                                         *
*              if (t)                                                       *
*              {                                                            *
*              x[2*i2]   = xj2r;                                            *
*              x[2*i2+1] = xj2i;                                            *
*              x[2*j2]   = xi2r;                                            *
*              x[2*j2+1] = xi2i;                                            *
*              }                                                            *
*            }                                                              *
*                                                                           *
*          }                                                                *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1. The index table can be generated using the bitrev_index           *
*         function provided in the dsplib\support\fft directory.            *
*      2. If nx <= 4K one can use the char (8-bit) data type for            *
*         the "index" variable. This would require changing the LDH when    *
*         loading index values in the assembly routine to LDB. This would   *
*         further reduce the size of the Index Table by half its size.      *
*                                                                           *
*      3. Endian: LITTLE ENDIAN configuration used.                         *
*                                                                           *
*      4. Interruptibility: This code is interrupt tolerant, but not        *
*         interruptible.                                                    *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      5*nx + 33                                                            *
*      e.g. nx = 128, cycles = 673                                          *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      736 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_bitrev_cplx
_DSPF_dp_bitrev_cplx   .cproc  x, index, n
                .reg    i0, i0c, i1, i2, j0, j1, j2, a, b, halfn, halfn1
                .reg    ia, ib, ibs, t, nbits, nbot, temp, flag
                .reg    ndiff, ntop, n2, mask, x_t1, x_t2, x_l1, x_l2
                .reg    xi0rh:xi0rl, xi0ih:xi0il, xi1rh:xi1rl, xi1ih:xi1il
                .reg    xi2rh:xi2rl, xi2ih:xi2il, xj0rh:xj0rl, xj0ih:xj0il
                .reg    xj1rh:xj1rl, xj1ih:xj1il, xj2rh:xj2rl, xj2ih:xj2il


            LMBD        1,          n,          nbits   ;to find log(n) to base2
            MVK         31,         temp
            SUB         temp,       nbits,      nbits   ;nbits=log(n)to base2
            SHR         nbits,      1,          nbot    ;nbot=nbits>>1
            AND         nbits,      1,          ndiff   ;ndiff=nbits&1
            ADD         ndiff,      nbot,       ntop    ;ntop=nbot+ndiff
            MVK         1,          temp
            SHL         temp,       ntop,       n2
            SUB         n2,         1,          mask    ;mask=2^(ntop-1)
            SHR         n,          1,          halfn   ;Loop Counter
            ZERO        i0c                             ;initialise Counter
            MV          x,          x_l1                ;Copy for Pointer x
            ADD         x_l1,       8,          x_l2    ;To Load Imag Part
            MV          halfn,      halfn1              ;To Check Condition
            MPY         halfn,      2,          halfn   ;2*halfn
loop:
            AND         i0c,        mask,       b       ;b=i0&mask;
            SHR         i0c,        nbot,       a       ;a=i0>>nbot
    [!b]    LDHU        *index[a],  ia                  ;if(!a) ia=index[a]
            LDHU        *index[b],  ib                  ;ib=index[b]
            SHL         ib,         nbot,       ibs     ;ibs=ib<<nbot
            ADD         ibs,        ia,         j0      ;j0=ibs+ia
            MPY         i0c,        2,          i0      ;2*i0
            MPY         j0,         2,          j0      ;2*j0
            CMPLT       i0,         j0,         t       ;i0<j0
            LDDW        *+x_l1[i0], xi0rh:xi0rl         ;load x[i0] Real Part
            LDDW        *+x_l2[i0], xi0ih:xi0il         ;load x[i0] Imag Part
            LDDW        *+x_l1[j0], xj0rh:xj0rl         ;load x[j0] Real Part
            LDDW        *+x_l2[j0], xj0ih:xj0il         ;load x[j0] Imag Part
            ADD         i0,         2,          i1      ;i1=i0+1
            ADD         j0,         halfn,      j1      ;j1=j0+halfn
     [t]    MPY         i0,         2,          i0      ;2*i0
     [t]    MPY         j0,         2,          j0      ;2*j0
     [t]    STW         xj0rl,      *+x_l1[i0]          ;Store x[j0] Real Part
     [t]    STW         xj0il,      *+x_l2[i0]          ;Store x[j0] Imag Part
            ADD         i0,         1,          i0      ;To Store Upper 32 Msb's
     [t]    STW         xj0rh,      *+x_l1[i0]          ;Store x[j0] Real Part
     [t]    STW         xj0ih,      *+x_l2[i0]          ;Store x[j0] Imag Part
     [t]    STW         xi0rl,      *+x_l1[j0]          ;Store x[i0] Real Part
     [t]    STW         xi0il,      *+x_l2[j0]          ;Store x[i0] Imag Part
            ADD         j0,         1,          j0      ;To Store Upper 32 Msb's
     [t]    STW         xi0rh,      *+x_l1[j0]          ;Store x[i0] Real Part
     [t]    STW         xi0ih,      *+x_l2[j0]          ;Store x[i0] Imag Part

            ADD         i1,         halfn,      i2      ;i2=i1+halfn
            ADD         j1,         2,          j2      ;j2=j1+1
            LDDW        *+x_l1[i1], xi1rh:xi1rl         ;load x[i1] Real Part
            LDDW        *+x_l2[i1], xi1ih:xi1il         ;load x[i1] Imag Part
            LDDW        *+x_l1[j1], xj1rh:xj1rl         ;load x[j1] Real Part
            LDDW        *+x_l2[j1], xj1ih:xj1il         ;load x[j1] Imag Part
            MPY         i1,         2,          i1      ;2*i1
            MPY         j1,         2,          j1      ;2*j1
            STW         xj1rl,      *+x_l1[i1]          ;Store x[j1] Real Part
            STW         xj1il,      *+x_l2[i1]          ;Store x[j1] Imag Part
            ADD         i1,         1,          i1      ;To Store Upper 32 Msb's
            STW         xj1rh,      *+x_l1[i1]          ;Store x[j1] Real Part
            STW         xj1ih,      *+x_l2[i1]          ;Store x[j1] Imag Part
            STW         xi1rl,      *+x_l1[j1]          ;Store x[i1] Real Part
            STW         xi1il,      *+x_l2[j1]          ;Store x[i1] Imag Part
            ADD         j1,         1,          j1      ;To Store Upper 32 Msb's
            STW         xi1rh,      *+x_l1[j1]          ;Store x[i1] Real Part
            STW         xi1ih,      *+x_l2[j1]          ;Store x[i1] Imag Part

            LDDW        *+x_l1[i2], xi2rh:xi2rl         ;load x[i2] Real Part
            LDDW        *+x_l2[i2], xi2ih:xi2il         ;load x[i2] Imag Part
            LDDW        *+x_l1[j2], xj2rh:xj2rl         ;load x[j2] Real Part
            LDDW        *+x_l2[j2], xj2ih:xj2il         ;load x[j2] Imag Part
    [t]     MPY         i2,         2,          i2      ;2*i2
    [t]     MPY         j2,         2,          j2      ;2*j2
    [t]     STW         xj2rl,      *+x_l1[i2]          ;Store x[j2] Real Part
    [t]     STW         xj2il,      *+x_l2[i2]          ;Store x[j2] Imag Part
    [t]     ADD         i2,         1,          i2      ;To Store Upper 32 Msb's
    [t]     STW         xj2rh,      *+x_l1[i2]          ;Store x[j2] Real Part
    [t]     STW         xj2ih,      *+x_l2[i2]          ;Store x[j2] Imag Part
    [t]     STW         xi2rl,      *+x_l1[j2]          ;Store x[i2] Real Part
    [t]     STW         xi2il,      *+x_l2[j2]          ;Store x[i2] Imag Part
    [t]     ADD         j2,         1,          j2      ;To Store Upper 32 Msb's
    [t]     STW         xi2rh,      *+x_l1[j2]          ;Store x[i2] Real Part
    [t]     STW         xi2ih,      *+x_l2[j2]          ;Store x[i2] Imag Part
            ADD         i0c,        2,          i0c     ;Increment The Counter
            CMPEQ       i0c,        halfn1,     flag    ;Check Condition
    [!flag] B           loop

            .return
            .endproc

* ======================================================================== *
*  End of file: DSPF_dp_bitrev_cplx.sa                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_cfftr4_/1117057375  709   0     0       22277     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      *
*      Frequency radix-4 FFT with complex input                            *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*   This routine is C Callable and can be called as:                        *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*                                                                           *
*   x : Pointer to an array holding the input and output floating           *
*       point array which contains 'n' complex points                       *
*   w : Pointer to an array holding the coefficient floating point          *
*       array which contains 3*n/4 complex numbers                          *
*   n : Number of complex points in x                                       *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*   This routine implements the DIF (decimation in frequency)               *
*   complex radix 4 FFT with digit-reversed output and normal               *
*   order input.  The number of points, 'n', must be a power                *
*   of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   *
*   in-place routine in the sense that the output is written                *
*   over the input.  It is not an in-place routine in the                   *
*   sense that the input is in normal order and the output is               *
*   in digit-reversed order.                                                *
*                                                                           *
*   There must be n complex points (2*n values), and 3*n/4 complex          *
*   coefficients (3*n/2 values).                                            *
*                                                                           *
*   Each real and imaginary input value is interleaved in the               *
*   'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             *
*   are in normal order.  Each real and imaginary output value              *
*   is interleaved in the 'x' array and the complex numbers are             *
*   in digit-reversed  order {rx0, ix0, ...}.  The real and                 *
*   imaginary values of the coefficients are interleaved in the             *
*   'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           *
*   are in normal order.                                                    *
*                                                                           *
*   Note that the imaginary coefficients are negated                        *
*   {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           *
*   {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       *
*   where d = 2*PI/n.  The value of w(n,k) is usually written               *
*   w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                *
*                                                                           *
*   The routine can be used to implement an inverse FFT by                  *
*   performing the complex conjugate on the input complex numbers           *
*   (negating the imaginary value), and dividing the result by n.           *
*   Another method to use the FFT to perform an inverse FFT, is to          *
*   swap the real and imaginary values of the input and the result,         *
*   and divide the result by n.  In either case, the input is still         *
*   in normal order and the output is still in digit-reversed order.        *
*                                                                           *
*   Note that you can not make the radix 4 FFT into an inverse              *
*   FFT by using the complex conjugate of the coefficients as               *
*   you can do with the complex radix 2 FFT.                                *
*                                                                           *
*   If you label the input locations from 0 to (n-1) (normal order),        *
*   the digit-reversed locations can be calculated by reversing the         *
*   order of the bit pairs of the labels.  For example, for a 1024          *
*   point FFT, the digit reversed location for                              *
*   617d = 1001101001b = 10 01 10 10 01  is                                 *
*   422d = 0110100110b = 01 10 10 01 10  and visa versa.                    *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*   1.  There are no special alignment requirements.                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent for the assembly code.  Note that              *
*   the assembly code is hand optimized and restrictions may                *
*   apply.                                                                  *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*   {                                                                       *
*       short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              *
*       double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               *
*       double si1, si2, si3;                                               *
*       n2 = n;                                                             *
*       ie = 1;                                                             *
*       for(k=n; k>1; k>>=2)                                                *
*       {                                                                   *
*          n1 = n2;                                                         *
*          n2 >>= 2;                                                        *
*          ia1 = 0;                                                         *
*          for(j=0; j<n2; j++)                                              *
*          {                                                                *
*              ia2 = ia1 + ia1;                                             *
*              ia3 = ia1 + ia2;                                             *
*              co1 = w[ia1*2];                                              *
*              si1 = w[ia1*2 + 1];                                          *
*              co2 = w[ia2*2];                                              *
*              si2 = w[ia2*2 + 1];                                          *
*              co3 = w[ia3*2];                                              *
*              si3 = w[ia3*2 + 1];                                          *
*              ia1 += ie;                                                   *
*              for(i0=j; i0<n; i0+=n1)                                      *
*              {                                                            *
*                  i1 = i0 + n2;                                            *
*                  i2 = i1 + n2;                                            *
*                  i3 = i2 + n2;                                            *
*                  r1 = x[i0*2]   + x[i2*2];                                *
*                  r3 = x[i0*2]   - x[i2*2];                                *
*                  s1 = x[i0*2+1] + x[i2*2+1];                              *
*                  s3 = x[i0*2+1] - x[i2*2+1];                              *
*                  r2 = x[i1*2]   + x[i3*2];                                *
*                  r4 = x[i1*2]   - x[i3*2];                                *
*                  s2 = x[i1*2+1] + x[i3*2+1];                              *
*                  s4 = x[i1*2+1] - x[i3*2+1];                              *
*                  x[i0*2]   = r1 + r2;                                     *
*                  r2        = r1 - r2;                                     *
*                  r1        = r3 - s4;                                     *
*                  r3        = r3 + s4;                                     *
*                  x[i0*2+1] = s1 + s2;                                     *
*                  s2        = s1 - s2;                                     *
*                  s1        = s3 + r4;                                     *
*                  s3        = s3 - r4;                                     *
*                  x[i1*2]   = co1*r3 + si1*s3;                             *
*                  x[i1*2+1] = co1*s3 - si1*r3;                             *
*                  x[i2*2]   = co2*r2 + si2*s2;                             *
*                  x[i2*2+1] = co2*s2 - si2*r2;                             *
*                  x[i3*2]   = co3*r1 + si3*s1;                             *
*                  x[i3*2+1] = co3*s1 - si3*r1;                             *
*             }                                                             *
*          }                                                                *
*          ie <<= 2;                                                        *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. The twiddle factor array w can be generated by the tw_r4fft       *
*         function provided in dsplib\support\fft\tw_r4fft.c. The exe       *
*         file for this function, dsplib\bin\tw_r4fft.exe, can be           *
*         used dump the twiddle factor array into a file.                   *
*      2. The function bit_rev in dsplib\support\fft can be used to         *
*         bit-reverse the output array to convert it into normal order.     *
*      3. Endian: This code is LITTLE  ENDIAN.                              *
*      4. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     14*n*log4(n) + 46                                                     *
*     eg. if n = 256, cycles = 14382.                                       *
*                                                                           *
*   CODESIZE                                                                *
*       1344 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_cfftr4_dif
_DSPF_dp_cfftr4_dif   .cproc  x, w, n

                .reg    k, ie, n2, n1, i, j, i0, i1, i2, i3, t_ia1
                .reg    ia1, ia2, ia3, tctr, ictr, t_i0, t_w, t_x
                .reg    co1h:co1l, si1h:si1l, co2h:co2l, si2h:si2l
                .reg    co3h:co3l, si3h:si3l, xi0rh:xi0rl, xi0ih:xi0il
                .reg    xi1rh:xi1rl, xi1ih:xi1il, xi2rh:xi2rl, xi2ih:xi2il
                .reg    xi3rh:xi3rl, xi3ih:xi3il, xi4rh:xi4rl, xi4ih:xi4il
                .reg    r1h:r1l, r2h:r2l, r3h:r3l, r4h:r4l, s1h:s1l, s2h:s2l
                .reg    s3h:s3l, s4h:s4l, sa1:sa0,  sa3:sa2, pa1:pa0, pa3:pa2
                .reg    pa5:pa4, pa7:pa6

            MV      n,      n2                      ;init n2
            MVK     1,      ie                      ;init ie
            SHR     n,      2,      tctr            ;loopCounter Value
            MV      tctr,   k                       ;init Outerloop Counter
            ADDAD   w,      1,      t_w             ;temp Pointer for w
            ADDAD   x,      1,      t_x             ;temp Pointer for x
oloop:
            MV      n2,     n1                      ;init  n1
            SHR     n2,     2,      n2              ;n2>>=2
            ZERO    t_ia1                           ;init ia1
            MV      ie,     i                       ;init i
            MV      tctr,   ictr                    ;init innerloopCounter
            ZERO    t_i0                            ;Temp store for i0
            ZERO    i0                              ;Init i0
            ZERO    j                               ;init j
            ZERO    ia1
            SHL     ia1,    1,      ia2             ;ia2=ia1<<1
            ADD     ia2,    ia1,    ia3             ;ia3=ia1+ia2
            ADD     ia1,    ie,     t_ia1           ;Update ia1
            MPY     ia1,    2,      ia1
            MPY     ia2,    2,      ia2
            MPY     ia3,    2,      ia3
            LDDW    *w[ia1],        co1h:co1l       ;load co1
            LDDW    *t_w[ia1],      si1h:si1l       ;load si1
            LDDW    *w[ia2],        co2h:co2l       ;load co2
            LDDW    *t_w[ia2],      si2h:si2l       ;load si2
            LDDW    *w[ia3],        co3h:co3l       ;load co3
            LDDW    *t_w[ia3],      si3h:si3l       ;load si3
loop:
    [!i]    MV      t_ia1,  ia1
    [!i]    SHL     ia1,    1,      ia2             ;ia2=ia1<<1
    [!i]    ADD     ia2,    ia1,    ia3             ;ia3=ia1+ia2
    [!i]    ADD     ia1,    ie,     t_ia1           ;Update ia1
    [!i]    MPY     ia1,    2,      ia1
    [!i]    MPY     ia2,    2,      ia2
    [!i]    MPY     ia3,    2,      ia3
    [!i]    LDDW    *w[ia1],        co1h:co1l       ;load co1
    [!i]    LDDW    *t_w[ia1],      si1h:si1l       ;load si1
    [!i]    LDDW    *w[ia2],        co2h:co2l       ;load co2
    [!i]    LDDW    *t_w[ia2],      si2h:si2l       ;load si2
    [!i]    LDDW    *w[ia3],        co3h:co3l       ;load co3
    [!i]    LDDW    *t_w[ia3],      si3h:si3l       ;load si3
    [!i]    ADD     j,              1,          j   ;Increment i0
    [!i]    MV      j,              t_i0
    [!i]    MV      ie,     i                       ;Innermost loop Counter Update
            MV      t_i0,   i0
            ADD     i0,     n2,     i1              ;i1=i0+n1
            ADD     i1,     n2,     i2              ;i2=i1+n1
            ADD     i2,     n2,     i3              ;i3=i2+n1
            MPY     i0,     2,      i0              ;2*i0
            MPY     i1,     2,      i1              ;2*i1
            MPY     i2,     2,      i2              ;2*i2
            MPY     i3,     2,      i3              ;2*i3
            LDDW    *x[i0],         xi0rh:xi0rl     ;load x[i0] real part
            LDDW    *t_x[i0],       xi0ih:xi0il     ;load x[i0] Imag part
            LDDW    *x[i1],         xi1rh:xi1rl     ;load x[i1] real part
            LDDW    *t_x[i1],       xi1ih:xi1il     ;load x[i1] Imag part
            LDDW    *x[i2],         xi2rh:xi2rl     ;load x[i2] real part
            LDDW    *t_x[i2],       xi2ih:xi2il     ;load x[i2] Imag part
            LDDW    *x[i3],         xi3rh:xi3rl     ;load x[i3] real part
            LDDW    *t_x[i3],       xi3ih:xi3il     ;load x[i3] Imag part
            ADDDP   xi0rh:xi0rl,    xi2rh:xi2rl ,   r1h:r1l     ;r1
            SUBDP   xi0rh:xi0rl,    xi2rh:xi2rl ,   r3h:r3l     ;r3
            ADDDP   xi0ih:xi0il,    xi2ih:xi2il ,   s1h:s1l     ;s1
            SUBDP   xi0ih:xi0il,    xi2ih:xi2il ,   s3h:s3l     ;s3
            ADDDP   xi1rh:xi1rl,    xi3rh:xi3rl ,   r2h:r2l     ;r2
            SUBDP   xi1rh:xi1rl,    xi3rh:xi3rl ,   r4h:r4l     ;r4
            ADDDP   xi1ih:xi1il,    xi3ih:xi3il ,   s2h:s2l     ;s2
            SUBDP   xi1ih:xi1il,    xi3ih:xi3il ,   s4h:s4l     ;s4
            ADDDP   r1h:r1l,        r2h:r2l,        sa1:sa0     ;r1+r2
            SUBDP   r1h:r1l,        r2h:r2l,        r2h:r2l     ;r1-r2
            SUBDP   r3h:r3l,        s4h:s4l,        r1h:r1l     ;r3-s4
            ADDDP   r3h:r3l,        s4h:s4l,        r3h:r3l     ;r3+s4
            ADDDP   s1h:s1l,        s2h:s2l,        sa3:sa2     ;s1+s2
            SUBDP   s1h:s1l,        s2h:s2l,        s2h:s2l     ;s1-s2
            ADDDP   s3h:s3l,        r4h:r4l,        s1h:s1l     ;s3-r4
            SUBDP   s3h:s3l,        r4h:r4l,        s3h:s3l     ;s3+r4
            MPY     i0,             2,          i0
            STW     sa0,            *x[i0]                      ;store x[2*i0]
            STW     sa2,            *t_x[i0]                    ;storex[2*i0+1]
            ADD     i0,             1,          i0
            STW     sa1,            *x[i0]                      ;store x[2*i0]
            STW     sa3,            *t_x[i0]                    ;storex[2*i0+1]
            MPYDP   co1h:co1l,      r3h:r3l,    pa1:pa0         ;co1*r3
            MPYDP   si1h:si1l,      s3h:s3l,    pa3:pa2         ;si1*s3
            MPYDP   co1h:co1l,      s3h:s3l,    pa5:pa4         ;co1*s3
            MPYDP   si1h:si1l,      r3h:r3l,    pa7:pa6         ;si1*r3
            ADDDP   pa1:pa0,        pa3:pa2,    sa1:sa0         ;x[2*i1]
            SUBDP   pa5:pa4,        pa7:pa6,    sa3:sa2         ;x[2*i1+1]
            MPY     i1,             2,          i1
            STW     sa0,            *x[i1]                      ;store x[2*i1]
            STW     sa2,            *t_x[i1]                    ;storex[2*i1+1]
            ADD     i1,             1,          i1
            STW     sa1,            *x[i1]                      ;store x[2*i1]
            STW     sa3,            *t_x[i1]                    ;storex[2*i1+1]
            MPYDP   co2h:co2l,      r2h:r2l,    pa1:pa0         ;co2*r2
            MPYDP   si2h:si2l,      s2h:s2l,    pa3:pa2         ;si2*s2
            MPYDP   co2h:co2l,      s2h:s2l,    pa5:pa4         ;co2*s2
            MPYDP   si2h:si2l,      r2h:r2l,    pa7:pa6         ;si2*r2
            ADDDP   pa1:pa0,        pa3:pa2,    sa1:sa0         ;x[2*i2]
            SUBDP   pa5:pa4,        pa7:pa6,    sa3:sa2         ;x[2*i2+1]
            MPY     i2,             2,          i2
            STW     sa0,            *x[i2]                      ;store x[2*i2]
            STW     sa2,            *t_x[i2]                    ;storex[2*i2+1]
            ADD     i2,             1,          i2
            STW     sa1,            *x[i2]                      ;store x[2*i2]
            STW     sa3,            *t_x[i2]                    ;storex[2*i2+1]
            MPYDP   co3h:co3l,      r1h:r1l,    pa1:pa0         ;co3*r1
            MPYDP   si3h:si3l,      s1h:s1l,    pa3:pa2         ;si3*s1
            MPYDP   co3h:co3l,      s1h:s1l,    pa5:pa4         ;co3*s1
            MPYDP   si3h:si3l,      r1h:r1l,    pa7:pa6         ;si3*r1
            ADDDP   pa1:pa0,        pa3:pa2,    sa1:sa0         ;x[2*i3]
            SUBDP   pa5:pa4,        pa7:pa6,    sa3:sa2         ;x[2*i3+1]
            MPY     i3,             2,          i3
            STW     sa0,            *x[i3]                      ;store x[2*i3]
            STW     sa2,            *t_x[i3]                    ;storex[2*i3+1]
            ADD     i3,             1,          i3
            STW     sa1,            *x[i3]                      ;store x[2*i3]
            STW     sa3,            *t_x[i3]                    ;storex[2*i3+1]

            ADD     t_i0,           n1,         t_i0            ;Update i0
            SUB     i,              1,          i
    [ictr]  SUB     ictr,           1,          ictr            ;Decrement loop counter
    [ictr]  B       loop

            SHL     ie,             2,          ie              ;ie<<=2
            SHR     k,              2,          k               ;k>>=2
     [k]    B       oloop

            .return
            .endproc

* ======================================================================== *
*  End of file: DSPF_dp_cfftr4_dif.sa                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_cfftr2./1117057376  732   0     0       24402     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr2 -- Double Precision Cache optimised radix-2 forward FFT   *
*      with complex input                                                  *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      12-Feb-2004                                                         *
*                                                                          *
*  USAGE                                                                   *  
*         This routine is C-callable and can be called as:                 *  
*                                                                          *  
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)         *  
*                                                                          *  
*         x : input and output sequences (dim-n)      (input/output)       *  
*             x has n complex numbers (2*n DP values).                     *  
*             The real and imaginary values are interleaved in memory.     *  
*             The input is in normal order and output is in bit-reversed   *  
*             Order.                                                       *  
*         w : FFT coefficients (dim-n)                (input)              *  
*             w has n complex numbers (n DP values).                       *  
*             FFT coeficients are in a special sequence so that FFT can    *  
*             be called on smaller input sets multiple times to avoid      *  
*             cache thrashing.                                             *  
*             The real and imaginary values are interleaved in memory.     *  
*         n : FFT size which is a power of 2 and > 4  (input)              *  
*                                                                          *  
*                                                                          *  
*  DESCRIPTION                                                             *  
*       This routine is used to compute the Complex, Radix-2, Fast         *  
*       Fourier Transform of a double precision complex sequence of size   *  
*       n, and a power of 2 in a Cache-friendly way. The routine requires  *  
*       normal order input and normal order coefficents (twiddle factors)  *  
*       in a special sequence and produces results that are in             *  
*       bit-reversed order.                                                *  
*                                                                          *  
*       The input can be broken into smaller parts and called multiple     *  
*       times to avoid cache thrashing.                                    *  
*                                                                          *  
*       How to use                                                         *  
*                                                                          *  
*       void main(void)                                                    *  
*       {                                                                  *  
*          gen_w_r2(w, N);         // Generate coefficient table           *  
*                                  // in normal order                      *  
*                                  // Function is given in C-CODE section  *  
*                                                                          *  
*         DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in     *  
*                                  // order bit-reversed                   *  
*                                                                          *  
*         bit_rev(x, N)           // Bit reverse the output if             *  
*                                  // normal order output is needed        *  
*                                  // Function is given in C-CODE section  *  
*       }                                                                  *  
*                                                                          *  
*       main fft of size N can be divided into several steps (where        *  
*       number of steps is a power of 2), allowing as much data            *  
*       reuse as possible.                                                 *  
*                                                                          *  
*       For example the following function                                 *  
*       DSPF_dp_cfftr2(N, x, w, 1);                                             *  
*                                                                          *  
*       is equivalent to:                                                  *  
*                                                                          *  
*       DSPF_dp_cfftr2(N, x, w, N/4);                                           *  
*                                                                          *  
*       DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                 *  
*       DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                 *  
*       DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                 *  
*       DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                 *  
*                                                                          *  
*       Notice how the 1st fft function is called on the entire data set.  *  
*       It covers the 1st pass of the fft until the butterfly size is      *  
*       N/4. The following 4 ffts do N/4 point ffts, 25% of the original   *  
*       size. These continue down to the end when the buttly is of size    *  
*       2. We use an index of 2* 3/4 *N to the main twiddle factor array   *  
*       for the last 4 calls. This is because the twiddle factor array     *  
*       is composed of successively decimated versions of the main array.  *  
*                                                                          *  
*       The twiddle factor array is composed of log2(N) sets of twiddle    *  
*       factors of size N, N/2, N/4, N/8 etc. The index into this array    *  
*       for each stage of the fft can be calculated by summing these       *  
*       indices up appropriately. For example, if we are dividing the      *  
*       input into 2 parts then index into this array should be N, if we   *  
*       are dividing into 4 parts then index into this array should be     *  
*       N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.  *  
*                                                                          *  
*       For multiple ffts they can share the same table by calling the     *  
*       small ffts from further down in the twiddle factor array, in the   *  
*       same way as the decomposition works for more data reuse.           *  
*                                                                          *  
*       The functions for creating this special sequence of twiddle        *  
*       factors and bit-reversal are provided in the C CODE section.       *  
*                                                                          *  
*       In general if divide the input into NO_OF_DIV parts we can call    *  
*       the function as follows:                                           *  
*                                                                          *  
*       // Divide the input into NO_OF_DIV parts                           *  
*       DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                   *  
*                                                                          *  
*                                                                          *  
*       // Find out the index into twiddle factor array                    *  
*       for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                      *  
*       {                                                                  *  
*          w_index += j;                                                   *  
*       }                                                                  *  
*       w_index = N * w_index / NO_OF_DIV;                                 *  
*                                                                          *  
*       // Call the Function a subset of inputs                            *  
*       for(i=0; i<NO_OF_DIV; i++)                                         *  
*       {                                                                  *  
*          DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);  *  
*       }                                                                  *  
*                                                                          *  
*  TECHNIQUES                                                              *  
*                                                                          *  
*       1. Outer loop instructions are executed in parallel with the       *  
*          inner loop epilog.                                              *  
*                                                                          *  
*  ASSUMPTIONS                                                             *  
*       1. Both input x and coefficient w should be aligned on double      *  
*          word boundary.                                                  *  
*       2. n should be greater than 4 and a power of 2.                    *  
*                                                                          *  
*  C CODE                                                                  *  
*         This is the C equivalent of the assembly code without            *  
*         restrictions. Note that the assembly code is hand optimized      *  
*         and restrictions may apply.                                      *  
*                                                                          *  
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)         *  
*         {                                                                *  
*              int n2, ie, ia, i, j, k, m;                                 *  
*              double rtemp, itemp, c, s;                                  *  
*                                                                          *  
*              n2 = n;                                                     *  
*              ie = 1;                                                     *  
*                                                                          *  
*              for(k = n; k > n_min; k >>= 1)                              *  
*               {                                                          *  
*                 n2 >>= 1;                                                *  
*                 ia = 0;                                                  *  
*                 for(j=0; j < ie; j++)                                    *  
*                 {                                                        *  
*                  for(i=0; i < n2; i++)                                   *  
*                    {                                                     *  
*                       c = w[2*i];                                        *  
*                       s = w[2*i+1];                                      *  
*                       m = ia + n2;                                       *  
*                       rtemp     = x[2*ia]   - x[2*m];                    *  
*                       x[2*ia]   = x[2*ia]   + x[2*m];                    *  
*                       itemp     = x[2*ia+1] - x[2*m+1];                  *  
*                       x[2*ia+1] = x[2*ia+1] + x[2*m+1];                  *  
*                       x[2*m]    = c*rtemp   - s*itemp;                   *  
*                       x[2*m+1]  = c*itemp   + s*rtemp;                   *  
*                       ia++;                                              *  
*                      }                                                   *  
*                   ia += n2;                                              *  
*                  }                                                       *  
*                 ie <<= 1;                                                *  
*                 w = w + k;                                               *  
*              }                                                           *  
*          }                                                               *  
*                                                                          *  
*          The follwoing C code is used to generate the coefficient table. *  
*                                                                          *  
*           #include <math.h>                                              *  
*           // generate real and imaginary twiddle                         *  
*           //  table of size n complex numbers (or 2*n numbers)           *  
*                                                                          *  
*           void gen_w_r2(double* w, int n)                                *  
*           {                                                              *  
*                int i, j=1;                                               *  
*                double pi = 4.0*atan(1.0);                                *  
*                double e = pi*2.0/n;                                      *  
*                for(j=1; j < n; j <<= 1)                                  *  
*                {                                                         *  
*                for(i=0; i < ( n>>1 ); i += j)                            *  
*                   {                                                      *  
*                   *w++   = cos(i*e);                                     *  
*                   *w++   = -sin(i*e);                                    *  
*                   }                                                      *  
*                }                                                         *  
*           }                                                              *  
*                                                                          *  
*                                                                          *  
*           The follwoing C code is used to bit-reverse the output.        *  
*                                                                          *  
*           bit_rev(double* x, int n)                                      *  
*           {                                                              *  
*             int i, j, k;                                                 *  
*             double rtemp, itemp;                                         *  
*                                                                          *  
*             j = 0;                                                       *  
*             for(i=1; i < (n-1); i++)                                     *  
*             {                                                            *  
*               k = n >> 1;                                                *  
*                while(k <= j)                                             *  
*                {                                                         *  
*                   j -= k;                                                *  
*                   k >>= 1;                                               *  
*                }                                                         *  
*                j += k;                                                   *  
*                if(i < j)                                                 *  
*                {                                                         *  
*                   rtemp    = x[j*2];                                     *  
*                   x[j*2]   = x[i*2];                                     *  
*                   x[i*2]   = rtemp;                                      *  
*                   itemp    = x[j*2+1];                                   *  
*                   x[j*2+1] = x[i*2+1];                                   *  
*                   x[i*2+1] = itemp;                                      *  
*                }                                                         *  
*             }                                                            *  
*           }                                                              *  
*                                                                          *  
*  NOTES                                                                   *  
*                                                                          *  
*       1. The special sequence of twiddle factor array w can be generated *  
*         using the gen_w_r2 function provided in the previous section.    *  
*                                                                          *  
*       2. Endian:This code is LITTLE ENDIAN.                              *  
*                                                                          *  
*       3. Interruptibility: This code is interrupt-tolerant but not       *  
*          interruptible.                                                  *  
*                                                                          *  
*  CYCLES                                                                  *  
*                                                                          *  
*        4 * n * lg(n) + 16 * lg(n) + 34                                   *  
*        eg. IF n = 64,  cycles = 1666                                     *  
*        eg. IF n = 32,  cycles = 754                                      *  
*                                                                          *  
*  CODESIZE                                                                *  
*                                                                          *  
*        1408 bytes                                                        *  
* ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *



        .text
        .global _DSPF_dp_cfftr2
_DSPF_dp_cfftr2   .cproc  n, x, w, n_min

             .reg    x1rh:x1rl, x1ih:x1il, x2rh:x2rl, x2ih:x2il
             .reg    s1:s0, s3:s2, coh:col, sih:sil, rth:rtl, ith:itl  
             .reg    ie, n2, i, j, k, m, ia
             .reg    flag, t_i, t_m, t_ia, t_x, t_w
             .no_mdep
             
             
      MV      n,      n2                 ;init n2
      MVK     1,      ie                 ;init ie    
      MV      n,      k                  ;k=n
      ADDAD   x,      1,      t_x        ;For Imag Partof x
      ADDAD   w,      1,      t_w        ;For Imag Partof w 

kloop:

      SHR     n2,      1,      n2        ;n2 >>=1
      ZERO    ia                         ;ia=0
      MV      ie,      j                 ;j=ie

jloop:

      MV      n2,       i                ;i=n2
      ZERO    t_i                        ;t_i=0
      
iloop:

      LDDW    *w[t_i],      coh:col                ;c=w[2*i]
      LDDW    *t_w[t_i],    sih:sil                ;s=w[2*i+1]
      
      ADD     ia,        n2,      m                ;m=ia+n2
      
      ADD     ia,        ia,      t_ia             ;t_ia=2*ia
      ADD     m,         m,       t_m              ;t_m=2*m
      
      LDDW    *x[t_ia],     x1rh:x1rl              ;load x[2*ia]
      LDDW    *x[t_m],      x2rh:x2rl              ;load x[2*m]
      
      SUBDP   x1rh:x1rl,    x2rh:x2rl,     rth:rtl ;rtemp =x[2*ia]-x[2*m]
      ADDDP   x1rh:x1rl,    x2rh:x2rl,     s1:s0   ;S1 =x[2*ia]+x[2*m]
      
      LDDW    *t_x[t_ia],   x1ih:x1il              ;load x[2*ia+1]
      LDDW    *t_x[t_m],    x2ih:x2il              ;load x[2*m+1]
      
      SUBDP   x1ih:x1il,    x2ih:x2il,     ith:itl ;itemp =x[2*ia+1]-x[2*m+1]
      ADDDP   x1ih:x1il,    x2ih:x2il,     s3:s2   ;S2 =x[2*ia+1]+x[2*m+1]
      
      ADD     t_ia,         t_ia,          t_ia    ;t_ia=2*(2*ia)
      
      STW     s0,           *x[t_ia]               ;x[2*ia]=s1
      STW     s2,           *t_x[t_ia]             ;x[2*ia+1]=s2                                                
      
      ADD     t_ia,         1,             t_ia    ;t_ia=2*(2*ia)+1
                   
      STW     s1,           *x[t_ia]               ;x[2*ia]=s1
      STW     s3,           *t_x[t_ia]             ;x[2*ia+1]=s2
      
      MPYDP   rth:rtl,       coh:col,      x1rh:x1rl;x1r=c*rtemp
      MPYDP   ith:itl,       sih:sil,      x2rh:x2rl;x2r=s*itemp                                                                                                
                              
      MPYDP   rth:rtl,       sih:sil,      x1ih:x1il;x1i=s*rtemp
      MPYDP   ith:itl,       coh:col,      x2ih:x2il;x2i=c*itemp
      
      SUBDP   x1rh:x1rl,     x2rh:x2rl,    s1:s0    ;c*rtemp-s*itemp
      ADDDP   x2ih:x2il,     x1ih:x1il,    s3:s2    ;c*itemp+s*itemp
                                                                                                                                                                                                                                                                                                        
      ADD     t_m,           t_m,          t_m      ;t_m=2*(2*m)
      
      STW     s0,            *x[t_m]                ;x[2*m]=s1
      STW     s2,            *t_x[t_m]              ;x[2*m+1]=s2                                                
      
      ADD     t_m,           1,            t_m      ;t_m=2*(2*ia)+1
                   
      STW     s1,            *x[t_m]                ;x[2*m]=s1
      STW     s3,            *t_x[t_m]              ;x[2*m+1]=s2
      
      ADD     ia,            1,            ia       ;ia+=1
      ADD     t_i,           2,            t_i      ;t_i=i+1
      SUB     i,             1,            i        ;i -=1
      
 [i]  B      iloop
 
      ADD     ia,            n2,           ia       ;ia +=n2;
      SUB     j,             1,            j        ;j-=1
                
 [j]  B      jloop
 
      SHL     ie,            1,            ie       ;ie <<= 1
      ADDAD   w,             k,            w        ;w +=k
      ADDAD   w,             1,            t_w      ;w +=1
      SHR     k,             1,            k       ;k >>= 1
      CMPGT   k,             n_min,        flag
      
[flag]B      kloop

        .return
        .endproc

* ======================================================================== *
*  End of file: DSPF_dp_cfftr2.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_icfftr2/1117057377  751   0     0       26498     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      *
*      FFT with complex input                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      12-Feb-2004                                                         *
*                                                                          *
*  USAGE                                                                   *  
*                                                                          *  
*         This routine is C-callable and can be called as:                 *  
*                                                                          *  
*         void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)        *  
*                                                                          *  
*         x : input and output sequences (dim-n)      (input/output)       *  
*             x has n complex numbers (2*n DP values).                     *  
*             The real and imaginary values are interleaved in memory.     *  
*             The input is in normal order and output is in bit-reversed   *  
*             Order.                                                       *  
*         w : FFT coefficients (dim-n)                (input)              *  
*             w has n complex numbers (n DP values).                       *  
*             FFT coeficients are in a special sequence so that FFT can    *  
*             be called on smaller input sets multiple times to avoid      *  
*             cache thrashing.                                             *  
*             The real and imaginary values are interleaved in memory.     *  
*         n : FFT size which is a power of 2 and > 4  (input)              *  
*                                                                          *  
*                                                                          *  
*  DESCRIPTION                                                             *  
*                                                                          *  
*       This routine is used to compute the Inverse Complex, Radix-2, Fast *  
*       Fourier Transform of a double precision complex sequence of size   *  
*       n, and a power of 2 in a Cache-friendly way. The routine requires  *  
*       normal order input and normal order coefficents (twiddle factors)  *  
*       in a special sequence and produces results that are in             *  
*       bit-reversed order.                                                *  
*                                                                          *  
*       The input can be broken into smaller parts and called multiple     *  
*       times to avoid cache thrashing.                                    *  
*                                                                          *  
*       How to use                                                         *  
*                                                                          *  
*       void main(void)                                                    *  
*       {                                                                  *  
*          gen_w_r2(w, N);         // Generate coefficient table           *  
*                                  // in normal order                      *  
*                                  // Function is given in C-CODE section  *  
*                                                                          *  
*         DSPF_dp_icfftr2(N, x, w, 1);  // input in normal order, output in     *  
*                                  // order bit-reversed                   *  
*                                                                          *  
*         bit_rev(x, N)            // Bit reverse the output if            *  
*                                  // normal order output is needed        *  
*                                  // Function is given in C-CODE section  *  
*                                                                          *  
*         divide(x, N);            // scale inverse FFT output             *  
*                                  // result is the same as original       *  
*                                  // input                                *  
*                                                                          *  
*      }                                                                   *  
*                                                                          *  
*       main Inverse fft of size N can be divided into several steps (wher *  
*       number of steps is a power of 2), allowing as much data            *  
*       reuse as possible.                                                 *  
*                                                                          *  
*       For example the following function                                 *  
*       DSPF_dp_icfftr2(N, x, w, 1);                                            *  
*                                                                          *  
*       is equivalent to:                                                  *  
*                                                                          *  
*       DSPF_dp_icfftr2(N, x, w, N/4);                                          *  
*                                                                          *  
*       DSPF_dp_icfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                *  
*       DSPF_dp_icfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                *  
*       DSPF_dp_icfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                *  
*       DSPF_dp_icfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                *  
*                                                                          *  
*       Notice how the 1st icfft function is called on the entire data set *  
*       It covers the 1st pass of the fft until the butterfly size is      *  
*       N/4. The following 4 ffts do N/4 point ffts, 25% of the original   *  
*       size. These continue down to the end when the buttly is of size    *  
*       2. We use an index of 2* 3/4 *N to the main twiddle factor array   *  
*       for the last 4 calls. This is because the twiddle factor array     *  
*       is composed of successively decimated versions of the main array.  *  
*                                                                          *  
*       The twiddle factor array is composed of log2(N) sets of twiddle    *  
*       factors of size N, N/2, N/4, N/8 etc. The index into this array    *  
*       for each stage of the fft can be calculated by summing these       *  
*       indices up appropriately. For example, if we are dividing the      *  
*       input into 2 parts then index into this array should be N, if we   *  
*       are dividing into 4 parts then index into this array should be     *  
*       N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.  *  
*                                                                          *  
*       For multiple iffts they can share the same table by calling the    *  
*       small iffts from further down in the twiddle factor array, in the  *  
*       same way as the decomposition works for more data reuse.           *  
*                                                                          *  
*       The functions for creating this special sequence of twiddle        *  
*       factors and bit-reversal are provided in the C CODE section.       *  
*                                                                          *  
*       In general if divide the input into NO_OF_DIV parts we can call    *  
*       the function as follows:                                           *  
*                                                                          *  
*       // Divide the input into NO_OF_DIV parts                           *  
*       DSPF_dp_icfftr2(N, x, w, N/NO_OF_DIV);                                  *  
*                                                                          *  
*                                                                          *  
*       // Find out the index into twiddle factor array                    *  
*       for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                      *  
*       {                                                                  *  
*          w_index += j;                                                   *  
*       }                                                                  *  
*       w_index = N * w_index / NO_OF_DIV;                                 *  
*                                                                          *  
*       // Call the Function a subset of inputs                            *  
*       for(i=0; i<NO_OF_DIV; i++)                                         *  
*       {                                                                  *  
*          DSPF_dp_icfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1); *  
*       }                                                                  *  
*                                                                          *  
*  TECHNIQUES                                                              *  
*                                                                          *  
*       1. Outer loop instructions are executed in parallel with the       *  
*          inner loop epilog.                                              *  
*                                                                          *  
*  ASSUMPTIONS                                                             *  
*                                                                          *  
*       1. Both input x and coefficient w should be aligned on double      *  
*          word boundary.                                                  *  
*       2. n should be greater than 4 and a power of 2.                    *  
*                                                                          *  
*  C CODE                                                                  *  
*                                                                          *  
*         This is the C equivalent of the assembly code without            *  
*         restrictions. Note that the assembly code is hand optimized      *  
*         and restrictions may apply.                                      *  
*                                                                          *  
*         void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)        *  
*         {                                                                *  
*              int n2, ie, ia, i, j, k, m;                                 *  
*              double rtemp, itemp, c, s;                                  *  
*                                                                          *  
*              n2 = n;                                                     *  
*              ie = 1;                                                     *  
*                                                                          *  
*              for(k = n; k > n_min; k >>= 1)                              *  
*               {                                                          *  
*                 n2 >>= 1;                                                *  
*                 ia = 0;                                                  *  
*                 for(j=0; j < ie; j++)                                    *  
*                 {                                                        *  
*                  for(i=0; i < n2; i++)                                   *  
*                    {                                                     *  
*                       c = w[2*i];                                        *  
*                       s = w[2*i+1];                                      *  
*                       m = ia + n2;                                       *  
*                       rtemp     = x[2*ia]   - x[2*m];                    *  
*                       x[2*ia]   = x[2*ia]   + x[2*m];                    *  
*                       itemp     = x[2*ia+1] - x[2*m+1];                  *  
*                       x[2*ia+1] = x[2*ia+1] + x[2*m+1];                  *  
*                       x[2*m]    = c*rtemp   + s*itemp;                   *  
*                       x[2*m+1]  = c*itemp   - s*rtemp;                   *  
*                       ia++;                                              *  
*                      }                                                   *  
*                   ia += n2;                                              *  
*                  }                                                       *  
*                 ie <<= 1;                                                *  
*                 w = w + k;                                               *  
*              }                                                           *  
*          }                                                               *  
*                                                                          *  
*          The follwoing C code is used to generate the coefficient table. *  
*                                                                          *  
*           #include <math.h>                                              *  
*           // generate real and imaginary twiddle                         *  
*           // table of size n complex numbers (or 2*n numbers)            *  
*                                                                          *  
*           void gen_w_r2(double* w, int n)                                *  
*           {                                                              *  
*                int i, j=1;                                               *  
*                double pi = 4.0*atan(1.0);                                *  
*                double e = pi*2.0/n;                                      *  
*                for(j=1; j < n; j <<= 1)                                  *  
*                {                                                         *  
*                for(i=0; i < ( n>>1 ); i += j)                            *  
*                   {                                                      *  
*                   *w++   = cos(i*e);                                     *  
*                   *w++   = -sin(i*e);                                    *  
*                   }                                                      *  
*                }                                                         *  
*           }                                                              *  
*                                                                          *  
*                                                                          *  
*           The follwoing C code is used to bit-reverse the output.        *  
*                                                                          *  
*           bit_rev(double* x, int n)                                      *  
*           {                                                              *  
*             int i, j, k;                                                 *  
*             double rtemp, itemp;                                         *  
*                                                                          *  
*             j = 0;                                                       *  
*             for(i=1; i < (n-1); i++)                                     *  
*             {                                                            *  
*               k = n >> 1;                                                *  
*                while(k <= j)                                             *  
*                {                                                         *  
*                   j -= k;                                                *  
*                   k >>= 1;                                               *  
*                }                                                         *  
*                j += k;                                                   *  
*                if(i < j)                                                 *  
*                {                                                         *  
*                   rtemp    = x[j*2];                                     *  
*                   x[j*2]   = x[i*2];                                     *  
*                   x[i*2]   = rtemp;                                      *  
*                   itemp    = x[j*2+1];                                   *  
*                   x[j*2+1] = x[i*2+1];                                   *  
*                   x[i*2+1] = itemp;                                      *  
*                }                                                         *  
*             }                                                            *  
*           }                                                              *  
*                                                                          *  
*       The follwoing C code is used to perform the final scaling          *  
*       of the IFFT:                                                       *  
*                                                                          *  
*       // divide each element of x by n                                   *  
*                                                                          *  
*       divide(double* x, int n)                                           *  
*       {                                                                  *  
*         int i;                                                           *  
*         double inv = 1.0 / n;                                            *  
*                                                                          *  
*          for(i=0; i < n; i++)                                            *  
*           {                                                              *  
*               x[2*i] = inv * x[2*i];                                     *  
*               x[2*i+1] = inv * x[2*i+1];                                 *  
*             }                                                            *  
*        }                                                                 *  
*                                                                          *  
*  NOTES                                                                   *  
*                                                                          *  
*       1. The special sequence of twiddle factor array w can be generated *  
*         using the gen_w_r2 function provided in the previous section.    *  
*                                                                          *  
*       2. Endian:This code is LITTLE ENDIAN.                              *  
*                                                                          *  
*       3. Interruptibility: This code is interrupt-tolerant but not       *  
*          interruptible.                                                  *  
*                                                                          *  
*  CYCLES                                                                  *  
*                                                                          *  
*        4 * n * lg(n) + 16 * lg(n) + 34                                   *  
*        eg. IF n = 64,  cycles = 1666                                     *  
*        eg. IF n = 32,  cycles = 754                                      *  
*                                                                          *  
*  CODESIZE                                                                *  
*                                                                          *  
*        1408 bytes                                                        *  
* ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *



        .text
        .global _DSPF_dp_icfftr2
_DSPF_dp_icfftr2   .cproc  n, x, w, n_min

 .reg    x1rh:x1rl, x1ih:x1il, x2rh:x2rl, x2ih:x2il
             .reg    s1:s0, s3:s2, coh:col, sih:sil, rth:rtl, ith:itl  
             .reg    ie, n2, i, j, k, m, ia
             .reg    flag, t_i, t_m, t_ia, t_x, t_w
             .no_mdep
             
             
      MV      n,      n2                 ;init n2
      MVK     1,      ie                 ;init ie    
      MV      n,      k                  ;k=n
      ADDAD   x,      1,      t_x        ;For Imag Partof x
      ADDAD   w,      1,      t_w        ;For Imag Partof w 

kloop:

      SHR     n2,      1,      n2        ;n2 >>=1
      ZERO    ia                         ;ia=0
      MV      ie,      j                 ;j=ie

jloop:

      MV      n2,       i                ;i=n2
      ZERO    t_i                        ;t_i=0
      
iloop:

      LDDW    *w[t_i],      coh:col                ;c=w[2*i]
      LDDW    *t_w[t_i],    sih:sil                ;s=w[2*i+1]
      
      ADD     ia,        n2,      m                ;m=ia+n2
      
      ADD     ia,        ia,      t_ia             ;t_ia=2*ia
      ADD     m,         m,       t_m              ;t_m=2*m
      
      LDDW    *x[t_ia],     x1rh:x1rl              ;load x[2*ia]
      LDDW    *x[t_m],      x2rh:x2rl              ;load x[2*m]
      
      SUBDP   x1rh:x1rl,    x2rh:x2rl,     rth:rtl ;rtemp =x[2*ia]-x[2*m]
      ADDDP   x1rh:x1rl,    x2rh:x2rl,     s1:s0   ;S1 =x[2*ia]+x[2*m]
      
      LDDW    *t_x[t_ia],   x1ih:x1il              ;load x[2*ia+1]
      LDDW    *t_x[t_m],    x2ih:x2il              ;load x[2*m+1]
      
      SUBDP   x1ih:x1il,    x2ih:x2il,     ith:itl ;itemp =x[2*ia+1]-x[2*m+1]
      ADDDP   x1ih:x1il,    x2ih:x2il,     s3:s2   ;S2 =x[2*ia+1]+x[2*m+1]
      
      ADD     t_ia,         t_ia,          t_ia    ;t_ia=2*(2*ia)
      
      STW     s0,           *x[t_ia]               ;x[2*ia]=s1
      STW     s2,           *t_x[t_ia]             ;x[2*ia+1]=s2                                                
      
      ADD     t_ia,         1,             t_ia    ;t_ia=2*(2*ia)+1
                   
      STW     s1,           *x[t_ia]               ;x[2*ia]=s1
      STW     s3,           *t_x[t_ia]             ;x[2*ia+1]=s2
      
      MPYDP   rth:rtl,       coh:col,      x1rh:x1rl;x1r=c*rtemp
      MPYDP   ith:itl,       sih:sil,      x2rh:x2rl;x2r=s*itemp                                                                                                
                              
      MPYDP   rth:rtl,       sih:sil,      x1ih:x1il;x1i=s*rtemp
      MPYDP   ith:itl,       coh:col,      x2ih:x2il;x2i=c*itemp
      
      ADDDP   x1rh:x1rl,     x2rh:x2rl,    s1:s0    ;c*rtemp+s*itemp
      SUBDP   x2ih:x2il,     x1ih:x1il,    s3:s2    ;c*itemp-s*itemp
                                                                                                                                                                                                                                                                                                        
      ADD     t_m,           t_m,          t_m      ;t_m=2*(2*m)
      
      STW     s0,            *x[t_m]                ;x[2*m]=s1
      STW     s2,            *t_x[t_m]              ;x[2*m+1]=s2                                                
      
      ADD     t_m,           1,            t_m      ;t_m=2*(2*ia)+1
                   
      STW     s1,            *x[t_m]                ;x[2*m]=s1
      STW     s3,            *t_x[t_m]              ;x[2*m+1]=s2
      
      ADD     ia,            1,            ia       ;ia+=1
      ADD     t_i,           2,            t_i      ;t_i=i+1
      SUB     i,             1,            i        ;i -=1
      
 [i]  B      iloop
 
      ADD     ia,            n2,           ia       ;ia +=n2;
      SUB     j,             1,            j        ;j-=1
                
 [j]  B      jloop
 
      SHL     ie,            1,            ie       ;ie <<= 1
      ADDAD   w,             k,            w        ;w +=k
      ADDAD   w,             1,            t_w      ;w +=1
      SHR     k,             1,            k       ;k >>= 1
      CMPGT   k,             n_min,        flag
      
[flag]B      kloop

        .return
        .endproc

* ======================================================================== *
*  End of file: DSPF_dp_icfftr2.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_fir_cpl/1117057378  771   0     0       11760     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_cplx(                                                  *
*                         const double * restrict x,                        *
*                         const double * restrict h,                        *
*                         double *       restrict r,                        *
*                         int   nh,                                         *
*                         int   nr                                          *
*                        )                                                  *
*                                                                           *
*             x[2*(nr+nh-1)]: Pointer to complex input array.               *
*                             The input data pointer x must point to the    *
*                            (nh)th complex element, i.e. element 2*(nh-1). *
*             h[2*nh]       : Pointer to complex coefficient array          *
*                             (in normal order).                            *
*             r[2*nr]       : Pointer to complex output array.              *
*             nh            : Number of complex coefficients in vector h.   *
*             nr            : Number of complex output samples to           *
*                            calculate.                                     *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        This function implements the FIR filter for complex input data.    *
*        The filter has nr output samples and nh coefficients. Each array   *
*        consists of an even and odd term with even terms representing the  *
*        real part and the odd terms the imaginary part of the element.     *
*        The coefficients are expected in normal order.                     *
*                                                                           *
*                                                                           *
*      TECHNIQUES                                                           *
*                                                                           *
*     1. The outer loop is unrolled twice.                                  *
*     3. Register Sharing is used to make optimal use of available register *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. nr is a multiple of 2 and greater than or equal to 2.              *
*     2. nh is greater than or equal to 4.                                  *
*     3. x points to 2*(nh-1)th input element.                              *
*                                                                           *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_cplx(const double * x, const double * h,                    *
*                    double * restrict r, int nh, int nr)                   *
*   {                                                                       *
*        int i,j;                                                           *
*        double imag, real;                                                 *
*        for (i = 0; i < 2*nr; i += 2)                                      *
*        {                                                                  *
*            imag = 0;                                                      *
*            real = 0;                                                      *
*            for (j = 0; j < 2*nh; j += 2)                                  *
*            {                                                              *
*                real += h[j] * x[i-j] - h[j+1] * x[i+1-j];                 *
*                imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];                 *
*            }                                                              *
*            r[i] = real;                                                   *
*            r[i+1] = imag;                                                 *
*        }                                                                  *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*   8*nh*nr + 5*nr + 30                                                     *
*   For nh=24 and nr=48, cycles=9486                                        *
*   For nh=16 and nr=36, cycles=4818                                        *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   608 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_fir_cplx
_DSPF_dp_fir_cplx   .cproc  x, h, r, nh, nr
    .reg   xa1:xa0, xa3:xa2, xb1:xb0, xb3:xb2
            .reg   pa1:pa0, pa3:pa2, pa5:pa4, pa7:pa6
            .reg   acc1:acc0, acc3:acc2, acc5:acc4, acc7:acc6
            .reg   xptr, hptr, ictr, octr, temp1, temp2
            .no_mdep


            MV      x,      temp1
            MV      nr,     octr                ;Set the OuterLoop Counter

            ;Outerloop Unrolled twice

oloop:      .trip   1

            MV      temp1,  xptr                ;Set Pointer for x[i-j]
            MV      h,      hptr                ;Set Pointer for h[j]
            MV      nh,     ictr                ;Set InnerLoop Counter
            ZERO    acc0
            ZERO    acc1
            ZERO    acc2
            ZERO    acc3
            ZERO    acc4
            ZERO    acc5
            ZERO    acc6
            ZERO    acc7

iloop:      .trip   2

            LDDW    *xptr++[02],    xa1:xa0             ;load x[i-j] Real part
            LDDW    *hptr++[01],    xb1:xb0             ;load h[j] Real Part
            LDDW    *xptr--[01],    xa3:xa2             ;load x[i-j+1] Real part
            LDDW    *hptr++[01],    xb3:xb2             ;load h[j] Imag Part
            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;P11=x0(real)*h(real)
            MPYDP   xb1:xb0,        xa3:xa2,    pa3:pa2 ;P12=x1(real)*h(real)
            MPYDP   xa1:xa0,        xb3:xb2,    pa5:pa4 ;P13=x0(real)*h(imag)
            MPYDP   xb3:xb2,        xa3:xa2,    pa7:pa6 ;P14=x1(real)*h(imag)
            ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0;S1+=P11
            ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2;S2+=P12
            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4;S3+=P13
            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6;S4+=P14
            LDDW    *xptr++[02],    xa1:xa0             ;load x[i-j] Imag part
            LDDW    *xptr--[05],    xa3:xa2             ;load x[i-j+1] Imag part
            MPYDP   xa1:xa0,        xb3:xb2,    pa1:pa0 ;P21=x0(imag)*h(imag)
            MPYDP   xb3:xb2,        xa3:xa2,    pa3:pa2 ;P22=x1(imag)*h(imag)
            MPYDP   xa1:xa0,        xb1:xb0,    pa5:pa4 ;P23=x0(imag)*h(real)
            MPYDP   xb1:xb0,        xa3:xa2,    pa7:pa6 ;P24=x1(imag)*h(real)
            SUBDP   acc1:acc0,      pa1:pa0,    acc1:acc0;S1-=P21
            SUBDP   acc3:acc2,      pa3:pa2,    acc3:acc2;S2-=P22
            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4;S3+=P23
            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6;S4+=P24
            SUB     ictr,           1,          ictr    ;Decrement inner Loop Counter
    [ictr]  B       iloop
            ADDAD   temp1,          04,     temp1       ;Update pointer of x[i-j]
            ADDAD   r,              02,     temp2       ;Pointer for storing r1
            STW     acc0,           *r++                ;Storing r0(real)
            STW     acc1,           *r++
            STW     acc2,           *temp2++            ;Storing r1(real)
            STW     acc3,           *temp2++
            STW     acc4,           *r++                ;Storing r0(Imag)
            STW     acc5,           *r++[05]
            STW     acc6,           *temp2++            ;Storing r1(Imag)
            STW     acc7,           *temp2++
            SUB     octr,           02,     octr        ;Decrement OuterloopCounter
    [octr]  B       oloop

            .return
            .endproc

* ======================================================================== *
*  End of file: DSPF_dp_fir_cplx.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_fir_gen/1117057379  792   0     0       11103     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*    This routine is C Callable and can be called as:                       *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                               double * restrict r,int nh, int nr);        *
*                                                                           *
*        x : Pointer to array holding the input floating point array        *
*        h : Pointer to array holding the coefficient floating point        *
*            array                                                          *
*        r : Pointer to output array                                        *
*        nh: Number of coefficents                                          *
*        nr: Number of output values                                        *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine implements a block FIR filter.  There are "nh"        *
*        filter coefficients, "nr" output samples, and "nh+nr-1"            *
*        input samples.    The coefficients need to be placed in the "h"    *
*        array in reverse order {h(nh-1), ... , h(1), h(0)} and the         *
*        array "x" starts at x(-nh+1) and ends at x(nr-1).  The             *
*        routine calculates y(0) through y(nr-1) using the following        *
*        formula:                                                           *
*                                                                           *
*        r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           *
*                                                                           *
*        where n = {0, 1, ... , nr-1}.                                      *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*        This is the C equivalent for the assembly code.  Note that         *
*        the assembly code is hand optimized and restrictions may           *
*        apply.                                                             *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                    double * restrict r, int nh, int nr)                   *
*        {                                                                  *
*           int i, j;                                                       *
*           double sum;                                                     *
*                                                                           *
*           for(i=0; i < nr; i++)                                           *
*           {                                                               *
*              sum = 0;                                                     *
*              for(j=0; j < nh; j++)                                        *
*              {                                                            *
*                  sum += x[i+j] * h[j];                                    *
*              }                                                            *
*              r[i] = sum;                                                  *
*           }                                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*    NOTES                                                                  *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*    CYCLES                                                                 *
*                                                                           *
*    (16*floor((nh+1)/2)+10)*(ceil(nr/4)) + 32                              *
*     for nh=26, nr=42, cycles=2430 cycles.                                 *
*                                                                           *
*    CODESIZE                                                               *
*                                                                           *
*     672 bytes                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_fir_gen
_DSPF_dp_fir_gen   .cproc  x, h, r, nh, nr
            .reg   xa1:xa0, xa3:xa2, xa5:xa4, xb1:xb0, xb3:xb2
            .reg   pa1:pa0, pa3:pa2, pa5:pa4, pa7:pa6
            .reg   acc1:acc0, acc3:acc2, acc5:acc4, acc7:acc6
            .reg   xptr, hptr, ictr, octr,irctr,isctr, temp1, temp2
            .no_mdep


            MV      x,      temp1
            MV      nr,     octr                ;Set the OuterLoop Counter

            ;Outerloop Unrolled 4 times

oloop:      .trip   1

            MV      temp1,  xptr                ;Set Pointer for x[i+j]
            MV      h,      hptr                ;Set Pointer for h[j]
            MV      nh,     ictr                ;Set InnerLoop Counter
            ZERO    acc0                        ;Clear the accumulators
            ZERO    acc1
            ZERO    acc2
            ZERO    acc3
            ZERO    acc4
            ZERO    acc5
            ZERO    acc6
            ZERO    acc7

            ;Innerloop Unrolled two times

iloop:      .trip   2


            SUB     ictr,           2,          ictr    ;Decrement inner Loop Counter

            LDDW    *xptr++[01],    xa1:xa0             ;load x[0]

            LDDW    *hptr++[01],    xb1:xb0             ;load h[j]

            LDDW    *xptr++[01],    xa3:xa2             ;load x[1]

            LDDW    *hptr++[01],    xb3:xb2             ;load h[j+1]

            LDDW    *xptr,          xa5:xa4             ;load x[2]

            CMPGT   ictr,           0,          irctr   ;Checking whether

    [!irctr]ADD     ictr,           1,          ictr    ;nh is odd or even

            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;P11=x[0]*h[0]

            LDDW    *+xptr[01],     xa1:xa0             ;load x[3]

            MPYDP   xb1:xb0,        xa3:xa2,    pa3:pa2 ;P12=x[1]*h[0]

            MPYDP   xa5:xa4,        xb1:xb0,    pa5:pa4 ;P13=x[2]*h[0]

            MPYDP   xb1:xb0,        xa1:xa0,    pa7:pa6 ;P14=x[3]*h[0]

            ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0;S1+=P11

            ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2;S2+=P12

            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4;S3+=P13

            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6;S4+=P14

            MPYDP   xa3:xa2,        xb3:xb2,    pa1:pa0 ;P21=x[1]*h[1]

            LDDW    *+xptr[02],     xa3:xa2             ;load x[4]

            MPYDP   xb3:xb2,        xa5:xa4,    pa3:pa2 ;P22=x[2]*h[1]

            MPYDP   xa1:xa0,        xb3:xb2,    pa5:pa4 ;P23=x[3]*h[1]

            MPYDP   xb3:xb2,        xa3:xa2,    pa7:pa6 ;P24=x[4]*h[1]

    [ictr]  ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0;S1+=P21(if nh is even Only for last iteration)

    [ictr]  ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2;S2+=P22(if nh is even Only for last iteration)

    [ictr]  ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4;S3+=P23(if nh is even Only for last iteration)

    [ictr]  ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6;S4+=P24(if nh is even Only for last iteration)



    [irctr] B       iloop

            SUB     octr,           04,     octr        ;Decrement OuterloopCounter

            CMPGT   octr,           0,      irctr       ;Checking whether

            ADD     octr,           04,     isctr

            ADDAD   temp1,          04,     temp1       ;Update pointer of x[i+j]


    [isctr] STW     acc0,           *r++                ;Storing r0

    [isctr] STW     acc1,           *r++

    [isctr]SUB     isctr,           01,     isctr



    [isctr] STW     acc2,           *r++                ;Storing r1

    [isctr] STW     acc3,           *r++

    [isctr]SUB     isctr,           01,     isctr



    [isctr] STW     acc4,           *r++                ;Storing r2

    [isctr] STW     acc5,           *r++

    [isctr]SUB     isctr,           01,     isctr



    [isctr] STW     acc6,           *r++                ;Storing r3

    [isctr] STW     acc7,           *r++

    [isctr]SUB     isctr,           01,     isctr

    [irctr] B       oloop

            .return
            .endproc
* ======================================================================== *
*  End of file: DSPF_dp_fir_gen.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_fir_r2./1117057380  812   0     0       7457      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_r2(                                                    *
*                      const double * restrict x,                           *
*                      const double * restrict h,                           *
*                      double      * restrict r,                            *
*                      int   nh,                                            *
*                      int   nr                                             *
*                      )                                                    *
*             x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           *
*             h[nh]     : Pointer to coefficient array of size nh.          *
*                         (in reverse order).                               *
*             r[nr]     : Pointer to output array of size nr.               *
*             nh        : Number of coefficients                            *
*             nr        : Number of output samples.                         *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        Computes a real FIR filter (direct-form) using coefficients        *
*        stored in vector h[]. The real data input is stored in vector      *
*        x[]. The filter output result is stored in vector r[]. The         *
*        filter calculates nr output samples using nh coefficients.         *
*        The coefficients are expected to be in reverse order.              *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_fir_r2
_DSPF_dp_fir_r2   .cproc  x, h, r, nh, nr

            .reg   xa1:xa0, xa3:xa2, xa5:xa4, xb1:xb0, xb3:xb2
            .reg   pa1:pa0, pa3:pa2, pa5:pa4, pa7:pa6
            .reg   acc1:acc0, acc3:acc2, acc5:acc4, acc7:acc6
            .reg   xptr, hptr, ictr, octr,irctr, temp1, temp2
            .no_mdep


            MV      x,      temp1
            MV      nr,     octr                ;Set the OuterLoop Counter

            ;Outerloop Unrolled 4 times

oloop:      .trip   1

            MV      temp1,  xptr                ;Set Pointer for x[i+j]
            MV      h,      hptr                ;Set Pointer for h[j]
            MV      nh,     ictr                ;Set InnerLoop Counter
            ZERO    acc0                        ;Clear the accumulators
            ZERO    acc1
            ZERO    acc2
            ZERO    acc3
            ZERO    acc4
            ZERO    acc5
            ZERO    acc6
            ZERO    acc7

            ;Innerloop Unrolled two times

iloop:      .trip   2

            LDDW    *xptr++[01],    xa1:xa0             ;load x[0]
            LDDW    *hptr++[01],    xb1:xb0             ;load h[j]
            LDDW    *xptr++[01],    xa3:xa2             ;load x[1]
            LDDW    *hptr++[01],    xb3:xb2             ;load h[j+1]
            LDDW    *xptr,          xa5:xa4             ;load x[2]
            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;P11=x[0]*h[0]
            LDDW    *+xptr[01],     xa1:xa0             ;load x[3]

            MPYDP   xb1:xb0,        xa3:xa2,    pa3:pa2 ;P12=x[1]*h[0]

            MPYDP   xa5:xa4,        xb1:xb0,    pa5:pa4 ;P13=x[2]*h[0]

            MPYDP   xb1:xb0,        xa1:xa0,    pa7:pa6 ;P14=x[3]*h[0]

            ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0;S1+=P11

            ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2;S2+=P12

            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4;S3+=P13

            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6;S4+=P14

            MPYDP   xa3:xa2,        xb3:xb2,    pa1:pa0 ;P21=x[1]*h[1]

            LDDW    *+xptr[02],     xa3:xa2             ;load x[4]

            MPYDP   xb3:xb2,        xa5:xa4,    pa3:pa2 ;P22=x[2]*h[1]

            MPYDP   xa1:xa0,        xb3:xb2,    pa5:pa4 ;P23=x[3]*h[1]

            MPYDP   xb3:xb2,        xa3:xa2,    pa7:pa6 ;P24=x[4]*h[1]

            ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0;S1+=P21

            ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2;S2+=P22

            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4;S3+=P23

            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6;S4+=P24

            SUB     ictr,           2,          ictr    ;Decrement inner Loop Counter

    [ictr]  B       iloop

            ADDAD   temp1,          04,     temp1       ;Update pointer of x[i+j]


            SUB     octr,           04,     octr        ;Decrement OuterloopCounter

            CMPGT   octr,           0,      irctr

            STW     acc0,           *r++                ;Storing r0

            STW     acc1,           *r++

    [!irctr]ADD     octr,           02,     octr

            STW     acc2,           *r++                ;Storing r1

            STW     acc3,           *r++

    [octr]  STW     acc4,           *r++                ;Storing r2(Only if nr is Multiple of 4 in Last iteration)

    [octr]  STW     acc5,           *r++

    [octr]  STW     acc6,           *r++                ;Storing r3(Only if nr is Multiple of 4 in Last iteration)

    [octr]  STW     acc7,           *r++



    [irctr]  B      oloop

            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_fir_r2.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_fircirc/1117057381  831   0     0       9248      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      30-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          *
*                      int csize, int nh, int nr)                           *
*                                                                           *
*             x[]     :     Input array (circular buffer of 2^(csize+1)     *
*                           bytes)                                          *
*                           Must be aligned at 2^(csize+1) byte boundary    *
*             h[nh]   :     Filter coefficients array                       *
*                           Must be double-word aligned                     *
*             r[nr]   :     Output array                                    *
*             index   :     Offset by which to start reading from the       *
*                           input array. Must be multiple of 2              *
*             csize   :     Size of circular buffer x[] is 2^(csize+1)      *
*                           bytes. Must be 2 <= csize <= 31.                *
*             nh      :     Number of filter coefficients                   *
*                           Must be multiple of 2 and >= 4                  *
*             nr      :     Size of output array                            *
*                           Must be multiple of 4                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This routine implements a circularly addressed FIR filter.            *
*     'nh' is the number of filter coefficients. 'nr' is the number         *
*     of the output samples.                                                *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_fircirc
_DSPF_dp_fircirc   .cproc  x, h, r, index, csize, nh, nr

            .reg   xa1:xa0, xa3:xa2, xa5:xa4, xb1:xb0, xb3:xb2
            .reg   pa1:pa0, pa3:pa2, pa5:pa4, pa7:pa6, xa7:xa6, xa9:xa8
            .reg   acc1:acc0, acc3:acc2, acc5:acc4, acc7:acc6
            .reg   xptr, hptr, ictr, octr,csizet,temp, index_save
            .reg   add0,add1,add2,add3,add4
            .no_mdep

                       ; save the value of index
               MV     index, index_save

               ; set the shift register for the ext instruction
               MVK    34,    temp
               SUB    temp, csize, csize
               SHL    csize, 5, csizet
               OR     csize, csizet, csize

               ; store the h pointer
               MV     h, hptr

               ; init the outer loop counter
               MV     nr, octr

               ; make a copy of ptr
               MV     x, xptr



oloop:
               ; initialize the sums
               ZERO           acc0
               ZERO           acc1
               ZERO           acc2
               ZERO           acc3
               ZERO           acc4
               ZERO           acc5
               ZERO           acc6
               ZERO           acc7

               ; preserve the index value
               MV             index_save, index

               ; extract the lower csize-1 bits
               EXTU           index, csize, add0

               ; load x0
               LDDW            *xptr[add0], xa1:xa0

               ; incr index
               ADD            index, 1, index

               ; extract the lower csize-1 bits
               EXTU           index, csize, add1

               ; load x1
               LDDW            *xptr[add1], xa3:xa2

               ; incr index
               ADD            index, 1, index

               ; extract the lower csize-1 bits
               EXTU           index, csize, add2

               ; load x2
               LDDW            *xptr[add2], xa5:xa4

               ; incr index
               ADD            index, 1, index

               ; init inner loop cntr
               MV             nh, ictr

iloop:
               ; extract the lower csize-1 bits
               EXTU           index, csize, add3

               ; load x3
               LDDW            *xptr[add3], xa7:xa6

               ; incr index
               ADD            index, 1, index

               ; extract the lower csize-1 bits and load

               EXTU           index, csize, add4
               LDDW           *xptr[add4], xa9:xa8
               ADD            index, 1, index


               LDDW           *hptr++, xb1:xb0
               LDDW           *hptr++, xb3:xb2

               ; find all products  k=(i+j+index)% mod  ; mod = 2^(csize -2)

               MPYDP          xa1:xa0,      xb1:xb0,    pa1:pa0     ;P11=x[k]*h[0]
               MPYDP          xb1:xb0,      xa3:xa2,    pa3:pa2     ;P12=x[k+1]*h[0]
               MPYDP          xa5:xa4,      xb1:xb0,    pa5:pa4     ;P13=x[k+2]*h[0]
               MPYDP          xb1:xb0,      xa7:xa6,    pa7:pa6     ;P14=x[k+3]*h[0]
               ADDDP          acc1:acc0,    pa1:pa0,    acc1:acc0   ;S1+=P11
               ADDDP          acc3:acc2,    pa3:pa2,    acc3:acc2   ;S2+=P12
               ADDDP          acc5:acc4,    pa5:pa4,    acc5:acc4   ;S3+=P13
               ADDDP          acc7:acc6,    pa7:pa6,    acc7:acc6   ;S4+=P14
               MPYDP          xa3:xa2,      xb3:xb2,    pa1:pa0     ;P21=x[k+1]*h[1]
               MPYDP          xb3:xb2,      xa5:xa4,    pa3:pa2     ;P22=x[k+2]*h[1]
               MPYDP          xa7:xa6,      xb3:xb2,    pa5:pa4     ;P23=x[k+3]*h[1]
               MPYDP          xb3:xb2,      xa9:xa8,    pa7:pa6     ;P24=x[k+4]*h[1]
               ADDDP          acc1:acc0,    pa1:pa0,    acc1:acc0   ;S1+=P21
               ADDDP          acc3:acc2,    pa3:pa2,    acc3:acc2   ;S2+=P22
               ADDDP          acc5:acc4,    pa5:pa4,    acc5:acc4   ;S3+=P23
               ADDDP          acc7:acc6,    pa7:pa6,    acc7:acc6   ;S4+=P24


               ; update the states of the filter
               MV             xa4, xa0
               MV             xa5, xa1
               MV             xa6, xa2
               MV             xa7, xa3
               MV             xa8, xa4
               MV             xa9, xa5

               SUB            ictr, 2, ictr         ;Decrement innerloop Counter

         [ictr]B              iloop

*------------------------------------------------------------------------

               ; store all results
               STW            acc0, *r++
               STW            acc1, *r++
               STW            acc2, *r++
               STW            acc3, *r++
               STW            acc4, *r++
               STW            acc5, *r++
               STW            acc6, *r++
               STW            acc7, *r++



               ; restore the hpointer value
               MV             h,hptr
               ; incr index_save for next outer loop
               ADD            index_save, 4, index_save

               SUB            octr, 4, octr
        [octr] B              oloop

               .return
               .endproc

* ======================================================================== *
*  End of file: DSPF_dp_fircirc.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_biquad./1117057382  851   0     0       6158      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      03-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        *
*                    double *r, int nx)                                     *
*                                                                           *
*            x       :  Pointer to input samples                            *
*            b       :  Pointer to Nr coefs b0, b1, b2                      *
*            a       :  Pointer to Dr coefs a1, a2                          *
*            delay   :  Pointer to filter delays                            *
*            r       :  Pointer to output samples                           *
*            nx      :  Number of input/output samples                      *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*       This routine implements a DF 2 transposed structure of the biquad   *
*       filter. The transfer function of a biquad can be written            *
*       as:                                                                 *
*                                                                           *
*                                    b(0) + b(1)z^(-1) + b(2)z^(-2)         *
*                        H(Z) =     _________________________________       *
*                                     1 + a(1)z^(-1) + a(2)z^(-2)           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_biquad
_DSPF_dp_biquad   .cproc  x, b, a, delay, r, nx

            .reg   xa1:xa0, xa3:xa2, xa5:xa4, xa7:xa6, b0h:b0l
            .reg   xb1:xb0, xb3:xb2, xb5:xb4, xb7:xb6, b1h:b1l
            .reg   b2h:b2l, a1h:a1l, a2h:a2l, d0h:d0l, d1h:d1l
            .reg   a1bh:a1bl, a2bh:a2bl, xptr, rptr, ctr
            .no_mdep



        MV      x,              xptr                    ;Pointer for x
        MV      r,              rptr                    ;Pointer for r
        MV      nx,             ctr                     ;Set the loop counter
        LDDW    *b,             b0h:b0l                 ;b0
        LDDW    *+b[01],        b1h:b1l                 ;b1
        LDDW    *+b[02],        b2h:b2l                 ;b2
        LDDW    *a,             a1h:a1l                 ;a1
        LDDW    *+a[01],        a2h:a2l                 ;a2
        LDDW    *delay,         d0h:d0l                 ;d0
        LDDW    *+delay[01],    d1h:d1l                 ;d1
        MPYDP   a1h:a1l,        b0h:b0l,    a1bh:a1bl   ;a1*b0
        MPYDP   a2h:a2l,        b0h:b0l,    a2bh:a2bl   ;a2*b0

loop:   .trip   1

        LDDW    *xptr++[01],    xa1:xa0                 ;x[i]
        MPYDP   b1h:b1l,        xa1:xa0,    xa3:xa2     ;b1*x[i]
        MPYDP   a1bh:a1bl,      xa1:xa0,    xa5:xa4     ;a1*b0*x[i]
        SUBDP   xa3:xa2,        xa5:xa4,    xa3:xa2     ;b1*x[i]-a1*b0*x[i]
        ADDDP   xa3:xa2,        d1h:d1l,    xa3:xa2     ;+d1


        MPYDP   b2h:b2l,        xa1:xa0,    xb3:xb2     ;b2*x[i]
        MPYDP   a2bh:a2bl,      xa1:xa0,    xb5:xb4     ;a2*b0*x[i]
        SUBDP   xb3:xb2,        xb5:xb4,    xb3:xb2     ;b2*x[i]-a2*b0*x[i]

        MPYDP   b0h:b0l,        xa1:xa0,    xa5:xa4     ;b0*x[i]
        ADDDP   xa5:xa4,        d0h:d0l,    xa5:xa4     ;r[i]=b0*x[i]+d0

        STW     xa4,        *rptr++                     ;Store r[i]
        STW     xa5,        *rptr++

        MPYDP   a1h:a1l,        d0h:d0l,    xa7:xa6     ;a1*d0
        MPYDP   a2h:a2l,        d0h:d0l,    xb7:xb6     ;a2*d0

        SUBDP   xa3:xa2,        xa7:xa6,    d0h:d0l     ;d0=b1*x[i]-a1*b0*x[i]+d1-a1*d0
        SUBDP   xb3:xb2,        xb7:xb6,    d1h:d1l     ;d1=b2*x[i]-a2*b0*x[i]-a2*d0


        SUB     ctr,        01,         ctr             ;Decrement InnerloopCounter

  [ctr] B   loop

        STW     d0l,        *delay++                    ;Store Final delay[0]

        STW     d0h,        *delay++

        STW     d1l,        *delay++                    ;Store final delay[1]

        STW     d1h,        *delay++


        .return
        .endproc

* ======================================================================== *
*  End of file: DSPF_dp_biquad.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_iir.sa/ 1117057383  0     0     0       10321     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*    This routine is C callable, and has the following C prototype:         *
*                                                                           *
*       void DSPF_dp_iir    (double* restrict r1,                                *
*                       const double*    x,                                 *
*                       double* restrict r2,                                *
*                       const double*    h2,                                *
*                       const double*    h1,                                *
*                       int nr                                              *
*                      );                                                   *
*                                                                           *
*            r1[nr+4]   :  Delay element values (i/p and o/p)               *
*            x[nr]      :  Pointer to the input array                       *
*            r2[nr+4]   :  Pointer to the output array                      *
*            h2[5]      :  Auto-regressive filter coefficients              *
*            h1[5]      :  Moving average filter coefficients               *
*            nr         :  Number of output samples                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*     The IIR performs an auto-regressive moving-average (ARMA)             *
*     filter with 4 auto-regressive filter coefficients and 5               *
*     moving-average filter coefficients for nr output samples.             *
*     The output vector is stored in two locations. This routine            *
*     is used as a high pass filter in the VSELP vocoder. The               *
*     4 values in the r1 vector store the initial values of the             *
*     delays.                                                               *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the Assembly Code without                   *
*   restrictions.                                                           *
*                                                                           *
*   Note that the assembly code is hand optimized and restrictions          *
*   may apply.                                                              *
*                                                                           *
*   void DSPF_dp_iir (double* restrict r1,                                       *
*                const double*    x,                                        *
*                double* restrict r2,                                       *
*                const double*    h2,                                       *
*                const double*    h1,                                       *
*                int nr                                                     *
*                )                                                          *
*    {                                                                      *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*          sum = h2[0] * x[4+i];                                            *
*          for (j = 1; j <= 4; j++)                                         *
*             sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];                  *
*                                                                           *
*          r1[4+i] = sum;                                                   *
*          r2[i] = r1[4+i];                                                 *
*       }                                                                   *
*   }                                                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_iir
_DSPF_dp_iir   .cproc  r1, x, r2, h2, h1, nr

            .reg   xa1:xa0, xa3:xa2, xb1:xb0, xb3:xb2, xa5:xa4
            .reg   pa1:pa0, pa3:pa2, sa1:sa0, sa3:sa2, xb5:xb4
            .reg   r1ptr, r2ptr, h1ptr, h2ptr, xptr, ctr, temp
            .no_mdep


            LDDW    *h2,    xb1:xb0             ;load h2[0]

            MV      r1,     r1ptr               ;Pointer for r1

            MV      x,      xptr                ;Pointer for x

            ADDAD   h2,     04,     temp        ;Set Pointer to h2[4+i]

            MV      temp,   h2ptr

            ADDAD   h1,     04,     h1ptr       ;Set Pointer to h1[4+i]

            MV      nr,     ctr                 ;Set the loop Counter

loop:       .trip   1

            LDDW    *+xptr[04],     xa1:xa0                 ;load x[4+i]

            MPYDP   xa1:xa0,        xb1:xb0,        sa1:sa0 ;h2[0]*x[4+i]

            LDDW    *h2ptr--[01],   xb3:xb2                 ;load h2[4]

            LDDW    *xptr++[01],    xa3:xa2                 ;load x[i]

            MPYDP   xa3:xa2,        xb3:xb2,        pa1:pa0 ;h2[4]*x[i]

            ADDDP   sa1:sa0,        pa1:pa0,        sa1:sa0 ;S1+=P1

            LDDW    *h1ptr--[01],   xb5:xb4                 ;load h1[4]

            LDDW    *r1ptr++[01],   xa5:xa4                 ;load r1[i]

            MPYDP   xa5:xa4,        xb5:xb4,        sa3:sa2 ;h2[4]*x[i]

            LDDW    *h2ptr--[01],   xb3:xb2                 ;load h2[3]

            LDDW    *xptr++[01],    xa3:xa2                 ;load x[1+i]

            MPYDP   xa3:xa2,        xb3:xb2,        pa1:pa0 ;h2[3]*x[1+i]

            ADDDP   sa1:sa0,        pa1:pa0,        sa1:sa0 ;S1+=P1

            LDDW    *h1ptr--[01],   xb5:xb4                 ;load h1[3]

            LDDW    *r1ptr++[01],   xa5:xa4                 ;load r1[1+i]

            MPYDP   xa5:xa4,        xb5:xb4,        pa3:pa2 ;h1[3]*r1[1+i]

            ADDDP   sa3:sa2,        pa3:pa2,        sa3:sa2 ;S2+=P2

            LDDW    *h2ptr--[01],   xb3:xb2                 ;load h2[2]

            LDDW    *xptr++[01],    xa3:xa2                 ;load x[2+i]

            MPYDP   xa3:xa2,        xb3:xb2,        pa1:pa0 ;h2[2]*x[2+i]

            ADDDP   sa1:sa0,        pa1:pa0,        sa1:sa0 ;S1+=P1

            LDDW    *h1ptr--[01],   xb5:xb4                 ;load h1[2]

            LDDW    *r1ptr++[01],   xa5:xa4                 ;load r1[2+i]

            MPYDP   xa5:xa4,        xb5:xb4,        pa3:pa2 ;h1[2]*r1[2+i]

            ADDDP   sa3:sa2,        pa3:pa2,        sa3:sa2 ;S2+=P2

            LDDW    *h2ptr--[01],   xb3:xb2                 ;load h2[1]

            LDDW    *xptr++[01],    xa3:xa2                 ;load x[3+i]

            MPYDP   xa3:xa2,        xb3:xb2,        pa1:pa0 ;h2[1]*x[3+i]

            ADDDP   sa1:sa0,        pa1:pa0,        sa1:sa0 ;S1+=P1

            LDDW    *h1ptr--[01],   xb5:xb4                 ;load h1[1]

            LDDW    *r1ptr++[01],   xa5:xa4                 ;load r1[3+i]

            MPYDP   xa5:xa4,        xb5:xb4,        pa3:pa2 ;h1[1]*r1[3+i]

            ADDDP   sa3:sa2,        pa3:pa2,        sa3:sa2 ;S2+=P2

            SUBDP   sa1:sa0,        sa3:sa2,        sa1:sa0 ;sum=S1-S2

            STW     sa0,            *r1ptr                  ;store r1[4+i]

            STW     sa1,            *+r1ptr[01]             ;store r1[4+i]

            STW     sa0,            *r2++                   ;store r1[4+i]

            STW     sa1,            *r2++                   ;store r1[4+i]

            ADDAD   h2ptr,          04,         h2ptr       ;set Pointer for h2

            SUBAW   xptr,           06,         xptr        ;Set Pointer for x

            ADDAD   h1ptr,          04,         h1ptr       ;set Pointer for h1

            SUBAW   r1ptr,          06,         r1ptr       ;Set Pointer for r1

    [ctr]   SUB     ctr,            1,          ctr         ;Decrement the loop Counter

    [ctr]   B       loop


            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_iir.sa                                                  *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_iirlat./1117057384  870   0     0       10678     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*         This routine has following C prototype:                           *
*                                                                           *
*             void DSPF_dp_iirlat(                                               *
*                           double *x,                                      *
*                           int nx,                                         *
*                           const double * restrict k,                      *
*                           int nk,                                         *
*                           double * restrict b,                            *
*                           double * r                                      *
*                           )                                               *
*          x[nx]   : Input vector                                           *
*          nx      : Length of input vector.                                *
*          k[nk]   : Reflection coefficients                                *
*          nk      : Number of reflection coefficients/lattice stages       *
*                    Must be multiple of 2 and >=6.                         *
*          b[nk+1] : Delay line elements from previous call. Should be      *
*                    initialized to all zeros prior to the first call.      *
*          r[nx]   : Output vector                                          *
*                                                                           *
*      DESCRIPTION                                                          *
*                                                                           *
*          This routine implements a real all-pole IIR filter in lattice    *
*      structure (AR lattice). The filter consists of nk lattice stages.    *
*      Each  stage  requires one  reflection coefficient  k and one delay   *
*      element b. The routine takes an input vector x[] and returns the     *
*      filter output in r[]. Prior to the first call of the outine the      *
*      delay elements in b[]  should be set to zero. The input data may     *
*      have to be pre-scaled to avoid overflow or achieve better SNR. The   *
*      reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     *
*      order of the coefficients is such that k[nk-1] corresponds to the    *
*      first lattice stage after the input and k[0] Corresponds to the      *
*      last stage.                                                          *
*                                                                           *
*     ASSUMPTIONS                                                           *
*                                                                           *
*         1. nk is a multiple of 4.                                         *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    void DSPF_dp_iirlat(double * x, int nx, const double * restrict k, int nk,  *
*                    double * restrict b, double * r)                       *
*    {                                                                      *
*                                                                           *
*       double rt;     // output       //                                   *
*       int i, j;                                                           *
*                                                                           *
*       for (j = 0; j < nx; j++)                                            *
*       {                                                                   *
*          rt = x[j];                                                       *
*                                                                           *
*          for (i = nk - 1; i >= 0; i--)                                    *
*          {                                                                *
*              rt = rt - b[i] * k[i];                                       *
*              b[i + 1] = b[i] + rt * k[i];                                 *
*          }                                                                *
*                                                                           *
*          b[0] = rt;                                                       *
*          r[j] = rt;                                                       *
*       }                                                                   *
*     }                                                                     *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_iirlat
_DSPF_dp_iirlat   .cproc  x, nx, k, nk, b, r

        .reg   xa1:xa0, xa3:xa2, xb1:xb0, xb3:xb2
            .reg   pa1:pa0, pa3:pa2, sa1:sa0, rth:rtl
            .reg   bptr, kptr, rptr, temp1, temp2
            .reg   xptr, ictr, octr, tctr
            .no_mdep


            ADDAD       k,      nk,     temp1

            ADDAD       b,      nk,     temp2

            MV          nx,     octr                ;Set OuterloopCounter

            MV          x,      xptr                ;Pointer for x[i]

            MV          r,      rptr                ;Pointer for r[i]

oloop:      .trip   1

            MV      temp1,      kptr                ;Pointer for k[i]

            MV      temp2,      bptr                ;Pointer for h[i]

            MV      nk,         ictr                ;Set Inner loop Counter

            LDDW    *xptr++,    rth:rtl             ;Load rt

            ;Innerloop Unrolled 4 times

iloop:      .trip   2

    [ictr]  SUB     ictr,           04,         ictr    ;Decrement Innerloop Counter

            LDDW    *--bptr[01],    xa1:xa0             ;load b[i]

            LDDW    *--kptr[01],    xb1:xb0             ;load k[i]

            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;b[i]*k[i]

            SUBDP   rth:rtl,        pa1:pa0,    rth:rtl ;rt-b[i]*k[i]

            MPYDP   rth:rtl,        xb1:xb0,    pa3:pa2 ;rt*k[i]

            ADDDP   xa1:xa0,        pa3:pa2,    sa1:sa0 ;b[i]+rt*k[i]

            STW     sa0,            *+bptr[02]          ;store b[i+1]

            STW     sa1,            *+bptr[03]          ;store b[i+1]

            LDDW    *--bptr[01],    xa1:xa0             ;load b[i-1]

            LDDW    *--kptr[01],    xb1:xb0             ;load k[i-1]

            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;b[i-1]*k[i-1]

            SUBDP   rth:rtl,        pa1:pa0,    rth:rtl ;rt-b[i-1]*k[i-1]

            MPYDP   rth:rtl,        xb1:xb0,    pa3:pa2 ;rt*k[i-1]

            ADDDP   xa1:xa0,        pa3:pa2,    sa1:sa0 ;b[i-1]+rt*k[i-1]

            STW     sa0,            *+bptr[02]          ;store b[i]

            STW     sa1,            *+bptr[03]          ;store b[i]

            CMPGT   ictr,           0,          tctr

    [!tctr] ADD     ictr,           2,          ictr    ;Check  nk Multiple of 4 or not

    [ictr]  LDDW    *--bptr[01],    xa1:xa0             ;load b[i-2]

    [ictr]  LDDW    *--kptr[01],    xb1:xb0             ;load k[i-2]

    [ictr]  MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;b[i-2]*k[i-2]

    [ictr]  SUBDP   rth:rtl,        pa1:pa0,    rth:rtl ;rt-b[i-2]*k[i-2]

    [ictr]  MPYDP   rth:rtl,        xb1:xb0,    pa3:pa2 ;rt*k[i-2]

    [ictr]  ADDDP   xa1:xa0,        pa3:pa2,    sa1:sa0 ;b[i-2]+rt*k[i-2]

    [ictr]  STW     sa0,            *+bptr[02]          ;store b[i-1]

    [ictr]  STW     sa1,            *+bptr[03]          ;store b[i-1]

    [ictr]  LDDW    *--bptr[01],    xa1:xa0             ;load b[i-3]

    [ictr]  LDDW    *--kptr[01],    xb1:xb0             ;load k[i-3]

    [ictr]  MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;b[i-3]*k[i-3]

    [ictr]  SUBDP   rth:rtl,        pa1:pa0,    rth:rtl ;rt-b[i-3]*k[i-3]

    [ictr]  MPYDP   rth:rtl,        xb1:xb0,    pa3:pa2 ;rt*k[i-3]

    [ictr]  ADDDP   xa1:xa0,        pa3:pa2,    sa1:sa0 ;b[i-3]+rt*k[i-3]

    [ictr]  STW     sa0,            *+bptr[02]          ;store b[i-2]

    [ictr]  STW     sa1,            *+bptr[03]          ;store b[i-2]

    [tctr]  B   iloop       ;innerloop Branch

            STW     rtl,            *bptr               ;store b[0]

            STW     rth,            *+bptr[01]          ;store b[0]

            STW     rtl,            *rptr++             ;store r[i]

            STW     rth,            *rptr++             ;store r[i]

            SUB     octr,           1,          octr    ;Decrement Outerloop Couter

    [octr]  B       oloop       ;Outerloop branch



            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_iirlat.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_convol./1117057385  889   0     0       12931     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_convol -- Double Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*     This routine has the following C prototype:                           *
*                                                                           *
*     void DSPF_dp_convol                                                        *
*          (                                                                *
*                double *x, //x: Pointer to input samples//                 *
*                double *h, //h: Pointer to impulse response samples//      *
*                double *r, //r: Pointer to output samples//                *
*                int   nh, //nh: Number of impulse response samples//       *
*                int   nr  //nr: Number of output samples//                 *
*          )                                                                *
*                                                                           *
*           x = pointer to real input vector of size = nr+nh-1              *
*           a typically contains input data (x) padded with                 *
*           consecutive nh - 1  zeros at the beginning and end.             *
*           h = pointer to real input vector of size nh in forward order.   *
*           h typically contains the filter coefs.                          *
*           r = Pointer to real output vector of size nr                    *
*           nh= Number of elements in vector b. NOTE: nh <= nr  nh is       *
*           typically noted as m in convol formulas. nh must be a           *
*           MULTIPLE of 2                                                   *
*           nr= Number of elements in vector r. nr must be a MULTIPLE of 4  *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*           This function calculates the full-length convolution of real    *
*           vectors x and h using time-domain techniques. The result is     *
*           placed in real vector r.                                        *
*                                                                           *
*           It is assumed that input vector x is padded with nh-1 no of     *
*           zeros in the beginning and end.                                 *
*                                                                           *
*           It is assumed that the length of the input vector h, nh, is a   *
*           multiple of 2 and the length of the output vector r, nr, is a   *
*           multiple of 4. nh is greater than or equal to 4 and nr is       *
*           greater than or equal to nh. The routine computes 4 output      *
*           samples at a time.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*           1. The inner loop is unrolled twice and the outer loop is       *
*              unrolled four times.                                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*           1. nh is a multiple of 2 and greater than or equal to 4         *
*           2. nr is a multiple of 4                                        *
*                                                                           *
*   C CODE                                                                  *
*           This is the C equivalent of the assembly code.  Note that       *
*           the assembly code is hand optimized and restrictions may        *
*           apply.                                                          *
*                                                                           *
*                                                                           *
*           void DSPF_dp_convol(double *x, double *h, double *r, short nh,       *
*                          short nr)                                        *
*           {                                                               *
*             short   octr, ictr;                                           *
*             double  acc ;                                                 *
*                                                                           *
*             for (octr = nr ; octr > 0 ; octr--)                           *
*             {                                                             *
*               acc = 0 ;                                                   *
*                                                                           *
*               for (ictr = nh ; ictr > 0 ; ictr--)                         *
*               {                                                           *
*              acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       *
*               }                                                           *
*               r[nr-octr] = acc;                                           *
*             }                                                             *
*           }                                                               *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*           1. Endian: This code is LITTLE ENDIAN.                          *
*           2. Interruptibility: This code is interrupt tolerant but not    *
*                        interruptible.                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*           2*(nh*nr) + 5/2*nr + 32                                         *
*           For nh=24 and nr=48, cycles=2456                                *
*           For nh=20 and nr=32, cycles=1392                                *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*           544 bytes                                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_convol
_DSPF_dp_convol   .cproc  x, h, r, nh, nr

            .reg   xa1:xa0, xa3:xa2, xa5:xa4, xb1:xb0, xb3:xb2
            .reg   pa1:pa0, pa3:pa2, pa5:pa4, pa7:pa6
            .reg   acc1:acc0, acc3:acc2, acc5:acc4, acc7:acc6
            .reg   xptr, hptr, ictr, octr, temp
            .no_mdep

            MV      x,      temp
            MV      nr,     octr                                ; Set outerloop Counter

            ; OuterLoop Unrolled 4 Times

oloop:      .trip   1

            ZERO    acc0                                        ; Zero the accumulator
            ZERO    acc1                                        ; Zero the accumulator
            ZERO    acc2                                        ; Zero the accumulator
            ZERO    acc3                                        ; Zero the accumulator
            ZERO    acc4                                        ; Zero the accumulator
            ZERO    acc5                                        ; Zero the accumulator
            ZERO    acc6                                        ; Zero the accumulator
            ZERO    acc7                                        ; Zero the accumulator
            MV      nh,     ictr                                ; Set innerloop Counter
            MV      temp,   xptr                                ; Set Pointer for array x
            ADDAD   h,      nh,     hptr                        ; Set Pointer for array h
            ; Innerloop Unrolled 2 Times

iloop:      .trip   2

            LDDW    *xptr++[01],    xa1:xa0                     ; Load  x[0]
            LDDW    *--hptr[01],    xb1:xb0                     ; Load  h[nh-1]

            MPYDP   xa1:xa0,        xb1:xb0,        pa1:pa0     ; P11 =x[0]*h[n-1]
            ADDDP   acc1:acc0,      pa1:pa0,        acc1:acc0   ; S1+=P11

            LDDW    *xptr++[01],    xa3:xa2                     ; Load  x[1]
            LDDW    *--hptr[01],    xb3:xb2                     ; Load  h[nh-2]

            MPYDP   xa3:xa2,        xb1:xb0,        pa3:pa2     ; P12 =x[1]*h[n-1]
            ADDDP   acc3:acc2,      pa3:pa2,        acc3:acc2   ; S2+=P12

            LDDW    *xptr,          xa5:xa4                     ; Load  x[2]

            MPYDP   xa5:xa4,        xb1:xb0,        pa5:pa4     ; P13 =x[2]*h[n-1]
            ADDDP   acc5:acc4,      pa5:pa4,        acc5:acc4   ; S3+=P13

            LDDW    *+xptr[01],     xa1:xa0                     ; Load  x[2]

            MPYDP   xa1:xa0,        xb1:xb0,        pa7:pa6     ; P14 =x[3]*h[n-1]
            ADDDP   acc7:acc6,      pa7:pa6,        acc7:acc6   ; S4+=P14

            MPYDP   xa3:xa2,        xb3:xb2,        pa1:pa0     ; P21 =x[1]*h[n-2]
            ADDDP   acc1:acc0,      pa1:pa0,        acc1:acc0   ; S1+=P21

            LDDW    *+xptr[02],     xa3:xa2                     ; Load  x[4]

            MPYDP   xa5:xa4,        xb3:xb2,        pa3:pa2     ; P22 =x[2]*h[n-2]
            ADDDP   acc3:acc2,      pa3:pa2,        acc3:acc2   ; S2+=P22

            MPYDP   xa1:xa0,        xb3:xb2,        pa5:pa4     ; P23 =x[3]*h[n-2]
            ADDDP   acc5:acc4,      pa5:pa4,        acc5:acc4   ; S3+=P23

            MPYDP   xa3:xa2,        xb3:xb2,        pa7:pa6     ; P24 =x[3]*h[n-1]
            ADDDP   acc7:acc6,      pa7:pa6,        acc7:acc6   ; S4+=P24

    [ictr]  SUB     ictr,           02,             ictr        ;Decrement innerloop Counter

    [ictr]  B       iloop


            STW     acc0,           *r++                        ; Storing S1
            STW     acc1,           *r++

            STW     acc2,           *r++                        ; Storing S2
            STW     acc3,           *r++

            STW     acc4,           *r++                        ; Storing S3
            STW     acc5,           *r++

            STW     acc6,           *r++                        ; Storing S4
            STW     acc7,           *r++

            ADDAD   temp,           4,              temp        ; Set pointer for x

            SUB     octr,           04,             octr        ; Decrement Outerloop Counter

    [octr]  B       oloop

            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_convol.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_dotp_sq/1117057386  908   0     0       8393      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_dotp_sqr(                                                *
*                        double G,                                          *
*                        const double * x,                                  *
*                        const double * y,                                  *
*                        double *  restrict r,                              *
*                        int   nx                                           *
*                        )                                                  *
*             G:      Sum of y-squared initial value.                       *
*             x[nx]:  Pointer to First input array.                         *
*             y[nx]:  Pointer to Second input array.                        *
*             r:      Pointer to Output for Accumulation of x[]*y[].        *
*             nx:     Length of input vectors.                              *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine computes the dot product of x[] and y[] arrays,       *
*    adding it to the value in the location pointed to by r.                *
*    Additionally, it computes the sum of the squares of the terms          *
*    in the y array,adding it to the argument G. The final value of         *
*    G is given as the return value of the function.                        *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*      1. Multiple Assignment was used to reduce loop carry path.           *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*      1. There are no special alignment requirements.                      *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    *
*                         double *restrict r, int nx)                       *
*       {                                                                   *
*                                                                           *
*          int i;                                                           *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          {                                                                *
*                *r += x[i] * y[i];     /* Compute Dot Product */           *
*                G += y[i] * y[i];      /* Compute Square  */               *
*          }                                                                *
*                                                                           *
*          return G;                                                        *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*         1. Endian : This code is LITTLE ENDIAN .                          *
*         2. Interruptibility: This code is interrupt-tolerant but not      *
*                              interruptible.                               *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*       4*nx + 26                                                           *
*                                                                           *
*        For nx=64, cycles=282.                                             *
*        For nx=30, cycles=146.                                             *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*       244 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_dotp_sqr
_DSPF_dp_dotp_sqr   .cproc  Gh:Gl, x, y, r, nx
                    .reg   xa1:xa0, xb1:xb0, pa1:pa0, pa3:pa2, rh:rl
                    .reg   xptr, yptr, ctr
                    .no_mdep


            MV      x,      xptr                        ;Pointer for x

            MV      y,      yptr                        ;Pointer for y

            MV      nx,     ctr                         ;Set the loop Counter

            LDDW    *r,     rh:rl                       ;Load *r

loop:
            LDDW    *xptr++[01],    xa1:xa0             ;Load x[i]

            LDDW    *yptr++[01],    xb1:xb0             ;Load y[i]

            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;x[i]*y[i]

            MPYDP   xb1:xb0,        xb1:xb0,    pa3:pa2 ;y[i]*y[i]

            ADDDP   rh:rl,          pa1:pa0,    rh:rl   ;*r+=x[i]*y[i]

            ADDDP   Gh:Gl,          pa3:pa2,    Gh:Gl   ;G+=y[i]*y[i]

            SUB     ctr,            1,          ctr     ;Decrement loop Counter

    [ctr]   B       loop

            STW     rl,             *r                  ;Store *r

            STW     rh,             *+r[01]             ;Store *r

            .return Gh:Gl
             .endproc

* ======================================================================== *
*  End of file: DSPF_dp_dotp_sqr.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_dotprod/1117057387  929   0     0       5592      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                  *
*                                                                          *
*     This routine is C Callable and can be called as:                     *
*                                                                          *
*       double DSPF_dp_dotprod(const double *x, const double *y, const int nx); *
*                                                                          *
*       x     : Pointer to array holding the first floating point vector   *
*       y     : Pointer to array holding the second floating point vector  *
*       nx    : Number of values in the x & y vectors                      *
*                                                                          *
*                                                                          *
*   DESCRIPTION                                                            *
*                                                                          *
*       This routine calculates the dot product of 2 Double precision      *
*   float vectors.                                                         *
*                                                                          *
*   C CODE                                                                 *
*       This is the C equivalent for the assembly code.  Note that         *
*       the assembly code is hand optimized and restrictions may           *
*       apply.                                                             *
*                                                                          *
*       double DSPF_dp_dotprod(const double *x, const double *y, const int nx)  *
*       {                                                                  *
*          int i;                                                          *
*          double sum = 0;                                                 *
*                                                                          *
*          for (i=0; i < nx; i++)                                          *
*          {                                                               *
*             sum += x[i] * y[i];                                          *
*          }                                                               *
*          return sum;                                                     *
*       }                                                                  *
*                                                                          *
* ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.          *
*                            All Rights Reserved.                          *
* ======================================================================== *


        .text
        .global _DSPF_dp_dotprod
_DSPF_dp_dotprod   .cproc  x, y, nx
            .reg    xa1:xa0, xb1:xb0, pa1:pa0, sa1:sa0
            .reg    xptr, yptr, ctr
            .no_mdep

            MV      x,      xptr                        ;Pointer for x
            MV      y,      yptr                        ;Pointer for y
            MV      nx,     ctr                         ;Set the loop Counter
            ZERO    sa0                                 ;Clear the Accumulator
            ZERO    sa1                                 ;Clear the Accumulator

loop:
            LDDW    *xptr++[01],    xa1:xa0             ;Load x[i]
            LDDW    *yptr++[01],    xb1:xb0             ;Load y[i]
            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;x[i]*y[i]
            ADDDP   sa1:sa0,        pa1:pa0,    sa1:sa0 ;sum+=x[i]*y[i]

    [ctr]   SUB     ctr,            1,          ctr     ;Decrement loop Counter

    [ctr]   LDDW    *xptr++[01],    xa1:xa0             ;Load x[i+1]
    [ctr]   LDDW    *yptr++[01],    xb1:xb0             ;Load y[i+1]
    [ctr]   MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;x[i+1]*y[i+1]
    [ctr]   ADDDP   sa1:sa0,        pa1:pa0,    sa1:sa0 ;sum+=x[i+1]*y[i+1]


    [ctr]   SUB     ctr,            1,          ctr     ;Decrement loop Counter

    [ctr]   B       loop


            .return sa1:sa0  ;Return the SUM
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_dotprod.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_dotp_cp/1117057388  949   0     0       9126      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine is C Callable and can be called as:                      *
*                                                                           *
*       void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double * *
*                         restrict re, double * restrict im);               *
*                                                                           *
*       x     : Pointer to array holding the first floating point vector    *
*       y     : Pointer to array holding the second floating point vector   *
*       n     : Number of values in the x & y vectors                       *
*       re    : Pointer to the location storing the real                    *
*               part of the result.                                         *
*       im    : Pointer to the location storing the imaginary part of       *
*               the result                                                  *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*       This routine calculates the dot product of 2 Double   precision     *
*   complex float vectors. The even numbered locations hold the real parts  *
*   of the complex numbers while the odd numbered locations contain the     *
*   imaginary portions.                                                     *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*       1.  The value of nx must be  > 0.                                   *
*                                                                           *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_dotp_cplx(const double* x, const double* y, int n,          *
*                     double* restrict re, double* restrict im)             *
*       {                                                                   *
*                                                                           *
*           double real=0, imag=0;                                          *
*           int i=0;                                                        *
*                                                                           *
*           for(i=0; i<n; i++)                                              *
*           {                                                               *
*               real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  *
*               imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  *
*           }                                                               *
*                                                                           *
*           *re=real;                                                       *
*           *im=imag;                                                       *
*      }                                                                    *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*   1. Endian: This code is LITTLE ENDIAN.                                  *
*   2. Interruptibility: This code is interrupt tolerant but not            *
*      interruptible.                                                       *
*                                                                           *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      8*N + 29                                                             *
*      eg. for N = 128, cycles = 1053.                                      *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*      352 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_dotp_cplx
_DSPF_dp_dotp_cplx   .cproc  x, y, n, re, im

              .reg  xa1:xa0, xb1:xb0, xa3:xa2, xb3:xb2
              .reg  pa1:pa0, sa1:sa0,  sa3:sa2
              .reg  xptr, yptr, ctr
              .no_mdep

            MV      x,      xptr                        ;Pointer for x
            MV      y,      yptr                        ;Pointer for y
            MV      n,      ctr                         ;Set the loop Counter
            ZERO    sa0                                 ;Clear the Accumulator
            ZERO    sa1                                 ;Clear the Accumulator
            ZERO    sa2                                 ;Clear the Accumulator
            ZERO    sa3                                 ;Clear the Accumulator

loop:
            LDDW    *xptr++[01],    xa1:xa0             ;Load real of x[i]
            LDDW    *yptr++[01],    xb1:xb0             ;Load real of y[i]

            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0 ;re(x[i])*re(y[i])
            ADDDP   sa1:sa0,        pa1:pa0,    sa1:sa0 ;sum1+=re(x[i])*re(y[i])

            LDDW    *xptr++[01],    xa3:xa2             ;Load imag of x[i]
            LDDW    *yptr++[01],    xb3:xb2             ;Load imag of y[i]

            MPYDP   xa1:xa0,        xb3:xb2,    pa1:pa0 ;re(x[i])*im(y[i])
            ADDDP   sa3:sa2,        pa1:pa0,    sa3:sa2 ;sum2+=re(x[i])*im(y[i])

            MPYDP   xa3:xa2,        xb1:xb0,    pa1:pa0 ;im(x[i])*re(y[i])
            ADDDP   sa3:sa2,        pa1:pa0,    sa3:sa2 ;sum2+=im(x[i])*re(y[i])

            MPYDP   xa3:xa2,        xb3:xb2,    pa1:pa0 ;im(x[i])*im(y[i])
            SUBDP   sa1:sa0,        pa1:pa0,    sa1:sa0 ;sum1-=im(x[i])*im(y[i])

    [ctr]   SUB     ctr,            1,          ctr     ;Decrement loop Counter

    [ctr]   B       loop

            STW     sa0,        *re                     ;Store the realPart
            STW     sa1,        *+re[01]
            STW     sa2,        *im                     ;Store the imagPart
            STW     sa3,        *+im[01]


            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_dotp_cplx.sa                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_maxval./1117057389  971   0     0       7666      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxval -- Maximum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_maxval(                                                  *
*                        const double* x,                                   *
*                        int nx                                             *
*                       )                                                   *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the maximum number in the                   *
*    input array.This code returns the maximum value                        *
*    in the array.                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *




        .text
        .global _DSPF_dp_maxval
_DSPF_dp_maxval   .cproc  x, nx
            .reg    xa1:xa0, xb1:xb0, xa3:xa2, xb3:xb2
            .reg    xa5:xa4, xb5:xb4, ma1:ma0, mb1:mb0
            .reg    ma3:ma2, mb3:mb2, ma5:ma4, mb5:mb4
            .reg    xptr, xbptr, ctr, tctr, tflag, aflag, bflag, mask
            .no_mdep

            MV      x,      xptr                ;Pointer on A side
            ADD     x,      8,      xbptr       ;Pointer on B side
            MV      nx,     ctr                 ;
            MVKL    0x00000000,     ma0         ;Set ma1:ma0=-INF
            MVKH    0x00000000,     ma0
            MVKL    0xfff00000,     ma1         ;Set ma1:ma0=-INF
            MVKH    0xfff00000,     ma1
            MVKL    0x00000006,     mask        ;Set mask=6
            MVKH    0x00000006,     mask
            MV      ma0,            mb0         ;Set max2=-INF
            MV      ma1,            mb1
            MV      ma0,            ma2         ;Set max3=-INF
            MV      ma1,            ma3
            MV      mb0,            mb2         ;Set max4=-INF
            MV      mb1,            mb3
            MV      ma0,            ma4         ;Set max5=-INF
            MV      ma1,            ma5
            MV      mb0,            mb4         ;Set max6=-INF
            MV      mb1,            mb5
            SUB     ctr,            6,          ctr     ;Decreemnt loop Counter
            MV      mask,           tflag

loop:       .trip   1


            LDDW    *xptr++[02],    xa1:xa0             ;x1

            LDDW    *xbptr++[02],   xb1:xb0             ;x2

            CMPGTDP xa1:xa0,        ma1:ma0,    aflag   ;x1>max1

            CMPGTDP xb1:xb0,        mb1:mb0,    bflag   ;x2>max2

    [aflag] MV      xa0,            ma0                 ;max1=x1

    [aflag] MV      xa1,            ma1

    [bflag] MV      xb0,            mb0                 ;max2=x2

    [bflag] MV      xb1,            mb1

            CMPGT   ctr,            0,          tctr    ;

    [tctr]  SUB     ctr,            6,          ctr     ;Decrement the loop counter

    [!tctr] ADD     ctr,            4,          ctr

            LDDW    *xptr++[02],    xa3:xa2             ;x3

            LDDW    *xbptr++[02],   xb3:xb2             ;x4

            CMPGTDP xa3:xa2,        ma3:ma2,    aflag   ;x3>max3

            CMPGTDP xb3:xb2,        mb3:mb2,    bflag   ;x4>max4

    [!tctr] AND     mask,           ctr,        tflag

    [!tflag]ZERO    aflag

    [!tflag]ZERO    bflag

    [aflag] MV      xa2,            ma2                 ;max3=x3

    [aflag] MV      xa3,            ma3

    [bflag] MV      xb2,            mb2                 ;max4=x4

    [bflag] MV      xb3,            mb3

    [!tctr] OR      tctr,           ctr,        tflag

            LDDW    *xptr++[02],    xa5:xa4             ;x5

            LDDW    *xbptr++[02],   xb5:xb4             ;x6

            CMPGTDP xa5:xa4,        ma5:ma4,    aflag   ;x5>max5

            CMPGTDP xb5:xb4,        mb5:mb4,    bflag   ;x6>max6

    [!tflag]ZERO    aflag

    [!tflag]ZERO    bflag

    [aflag] MV      xa4,            ma4                 ;max5=x5

    [aflag] MV      xa5,            ma5

    [bflag] MV      xb4,            mb4                 ;max6=x6

    [bflag] MV      xb5,            mb5

    [tctr]  B       loop

            CMPGTDP ma1:ma0,        ma3:ma2,    aflag   ;max1>max3

            CMPGTDP mb1:mb0,        mb3:mb2,    bflag   ;max2>max4

    [aflag] MV      ma0,            ma2                 ;max(max1, max3)

    [aflag] MV      ma1,            ma3

    [bflag] MV      mb0,            mb2                 ;max(max2, max4)

    [bflag] MV      mb1,            mb3

            CMPGTDP ma3:ma2,        ma5:ma4,    aflag   ;max1, max3, max5

            CMPGTDP mb3:mb2,        mb5:mb4,    bflag   ;max2, max4, max6

    [aflag] MV      ma2,            ma4                 ;max(max1, max3, max5)

    [aflag] MV      ma3,            ma5

    [bflag] MV      mb2,            mb4                 ;max(max2, max4, max6)

    [bflag] MV      mb3,            mb5

            CMPGTDP ma5:ma4,        mb5:mb4,    aflag   ;max1, max3, max5, max2, max4, max6

    [aflag] MV      ma4,            mb4                 ;max(max1, max3, max5)

    [aflag] MV      ma5,            mb5


            .return mb5:mb4
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_maxval.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_maxidx./1117057389  990   0     0       6724      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      16-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        int DSPF_dp_maxidx(                                                     *
*                       const double* x,                                    *
*                       int nx                                              *
*                     )                                                     *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the index of maximum number in the input    *
*        array. This function returns the index of the greatest value.      *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled three times.                                *
*       2. Three maximums are maintained in each iteration.                 *
*       3. MPY instructions are  used for move.                             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 3.                                           *
*       2. nx >= 3, and nx <= 2^16-1.                                       *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_maxidx
_DSPF_dp_maxidx   .cproc  x, nx
            .reg    xa1:xa0, xb1:xb0, xa3:xa2
            .reg    ma1:ma0, mb1:mb0, ma3:ma2, result
            .reg    xptr, ctr, index, i1, i2, i3, aflag, bflag
            .no_mdep

            MV      x,      xptr                ;Pointer for x
            MV      nx,     ctr                 ;Set theloop Counter
            ZERO    index
            MVKL    0x00000000,     ma0         ;Set Initial Max=-INF
            MVKH    0x00000000,     ma0         ;Set Initial Max=-INF

            MVKL    0xFFF00000,     ma1         ;Set Initial Max=-INF
            MVKH    0xFFF00000,     ma1         ;Set Initial Max=-INF

            MV      ma0,        mb0
            MV      ma1,        mb1
            MV      ma0,        ma2
            MV      ma1,        ma3

            ;Unrolled three times

loop:       .trip   1

            LDDW        *xptr++[01],    xa1:xa0             ;load x1
            CMPGTDP     xa1:xa0,        ma1:ma0,    aflag   ;x1>max1
    [aflag] MV          xa0,            ma0                 ;max1=x1
    [aflag] MV          xa1,            ma1
    [aflag] MV          index,          i1                  ;m1idx=index

            LDDW        *xptr++[01],    xa3:xa2             ;load x2
            CMPGTDP     xa3:xa2,        ma3:ma2,    aflag   ;x2>max2
    [aflag] MV          xa2,            ma2                 ;max2=x2
    [aflag] MV          xa3,            ma3
    [aflag] MV          index,          i2                  ;m2idx=index

            LDDW        *xptr++[01],    xb1:xb0             ;load x3
            CMPGTDP     xb1:xb0,        mb1:mb0,    bflag   ;x3>max3
    [bflag] MV          xb0,            mb0                 ;max3=x3
    [bflag] MV          xb1,            mb1
    [bflag] MV          index,          i1                  ;m3idx=index

            ADD         index,          3,          index   ;index+=3
    [ctr]   SUB         ctr,            3,          ctr     ;Decrement loop Counter

    [ctr]   B       loop


            CMPLTDP     ma1:ma0,       ma3:ma2,      aflag   ; if max1 < max2

   [!aflag] CMPLTDP     ma1:ma0,       mb1:mb0,      bflag   ; if max1 < max3

    [aflag] CMPLTDP     ma3:ma2,       mb1:mb0,      bflag   ; if max2 < max3

    [bflag] ADD         i3,            2,            result  ; Here max3 is maximum
    [bflag] B       end                                      ; Branch out of function

   [!bflag] CMPLTDP     ma1:ma0,       ma3:ma2,      aflag   ; if max1 < max2

   [!aflag] MV          i1,            result                ; Here max1 is maximum

    [aflag] ADD         i2,             1,          result   ; Here max2 is maximum
end:

                .return result
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_maxidx.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_minval./1117057390  1009  0     0       7424      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_minval -- Minimum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_minval(                                                  *
*                        const double* x,                                   *
*                        int nx                                             *
*                       )                                                   *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out and returns the minimum number              *
*    in the input array.                                                    *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_minval
_DSPF_dp_minval   .cproc  x, nx
            .reg    xa1:xa0, xb1:xb0, xa3:xa2, xb3:xb2
            .reg    xa5:xa4, xb5:xb4, ma1:ma0, mb1:mb0
            .reg    ma3:ma2, mb3:mb2, ma5:ma4, mb5:mb4
            .reg    xptr, xbptr, ctr, tctr, tflag, aflag, bflag, mask
            .no_mdep

            MV      x,      xptr                ;Pointer on A side
            ADD     x,      8,      xbptr       ;Pointer on B side
            MV      nx,     ctr                 ;
            MVKL    0x00000000,     ma0         ;Set ma1:ma0=+INF
            MVKH    0x00000000,     ma0
            MVKL    0x7ff00000,     ma1         ;Set ma1:ma0=+INF
            MVKH    0x7ff00000,     ma1
            MVKL    0x00000006,     mask        ;Set mask=6
            MVKH    0x00000006,     mask
            MV      ma0,            mb0         ;Set min2=+INF
            MV      ma1,            mb1
            MV      ma0,            ma2         ;Set min3=+INF
            MV      ma1,            ma3
            MV      mb0,            mb2         ;Set min4=+INF
            MV      mb1,            mb3
            MV      ma0,            ma4         ;Set min5=+INF
            MV      ma1,            ma5
            MV      mb0,            mb4         ;Set min6=+INF
            MV      mb1,            mb5
            SUB     ctr,            6,          ctr     ;Decreemnt loop Counter
            MV      mask,           tflag

loop:       .trip   1


            LDDW    *xptr++[02],    xa1:xa0             ;x1

            LDDW    *xbptr++[02],   xb1:xb0             ;x2

            CMPLTDP xa1:xa0,        ma1:ma0,    aflag   ;x1<min1

            CMPLTDP xb1:xb0,        mb1:mb0,    bflag   ;x2<min2

    [aflag] MV      xa0,            ma0                 ;min1=x1

    [aflag] MV      xa1,            ma1

    [bflag] MV      xb0,            mb0                 ;min2=x2

    [bflag] MV      xb1,            mb1

            CMPGT   ctr,            0,          tctr    ;

    [tctr]  SUB     ctr,            6,          ctr     ;Decrement the loop counter

    [!tctr] ADD     ctr,            4,          ctr

            LDDW    *xptr++[02],    xa3:xa2             ;x3

            LDDW    *xbptr++[02],   xb3:xb2             ;x4

            CMPLTDP xa3:xa2,        ma3:ma2,    aflag   ;x3<min3

            CMPLTDP xb3:xb2,        mb3:mb2,    bflag   ;x4<min4

    [!tctr] AND     mask,           ctr,        tflag

    [!tflag]ZERO    aflag

    [!tflag]ZERO    bflag

    [aflag] MV      xa2,            ma2                 ;min3=x3

    [aflag] MV      xa3,            ma3

    [bflag] MV      xb2,            mb2                 ;min4=x4

    [bflag] MV      xb3,            mb3

    [!tctr] OR      tctr,           ctr,        tflag

            LDDW    *xptr++[02],    xa5:xa4             ;x5

            LDDW    *xbptr++[02],   xb5:xb4             ;x6

            CMPLTDP xa5:xa4,        ma5:ma4,    aflag   ;x5<min5

            CMPLTDP xb5:xb4,        mb5:mb4,    bflag   ;x6<min6

    [!tflag]ZERO    aflag

    [!tflag]ZERO    bflag

    [aflag] MV      xa4,            ma4                 ;min5=x5

    [aflag] MV      xa5,            ma5

    [bflag] MV      xb4,            mb4                 ;min6=x6

    [bflag] MV      xb5,            mb5

    [tctr]  B       loop

            CMPLTDP ma1:ma0,        ma3:ma2,    aflag   ;min1<min3

            CMPLTDP mb1:mb0,        mb3:mb2,    bflag   ;min2<min4

    [aflag] MV      ma0,            ma2                 ;min(min1, min3)

    [aflag] MV      ma1,            ma3

    [bflag] MV      mb0,            mb2                 ;min(min2, min4)

    [bflag] MV      mb1,            mb3

            CMPLTDP ma3:ma2,        ma5:ma4,    aflag   ;min1, min3, min5

            CMPLTDP mb3:mb2,        mb5:mb4,    bflag   ;min2, min4, min6

    [aflag] MV      ma2,            ma4                 ;min(min1, min3, min5)

    [aflag] MV      ma3,            ma5

    [bflag] MV      mb2,            mb4                 ;min(min2, min4, min6)

    [bflag] MV      mb3,            mb5

            CMPLTDP ma5:ma4,        mb5:mb4,    aflag   ;min1, min3, min5, min2, min4, min6

    [aflag] MV      ma4,            mb4                 ;min(min1, min3, min5)

    [aflag] MV      ma5,            mb5


            .return mb5:mb4
             .endproc

* ======================================================================== *
*  End of file: DSPF_dp_minval.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_vecreci/1117057391  1028  0     0       10019     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecrecip -- Double Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void  DSPF_dp_vecrecip(const double *x,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_dp_vecrecip module calculates the reciprocal of each element    *
*   in the array x and returns the output in array r. It uses 3             *
*   iterations of the Newton-Raphson method to improve the accuracy         *
*   of the output generated by the RCPDP instruction of the C67x.           *
*   Each iteration doubles the accuracy. The initial output generated       *
*   by RCPDP is 8 bits.So after the first iteration it is 16 bits and       *
*   after the second it is the  23 bits and after third it is full 52 bits. *
*   The formula used is:                                                    *
*                                                                           *
*                r[n+1] = r[n](2 - v*r[n])                                  *
*                                                                           *
*       where v = the number whose reciprocal is to be found.               *
*       x[0], the seed value for the algorithm, is given by RCPDP.          *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*     void DSPF_dp_vecrecip(const double* x, double* restrict r, int n)          *
*     {                                                                     *
*      int i;                                                               *
*      for(i = 0; i < n; i++)                                               *
*         r[i] = 1 / x[i];                                                  *
*       }                                                                   *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_vecrecip
_DSPF_dp_vecrecip   .cproc  x, r, n

            .reg    xa1:xa0, xb1:xb0, xa3:xa2, xb3:xb2
            .reg    xa5:xa4, xb5:xb4, xa7:xa6, xb7:xb6
            .reg    xptr, ctr, rptr, aflag, bflag
            .no_mdep

            MV      x,      xptr                ;Pointer for x
            MV      r,      rptr                ;Pointer for r
            MV      n,      ctr                 ;Set the loop Couner

            ;loop is Unrolled 4 times

loop:       .trip   1

            LDDW    *xptr++[01],        xa1:xa0             ;load x1

            RCPDP   xa1:xa0,            xa3:xa2             ;1/x

            MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;r[n+1]=r[n]*(2-v*r[n])
            ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0 ;iteration 1
            MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
            SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

            MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;iteration 2
            ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0
            MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
            SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

            MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;iteration 3
            ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0
            MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
            SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

            STW     xa2,    *rptr++                         ;store r1
            STW     xa3,    *rptr++

            SUB     ctr,            1,              ctr     ;Decrement the loop Counter

    [ctr]   LDDW    *xptr++[01],        xa1:xa0             ;load x2

    [ctr]   RCPDP   xa1:xa0,            xa3:xa2             ;1/x2

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;r[n+1]=r[n]*(2-v*r[n])
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0 ;iteration 1
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;iteration 2
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;iteration 3
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   STW     xa2,    *rptr++                         ;store r2
    [ctr]   STW     xa3,    *rptr++

    [ctr]   SUB     ctr,            1,              ctr     ;Decrement the loop Counter

    [ctr]   LDDW    *xptr++[01],        xa1:xa0             ;load x3

    [ctr]   RCPDP   xa1:xa0,            xa3:xa2             ;1/x3

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;r[n+1]=r[n]*(2-v*r[n])
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0 ;iteration 1
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;iteration 2
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;iteration 3
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   STW     xa2,    *rptr++                         ;store r3
    [ctr]   STW     xa3,    *rptr++

    [ctr]   SUB     ctr,            1,              ctr     ;Decrement the loop Counter

    [ctr]   LDDW    *xptr++[01],        xa1:xa0             ;load x4

    [ctr]   RCPDP   xa1:xa0,            xa3:xa2             ;1/x4

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;r[n+1]=r[n]*(2-v*r[n])
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0 ;iteration 1
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;iteration 2
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   MPYDP   xa1:xa0,        xa3:xa2,        xa5:xa4 ;iteration 3
    [ctr]   ADDDP   xa3:xa2,        xa3:xa2,        xb1:xb0
    [ctr]   MPYDP   xa3:xa2,        xa5:xa4,        xa5:xa4
    [ctr]   SUBDP   xb1:xb0,        xa5:xa4,        xa3:xa2

    [ctr]   STW     xa2,    *rptr++                         ;store r4
    [ctr]   STW     xa3,    *rptr++

    [ctr]   SUB     ctr,            1,              ctr     ;Decrement the loop Counter

    [ctr]   B       loop

            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_vecrecip.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_vecsum_/1117057392  1049  0     0       5480      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecsum_sq -- Double Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       double DSPF_dp_vecsum_sq(const double *x,                                *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs a sum of squares of the elements of the      *
*        array x and returns the sum.                                       *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions. Note that the assembly code is hand optimized          *
*      and restrictions may apply.                                          *
*                                                                           *
*      double DSPF_dp_vecsum_sq(const double *x,int n)                           *
*      {                                                                    *
*          int i;                                                           *
*          double sum=0;                                                    *
*                                                                           *
*          for(i = 0;  i < n; i++ )                                         *
*              sum += x[i]*x[i];                                            *
*                                                                           *
*          return sum;                                                      *
*      }                                                                    *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_vecsum_sq
_DSPF_dp_vecsum_sq   .cproc  x, n

    .reg    xa1:xa0, pa1:pa0, sa1:sa0
            .reg    xptr,  ctr
            .no_mdep

            MV      x,      xptr                        ;Pointer for x
            MV      n,      ctr                         ;Set the loop Counter
            ZERO    sa0                                 ;Clear the Accumulator
            ZERO    sa1                                 ;Clear the Accumulator

loop:
            LDDW    *xptr++[01],    xa1:xa0             ;Load x[i]
            MPYDP   xa1:xa0,        xa1:xa0,    pa1:pa0 ;x[i]*x[i]
            ADDDP   sa1:sa0,        pa1:pa0,    sa1:sa0 ;sum+=x[i]*x[i]

    [ctr]   SUB     ctr,            1,          ctr     ;Decrement loop Counter

    [ctr]   LDDW    *xptr++[01],    xa1:xa0             ;Load x[i+1]
    [ctr]   MPYDP   xa1:xa0,        xa1:xa0,    pa1:pa0 ;x[i+1]*x[i+1]
    [ctr]   ADDDP   sa1:sa0,        pa1:pa0,    sa1:sa0 ;sum+=x[i+1]*x[i+1]


    [ctr]   SUB     ctr,            1,          ctr     ;Decrement loop Counter

    [ctr]   B       loop


            .return sa1:sa0  ;Return the SUM
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_vecsum_sq.sa                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_w_vec.s/1117057393  1071  0     0       6118      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_w_vec -- Double Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void DSPF_dp_w_vec(const double* x,                                    *
*                       const double* y,                                    *
*                       double m,                                           *
*                       double * restrict r,                                *
*                       int     nr                                          *
*                      )                                                    *
*                                                                           *
*              x    :  Pointer to first input array                         *
*              y    :  Pointer to second input array                        *
*              m    :  Weight factor                                        *
*              r    :  Output array pointer                                 *
*              nr   :  Number of elements in arrays                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine is used to obtain the weighted vector sum.              *
*      Both the inputs and output are Double precision floating             *
*      point numbers.                                                       *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_w_vec( const double * x,const double * y, double  m,         *
*                     double * restrict r,int nr)                           *
*                                                                           *
*     {                                                                     *
*         int i;                                                            *
*         for (i = 0; i < nr; i++)                                          *
*             r[i] = (m * x[i]) + y[i];                                     *
*     }                                                                     *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_w_vec
_DSPF_dp_w_vec   .cproc  x, y, mh:ml, r, nr
            .reg    xa1:xa0, xb1:xb0, pa1:pa0, sa1:sa0
            .reg    xptr, yptr, rptr, ctr
            .no_mdep

            MV      x,      xptr            ;Pointer for x
            MV      y,      yptr            ;Pointer for y
            MV      r,      rptr            ;Pointer for r
            MV      nr,     ctr             ;Loop Counter

            ;loop Unrolled twice

loop:       .trip   1

            LDDW    *xptr++,        xa1:xa0                 ;Load x1
            MPYDP   xa1:xa0,        mh:ml,      pa1:pa0     ;m1*x1
            LDDW    *yptr++,        xb1:xb0                 ;Load y1
            ADDDP   xb1:xb0,        pa1:pa0,    sa1:sa0     ;m1*x1+y1
            STW     sa0,            *rptr++                 ;Store r1
            STW     sa1,            *rptr++                 ;Store r1
    [ctr]   SUB     ctr,            1,          ctr         ;Decrement loop Counter

    [ctr]   LDDW    *xptr++,        xa1:xa0                 ;Load x1
    [ctr]   MPYDP   xa1:xa0,        mh:ml,      pa1:pa0     ;m1*x1
    [ctr]   LDDW    *yptr++,        xb1:xb0                 ;Load y1
    [ctr]   ADDDP   xb1:xb0,        pa1:pa0,    sa1:sa0     ;m1*x1+y1
    [ctr]   STW     sa0,            *rptr++                 ;Store r1
    [ctr]   STW     sa1,            *rptr++                 ;Store r1
    [ctr]   SUB     ctr,            1,          ctr         ;Decrement loop Counter


    [ctr]   B       loop

            .return
            .endproc

* ======================================================================== *
*  End of file: DSPF_dp_w_vec.sa                                                *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_vecmul./1117057394  1089  0     0       7114      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecmul -- Double Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void DSPF_dp_vecmul   (const double *x,                                  *
*                         const double *y,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                         )                                                 *
*                                                                           *
*              x        :  Pointer to first input array                     *
*              y        :  Pointer to second input array                    *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in arrays                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs an element by element Double Precision       *
*        floating point  multiplication of the vectors x[] and y[] and      *
*        returns the values in r[].                                         *
*                                                                           *
*     C CODE                                                                *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_vecmul(const double * x, const double * y,                   *
*                            double * restrict r, int n)                    *
*       {                                                                   *
*         int i;                                                            *
*                                                                           *
*         for(i = 0; i < n; i++)                                            *
*              r[i] = x[i] * y[i];                                          *
*                                                                           *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*        1. Endian: This code is LITTLE ENDIAN.                             *
*        2. Interruptibility: The code is interrupt tolerant but not        *
*           interruptible.                                                  *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*          4*Ceil(n/2) + 13                                                 *
*          eg. for n = 100, cycles = 213                                    *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*          256 bytes                                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_vecmul
_DSPF_dp_vecmul   .cproc  x, y, r, n

            .reg    xa1:xa0, xb1:xb0, pa1:pa0
            .reg    xptr, yptr, rptr, ctr
            .no_mdep

            MV      x,      xptr                ;Pointer for x

            MV      y,      yptr                ;Pointer for y

            MV      r,      rptr                ;Pointer for r

            MV      n,      ctr                 ;Set the Loop Counter

            ;Loop Unrolled 2 times

loop:       .trip   1

            LDDW    *xptr++,    xa1:xa0             ;Load x1

            LDDW    *yptr++,    xb1:xb0             ;Load y1

            MPYDP   xa1:xa0,    xb1:xb0,    pa1:pa0 ;r1=x1*y1

            STW     pa0,        *rptr++             ;Store r1

            STW     pa1,        *rptr++             ;Store r1

    [ctr]   SUB     ctr,        1,          ctr     ;Decrement loop Counter

    [ctr]   LDDW    *xptr++,    xa1:xa0             ;Load x1

    [ctr]   LDDW    *yptr++,    xb1:xb0             ;Load y1

    [ctr]   MPYDP   xa1:xa0,    xb1:xb0,    pa1:pa0 ;r1=x1*y1

    [ctr]   STW     pa0,        *rptr++             ;Store r1

    [ctr]   STW     pa1,        *rptr++             ;Store r1

    [ctr]   SUB     ctr,        1,          ctr     ;Decrement loop Counter

    [ctr]   B       loop


            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_vecmul.sa                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_mat_mul/1117057395  1108  0     0       11133     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine has following C prototype:                              *
*      void DSPF_dp_mat_mul(double *x, int r1, int c1,                           *
*                      double *y, int c2, double *r)                        *
*                                                                           *
*      x      : Pointer to r1 by c1 input matrix.                           *
*      r1     : Number of rows in x.                                        *
*      c1     : Number of columns in x.  Also number of rows in y.          *
*      y      : Pointer to c1 by c2 input matrix.                           *
*      c2     : Number of columns in y.                                     *
*      r      : Pointer to r1 by c2 output matrix.                          *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      This function computes the expression "r = x * y" for the matrices   *
*      x and y.  The column dimension of x must match the row dimension     *
*      of y.  The resulting matrix has the same number of rows as x and     *
*      the same number of columns as y.                                     *
*                                                                           *
*      The values stored in the matrices are assumed to be Double           *
*      precision floating point values.                                     *
*                                                                           *
*      This code is suitable for dense matrices.  No optimizations are      *
*      made for sparse matrices.                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_mat_mul
_DSPF_dp_mat_mul   .cproc  x, r1, c1, y, c2, r

        .reg   xa1:xa0, xa3:xa2, xb1:xb0, xb3:xb2
            .reg   pa1:pa0, pa3:pa2, pa5:pa4, pa7:pa6
            .reg   acc1:acc0, acc3:acc2, acc5:acc4, acc7:acc6
            .reg   inx, iny, ictr, jctr, kctr, tinx, tiny, rinx, riny
            .reg   t1, rtinx, rtiny
            .no_mdep



            MV      r1,     ictr                            ;Setting iLoop Counter
            MV      c2,     jctr                            ;Setting joop Counter
            MV      c1,     kctr                            ;Setting kLoop Counter
            ZERO    tinx                                    ;Clearing Index for X
            ZERO    tiny                                    ;Clearing Index for Y
            ZERO    rinx                                    ;Clearing Index for R
            ZERO    riny                                    ;Index for storing result
            ZERO    inx
            ZERO    iny
            ZERO    acc0                                    ; Zero the accumulator
            ZERO    acc1                                    ; Zero the accumulator
            ZERO    acc2                                    ; Zero the accumulator
            ZERO    acc3                                    ; Zero the accumulator
            ZERO    acc4                                    ; Zero the accumulator
            ZERO    acc5                                    ; Zero the accumulator
            ZERO    acc6                                    ; Zero the accumulator
            ZERO    acc7                                    ; Zero the accumulator


            ;i, j, kloop Unrolled 2 Times

kloop:      .trip   1

            LDDW    *+x[inx],       xa1:xa0                 ;Loading x[0][0]
            LDDW    *+y[iny],       xb1:xb0                 ;loading y[0][0]
            ADD     inx,            c1,         inx         ;Updating Index for x
            ADD     iny,            01,         iny         ;Updating Index for y
            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0     ; P11
            ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0   ; S11+=P11
            LDDW    *+x[inx],       xa3:xa2                 ;Loading x[1][0]
            LDDW    *+y[iny],       xb3:xb2                 ;Loading y[0][1]
            MPYDP   xa1:xa0,        xb3:xb2,    pa3:pa2     ; P12
            ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2   ; S12+=P12
            SUB     inx,            c1,         inx         ;Updating Index for x
            ADD     iny,            c2,         iny         ;Updating Index for y
            SUB     iny,            1,          iny
            ADD     inx,            1,          inx
            MPYDP   xa3:xa2,        xb1:xb0,    pa5:pa4     ; P13
            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4   ; S13+=P13
            MPYDP   xa3:xa2,        xb3:xb2,    pa7:pa6     ; P14
            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6   ; S14+=P14
            LDDW    *+x[inx],       xa1:xa0                 ;Loading x[0][1]
            LDDW    *+y[iny],       xb1:xb0                 ;Loading y[1][0]
            ADD     inx,            c1,         inx         ;Updating Index for x
            ADD     iny,            01,         iny         ;Updating Index for y
            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0     ; P21
            ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0   ; S1+=P21
            LDDW    *+x[inx],       xa3:xa2                 ;Loading x[1][1]
            LDDW    *+y[iny],       xb3:xb2                 ;Loading y[1][1]
            MPYDP   xa1:xa0,        xb3:xb2,    pa3:pa2     ; P22
            ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2   ; S2+=P22
            SUB     inx,            c1,         inx         ;Updating Index for x
            ADD     iny,            c2,         iny         ;Updating Index for y
            SUB     iny,            1,          iny
            ADD     inx,            1,          inx
            MPYDP   xa3:xa2,        xb1:xb0,    pa5:pa4     ; P32
            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4   ; S3+=P32
            MPYDP   xa3:xa2,        xb3:xb2,    pa7:pa6     ; P42
            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6   ; S4+=P42
            SUB     kctr,           02,         kctr        ; Decrementing k Loop Counter
    [kctr]  B       kloop
            ;k Loop Branch Occurs here
            SUB     jctr,           02,         jctr        ;Decrementing jLoop Counter
            MPY     rinx,           02,         rtinx       ;Index for Storing result
            MPY     riny,           02,         rtiny
            ADD     rtinx,          rtiny,      rtinx
            MPY     c2,             02,         t1
            ADD     rtinx,          t1,         t1
            STW     acc0,           *+r[rtinx]              ;Storing S1
            ADD     rtinx,          01,         rtinx
            STW     acc1,           *+r[rtinx]
            ADD     rtinx,          01,         rtinx
            STW     acc2,           *+r[rtinx]              ;Storing S2
            ADD     rtinx,          01,         rtinx
            STW     acc3,           *+r[rtinx]
            MV      t1,             rtinx
            STW     acc4,           *+r[rtinx]              ;Storing S3
            ADD     rtinx,          01,         rtinx
            STW     acc5,           *+r[rtinx]
            ADD     rtinx,          01,         rtinx
            STW     acc6,           *+r[rtinx]              ;Storing S4
            ADD     rtinx,          01,         rtinx
            STW     acc7,           *+r[rtinx]
            ADD     tiny,           02,         tiny        ;Incrementing Y Index
            MV      tiny,           riny
            ;i Loop instructions
    [!jctr] MPY     c1,             02,         t1
    [!jctr] ADD     tinx,           t1,         tinx        ;Updating Index for X
    [!jctr] ZERO    tiny
    [!jctr] MV      tiny,           riny
    [!jctr] MPY     c2,             02,         rtinx
    [!jctr] ADD     rinx,           rtinx,      rinx        ;Updating Index for R
    [!jctr] SUB     ictr,           02,         ictr        ;Decrementing iLoop Counter
    [!jctr] MV      c2,     jctr                            ;Setting jLoop Counter

            MV      c1,     kctr                            ;Setting kLoop Counter
            MV      tinx,   inx                             ;Index for X
            MV      tiny,   iny                             ;Index for Y
            ZERO    acc0                                    ; Zero the accumulator
            ZERO    acc1                                    ; Zero the accumulator
            ZERO    acc2                                    ; Zero the accumulator
            ZERO    acc3                                    ; Zero the accumulator
            ZERO    acc4                                    ; Zero the accumulator
            ZERO    acc5                                    ; Zero the accumulator
            ZERO    acc6                                    ; Zero the accumulator
            ZERO    acc7                                    ; Zero the accumulator

    [ictr]  B       kloop
            ; i,j Loop Branch Occurs
                .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_mat_mul.sa                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_mat_tra/1117057396  1128  0     0       7503      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_trans -- Double Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x,                        *
*                          int rows,                                        *
*                          int cols,                                        *
*                          double *restrict r                               *
*                          )                                                *
*                                                                           *
*           x       :  Input matrix containing rows*cols Double Precision   *
*                      floating point numbers.                              *
*           rows    :  No. of rows in matrix x.                             *
*                      Also no. of columns in matrix r                      *
*           cols    :  No. of columns in matrix x.                          *
*                      Also no. of rows in matrix r.                        *
*           r       :  Output matrix containing cols*rows Double Precision  *
*                      floating point numbers.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This function transposes the input matrix x[] and writes the          *
*     result to matrix r[].                                                 *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The number of rows and columns is > 0.                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*        This is the C equivalent of the assembly code.  Note that          *
*        the assembly code is hand optimized and restrictions may apply.    *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x, int rows,              *
*        int cols, double *restrict r)                                      *
*        {                                                                  *
*           int i,j;                                                        *
*                                                                           *
*           for(i=0; i<cols; i++)                                           *
*              for(j=0; j<rows; j++)                                        *
*                 r[i * rows + j] = x[i + cols * j];                        *
*        }                                                                  *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2 * rows * cols + 15                                                *
*       For rows=10 and cols=20, cycles=415                                 *
*       For rows=15 and cols=20, cycles=615                                 *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       256  bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *




        .text
        .global _DSPF_dp_mat_trans
_DSPF_dp_mat_trans   .cproc  x, rows, cols, r
                .reg   xa1:xa0, ctr, idx, tidx, cidx, temp, flag
                .no_mdep

            MPY     rows,       cols,       ctr         ;Set the Counter

            SUB     rows,       1,          temp        ;r1-1

            MPY     temp,       cols,       cidx        ;(r1-1)*c1

            ZERO    idx                                 ;initial index

            ZERO    tidx

loop:       .trip       1

            LDDW    *+x[idx],       xa1:xa0                 ;load x[i][j]

            CMPEQ   idx,            cidx,       flag        ;check limit of Index

    [flag]  ADD     tidx,           1,          tidx        ;Reset Index to Next Column

    [flag]  MV      tidx,           idx

    [flag]  ADD     cidx,           1,          cidx        ;Update Index for Checking limit

    [!flag] ADD     idx,            cols,       idx         ;index=index+cols

            STW     xa0,            *r++                    ;Store the result

            STW     xa1,            *r++                    ;Store the result

    [ctr]   SUB     ctr,            1,          ctr         ;Decrement the Counter

    [ctr]   B       loop

            .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_mat_trans.sa                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_mat_mul/1117057397  1150  0     0       15895     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_mul_cplx(                                              *
*                               const double* x,                            *
*                               int r1,                                     *
*                               int c1,                                     *
*                               const double* y,                            *
*                               int c2,                                     *
*                               double* restrict r                          *
*                            )                                              *
*                                                                           *
*             x[2*r1*c1]:   Input matrix containing r1*c1 complex           *
*                           floating point numbers having r1 rows and c1    *
*                           columns of complex numbers.                     *
*             r1        :   No. of rows in matrix x.                        *
*             c1        :   No. of columns in matrix x.                     *
*                           Also no. of rows in matrix y.                   *
*             y[2*c1*c2]:   Input matrix containing c1*c2 complex           *
*                           floating point numbers having c1 rows and c2    *
*                           columns of complex numbers.                     *
*             c2        :   No. of columns in matrix y.                     *
*             r[2*r1*c2]:   Output matrix of c1*c2 complex floating         *
*                           point numbers having c1 rows and c2 columns of  *
*                           complex numbers.                                *
*                                                                           *
*                           Complex numbers are stored consecutively with   *
*                           real values stored in even positions and        *
*                           imaginary values in odd positions.              *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*         This function computes the expression "r = x * y" for the         *
*         matrices x and y. The columnar dimension of x must match the row  *
*         dimension of y. The resulting matrix has the same number of rows  *
*         as x and the same number of columns as y.                         *
*                                                                           *
*         Each element of the matrix is assumed to be complex numbers with  *
*         Real values are stored in even positions and imaginary            *
*         values in odd positions.                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*         1. Innermost loop is unrolled twice.                              *
*         2. Outermost loop is executed in parallel with innner loops.      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*         1. r1,r2>=1,c1 should be a multiple of 2 and >=2.                 *
*         2. x should be padded with 6 words                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*    the assembly code is hand optimized and restrictions may apply.        *
*                                                                           *
*         void DSPF_dp_mat_mul_cplx(const double* x, int r1, int c1,             *
*           const double* y, int c2, double* restrict r)                    *
*         {                                                                 *
*             double real, imag;                                            *
*             int i, j, k;                                                  *
*                                                                           *
*             for(i = 0; i < r1; i++)                                       *
*             {                                                             *
*               for(j = 0; j < c2; j++)                                     *
*               {                                                           *
*                 real=0;                                                   *
*                 imag=0;                                                   *
*                                                                           *
*                 for(k = 0; k < c1; k++)                                   *
*                 {                                                         *
*                 real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j]                  *
*                 -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);              *
*                                                                           *
*                 imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1]              *
*                    + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);              *
*                 }                                                         *
*                 r[i*2*c2 + 2*j] = real;                                   *
*                 r[i*2*c2 + 2*j + 1] = imag;                               *
*               }                                                           *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*         1. Real values are stored in even word positions and imaginary    *
*            values in odd positions.                                       *
*         2. Endian: This code is LITTLE ENDIAN.                            *
*         3. Interruptibility: This code is interrupt tolerant but not      *
*            interruptible.                                                 *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*         8*r1*c1*c2'+ 18*(r1*c2)+40 WHERE c2'=2*ceil(c2/2)                 *
*         When r1=3, c1=4, c2=4, cycles = 640                               *
*         When r1=4, c1=4, c2=5, cycles = 1040                              *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSPF_dp_mat_mul_cplx
_DSPF_dp_mat_mul_cplx   .cproc  x, r1, c1, y, c2, r

            .reg   xa1:xa0, xa3:xa2, xb1:xb0, xb3:xb2
            .reg   pa1:pa0, pa3:pa2, pa5:pa4, pa7:pa6
            .reg   acc1:acc0, acc3:acc2, acc5:acc4, acc7:acc6
            .reg   inx, iny, ictr, jctr, kctr, t1, t2, tinx, tiny
            .no_mdep



            MV      r1,     ictr                            ;Setting iLoop Counter
            MV      c2,     jctr                            ;Setting joop Counter
            MV      c1,     kctr                            ;Setting kLoop Counter
            ZERO    inx
            ZERO    iny
            ZERO    tinx
            ZERO    tiny

            ZERO    acc0                                    ; Zero the accumulator
            ZERO    acc1                                    ; Zero the accumulator
            ZERO    acc2                                    ; Zero the accumulator
            ZERO    acc3                                    ; Zero the accumulator
            ZERO    acc4                                    ; Zero the accumulator
            ZERO    acc5                                    ; Zero the accumulator
            ZERO    acc6                                    ; Zero the accumulator
            ZERO    acc7                                    ; Zero the accumulator
            MPY     c2,     2,      t1                      ;2*c2
            MPY     c1,     2,      t2                      ;2*c1
            SUB     t1,     1,      t1                      ;2*c1-1


kloop:      .trip   1

            LDDW    *+x[inx],       xa1:xa0                 ;Loading x1real
            LDDW    *+y[iny],       xb1:xb0                 ;loading y1real
            ADD     inx,            01,         inx         ;Updating Index for x
            ADD     iny,            01,         iny         ;Updating Index for y
            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0     ; P11=x1real*y1real
            ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0   ; S11+=P11
            LDDW    *+x[inx],       xa3:xa2                 ;Loading x1imag
            LDDW    *+y[iny],       xb3:xb2                 ;Loading y1imag
            MPYDP   xa1:xa0,        xb3:xb2,    pa3:pa2     ; P12=x1real*y1imag
            ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2   ; S12+=P12
            MPYDP   xa3:xa2,        xb1:xb0,    pa5:pa4     ; P13=x1imag*y1real
            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4   ; S13+=P13
            MPYDP   xa3:xa2,        xb3:xb2,    pa7:pa6     ; P14=x1imag*y1imag
            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6   ; S14+=P14
            ADD     inx,            01,         inx         ;Updating Index for x
            ADD     iny,            t1,         iny         ;Updating Index for y

            LDDW    *+x[inx],       xa1:xa0                 ;Loading x2real
            LDDW    *+y[iny],       xb1:xb0                 ;Loading y2real
            ADD     inx,            01,         inx         ;Updating Index for x
            ADD     iny,            01,         iny         ;Updating Index for y
            MPYDP   xa1:xa0,        xb1:xb0,    pa1:pa0     ; P21=x2real*y2real
            ADDDP   acc1:acc0,      pa1:pa0,    acc1:acc0   ; S1+=P21
            LDDW    *+x[inx],       xa3:xa2                 ;Loading x2Imag
            LDDW    *+y[iny],       xb3:xb2                 ;Loading y2Imag
            MPYDP   xa1:xa0,        xb3:xb2,    pa3:pa2     ; P22=x2real*y2imag
            ADDDP   acc3:acc2,      pa3:pa2,    acc3:acc2   ; S12+=P22
            MPYDP   xa3:xa2,        xb1:xb0,    pa5:pa4     ; P23=x2imag*y2real
            ADDDP   acc5:acc4,      pa5:pa4,    acc5:acc4   ; S13+=P23
            MPYDP   xa3:xa2,        xb3:xb2,    pa7:pa6     ; P24=x2imag*y2imag
            ADDDP   acc7:acc6,      pa7:pa6,    acc7:acc6   ; S14+=P24
            ADD     inx,            01,         inx         ;Updating Index for x
            ADD     iny,            t1,         iny         ;Updating Index for y

            SUB     kctr,           02,         kctr        ; Decrementing k Loop Counter

    [kctr]  B       kloop

            ;k Loop Branch Occurs here

            SUBDP   acc1:acc0,      acc7:acc6,  acc1:acc0   ;rreal=P1-P4

            ADDDP   acc3:acc2,      acc5:acc4,  acc3:acc2   ;rImag=P2+P3

            STW     acc0,           *r++                    ;store rreal
            STW     acc1,           *r++                    ;store rreal
            STW     acc2,           *r++                    ;store rImag
            STW     acc3,           *r++                    ;store rImag

            SUB     jctr,           1,      jctr            ;Decrement jloop Counter
            ADD     tiny,           02,     tiny            ;Update y Index
            MV      c1,             kctr                    ;Set k loop Counter

            ;iloop Instructions

    [!jctr] ZERO    tiny
    [!jctr] ADD     tinx,       t2,         tinx            ;Update X index
    [!jctr] SUB     ictr,       1,          ictr            ;Decrement i loop Counter
    [!jctr] MV      c2,         jctr                        ;set jloop Counter

            MV      tinx,       inx                         ;Set xindex
            MV      tiny,       iny                         ;Set yindex

            ZERO    acc0                                    ; Zero the accumulator
            ZERO    acc1                                    ; Zero the accumulator
            ZERO    acc2                                    ; Zero the accumulator
            ZERO    acc3                                    ; Zero the accumulator
            ZERO    acc4                                    ; Zero the accumulator
            ZERO    acc5                                    ; Zero the accumulator
            ZERO    acc6                                    ; Zero the accumulator
            ZERO    acc7                                    ; Zero the accumulator

    [ictr]  B       kloop
            ; i,j Loop Branch Occurs
                .return
                .endproc

* ======================================================================== *
*  End of file: DSPF_dp_mat_mul_cplx.sa                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_blk_mov/1117057398  1175  0     0       6338      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_blk_move -- DSPF_dp_blk_move                                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_blk_move(                                                  *
*                         const double *   x,                               *
*                         double *restrict r,                               *
*                         int nx                                            *
*                        )                                                  *
*                                                                           *
*             x[nx]: Pointer to source data to be moved.                    *
*             r[nx]: Pointer to destination array.                          *
*             nx:    Number of floats to move.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*    This routine moves nx doubles from one memory location                 *
*        pointed to by x to another pointed to by r.                        *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*        1. nx is greater than 0.                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*        void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     *
*        {                                                                  *
*            int i;                                                         *
*            for (i = 0 ; i < nx; i++)                                      *
*                r[i] = x[i];                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. Endian: This implementation is Little-Endian.                    *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*                            interruptible.                                 *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2*nx+ 8                                                             *
*       For nx=64, cycles=136.                                              *
*       For nx=25, cycles=58.                                               *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       96 bytes                                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSPF_dp_blk_move
_DSPF_dp_blk_move   .cproc  x, r, nx
            .reg    xa1:xa0, ctr, xptr
            .no_mdep


            MV      nx,     ctr
            MV      x,      xptr                    ;Pointer for x

loop:       .trip   1

            LDDW    *xptr++,        xa1:xa0
            STW     xa0,            *r++
            STW     xa1,            *r++
    [ctr]   SUB     ctr,        1,      ctr         ;Decrement Loop Counter
    [ctr]   B       loop

            .return
            .endproc

* ======================================================================== *
*  End of file: DSPF_dp_blk_move.sa                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_lms.h/  1117057336  0     0     0       11198     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_lms -- Single Precision floating point LMS algorithm             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_lms                                                        */
/*      (                                                                   */
/*          float *x,                                                       */
/*          float *h,                                                       */
/*          float *desired,                                                 */
/*          float *r,                                                       */
/*          float adaptrate,                                                */
/*          float error,                                                    */
/*          int nh,                                                         */
/*          int nr                                                          */
/*      );                                                                  */
/*                                                                          */
/*      x        :  Pointer to input samples                                */
/*      h        :  Pointer to the coefficient array                        */
/*      desired  :  Pointer to the desired output array                     */
/*      r        :  Pointer to filtered output array                        */
/*      adaptrate:  Adaptation rate                                         */
/*      error    :  Initial error                                           */
/*      nh       :  Number of coefficients                                  */
/*      nr       :  Number of output samples                                */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       */
/*      input signal and a desired input signal, the filter produces an     */
/*      output signal, the final coefficient values, and returns the final  */
/*      output error signal.                                                */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled six times to allow update of          */
/*         six coefficients in the kernel.                                  */
/*      2. The outer loop has been unrolled twice to enable use of LDDW     */
/*         for loading the input coefficients.                              */
/*      3. LDDW instruction is used to load in the coefficients.            */
/*      4. Register sharing is used to make optimal use of available        */
/*         registers.                                                       */
/*      5. The outer loop instructions are scheduled in parallel with       */
/*         epilog and prolog wherever possible.                             */
/*      6. The 'error' term needs to be computed in the outer loop          */
/*         before a new iteration of the inner loop can start. As a         */
/*         result the prolog cannot be placed in parallel with epilog       */
/*         (after the loop kernel).                                         */
/*      7. Pushing and popping variables from the stack does not            */
/*         really add any overhead except increase stack size. This         */
/*         is because the pops and pushes are done in the delay slots       */
/*         of the outer loop instructions.                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The inner loop counter must be a multiple of 6 and >=6.          */
/*      2. Little endianness is assumed.                                    */
/*      3. Extraneous loads are allowed in the program.                     */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions      */
/*      may apply.                                                          */
/*                                                                          */
/*      float DSPF_sp_lms                                                        */
/*      (                                                                   */
/*          float *x,                                                       */
/*          float *h,                                                       */
/*          float *desired,                                                 */
/*          float *r,                                                       */
/*          float adaptrate,                                                */
/*          float error,                                                    */
/*          int nh,                                                         */
/*          int nr                                                          */
/*      )                                                                   */
/*      {                                                                   */
/*          int i,j;                                                        */
/*                                                                          */
/*          float sum, temp, ae;                                            */
/*          temp = 0.0f;                                                    */
/*                                                                          */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              sum = 0.0f;                                                 */
/*              ae = adaptrate * error;                                     */
/*                                                                          */
/*              for (j = 0; j < nh; j++)                                    */
/*              {                                                           */
/*                  h[j] = h[j] + (ae * temp);                              */
/*                  sum += h[j] * x[i+j];                                   */
/*                  temp = x[i + j];                                        */
/*              }                                                           */
/*                                                                          */
/*              r[i] = sum;                                                 */
/*              error = desired[i] - sum;                                   */
/*              temp = x[i];                                                */
/*          }                                                               */
/*          // return the final error //                                    */
/*          return error;                                                   */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*      (nh + 35) nr + 21                                                   */
/*      eg. for nh = 36 and nr = 64                                         */
/*      cycles = 4565                                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      1376 bytes                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_LMS_H_
#define DSPF_SP_LMS_H_ 1

float DSPF_sp_lms
(
    float *x,
    float *h,
    float *desired,
    float *r,
    float adaptrate,
    float error,
    int nh,
    int nr
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_lms.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_lms.h67/1117057336  0     0     0       11188     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_lms -- Single Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       );                                                                  *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_sp_lms implements an LMS adaptive filter. Given an actual       *
*       input signal and a desired input signal, the filter produces an     *
*       output signal, the final coefficient values, and returns the final  *
*       output error signal.                                                *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled six times to allow update of          *
*          six coefficients in the kernel.                                  *
*       2. The outer loop has been unrolled twice to enable use of LDDW     *
*          for loading the input coefficients.                              *
*       3. LDDW instruction is used to load in the coefficients.            *
*       4. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*       5. The outer loop instructions are scheduled in parallel with       *
*          epilog and prolog wherever possible.                             *
*       6. The 'error' term needs to be computed in the outer loop          *
*          before a new iteration of the inner loop can start. As a         *
*          result the prolog cannot be placed in parallel with epilog       *
*          (after the loop kernel).                                         *
*       7. Pushing and popping variables from the stack does not            *
*          really add any overhead except increase stack size. This         *
*          is because the pops and pushes are done in the delay slots       *
*          of the outer loop instructions.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The inner loop counter must be a multiple of 6 and >=6.          *
*       2. Little endianness is assumed.                                    *
*       3. Extraneous loads are allowed in the program.                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions      *
*       may apply.                                                          *
*                                                                           *
*       float DSPF_sp_lms                                                        *
*       (                                                                   *
*           float *x,                                                       *
*           float *h,                                                       *
*           float *desired,                                                 *
*           float *r,                                                       *
*           float adaptrate,                                                *
*           float error,                                                    *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i,j;                                                        *
*                                                                           *
*           float sum, temp, ae;                                            *
*           temp = 0.0f;                                                    *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0.0f;                                                 *
*               ae = adaptrate * error;                                     *
*                                                                           *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   h[j] = h[j] + (ae * temp);                              *
*                   sum += h[j] * x[i+j];                                   *
*                   temp = x[i + j];                                        *
*               }                                                           *
*                                                                           *
*               r[i] = sum;                                                 *
*               error = desired[i] - sum;                                   *
*               temp = x[i];                                                *
*           }                                                               *
*           /* return the final error */                                    *
*           return error;                                                   *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       (nh + 35) nr + 21                                                   *
*       eg. for nh = 36 and nr = 64                                         *
*       cycles = 4565                                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1376 bytes                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_lms

*  ======================================================================== *
*   End of file:  DSPF_sp_lms.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_autocor/1117057337  1196  0     0       4797      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_autocor -- Single Precision autocorrelation                      */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_autocor                                                    */
/*                     (                                                    */
/*                         float       *  restrict r,                       */
/*                         const short *  restrict x,                       */
/*                         int            nx,                               */
/*                         int            nr                                */
/*                     )                                                    */
/*            r  = pointer to output array of autocorrelation of length nr  */
/*            x  = pointer to input array of length nx+nr. Input data must  */
/*                 be padded with nr consecutive zeros at the beginning.    */
/*            nx = Length of Autocorrelation vector.                        */
/*            nr = Length of lags.                                          */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This routine performs the autocorrelation of the input array inp.  */
/*       It is assumed that the length of the input array, x, is a multiple */
/*       of 2 and the length of the output array, r, is a multiple of 4.    */
/*       The assembly routine computes 4 output samples at a time.          */
/*                                                                          */
/*       It is assumed that input vector x is padded with nr no of zeros in */
/*       the beginning.                                                     */
/*                                                                          */
/*       x is to be aligned on a double word boundary.                      */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       The inner loop is unrolled twice and the outer loop is unrolled    */
/*       four times.                                                        */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nx is a multiple of 2 and greater than or equal to 4.           */
/*       2. nr is a multiple of 4 and greater than or equal to 4.           */
/*       3. nx is greater than or equal to nr                               */
/*       4. x  is double word aligned.                                      */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_AUTOCOR_ASM_H_
#define DSPF_SP_AUTOCOR_ASM_H_ 1

void DSPF_sp_autocor(float     *restrict r, float *restrict x, int nx, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_autocor_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_autocor/1117057337  1215  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_autocor -- Single Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_autocor

* ======================================================================== *
*  End of file: DSPF_sp_autocor_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_bitrev_/1117057338  1236  0     0       7052      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_bitrev_cplx -- Bit reversal for Single Precision Complex         */
/*      numbers                                                             */
/*                                                                          */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*     This routine is C Callable and can be called as:                     */
/*                                                                          */
/*     void bitrev_cplx(double *x, short *index, int nx);                   */
/*                                                                          */
/*     x[nx]  : Complex input array to be bit-reversed.                     */
/*              Contains 2*nx floats                                        */
/*     index[]: Array of size ~sqrt(nx) created by the routine              */
/*              bitrev_index to allow the fast implementation of the        */
/*              bit-reversal.                                               */
/*     nx     : Number of elements in array x[]. Must be power of 2.        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine performs the bit-reversal of the input array x[],       */
/*     where x[] is an integer array of length nx containing 16-bit         */
/*     complex pairs of data.  This routine requires the index array        */
/*     provided by the program below.  This index should be generated at    */
/*     compile time not by the DSP.                                         */
/*                                                                          */
/*     TI retains all rights, title and interest in this code and only      */
/*     authorizes the use of the bit-reversal code and related table        */
/*     generation code with TMS320-family DSPs manufactured by TI.          */
/*                                                                          */
/*     // ----------------------------------------------------------- //    */
/*     //  This routine calculates the index for bit reversal of      //    */
/*     //  an array of length nx.  The length of the index table is   //    */
/*     //  2^(2*ceil(k/2)) where nx = 2^k.                            //    */
/*     //                                                             //    */
/*     //  In other words, the length of the index table is:          //    */
/*     //      - for even power of radix: sqrt(nx)                    //    */
/*     //      - for odd  power of radix: sqrt(2*nx)                  //    */
/*     // ----------------------------------------------------------- //    */
/*     void bitrev_index(short *index, int nx)                              */
/*     {                                                                    */
/*         int   i, j, k, radix = 2;                                        */
/*         short nbits, nbot, ntop, ndiff, n2, raddiv2;                     */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*             i = i >> 1;                                                  */
/*             nbits++;                                                     */
/*         }                                                                */
/*                                                                          */
/*         raddiv2 = radix >> 1;                                            */
/*         nbot    = nbits >> raddiv2;                                      */
/*         nbot    = nbot << raddiv2 - 1;                                   */
/*         ndiff   = nbits & raddiv2;                                       */
/*         ntop    = nbot + ndiff;                                          */
/*         n2      = 1 << ntop;                                             */
/*                                                                          */
/*         index[0] = 0;                                                    */
/*         for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  */
/*         {                                                                */
/*             index[i] = j - 1;                                            */
/*                                                                          */
/*             for (k = n2/radix; k*(radix-1) < j; k /= radix)              */
/*                 j -= k*(radix-1);                                        */
/*                                                                          */
/*             j += k;                                                      */
/*         }                                                                */
/*         index[n2 - 1] = n2 - 1;                                          */
/*     }                                                                    */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_BITREV_CPLX_ASM_H_
#define DSPF_SP_BITREV_CPLX_ASM_H_ 1

void DSPF_sp_bitrev_cplx(double     * x, short * index, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_bitrev_cplx_h.asm                                       */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_bitrev_/1117057337  1259  0     0       1766      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_bitrev_cplx -- Bit reversal for Single Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_bitrev_cplx

* ======================================================================== *
*  End of file: DSPF_sp_bitrev_cplx_h.asm                                       *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr4_/1117057339  1284  0     0       7440      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      */
/*                                                                          */
/*  USAGE                                                                 */
/*                                                                          */
/*  This routine is C Callable and can be called as:                        */
/*                                                                        */
/*  void cfftr4_dif(float* x, float* w, short n)                          */
/*                                                                          */
/*  x is pointer to an array holding the input and output floating        */
/*     point array which contains 'n' complex points                      */
/*  w is pointer to an array holding the coefficient floating point       */
/*     array which contains 3*n/4 complex numbers                         */
/*  n is the number of complex points in x                                */
/*                                                                          */
/*  If the routine is not to be used as a C callable function,            */
/*  then you need to initialize values for all of the parameters          */
/*  passed to the function since these are assumed to be in               */
/*  registers as defined by the calling convention of the                 */
/*  compiler, (refer to the TMS320C6x Optimizing C Compiler               */
/*  User's Guide).                                                        */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                            */
/*                                                                          */
/*  This routine implements the DIF (decimation in frequency)             */
/*  complex radix 4 FFT with digit-reversed output and normal             */
/*  order input.  The number of points, 'n', must be a power              */
/*  of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                 */
/*  in-place routine in the sense that the output is written              */
/*  over the input.  It is not an in-place routine in the                 */
/*  sense that the input is in normal order and the output is             */
/*  in digit-reversed order.                                              */
/*                                                                          */
/*  There must be n complex points (2*n values), and 3*n/4 complex        */
/*  coefficients (3*n/2 values).                                          */
/*                                                                          */
/*  Each real and imaginary input value is interleaved in the             */
/*  'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers           */
/*  are in normal order.  Each real and imaginary output value            */
/*  is interleaved in the 'x' array and the complex numbers are           */
/*  in digit-reversed  order {rx0, ix0, ...}.  The real and               */
/*  imaginary values of the coefficients are interleaved in the           */
/*  'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers         */
/*  are in normal order.                                                  */
/*                                                                          */
/*  Note that the imaginary coefficients are negated                      */
/*  {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than         */
/*  {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                     */
/*  where d = 2*PI/n.  The value of w(n,k) is usually written             */
/*  w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).              */
/*                                                                          */
/*  The routine can be used to implement an inverse FFT by                */
/*  performing the complex conjugate on the input complex numbers         */
/*  (negating the imaginary value), and dividing the result by n.         */
/*  Another method to use the FFT to perform an inverse FFT, is to        */
/*  swap the real and imaginary values of the input and the result,       */
/*  and divide the result by n.  In either case, the input is still       */
/*  in normal order and the output is still in digit-reversed order.      */
/*                                                                          */
/*  Note that you can not make the radix 4 FFT into an inverse            */
/*  FFT by using the complex conjugate of the coefficients as             */
/*  you can do with the complex radix 2 FFT.                              */
/*                                                                          */
/*  If you label the input locations from 0 to (n-1) (normal order),      */
/*  the digit-reversed locations can be calculated by reversing the       */
/*  order of the bit pairs of the labels.  For example, for a 1024        */
/*  point FFT, the digit reversed location for                            */
/*  617d = 1001101001b = 10 01 10 10 01  is                               */
/*  422d = 0110100110b = 01 10 10 01 10  and visa versa.                  */
/*                                                                          */
/*  TI plans to provide an inverse complex radix 4 FFT with digit-        */
/*  reversed input and normal order output.  With these 2 routines,       */
/*  the digit-reversed output of the FFT can be the input to the          */
/*  inverse FFT without performing digit-reversing on the data.           */
/*                                                                          */
/*  TI also plans to provide a complex digit reverse routine.             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_CFFTR4_DIF_ASM_H_
#define DSPF_SP_CFFTR4_DIF_ASM_H_ 1

void DSPF_sp_cfftr4_dif(float     * x, float * w, short n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_cfftr4_dif_h.asm                                        */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_cfftr4_/1117057339  1306  0     0       1692      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr4_dif -- DSPF_sp_cfftr4_dif                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_cfftr4_dif

* ======================================================================== *
*  End of file: DSPF_sp_cfftr4_dif_h.asm                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_cfftr2_/1117057340  1330  0     0       7763      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_cfftr2_dit -- Single Precision floating point radix-2 FFT with   */
/*      complex input                                                       */
/*                                                                          */
/*  USAGE                                                                   */
/*          This routine is C-callable and can be called as:                */
/*                                                                          */
/*          void DSPF_sp_cfftr2_dit(float * x, float * w, short n);              */
/*                                                                          */
/*          x : Pointer to complex data input                               */
/*          w : pointer to complex twiddle factor in Bit reverse order      */
/*          N : length of FFT in complex samples, power of 2 such that N>=3 */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine performs the Decimation-in-Time (DIT) Radix-2 FFT      */
/*      of the input array x.                                               */
/*      x has N complex floating point numbers arranged as successive       */
/*      real and imaginary number pairs. Input array x contains N           */
/*      complex points (N*2 elements). The coefficients for the             */
/*      FFT are passed to the function in array w which contains            */
/*      N/2 complex numbers (N elements) as successive real and             */
/*      imaginary number pairs.                                             */
/*      The FFT Coefficients w are in N/2 bit-reversed order                */
/*      The elements of input array x are in normal order                   */
/*      The assembly routine performs 4 output samples (2 real and 2        */
/*      imaginary) for a pass through inner loop.                           */
/*                                                                          */
/*      Note that (bit-reversed) coefficients for higher order FFT (1024    */
/*      point) can be used unchanged as coefficients for a lower order      */
/*      FFT (512, 256, 128 ... ,2)                                          */
/*                                                                          */
/*      The routine can be used to implement Inverse-FFT by any ONE of      */
/*      the following methods:                                              */
/*                                                                          */
/*      1.Inputs (x) are replaced by their Complex-conjugate values         */
/*        Output values are divided by N                                    */
/*      2.FFT Coefficients (w) are replaced by their Complex-conjugates     */
/*        Output values are divided by N                                    */
/*      3.Swap Real and Imaginary values of input                           */
/*      4.Swap Real and Imaginary values of output                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_cfftr2_dit(float* x, float* w, short n)                     */
/*      {                                                                   */
/*         short n2, ie, ia, i, j, k, m;                                    */
/*         float rtemp, itemp, c, s;                                        */
/*                                                                          */
/*         n2 = n;                                                          */
/*         ie = 1;                                                          */
/*                                                                          */
/*         for(k=n; k > 1; k >>= 1)                                         */
/*         {                                                                */
/*            n2 >>= 1;                                                     */
/*            ia = 0;                                                       */
/*            for(j=0; j < ie; j++)                                         */
/*            {                                                             */
/*               c = w[2*j];                                                */
/*               s = w[2*j+1];                                              */
/*               for(i=0; i < n2; i++)                                      */
/*               {                                                          */
/*                  m = ia + n2;                                            */
/*                  rtemp     = c * x[2*m]   + s * x[2*m+1];                */
/*                  itemp     = c * x[2*m+1] - s * x[2*m];                  */
/*                  x[2*m]    = x[2*ia]   - rtemp;                          */
/*                  x[2*m+1]  = x[2*ia+1] - itemp;                          */
/*                  x[2*ia]   = x[2*ia]   + rtemp;                          */
/*                  x[2*ia+1] = x[2*ia+1] + itemp;                          */
/*                  ia++;                                                   */
/*               }                                                          */
/*               ia += n2;                                                  */
/*            }                                                             */
/*            ie <<= 1;                                                     */
/*         }                                                                */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_CFFTR2_DIT_ASM_H_
#define DSPF_SP_CFFTR2_DIT_ASM_H_ 1

void DSPF_sp_cfftr2_dit(float     * x, float * w, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_cfftr2_dit_h.asm                                        */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_cfftr2_/1117057339  1352  0     0       1765      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_cfftr2_dit -- Single Precision floating point radix-2 FFT with   *
*      complex input                                                       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_cfftr2_dit

* ======================================================================== *
*  End of file: DSPF_sp_cfftr2_dit_h.asm                                        *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fftSPxS/1117057341  1376  0     0       37257     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          */
/*     forwards FFT with complex input                                     */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*      void DSPF_sp_fftSPxSP                                                    */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*                                                                          */
/*      N      :  Length of fft in complex samples, power of 2 such that    */
/*                   N >=8 and N<= 16385.                                   */
/*      ptr_x  :  Pointer to complex data input.                            */
/*      ptr_w  :  Pointer to complex twiddle factor (see below).            */
/*      ptr_y  :  Pointer to complex output data.                           */
/*      brev   :  Pointer to bit reverse table containing 64 entries.       */
/*      n_min  :  Smallest fft butterfly used in computation used for       */
/*                decomposing fft into subffts, see notes.                  */
/*      offset :  Index in complex samples of sub-fft from start of main    */
/*                fft.                                                      */
/*      n_max  :  size of main fft in complex samples.                      */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The benchmark performs a mixed radix forwards fft using a special   */
/*      sequece of coefficients generated in the following way:             */
/*                                                                          */
/*      // generate vector of twiddle factors for optimized algorithm //    */
/*      void tw_gen(float * w, int N)                                       */
/*      {                                                                   */
/*          int j, k;                                                       */
/*          double x_t, y_t, theta1, theta2, theta3;                        */
/*          const double PI = 3.141592654;                                  */
/*                                                                          */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                             */
/*          {                                                               */
/*              for (i=0; i < N>>2; i+=j)                                   */
/*              {                                                           */
/*                  theta1 = 2*PI*i/N;                                      */
/*                  x_t = cos(theta1);                                      */
/*                  y_t = sin(theta1);                                      */
/*                  w[k]   =  (float)x_t;                                   */
/*                  w[k+1] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta2 = 4*PI*i/N;                                      */
/*                  x_t = cos(theta2);                                      */
/*                  y_t = sin(theta2);                                      */
/*                  w[k+2] =  (float)x_t;                                   */
/*                  w[k+3] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta3 = 6*PI*i/N;                                      */
/*                  x_t = cos(theta3);                                      */
/*                  y_t = sin(theta3);                                      */
/*                  w[k+4] =  (float)x_t;                                   */
/*                  w[k+5] =  (float)y_t;                                   */
/*                  k+=6;                                                   */
/*               }                                                          */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      This redundant set of twiddle factors is size 2*N float samples.    */
/*      The function is accurate to about 130dB of signal to noise ratio    */
/*      to the DFT function below:                                          */
/*                                                                          */
/*      void dft(int N, float x[], float y[])                               */
/*      {                                                                   */
/*          int k,i, index;                                                 */
/*          const float PI = 3.14159654;                                    */
/*          float * p_x;                                                    */
/*          float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      */
/*                                                                          */
/*          for(k = 0; k<N; k++)                                            */
/*          {                                                               */
/*              p_x = x;                                                    */
/*              fy_0 = 0;                                                   */
/*              fy_1 = 0;                                                   */
/*              for(i=0; i<N; i++)                                          */
/*              {                                                           */
/*                  fx_0 = p_x[0];                                          */
/*                  fx_1 = p_x[1];                                          */
/*                  p_x += 2;                                               */
/*                  index = (i*k) % N;                                      */
/*                  arg = 2*PI*index/N;                                     */
/*                  co = cos(arg);                                          */
/*                  si = -sin(arg);                                         */
/*                  fy_0 += ((fx_0 * co) - (fx_1 * si));                    */
/*                  fy_1 += ((fx_1 * co) + (fx_0 * si));                    */
/*              }                                                           */
/*              y[2*k] = fy_0;                                              */
/*              y[2*k+1] = fy_1;                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      The function takes the table and input data and calculates the fft  */
/*      producing the frequency domain data in the Y array.                 */
/*      As the fft allows every input point to effect every output point    */
/*      in a cache based system such as the c6711, this causes cache        */
/*      thrashing. This is mitigated by allowing the main fft of size N to  */
/*      be divided into several steps, allowing as much data reuse as       */
/*      possible.                                                           */
/*                                                                          */
/*      For example the following function:                                 */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           */
/*      DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           */
/*                                                                          */
/*      Notice how the 1st fft function is called on the entire 1K data     */
/*      set it covers the 1st pass of the fft until the butterfly size is   */
/*      256. The following 4 ffts do 256 pt ffts 25% of the size. These     */
/*      continue down to the end when the buttefly is of size 4. They use   */
/*      an index the main twiddle factor array of 0.75*2*N. This is         */
/*      because the twiddle factor array is composed of successively        */
/*      decimated versions of the main array.                               */
/*                                                                          */
/*      N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*      decompose the fft the following would be needed :                   */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            */
/*      DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            */
/*                                                                          */
/*      The twiddle factor array is composed of log4(N) sets of twiddle     */
/*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*      array for each stage of the fft is calculated by summing these      */
/*      indices up appropriately.                                           */
/*                                                                          */
/*      For multiple ffts they can share the same table by calling the      */
/*      small ffts from further down in the twiddle factor array. In the    */
/*      smae way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      Thus, the above decomposition can be summarized for a general N,    */
/*      radix "rad" as follows:                                             */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         */
/*                                                                          */
/*      As discussed previously, N can be either a power of 4 or 2.         */
/*      If N is a power of 4, then rad = 4, and if N is a power of 2 and    */
/*      not a power of 4, then rad = 2. "rad" is used to control how many   */
/*      stages of decomposition are performed. It is also used to           */
/*      determine whether a radix-4 or radix-2 decomposition should be      */
/*      performed at the last stage. Hence when "rad" is set to "N/4" the   */
/*      first stage of the transform alone is performed and the code        */
/*      exits. To complete the FFT, four other calls are required to        */
/*      perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        */
/*      amongst themselves does not matter and hence from a cache           */
/*      perspective, it helps to go through the remaining 4 FFTs in         */
/*      exactly the opposite order to the first. This is illustrated as     */
/*      follows:                                                            */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         */
/*      DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         */
/*                                                                          */
/*      In addition this function can be used to minimize call overhead,    */
/*      by completing the FFT with one function call invocation as shown    */
/*      below:                                                              */
/*                                                                          */
/*      DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. A special sequence of coeffs. used as generated above            */
/*         produces the fft. This collapses the inner 2 loops in the        */
/*         taditional Burrus and Parks implementation Fortran Code.         */
/*                                                                          */
/*      2. The revised FFT uses a redundant sequence of twiddle factors to  */
/*         allow a linear access through the data. This linear access       */
/*         enables data and instruction level parallelism.                  */
/*                                                                          */
/*      3. The data produced by the fftSPxSP fft is in normal form, the     */
/*         whole data array is written into a new output buffer.            */
/*                                                                          */
/*      4. The fftSPxSP butterfly is bit reversed, i.e. the inner 2 points  */
/*         of the butterfly are corssed over, this has the effect of        */
/*         making the data come out in bit reversed rather than fftSPxSP    */
/*         digit reversed order. This simplifies the last pass of the       */
/*         loop. A simple table is used to do the bit reversal out of       */
/*         place.                                                           */
/*                                                                          */
/*             unsigned char brev[64] =                                     */
/*             {                                                            */
/*                   0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,          */
/*                   0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,          */
/*                   0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,          */
/*                   0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,          */
/*                   0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,          */
/*                   0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,          */
/*                   0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,          */
/*                   0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f           */
/*             };                                                           */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. N must be a power of 2 and N >= 8  N <= 16384 points.            */
/*                                                                          */
/*      2. Complex time data x and twiddle facotrs w are aligned on double  */
/*         word boundares. Real values are stored in even word positions    */
/*         and imaginary values in odd positions.                           */
/*                                                                          */
/*      3. All data is in single precision floating point format. The       */
/*         complex frequency data will be returned in linear order.         */
/*                                                                          */
/*      4. This code is interupt tolerant, interupts are disabled on entry  */
/*         to each loop and reanlbed on exit out of the loop.               */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions may  */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_fftSPxSP                                                    */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      )                                                                   */
/*      {                                                                   */
/*          int  i, j, k, l1, l2, h2, predj;                                */
/*          int  tw_offset, stride, fft_jmp;                                */
/*                                                                          */
/*          float x0, x1, x2, x3,x4,x5,x6,x7;                               */
/*          float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        */
/*          float yt4, yt5, yt6, yt7;                                       */
/*          float si1,si2,si3,co1,co2,co3;                                  */
/*          float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      */
/*          float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      */
/*          float xl0_0, xl1_0, xl0_1, xl1_1;                               */
/*          float xh0_0, xh1_0, xh0_1, xh1_1;                               */
/*          float *x,*w;                                                    */
/*          int   k0, k1, j0, j1, l0, radix;                                */
/*          float * y0, * ptr_x0, * ptr_x2;                                 */
/*                                                                          */
/*          radix = n_min;                                                  */
/*                                                                          */
/*          stride = N; // N is the number of complex samples //            */
/*          tw_offset = 0;                                                  */
/*          while (stride > radix)                                          */
/*          {                                                               */
/*              j = 0;                                                      */
/*              fft_jmp = stride + (stride>>1);                             */
/*              h2 = stride>>1;                                             */
/*              l1 = stride;                                                */
/*              l2 = stride + (stride>>1);                                  */
/*              x = ptr_x;                                                  */
/*              w = ptr_w + tw_offset;                                      */
/*                                                                          */
/*              for (i = 0; i < N; i += 4)                                  */
/*              {                                                           */
/*                  co1 = w[j];                                             */
/*                  si1 = w[j+1];                                           */
/*                  co2 = w[j+2];                                           */
/*                  si2 = w[j+3];                                           */
/*                  co3 = w[j+4];                                           */
/*                  si3 = w[j+5];                                           */
/*                                                                          */
/*                  x_0    = x[0];                                          */
/*                  x_1    = x[1];                                          */
/*                  x_h2   = x[h2];                                         */
/*                  x_h2p1 = x[h2+1];                                       */
/*                  x_l1   = x[l1];                                         */
/*                  x_l1p1 = x[l1+1];                                       */
/*                  x_l2   = x[l2];                                         */
/*                  x_l2p1 = x[l2+1];                                       */
/*                                                                          */
/*                  xh0  = x_0    + x_l1;                                   */
/*                  xh1  = x_1    + x_l1p1;                                 */
/*                  xl0  = x_0    - x_l1;                                   */
/*                  xl1  = x_1    - x_l1p1;                                 */
/*                                                                          */
/*                  xh20 = x_h2   + x_l2;                                   */
/*                  xh21 = x_h2p1 + x_l2p1;                                 */
/*                  xl20 = x_h2   - x_l2;                                   */
/*                  xl21 = x_h2p1 - x_l2p1;                                 */
/*                                                                          */
/*                  ptr_x0 = x;                                             */
/*                  ptr_x0[0] = xh0 + xh20;                                 */
/*                  ptr_x0[1] = xh1 + xh21;                                 */
/*                                                                          */
/*                  ptr_x2 = ptr_x0;                                        */
/*                  x += 2;                                                 */
/*                  j += 6;                                                 */
/*                  predj = (j - fft_jmp);                                  */
/*                  if (!predj) x += fft_jmp;                               */
/*                  if (!predj) j = 0;                                      */
/*                                                                          */
/*                  xt0 = xh0 - xh20;                                       */
/*                  yt0 = xh1 - xh21;                                       */
/*                  xt1 = xl0 + xl21;                                       */
/*                  yt2 = xl1 + xl20;                                       */
/*                  xt2 = xl0 - xl21;                                       */
/*                  yt1 = xl1 - xl20;                                       */
/*                                                                          */
/*                  ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;                   */
/*                  ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;                   */
/*                  ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;                   */
/*                  ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;                   */
/*                  ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;                   */
/*                  ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;                   */
/*              }                                                           */
/*                                                                          */
/*              tw_offset += fft_jmp;                                       */
/*              stride = stride>>2;                                         */
/*          }// end while //                                                */
/*                                                                          */
/*          j = offset>>2;                                                  */
/*                                                                          */
/*          ptr_x0 = ptr_x;                                                 */
/*          y0 = ptr_y;                                                     */
/*          //l0 = _norm(n_max) - 17;    get size of fft //                 */
/*          l0=0;                                                           */
/*                                                                          */
/*          for(k=30;k>=0;k--)                                              */
/*              if( (n_max & (1 << k)) == 0 )                               */
/*                  l0++;                                                   */
/*          else                                                            */
/*              break;                                                      */
/*                                                                          */
/*          l0=l0-17;                                                       */
/*          if (radix <= 4) for (i = 0; i < N; i += 4)                      */
/*          {                                                               */
/*              // reversal computation //                                  */
/*              j0 = (j     ) & 0x3F;                                       */
/*              j1 = (j >> 6);                                              */
/*              k0 = brev[j0];                                              */
/*              k1 = brev[j1];                                              */
/*              k = (k0 << 6) +  k1;                                        */
/*              k = k >> l0;                                                */
/*              j++;        // multiple of 4 index //                       */
/*                                                                          */
/*              x0   = ptr_x0[0];  x1 = ptr_x0[1];                          */
/*              x2   = ptr_x0[2];  x3 = ptr_x0[3];                          */
/*              x4   = ptr_x0[4];  x5 = ptr_x0[5];                          */
/*              x6   = ptr_x0[6];  x7 = ptr_x0[7];                          */
/*              ptr_x0 += 8;                                                */
/*                                                                          */
/*              xh0_0  = x0 + x4;                                           */
/*              xh1_0  = x1 + x5;                                           */
/*              xh0_1  = x2 + x6;                                           */
/*              xh1_1  = x3 + x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xh0_0 = x0;                                             */
/*                  xh1_0 = x1;                                             */
/*                  xh0_1 = x2;                                             */
/*                  xh1_1 = x3;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt0  = xh0_0 + xh0_1;                                       */
/*              yt1  = xh1_0 + xh1_1;                                       */
/*              yt4  = xh0_0 - xh0_1;                                       */
/*              yt5  = xh1_0 - xh1_1;                                       */
/*                                                                          */
/*              xl0_0  = x0 - x4;                                           */
/*              xl1_0  = x1 - x5;                                           */
/*              xl0_1  = x2 - x6;                                           */
/*              xl1_1  = x3 - x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xl0_0 = x4;                                             */
/*                  xl1_0 = x5;                                             */
/*                  xl1_1 = x6;                                             */
/*                  xl0_1 = x7;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt2  = xl0_0 + xl1_1;                                       */
/*              yt3  = xl1_0 - xl0_1;                                       */
/*              yt6  = xl0_0 - xl1_1;                                       */
/*              yt7  = xl1_0 + xl0_1;                                       */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  yt7  = xl1_0 - xl0_1;                                   */
/*                  yt3  = xl1_0 + xl0_1;                                   */
/*              }                                                           */
/*                                                                          */
/*              y0[k] = yt0; y0[k+1] = yt1;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt2; y0[k+1] = yt3;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt4; y0[k+1] = yt5;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt6; y0[k+1] = yt7;                                 */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      Configuration is LITTLE ENDIAN.                                     */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   */
/*      e.g. N = 1024,  cycles = 14464                                      */
/*      e.g. N = 512,   cycles = 7296                                       */
/*      e.g. N = 256,   cycles = 2923                                       */
/*      e.g. N = 128,   cycles = 1515                                       */
/*      e.g. N = 64,    cycles = 598                                        */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      1472 bytes                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FFTSPXSP_H_
#define DSPF_SP_FFTSPXSP_H_ 1

void DSPF_sp_fftSPxSP
(
    int N,
    float * ptr_x,
    float * ptr_w,
    float * ptr_y,
    unsigned char * brev,
    int n_min,
    int offset,
    int n_max
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_fftSPxSP.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_fftSPxS/1117057341  1396  0     0       36898     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fftSPxSP -- Single Precision floating point mixed radix          *
*      forwards FFT with complex input                                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of fft in complex samples, power of 2 such that    *
*                    N >=8 and N<= 16385.                                   *
*       ptr_x  :  Pointer to complex data input.                            *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data.                           *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest fft butterfly used in computation used for       *
*                 decomposing fft into subffts, see notes.                  *
*       offset :  Index in complex samples of sub-fft from start of main    *
*                 fft.                                                      *
*       n_max  :  size of main fft in complex samples.                      *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards fft using a special   *
*       sequece of coefficients generated in the following way:             *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the fft  *
*       producing the frequency domain data in the Y array.                 *
*       As the fft allows every input point to effect every output point    *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main fft of size N to  *
*       be divided into several steps, allowing as much data reuse as       *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                   *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;           *
*       DSPF_sp_fftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;           *
*                                                                           *
*       Notice how the 1st fft function is called on the entire 1K data     *
*       set it covers the 1st pass of the fft until the butterfly size is   *
*       256. The following 4 ffts do 256 pt ffts 25% of the size. These     *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the fft the following would be needed :                   *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                     *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_fftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)            *
*       DSPF_sp_fftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)            *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the fft is calculated by summing these      *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array. In the    *
*       smae way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the FFT, four other calls are required to        *
*       perform N/4 size FFTs. In fact, the ordering of these 4 FFTs        *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 FFTs in         *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)         *
*       DSPF_sp_fftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)         *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the FFT with one function call invocation as shown    *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_fftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)         *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the fft. This collapses the inner 2 loops in the        *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised FFT uses a redundant sequence of twiddle factors to  *
*          allow a linear access through the data. This linear access       *
*          enables data and instruction level parallelism.                  *
*                                                                           *
*       3. The data produced by the fftSPxSP fft is in normal form, the     *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The fftSPxSP butterfly is bit reversed, i.e. the inner 2 points  *
*          of the butterfly are corssed over, this has the effect of        *
*          making the data come out in bit reversed rather than fftSPxSP    *
*          digit reversed order. This simplifies the last pass of the       *
*          loop. A simple table is used to do the bit reversal out of       *
*          place.                                                           *
*                                                                           *
*              unsigned char brev[64] =                                     *
*              {                                                            *
*                    0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,          *
*                    0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,          *
*                    0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,          *
*                    0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,          *
*                    0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,          *
*                    0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,          *
*                    0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,          *
*                    0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f           *
*              };                                                           *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on double  *
*          word boundares. Real values are stored in even word positions    *
*          and imaginary values in odd positions.                           *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on entry  *
*          to each loop and reanlbed on exit out of the loop.               *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fftSPxSP                                                    *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       )                                                                   *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, fft_jmp;                                *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               fft_jmp = stride + (stride>>1);                             *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - fft_jmp);                                  *
*                   if (!predj) x += fft_jmp;                               *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 + xl21;                                       *
*                   yt2 = xl1 + xl20;                                       *
*                   xt2 = xl0 - xl21;                                       *
*                   yt1 = xl1 - xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 + yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 - xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 + yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 - xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 + yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 - xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += fft_jmp;                                       *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of fft */                 *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       1472 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_fftSPxSP

*  ======================================================================== *
*   End of file:  DSPF_sp_fftSPxSP.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_ifftSPx/1117057343  1418  0     0       37500     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         */
/*     inverse FFT with complex input                                      */
/*                                                                         */
/*  USAGE                                                                   */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*                                                                          */
/*      void DSPF_sp_ifftSPxSP                                                   */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*                                                                          */
/*      N      :  Length of ifft in complex samples, power of 2 such that   */
/*                N >=8 and N<= 16385.                                      */
/*      ptr_x  :  Pointer to complex data input (normal order).             */
/*      ptr_w  :  Pointer to complex twiddle factor (see below).            */
/*      ptr_y  :  Pointer to complex output data (normal order).            */
/*      brev   :  Pointer to bit reverse table containing 64 entries.       */
/*      n_min  :  Smallest ifft butterfly used in computation used for      */
/*                decomposing ifft into sub iffts, see notes.               */
/*      offset :  Index in complex samples of sub-ifft from start of main   */
/*                ifft.                                                     */
/*      n_max  :  size of main ifft in complex samples.                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The benchmark performs a mixed radix forwards ifft using a special  */
/*      sequence of coefficients generated in the following way:            */
/*                                                                          */
/*      // generate vector of twiddle factors for optimized algorithm //    */
/*      void tw_gen(float * w, int N)                                       */
/*      {                                                                   */
/*          int j, k;                                                       */
/*          double x_t, y_t, theta1, theta2, theta3;                        */
/*          const double PI = 3.141592654;                                  */
/*                                                                          */
/*          for (j=1, k=0; j <= N>>2; j = j<<2)                             */
/*          {                                                               */
/*              for (i=0; i < N>>2; i+=j)                                   */
/*              {                                                           */
/*                  theta1 = 2*PI*i/N;                                      */
/*                  x_t = cos(theta1);                                      */
/*                  y_t = sin(theta1);                                      */
/*                  w[k]   =  (float)x_t;                                   */
/*                  w[k+1] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta2 = 4*PI*i/N;                                      */
/*                  x_t = cos(theta2);                                      */
/*                  y_t = sin(theta2);                                      */
/*                  w[k+2] =  (float)x_t;                                   */
/*                  w[k+3] =  (float)y_t;                                   */
/*                                                                          */
/*                  theta3 = 6*PI*i/N;                                      */
/*                  x_t = cos(theta3);                                      */
/*                  y_t = sin(theta3);                                      */
/*                  w[k+4] =  (float)x_t;                                   */
/*                  w[k+5] =  (float)y_t;                                   */
/*                  k+=6;                                                   */
/*               }                                                          */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      This redundant set of twiddle factors is size 2*N float samples.    */
/*      The function is accurate to about 130dB of signal to noise ratio    */
/*      to the DFT function below:                                          */
/*                                                                          */
/*      void dft(int N, float x[], float y[])                               */
/*      {                                                                   */
/*          int k,i, index;                                                 */
/*          const float PI = 3.14159654;                                    */
/*          float * p_x;                                                    */
/*          float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      */
/*                                                                          */
/*          for(k = 0; k<N; k++)                                            */
/*          {                                                               */
/*              p_x = x;                                                    */
/*              fy_0 = 0;                                                   */
/*              fy_1 = 0;                                                   */
/*              for(i=0; i<N; i++)                                          */
/*              {                                                           */
/*                  fx_0 = p_x[0];                                          */
/*                  fx_1 = p_x[1];                                          */
/*                  p_x += 2;                                               */
/*                  index = (i*k) % N;                                      */
/*                  arg = 2*PI*index/N;                                     */
/*                  co = cos(arg);                                          */
/*                  si = -sin(arg);                                         */
/*                  fy_0 += ((fx_0 * co) - (fx_1 * si));                    */
/*                  fy_1 += ((fx_1 * co) + (fx_0 * si));                    */
/*              }                                                           */
/*              y[2*k] = fy_0;                                              */
/*              y[2*k+1] = fy_1;                                            */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*      The function takes the table and input data and calculates the      */
/*      ifft producing the time domain data in the Y array. The output is   */
/*      scaled by a scaling factor of 1/N.                                  */
/*                                                                          */
/*      As the ifft allows every input point to effect every output point   */
/*      in a cache based system such as the c6711, this causes cache        */
/*      thrashing. This is mitigated by allowing the main ifft of size N    */
/*      to be divided into several steps, allowing as much data reuse as    */
/*      possible.                                                           */
/*                                                                          */
/*      For example the following function:                                 */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          */
/*      DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          */
/*                                                                          */
/*      Notice how the 1st ifft function is called on the entire 1K data    */
/*      set it covers the 1st pass of the ifft until the butterfly size is  */
/*      256. The following 4 iffts do 256 pt iffts 25% of the size. These   */
/*      continue down to the end when the buttefly is of size 4. They use   */
/*      an index the main twiddle factor array of 0.75*2*N. This is         */
/*      because the twiddle factor array is composed of successively        */
/*      decimated versions of the main array.                               */
/*                                                                          */
/*      N not equal to a power of 4 can be used, i.e. 512. In this case to  */
/*      decompose the ifft the following would be needed :                  */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    */
/*                                                                          */
/*      is equvalent to:                                                    */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           */
/*      DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           */
/*                                                                          */
/*      The twiddle factor array is composed of log4(N) sets of twiddle     */
/*      factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     */
/*      array for each stage of the ifft is calculated by summing these     */
/*      indices up appropriately.                                           */
/*                                                                          */
/*      For multiple iffts they can share the same table by calling the     */
/*      small iffts from further down in the twiddle factor array. In the   */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      Thus, the above decomposition can be summarized for a general N,    */
/*      radix "rad" as follows:                                             */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        */
/*                                                                          */
/*      As discussed previously, N can be either a power of 4 or 2.         */
/*      If N is a power of 4, then rad = 4, and if N is a power of 2 and    */
/*      not a power of 4, then rad = 2. "rad" is used to control how many   */
/*      stages of decomposition are performed. It is also used to           */
/*      determine whether a radix-4 or radix-2 decomposition should be      */
/*      performed at the last stage. Hence when "rad" is set to "N/4" the   */
/*      first stage of the transform alone is performed and the code        */
/*      exits. To complete the IFFT, four other calls are required to       */
/*      perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      */
/*      amongst themselves does not matter and hence from a cache           */
/*      perspective, it helps to go through the remaining 4 IFFTs in        */
/*      exactly the opposite order to the first. This is illustrated as     */
/*      follows:                                                            */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        */
/*      DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        */
/*                                                                          */
/*      In addition this function can be used to minimize call overhead,    */
/*      by completing the IFFT with one function call invocation as shown   */
/*      below:                                                              */
/*                                                                          */
/*      DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. A special sequence of coeffs. used as generated above            */
/*         produces the ifft. This collapses the inner 2 loops in the       */
/*         taditional Burrus and Parks implementation Fortran Code.         */
/*                                                                          */
/*      2. The revised IFFT uses a redundant sequence of twiddle            */
/*         factors to allow a linear access through the data. This linear   */
/*         access enables data and instruction level parallelism.           */
/*                                                                          */
/*      3.The data produced by the ifftSPxSP ifft is in normal form, the    */
/*         whole data array is written into a new output buffer.            */
/*                                                                          */
/*      4. The ifftSPxSP butterfly is bit reversed, i.e. the inner 2        */
/*         points of the butterfly are corssed over, this has the effect    */
/*         of making the data come out in bit reversed rather than          */
/*         ifftSPxSP digit reversed order. This simplifies the last pass    */
/*         of the loop. A simple table is used to do the bit reversal out   */
/*         of place.                                                        */
/*                                                                          */
/*      unsigned char brev[64] =                                            */
/*      {                                                                   */
/*          0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,                   */
/*          0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,                   */
/*          0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,                   */
/*          0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,                   */
/*          0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,                   */
/*          0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,                   */
/*          0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,                   */
/*          0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f                    */
/*      };                                                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*      1. N must be a power of 2 and N >= 8  N <= 16384 points.            */
/*                                                                          */
/*      2. Complex time data x and twiddle facotrs w are aligned on         */
/*         double word boundares. Real values are stored in even word       */
/*         positions and imaginary values in odd positions.                 */
/*                                                                          */
/*      3. All data is in single precision floating point format. The       */
/*         complex frequency data will be returned in linear order.         */
/*                                                                          */
/*      4. This code is interupt tolerant, interupts are disabled on        */
/*         entry to each loop and reanlbed on exit out of the loop.         */
/*                                                                          */
/*      5. x must be padded with 16 words at the end.                       */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*      Note that the assembly code is hand optimized and restrictions may  */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_ifftSPxSP                                                   */
/*      (                                                                   */
/*          int N,                                                          */
/*          float * ptr_x,                                                  */
/*          float * ptr_w,                                                  */
/*          float * ptr_y,                                                  */
/*          unsigned char * brev,                                           */
/*          int n_min,                                                      */
/*          int offset,                                                     */
/*          int n_max                                                       */
/*      );                                                                  */
/*      {                                                                   */
/*          int  i, j, k, l1, l2, h2, predj;                                */
/*          int  tw_offset, stride, ifft_jmp;                               */
/*                                                                          */
/*          float x0, x1, x2, x3,x4,x5,x6,x7;                               */
/*          float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        */
/*          float yt4, yt5, yt6, yt7;                                       */
/*          float si1,si2,si3,co1,co2,co3;                                  */
/*          float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      */
/*          float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      */
/*          float xl0_0, xl1_0, xl0_1, xl1_1;                               */
/*          float xh0_0, xh1_0, xh0_1, xh1_1;                               */
/*          float *x,*w;                                                    */
/*          int   k0, k1, j0, j1, l0, radix;                                */
/*          float * y0, * ptr_x0, * ptr_x2;                                 */
/*                                                                          */
/*          radix = n_min;                                                  */
/*                                                                          */
/*          stride = N; // N is the number of complex samples //            */
/*          tw_offset = 0;                                                  */
/*          while (stride > radix)                                          */
/*          {                                                               */
/*              j = 0;                                                      */
/*              ifft_jmp = stride + (stride>>1);                            */
/*              h2 = stride>>1;                                             */
/*              l1 = stride;                                                */
/*              l2 = stride + (stride>>1);                                  */
/*              x = ptr_x;                                                  */
/*              w = ptr_w + tw_offset;                                      */
/*                                                                          */
/*              for (i = 0; i < N; i += 4)                                  */
/*              {                                                           */
/*                  co1 = w[j];                                             */
/*                  si1 = w[j+1];                                           */
/*                  co2 = w[j+2];                                           */
/*                  si2 = w[j+3];                                           */
/*                  co3 = w[j+4];                                           */
/*                  si3 = w[j+5];                                           */
/*                                                                          */
/*                  x_0    = x[0];                                          */
/*                  x_1    = x[1];                                          */
/*                  x_h2   = x[h2];                                         */
/*                  x_h2p1 = x[h2+1];                                       */
/*                  x_l1   = x[l1];                                         */
/*                  x_l1p1 = x[l1+1];                                       */
/*                  x_l2   = x[l2];                                         */
/*                  x_l2p1 = x[l2+1];                                       */
/*                                                                          */
/*                  xh0  = x_0    + x_l1;                                   */
/*                  xh1  = x_1    + x_l1p1;                                 */
/*                  xl0  = x_0    - x_l1;                                   */
/*                  xl1  = x_1    - x_l1p1;                                 */
/*                                                                          */
/*                  xh20 = x_h2   + x_l2;                                   */
/*                  xh21 = x_h2p1 + x_l2p1;                                 */
/*                  xl20 = x_h2   - x_l2;                                   */
/*                  xl21 = x_h2p1 - x_l2p1;                                 */
/*                                                                          */
/*                  ptr_x0 = x;                                             */
/*                  ptr_x0[0] = xh0 + xh20;                                 */
/*                  ptr_x0[1] = xh1 + xh21;                                 */
/*                                                                          */
/*                  ptr_x2 = ptr_x0;                                        */
/*                  x += 2;                                                 */
/*                  j += 6;                                                 */
/*                  predj = (j - ifft_jmp);                                 */
/*                  if (!predj) x += ifft_jmp;                              */
/*                  if (!predj) j = 0;                                      */
/*                                                                          */
/*                  xt0 = xh0 - xh20;                                       */
/*                  yt0 = xh1 - xh21;                                       */
/*                  xt1 = xl0 - xl21;                                       */
/*                  yt2 = xl1 - xl20;                                       */
/*                  xt2 = xl0 + xl21;                                       */
/*                  yt1 = xl1 + xl20;                                       */
/*                                                                          */
/*                  ptr_x2[l1  ] = xt1 * co1 - yt1 * si1;                   */
/*                  ptr_x2[l1+1] = yt1 * co1 + xt1 * si1;                   */
/*                  ptr_x2[h2  ] = xt0 * co2 - yt0 * si2;                   */
/*                  ptr_x2[h2+1] = yt0 * co2 + xt0 * si2;                   */
/*                  ptr_x2[l2  ] = xt2 * co3 - yt2 * si3;                   */
/*                  ptr_x2[l2+1] = yt2 * co3 + xt2 * si3;                   */
/*              }                                                           */
/*                                                                          */
/*              tw_offset += ifft_jmp;                                      */
/*              stride = stride>>2;                                         */
/*          }// end while //                                                */
/*                                                                          */
/*          j = offset>>2;                                                  */
/*                                                                          */
/*          ptr_x0 = ptr_x;                                                 */
/*          y0 = ptr_y;                                                     */
/*          //l0 = _norm(n_max) - 17;    get size of ifft //                */
/*          l0=0;                                                           */
/*                                                                          */
/*          for(k=30;k>=0;k--)                                              */
/*              if( (n_max & (1 << k)) == 0 )                               */
/*                  l0++;                                                   */
/*          else                                                            */
/*              break;                                                      */
/*                                                                          */
/*          l0=l0-17;                                                       */
/*          if (radix <= 4) for (i = 0; i < N; i += 4)                      */
/*          {                                                               */
/*              // reversal computation //                                  */
/*              j0 = (j     ) & 0x3F;                                       */
/*              j1 = (j >> 6);                                              */
/*              k0 = brev[j0];                                              */
/*              k1 = brev[j1];                                              */
/*              k = (k0 << 6) +  k1;                                        */
/*              k = k >> l0;                                                */
/*              j++;        // multiple of 4 index //                       */
/*                                                                          */
/*              x0   = ptr_x0[0];  x1 = ptr_x0[1];                          */
/*              x2   = ptr_x0[2];  x3 = ptr_x0[3];                          */
/*              x4   = ptr_x0[4];  x5 = ptr_x0[5];                          */
/*              x6   = ptr_x0[6];  x7 = ptr_x0[7];                          */
/*              ptr_x0 += 8;                                                */
/*                                                                          */
/*              xh0_0  = x0 + x4;                                           */
/*              xh1_0  = x1 + x5;                                           */
/*              xh0_1  = x2 + x6;                                           */
/*              xh1_1  = x3 + x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xh0_0 = x0;                                             */
/*                  xh1_0 = x1;                                             */
/*                  xh0_1 = x2;                                             */
/*                  xh1_1 = x3;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt0  = xh0_0 + xh0_1;                                       */
/*              yt1  = xh1_0 + xh1_1;                                       */
/*              yt4  = xh0_0 - xh0_1;                                       */
/*              yt5  = xh1_0 - xh1_1;                                       */
/*                                                                          */
/*              xl0_0  = x0 - x4;                                           */
/*              xl1_0  = x1 - x5;                                           */
/*              xl0_1  = x2 - x6;                                           */
/*              xl1_1  = x3 - x7;                                           */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  xl0_0 = x4;                                             */
/*                  xl1_0 = x5;                                             */
/*                  xl1_1 = x6;                                             */
/*                  xl0_1 = x7;                                             */
/*              }                                                           */
/*                                                                          */
/*              yt2  = xl0_0 + xl1_1;                                       */
/*              yt3  = xl1_0 - xl0_1;                                       */
/*              yt6  = xl0_0 - xl1_1;                                       */
/*              yt7  = xl1_0 + xl0_1;                                       */
/*                                                                          */
/*              if (radix == 2)                                             */
/*              {                                                           */
/*                  yt7  = xl1_0 - xl0_1;                                   */
/*                  yt3  = xl1_0 + xl0_1;                                   */
/*              }                                                           */
/*                                                                          */
/*              y0[k] = yt0; y0[k+1] = yt1;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt2; y0[k+1] = yt3;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt4; y0[k+1] = yt5;                                 */
/*              k += n_max>>1;                                              */
/*              y0[k] = yt6; y0[k+1] = yt7;                                 */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      Configuration is LITTLE ENDIAN.                                     */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   */
/*      e.g. N = 1024,  cycles = 14464                                      */
/*      e.g. N = 512,   cycles = 7296                                       */
/*      e.g. N = 256,   cycles = 2923                                       */
/*      e.g. N = 128,   cycles = 1515                                       */
/*      e.g. N = 64,    cycles = 598                                        */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*      1504 bytes                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_IFFTSPXSP_H_
#define DSPF_SP_IFFTSPXSP_H_ 1

void DSPF_sp_ifftSPxSP
(
    int N,
    float * ptr_x,
    float * ptr_w,
    float * ptr_y,
    unsigned char * brev,
    int n_min,
    int offset,
    int n_max
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_ifftSPxSP.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_ifftSPx/1117057342  1439  0     0       37136     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_ifftSPxSP -- Single Precision floating point mixed radix         *
*      inverse FFT with complex input                                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*                                                                           *
*       N      :  Length of ifft in complex samples, power of 2 such that   *
*                 N >=8 and N<= 16385.                                      *
*       ptr_x  :  Pointer to complex data input (normal order).             *
*       ptr_w  :  Pointer to complex twiddle factor (see below).            *
*       ptr_y  :  Pointer to complex output data (normal order).            *
*       brev   :  Pointer to bit reverse table containing 64 entries.       *
*       n_min  :  Smallest ifft butterfly used in computation used for      *
*                 decomposing ifft into sub iffts, see notes.               *
*       offset :  Index in complex samples of sub-ifft from start of main   *
*                 ifft.                                                     *
*       n_max  :  size of main ifft in complex samples.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The benchmark performs a mixed radix forwards ifft using a special  *
*       sequence of coefficients generated in the following way:            *
*                                                                           *
*       /* generate vector of twiddle factors for optimized algorithm */    *
*       void tw_gen(float * w, int N)                                       *
*       {                                                                   *
*           int j, k;                                                       *
*           double x_t, y_t, theta1, theta2, theta3;                        *
*           const double PI = 3.141592654;                                  *
*                                                                           *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                             *
*           {                                                               *
*               for (i=0; i < N>>2; i+=j)                                   *
*               {                                                           *
*                   theta1 = 2*PI*i/N;                                      *
*                   x_t = cos(theta1);                                      *
*                   y_t = sin(theta1);                                      *
*                   w[k]   =  (float)x_t;                                   *
*                   w[k+1] =  (float)y_t;                                   *
*                                                                           *
*                   theta2 = 4*PI*i/N;                                      *
*                   x_t = cos(theta2);                                      *
*                   y_t = sin(theta2);                                      *
*                   w[k+2] =  (float)x_t;                                   *
*                   w[k+3] =  (float)y_t;                                   *
*                                                                           *
*                   theta3 = 6*PI*i/N;                                      *
*                   x_t = cos(theta3);                                      *
*                   y_t = sin(theta3);                                      *
*                   w[k+4] =  (float)x_t;                                   *
*                   w[k+5] =  (float)y_t;                                   *
*                   k+=6;                                                   *
*                }                                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       This redundant set of twiddle factors is size 2*N float samples.    *
*       The function is accurate to about 130dB of signal to noise ratio    *
*       to the DFT function below:                                          *
*                                                                           *
*       void dft(int N, float x[], float y[])                               *
*       {                                                                   *
*           int k,i, index;                                                 *
*           const float PI = 3.14159654;                                    *
*           float * p_x;                                                    *
*           float arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*           for(k = 0; k<N; k++)                                            *
*           {                                                               *
*               p_x = x;                                                    *
*               fy_0 = 0;                                                   *
*               fy_1 = 0;                                                   *
*               for(i=0; i<N; i++)                                          *
*               {                                                           *
*                   fx_0 = p_x[0];                                          *
*                   fx_1 = p_x[1];                                          *
*                   p_x += 2;                                               *
*                   index = (i*k) % N;                                      *
*                   arg = 2*PI*index/N;                                     *
*                   co = cos(arg);                                          *
*                   si = -sin(arg);                                         *
*                   fy_0 += ((fx_0 * co) - (fx_1 * si));                    *
*                   fy_1 += ((fx_1 * co) + (fx_0 * si));                    *
*               }                                                           *
*               y[2*k] = fy_0;                                              *
*               y[2*k+1] = fy_1;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*       The function takes the table and input data and calculates the      *
*       ifft producing the time domain data in the Y array. The output is   *
*       scaled by a scaling factor of 1/N.                                  *
*                                                                           *
*       As the ifft allows every input point to effect every output point   *
*       in a cache based system such as the c6711, this causes cache        *
*       thrashing. This is mitigated by allowing the main ifft of size N    *
*       to be divided into several steps, allowing as much data reuse as    *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024, &x[0],&w[0],y,brev,4,  0,1024);                  *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(1024,&x[2*0],  &w[0] ,   y,brev,256,  0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*0],  &w[2*768],y,brev,4,    0,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*256],&w[2*768],y,brev,4,  256,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*512],&w[2*768],y,brev,4,  512,1024;          *
*       DSPF_sp_ifftSPxSP(256, &x[2*768],&w[2*768],y,brev,4,  768,1024;          *
*                                                                           *
*       Notice how the 1st ifft function is called on the entire 1K data    *
*       set it covers the 1st pass of the ifft until the butterfly size is  *
*       256. The following 4 iffts do 256 pt iffts 25% of the size. These   *
*       continue down to the end when the buttefly is of size 4. They use   *
*       an index the main twiddle factor array of 0.75*2*N. This is         *
*       because the twiddle factor array is composed of successively        *
*       decimated versions of the main array.                               *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*       decompose the ifft the following would be needed :                  *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[0],&w[0],y,brev,2,  0,512);                    *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSPF_sp_ifftSPxSP(512, &x[2*0],  &w[0] ,   y,brev,128,  0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*0],  &w[2*384],y,brev,4,    0,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*128],&w[2*384],y,brev,4,  128,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*256],&w[2*384],y,brev,4,  256,512)           *
*       DSPF_sp_ifftSPxSP(128, &x[2*384],&w[2*384],y,brev,4,  384,512)           *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the ifft is calculated by summing these     *
*       indices up appropriately.                                           *
*                                                                           *
*       For multiple iffts they can share the same table by calling the     *
*       small iffts from further down in the twiddle factor array. In the   *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       Thus, the above decomposition can be summarized for a general N,    *
*       radix "rad" as follows:                                             *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*                                                                           *
*       As discussed previously, N can be either a power of 4 or 2.         *
*       If N is a power of 4, then rad = 4, and if N is a power of 2 and    *
*       not a power of 4, then rad = 2. "rad" is used to control how many   *
*       stages of decomposition are performed. It is also used to           *
*       determine whether a radix-4 or radix-2 decomposition should be      *
*       performed at the last stage. Hence when "rad" is set to "N/4" the   *
*       first stage of the transform alone is performed and the code        *
*       exits. To complete the IFFT, four other calls are required to       *
*       perform N/4 size IFFTs. In fact, the ordering of these 4 IFFTs      *
*       amongst themselves does not matter and hence from a cache           *
*       perspective, it helps to go through the remaining 4 IFFTs in        *
*       exactly the opposite order to the first. This is illustrated as     *
*       follows:                                                            *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y,brev,N/4,0,    N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*3*N/4],&w[2*3*N/4],y,brev,rad,3*N/4,N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/2],  &w[2*3*N/4],y,brev,rad,N/2,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[2*N/4],  &w[2*3*N/4],y,brev,rad,N/4,  N)        *
*       DSPF_sp_ifftSPxSP(N/4,&x[0],      &w[2*3*N/4],y,brev,rad,0,    N)        *
*                                                                           *
*       In addition this function can be used to minimize call overhead,    *
*       by completing the IFFT with one function call invocation as shown   *
*       below:                                                              *
*                                                                           *
*       DSPF_sp_ifftSPxSP(N,  &x[0],      &w[0],      y, brev, rad, 0, N)        *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. A special sequence of coeffs. used as generated above            *
*          produces the ifft. This collapses the inner 2 loops in the       *
*          taditional Burrus and Parks implementation Fortran Code.         *
*                                                                           *
*       2. The revised IFFT uses a redundant sequence of twiddle            *
*          factors to allow a linear access through the data. This linear   *
*          access enables data and instruction level parallelism.           *
*                                                                           *
*       3.The data produced by the ifftSPxSP ifft is in normal form, the    *
*          whole data array is written into a new output buffer.            *
*                                                                           *
*       4. The ifftSPxSP butterfly is bit reversed, i.e. the inner 2        *
*          points of the butterfly are corssed over, this has the effect    *
*          of making the data come out in bit reversed rather than          *
*          ifftSPxSP digit reversed order. This simplifies the last pass    *
*          of the loop. A simple table is used to do the bit reversal out   *
*          of place.                                                        *
*                                                                           *
*       unsigned char brev[64] =                                            *
*       {                                                                   *
*           0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,                   *
*           0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,                   *
*           0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,                   *
*           0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,                   *
*           0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,                   *
*           0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,                   *
*           0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,                   *
*           0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f                    *
*       };                                                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       1. N must be a power of 2 and N >= 8  N <= 16384 points.            *
*                                                                           *
*       2. Complex time data x and twiddle facotrs w are aligned on         *
*          double word boundares. Real values are stored in even word       *
*          positions and imaginary values in odd positions.                 *
*                                                                           *
*       3. All data is in single precision floating point format. The       *
*          complex frequency data will be returned in linear order.         *
*                                                                           *
*       4. This code is interupt tolerant, interupts are disabled on        *
*          entry to each loop and reanlbed on exit out of the loop.         *
*                                                                           *
*       5. x must be padded with 16 words at the end.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions.                                                       *
*                                                                           *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_ifftSPxSP                                                   *
*       (                                                                   *
*           int N,                                                          *
*           float * ptr_x,                                                  *
*           float * ptr_w,                                                  *
*           float * ptr_y,                                                  *
*           unsigned char * brev,                                           *
*           int n_min,                                                      *
*           int offset,                                                     *
*           int n_max                                                       *
*       );                                                                  *
*       {                                                                   *
*           int  i, j, k, l1, l2, h2, predj;                                *
*           int  tw_offset, stride, ifft_jmp;                               *
*                                                                           *
*           float x0, x1, x2, x3,x4,x5,x6,x7;                               *
*           float xt0, yt0, xt1, yt1, xt2, yt2, yt3;                        *
*           float yt4, yt5, yt6, yt7;                                       *
*           float si1,si2,si3,co1,co2,co3;                                  *
*           float xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           float x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           float xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           float xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           float *x,*w;                                                    *
*           int   k0, k1, j0, j1, l0, radix;                                *
*           float * y0, * ptr_x0, * ptr_x2;                                 *
*                                                                           *
*           radix = n_min;                                                  *
*                                                                           *
*           stride = N; /* N is the number of complex samples */            *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               ifft_jmp = stride + (stride>>1);                            *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < N; i += 4)                                  *
*               {                                                           *
*                   co1 = w[j];                                             *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = xh0 + xh20;                                 *
*                   ptr_x0[1] = xh1 + xh21;                                 *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   j += 6;                                                 *
*                   predj = (j - ifft_jmp);                                 *
*                   if (!predj) x += ifft_jmp;                              *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0 = xh0 - xh20;                                       *
*                   yt0 = xh1 - xh21;                                       *
*                   xt1 = xl0 - xl21;                                       *
*                   yt2 = xl1 - xl20;                                       *
*                   xt2 = xl0 + xl21;                                       *
*                   yt1 = xl1 + xl20;                                       *
*                                                                           *
*                   ptr_x2[l1  ] = xt1 * co1 - yt1 * si1;                   *
*                   ptr_x2[l1+1] = yt1 * co1 + xt1 * si1;                   *
*                   ptr_x2[h2  ] = xt0 * co2 - yt0 * si2;                   *
*                   ptr_x2[h2+1] = yt0 * co2 + xt0 * si2;                   *
*                   ptr_x2[l2  ] = xt2 * co3 - yt2 * si3;                   *
*                   ptr_x2[l2+1] = yt2 * co3 + xt2 * si3;                   *
*               }                                                           *
*                                                                           *
*               tw_offset += ifft_jmp;                                      *
*               stride = stride>>2;                                         *
*           }/* end while */                                                *
*                                                                           *
*           j = offset>>2;                                                  *
*                                                                           *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = ptr_y;                                                     *
*           /*l0 = _norm(n_max) - 17;    get size of ifft */                *
*           l0=0;                                                           *
*                                                                           *
*           for(k=30;k>=0;k--)                                              *
*               if( (n_max & (1 << k)) == 0 )                               *
*                   l0++;                                                   *
*           else                                                            *
*               break;                                                      *
*                                                                           *
*           l0=l0-17;                                                       *
*           if (radix <= 4) for (i = 0; i < N; i += 4)                      *
*           {                                                               *
*               /* reversal computation */                                  *
*               j0 = (j     ) & 0x3F;                                       *
*               j1 = (j >> 6);                                              *
*               k0 = brev[j0];                                              *
*               k1 = brev[j1];                                              *
*               k = (k0 << 6) +  k1;                                        *
*               k = k >> l0;                                                *
*               j++;        /* multiple of 4 index */                       *
*                                                                           *
*               x0   = ptr_x0[0];  x1 = ptr_x0[1];                          *
*               x2   = ptr_x0[2];  x3 = ptr_x0[3];                          *
*               x4   = ptr_x0[4];  x5 = ptr_x0[5];                          *
*               x6   = ptr_x0[6];  x7 = ptr_x0[7];                          *
*               ptr_x0 += 8;                                                *
*                                                                           *
*               xh0_0  = x0 + x4;                                           *
*               xh1_0  = x1 + x5;                                           *
*               xh0_1  = x2 + x6;                                           *
*               xh1_1  = x3 + x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xh0_0 = x0;                                             *
*                   xh1_0 = x1;                                             *
*                   xh0_1 = x2;                                             *
*                   xh1_1 = x3;                                             *
*               }                                                           *
*                                                                           *
*               yt0  = xh0_0 + xh0_1;                                       *
*               yt1  = xh1_0 + xh1_1;                                       *
*               yt4  = xh0_0 - xh0_1;                                       *
*               yt5  = xh1_0 - xh1_1;                                       *
*                                                                           *
*               xl0_0  = x0 - x4;                                           *
*               xl1_0  = x1 - x5;                                           *
*               xl0_1  = x2 - x6;                                           *
*               xl1_1  = x3 - x7;                                           *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   xl0_0 = x4;                                             *
*                   xl1_0 = x5;                                             *
*                   xl1_1 = x6;                                             *
*                   xl0_1 = x7;                                             *
*               }                                                           *
*                                                                           *
*               yt2  = xl0_0 + xl1_1;                                       *
*               yt3  = xl1_0 - xl0_1;                                       *
*               yt6  = xl0_0 - xl1_1;                                       *
*               yt7  = xl1_0 + xl0_1;                                       *
*                                                                           *
*               if (radix == 2)                                             *
*               {                                                           *
*                   yt7  = xl1_0 - xl0_1;                                   *
*                   yt3  = xl1_0 + xl0_1;                                   *
*               }                                                           *
*                                                                           *
*               y0[k] = yt0; y0[k+1] = yt1;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt2; y0[k+1] = yt3;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt4; y0[k+1] = yt5;                                 *
*               k += n_max>>1;                                              *
*               y0[k] = yt6; y0[k+1] = yt7;                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       Configuration is LITTLE ENDIAN.                                     *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       cycles = 3 * ceil(log4(N)-1) * N  + 21*ceil(log4(N)-1) + 2*N + 44   *
*       e.g. N = 1024,  cycles = 14464                                      *
*       e.g. N = 512,   cycles = 7296                                       *
*       e.g. N = 256,   cycles = 2923                                       *
*       e.g. N = 128,   cycles = 1515                                       *
*       e.g. N = 64,    cycles = 598                                        *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*       1504 bytes                                                          *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_ifftSPxSP

*  ======================================================================== *
*   End of file:  DSPF_sp_ifftSPxSP.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_icfftr2/1117057344  1462  0     0       17513     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C-callable and can be called as:                    */
/*                                                                          */
/*          void DSPF_sp_icfftr2_dif(                                            */
/*                              float* x,                                   */
/*                              float* w,                                   */
/*                              short n                                     */
/*                             );                                           */
/*                                                                          */
/*          x : input and output sequences (dim-n)      (input/output)      */
/*              x has n complex numbers (2*n SP values).                    */
/*              The real and imaginary values are interleaved in memory.    */
/*              The input is in Bit reversed order nad output is in Normal  */
/*              Order.                                                      */
/*          w : FFT coefficients (dim-n/2)              (input)             */
/*              w has n/2 complex numbers (n SP values).                    */
/*              FFT coeficients must be in bit-reversed order               */
/*              The real and imaginary values are interleaved in memory     */
/*          n : FFT size                                (input)             */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine is used to compute the Inverse, Complex, Radix-2,      */
/*      Decimation-in-Frequency Fast Fourier Transform of a single          */
/*      precision complex sequence of size n, and a power of 2. The         */
/*      routine requires bit-reversed input and bit-reversed coefficents    */
/*      (twiddle factors) and produces results that are in normal order.    */
/*      Final scaling by 1/N is not done in this function.                  */
/*                                                                          */
/*      How To Use                                                          */
/*                                                                          */
/*          void main(void)                                                 */
/*          {                                                               */
/*              gen_w_r2(w, N);      // Generate coefficient table          */
/*              bit_rev(w, N>>1);    // Bit-reverse coefficient table       */
/*              cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   */
/*                                   // from TI available                   */
/*                                   // input in normal order, output in    */
/*                                   // order bit-reversed                  */
/*                                   // coefficient table in bit-reversed   */
/*                                   // order                               */
/*                                                                          */
/*              icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 */
/*                                   // input in bit-reversed order,        */
/*                                   // order output in normal              */
/*                                   // coefficient table in bit-reversed   */
/*                                   // order                               */
/*                                                                          */
/*              divide(x, N);        // scale inverse FFT output            */
/*                                   // result is same as original input    */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. Loading input x as well as coefficient w in double word.         */
/*      2. mpy was used to perform a mv.  EX. mpy x, 1, y <=> mv x, y       */
/*      3. Because the data loads are 1 itteration ahead of the             */
/*         coefficent loads, counter i was copied so that the actual        */
/*         count could live longer for the coefficent loads.                */
/*      4. 2 Inner loops are callapsed into one loop.                       */
/*      5. prolog and epilog are done in parallel with the outermost loop.  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. Both input x and coefficient w should be aligned on double word  */
/*         boundary.                                                        */
/*      2. x should be padded with 4 words.                                 */
/*      3. n should be greater than 8.                                      */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code without               */
/*      restrictions. Note that the assembly code is hand optimized         */
/*      and restrictions may apply.                                         */
/*                                                                          */
/*          void icfftr2_dif(float* x, float* w, short n)                   */
/*          {                                                               */
/*              short n2, ie, ia, i, j, k, m;                               */
/*              float rtemp, itemp, c, s;                                   */
/*                                                                          */
/*              n2 = 1;                                                     */
/*              ie = n;                                                     */
/*              for(k=n; k > 1; k >>= 1)                                    */
/*              {                                                           */
/*                  ie >>= 1;                                               */
/*                  ia = 0;                                                 */
/*                  for(j=0; j < ie; j++)                                   */
/*                  {                                                       */
/*                      c = w[2*j];                                         */
/*                      s = w[2*j+1];                                       */
/*                      for(i=0; i < n2; i++)                               */
/*                      {                                                   */
/*                          m = ia + n2;                                    */
/*                          rtemp     = x[2*ia]   - x[2*m];                 */
/*                          x[2*ia]   = x[2*ia]   + x[2*m];                 */
/*                          itemp     = x[2*ia+1] - x[2*m+1];               */
/*                          x[2*ia+1] = x[2*ia+1] + x[2*m+1];               */
/*                          x[2*m]    = c*rtemp   - s*itemp;                */
/*                          x[2*m+1]  = c*itemp   + s*rtemp;                */
/*                          ia++;                                           */
/*                      }                                                   */
/*                      ia += n2;                                           */
/*                  }                                                       */
/*                  n2 <<= 1;                                               */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to generate the coefficient table      */
/*      (non-bit reversed).                                                 */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*             table of size n/2 complex numbers //                         */
/*                                                                          */
/*          gen_w_r2(float* w, int n)                                       */
/*          {                                                               */
/*              int i;                                                      */
/*              float pi = 4.0*atan(1.0);                                   */
/*              float e = pi*2.0/n;                                         */
/*                                                                          */
/*              for(i=0; i < ( n>>1 ); i++)                                 */
/*              {                                                           */
/*                  w[2*i]   = cos(i*e);                                    */
/*                  w[2*i+1] = sin(i*e);                                    */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to bit-reverse the coefficents.        */
/*                                                                          */
/*          bit_rev(float* x, int n)                                        */
/*          {                                                               */
/*              int i, j, k;                                                */
/*              float rtemp, itemp;                                         */
/*                                                                          */
/*              j = 0;                                                      */
/*              for(i=1; i < (n-1); i++)                                    */
/*              {                                                           */
/*                  k = n >> 1;                                             */
/*                  while(k <= j)                                           */
/*                  {                                                       */
/*                      j -= k;                                             */
/*                      k >>= 1;                                            */
/*                  }                                                       */
/*                  j += k;                                                 */
/*                  if(i < j)                                               */
/*                  {                                                       */
/*                      rtemp    = x[j*2];                                  */
/*                      x[j*2]   = x[i*2];                                  */
/*                      x[i*2]   = rtemp;                                   */
/*                      itemp    = x[j*2+1];                                */
/*                      x[j*2+1] = x[i*2+1];                                */
/*                      x[i*2+1] = itemp;                                   */
/*                  }                                                       */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to perform the final scaling           */
/*      of the IFFT.                                                        */
/*                                                                          */
/*          // divide each element of x by n //                             */
/*          divide(float* x, int n)                                         */
/*          {                                                               */
/*              int i;                                                      */
/*              float inv = 1.0 / n;                                        */
/*                                                                          */
/*              for(i=0; i < n; i++)                                        */
/*              {                                                           */
/*                  x[2*i]   = inv * x[2*i];                                */
/*                  x[2*i+1] = inv * x[2*i+1];                              */
/*              }                                                           */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      x should be padded with 4 words at the end.                         */
/*                                                                          */
/*      Since the twiddle table is in bit-reversed order, it turns out      */
/*      that the same twiddle table will also work for smaller IFFTs.This   */
/*      means that if you need to do both 512 and 1024 point IFFTs in the   */
/*      same application, you only need to have the 1024 point twiddle      */
/*      table.  The 512 point FFT will use the first half of the 1024       */
/*      point twiddle table.                                                */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*       2*n*log2(n) + 37                                                   */
/*       eg. IF n = 64, cycles = 805                                        */
/*       eg. IF n = 128, cycles = 1829                                      */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*       1600 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_ICFFTR2_DIF_H_
#define DSPF_SP_ICFFTR2_DIF_H_ 1

void DSPF_sp_icfftr2_dif(
                    float* x,
                    float* w,
                    short n
                   );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_icfftr2_dif.h                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_icfftr2/1117057344  1485  0     0       17432     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_icfftr2_dif -- DSPF_sp_icfftr2_dif                                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSPF_sp_icfftr2_dif(                                            *
*                               float* x,                                   *
*                               float* w,                                   *
*                               short n                                     *
*                              );                                           *
*                                                                           *
*           x : input and output sequences (dim-n)      (input/output)      *
*               x has n complex numbers (2*n SP values).                    *
*               The real and imaginary values are interleaved in memory.    *
*               The input is in Bit reversed order nad output is in Normal  *
*               Order.                                                      *
*           w : FFT coefficients (dim-n/2)              (input)             *
*               w has n/2 complex numbers (n SP values).                    *
*               FFT coeficients must be in bit-reversed order               *
*               The real and imaginary values are interleaved in memory     *
*           n : FFT size                                (input)             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine is used to compute the Inverse, Complex, Radix-2,      *
*       Decimation-in-Frequency Fast Fourier Transform of a single          *
*       precision complex sequence of size n, and a power of 2. The         *
*       routine requires bit-reversed input and bit-reversed coefficents    *
*       (twiddle factors) and produces results that are in normal order.    *
*       Final scaling by 1/N is not done in this function.                  *
*                                                                           *
*       How To Use                                                          *
*                                                                           *
*           void main(void)                                                 *
*           {                                                               *
*               gen_w_r2(w, N);      // Generate coefficient table          *
*               bit_rev(w, N>>1);    // Bit-reverse coefficient table       *
*               cfftr2_dit(x, w, N); // This is the radix 2 FFT benchmark   *
*                                    // from TI available                   *
*                                    // input in normal order, output in    *
*                                    // order bit-reversed                  *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               icfftr2_dif(x, w, N);// Inverse radix 2 FFT                 *
*                                    // input in bit-reversed order,        *
*                                    // order output in normal              *
*                                    // coefficient table in bit-reversed   *
*                                    // order                               *
*                                                                           *
*               divide(x, N);        // scale inverse FFT output            *
*                                    // result is same as original input    *
*           }                                                               *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. Loading input x as well as coefficient w in double word.         *
*       2. mpy was used to perform a mv.  EX. mpy x, 1, y <=> mv x, y       *
*       3. Because the data loads are 1 itteration ahead of the             *
*          coefficent loads, counter i was copied so that the actual        *
*          count could live longer for the coefficent loads.                *
*       4. 2 Inner loops are callapsed into one loop.                       *
*       5. prolog and epilog are done in parallel with the outermost loop.  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Both input x and coefficient w should be aligned on double word  *
*          boundary.                                                        *
*       2. x should be padded with 4 words.                                 *
*       3. n should be greater than 8.                                      *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code without               *
*       restrictions. Note that the assembly code is hand optimized         *
*       and restrictions may apply.                                         *
*                                                                           *
*           void icfftr2_dif(float* x, float* w, short n)                   *
*           {                                                               *
*               short n2, ie, ia, i, j, k, m;                               *
*               float rtemp, itemp, c, s;                                   *
*                                                                           *
*               n2 = 1;                                                     *
*               ie = n;                                                     *
*               for(k=n; k > 1; k >>= 1)                                    *
*               {                                                           *
*                   ie >>= 1;                                               *
*                   ia = 0;                                                 *
*                   for(j=0; j < ie; j++)                                   *
*                   {                                                       *
*                       c = w[2*j];                                         *
*                       s = w[2*j+1];                                       *
*                       for(i=0; i < n2; i++)                               *
*                       {                                                   *
*                           m = ia + n2;                                    *
*                           rtemp     = x[2*ia]   - x[2*m];                 *
*                           x[2*ia]   = x[2*ia]   + x[2*m];                 *
*                           itemp     = x[2*ia+1] - x[2*m+1];               *
*                           x[2*ia+1] = x[2*ia+1] + x[2*m+1];               *
*                           x[2*m]    = c*rtemp   - s*itemp;                *
*                           x[2*m+1]  = c*itemp   + s*rtemp;                *
*                           ia++;                                           *
*                       }                                                   *
*                       ia += n2;                                           *
*                   }                                                       *
*                   n2 <<= 1;                                               *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to generate the coefficient table      *
*       (non-bit reversed).                                                 *
*                                                                           *
*           #include <math.h>                                               *
*           /* generate real and imaginary twiddle                          *
*              table of size n/2 complex numbers */                         *
*                                                                           *
*           gen_w_r2(float* w, int n)                                       *
*           {                                                               *
*               int i;                                                      *
*               float pi = 4.0*atan(1.0);                                   *
*               float e = pi*2.0/n;                                         *
*                                                                           *
*               for(i=0; i < ( n>>1 ); i++)                                 *
*               {                                                           *
*                   w[2*i]   = cos(i*e);                                    *
*                   w[2*i+1] = sin(i*e);                                    *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to bit-reverse the coefficents.        *
*                                                                           *
*           bit_rev(float* x, int n)                                        *
*           {                                                               *
*               int i, j, k;                                                *
*               float rtemp, itemp;                                         *
*                                                                           *
*               j = 0;                                                      *
*               for(i=1; i < (n-1); i++)                                    *
*               {                                                           *
*                   k = n >> 1;                                             *
*                   while(k <= j)                                           *
*                   {                                                       *
*                       j -= k;                                             *
*                       k >>= 1;                                            *
*                   }                                                       *
*                   j += k;                                                 *
*                   if(i < j)                                               *
*                   {                                                       *
*                       rtemp    = x[j*2];                                  *
*                       x[j*2]   = x[i*2];                                  *
*                       x[i*2]   = rtemp;                                   *
*                       itemp    = x[j*2+1];                                *
*                       x[j*2+1] = x[i*2+1];                                *
*                       x[i*2+1] = itemp;                                   *
*                   }                                                       *
*               }                                                           *
*           }                                                               *
*                                                                           *
*       The follwoing C code is used to perform the final scaling           *
*       of the IFFT.                                                        *
*                                                                           *
*           /* divide each element of x by n */                             *
*           divide(float* x, int n)                                         *
*           {                                                               *
*               int i;                                                      *
*               float inv = 1.0 / n;                                        *
*                                                                           *
*               for(i=0; i < n; i++)                                        *
*               {                                                           *
*                   x[2*i]   = inv * x[2*i];                                *
*                   x[2*i+1] = inv * x[2*i+1];                              *
*               }                                                           *
*           }                                                               *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       x should be padded with 4 words at the end.                         *
*                                                                           *
*       Since the twiddle table is in bit-reversed order, it turns out      *
*       that the same twiddle table will also work for smaller IFFTs.This   *
*       means that if you need to do both 512 and 1024 point IFFTs in the   *
*       same application, you only need to have the 1024 point twiddle      *
*       table.  The 512 point FFT will use the first half of the 1024       *
*       point twiddle table.                                                *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*        2*n*log2(n) + 37                                                   *
*        eg. IF n = 64, cycles = 805                                        *
*        eg. IF n = 128, cycles = 1829                                      *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*        1600 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_icfftr2_dif

*  ======================================================================== *
*   End of file:  DSPF_sp_icfftr2_dif.h67                                        *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_sp_fir_cpl/1117057345  1510  0     0       4588      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     */
/*      Filter                                                              */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_fir_cplx(                                                  */
/*                        const float * restrict x,                         */
/*                        const float * restrict h,                         */
/*                        float *       restrict r,                         */
/*                        int   nh,                                         */
/*                        int   nr                                          */
/*                       )                                                  */
/*            x[2*(nr+nh-1)]:Pointer to complex Input array.                */
/*                           The input data pointer x must point to the     */
/*                           (nh)th complex element, i.e. element 2*(nh-1). */
/*            h[2*nh]:       Pointer to complex Coefficient array           */
/*                           (in normal order).                             */
/*            r[2*nr]:       Pointer to complex Output array.               */
/*            nh:            Number of complex coefficients in vector h.    */
/*            nr:            Number of complex output samples to calculate. */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This function implements the FIR filter for complex input data.    */
/*       The filter has nr output samples and nh coefficients. Each array   */
/*       consists of an even and odd term with even terms representing the  */
/*       real part and the odd terms the imaginary part of the element.     */
/*       The coefficients are expected in normal order.                     */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       The outer loop is unrolled twice.                                  */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nr is a multiple of 2 and greater than or equal to 2.           */
/*       2. nh is greater than or equal to 5.                               */
/*       3. x and h are double word aligned.                                */
/*       4. x points to 2*(nh-1)th input element.                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FIR_CPLX_ASM_H_
#define DSPF_SP_FIR_CPLX_ASM_H_ 1

void DSPF_sp_fir_cplx(const     float *restrict x, const float *restrict h, float *restrict r, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_fir_cplx_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_fir_cpl/1117057345  1530  0     0       1763      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_cplx -- Single Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_fir_cplx

* ======================================================================== *
*  End of file: DSPF_sp_fir_cplx_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_fir_gen/1117057346  1552  0     0       5398      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   */
/*                                                                          */
/*   USAGE                                                                  */
/*                                                                          */
/*   This routine is C Callable and can be called as:                       */
/*                                                                          */
/*       void sp_firgen(const float *x, const float *h, float * restrict r, */
/*                  int nh, int nr);                                        */
/*                                                                          */
/*       x : Pointer to array holding the input floating point array        */
/*       h : Pointer to array holding the coefficient floating point        */
/*           array                                                          */
/*       y : Pointer to array holding the output floating point array       */
/*       nh: Number of coefficents                                          */
/*       nr: Number of output values                                        */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine implements a block FIR filter.  There are "nh"        */
/*       filter coefficients, "nr" output samples, and "nh+nr-1"            */
/*       input samples.    The coefficients need to be placed in the "h"    */
/*       array in reverse order {h(nh-1), ... , h(1), h(0)} and the         */
/*       array "x" starts at x(-nh+1) and ends at x(nr-1).  The             */
/*       routine calculates y(0) through y(nr-1) using the following        */
/*       formula:                                                           */
/*                                                                          */
/*       y(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           */
/*                                                                          */
/*       where n = {0, 1, ... , nr-1}.                                      */
/*   C CODE                                                                 */
/*       This is the C equivalent for the assembly code.  Note that         */
/*       the assembly code is hand optimized and restrictions may           */
/*       apply.                                                             */
/*                                                                          */
/*       void DSPF_sp_fir_gen(const float *x, const float *h, float * restrict r */
/*                   int nh, int nr)                                        */
/*       {                                                                  */
/*          int i, j;                                                       */
/*          float sum;                                                      */
/*                                                                          */
/*          for(j=0; j < nh; j++)                                           */
/*          {                                                               */
/*             sum = 0;                                                     */
/*             for(i=0; i < nr; i++)                                        */
/*             {                                                            */
/*                 sum += x[i+j] * h[i];                                    */
/*             }                                                            */
/*             r[j] = sum;                                                  */
/*          }                                                               */
/*       }                                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FIR_GEN_ASM_H_
#define DSPF_SP_FIR_GEN_ASM_H_ 1

void DSPF_sp_fir_gen(const     float * restrict x, const float * restrict h, float * restrict r, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_fir_gen_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_fir_gen/1117057346  1571  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_gen -- Single Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_fir_gen

* ======================================================================== *
*  End of file: DSPF_sp_fir_gen_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_fir_r2./1117057347  1592  0     0       4491      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       */
/*      Filter                                                              */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_fir_r2(                                                    */
/*                     const float * restrict x,                            */
/*                     const float * restrict h,                            */
/*                     float       * restrict r,                            */
/*                     int   nh,                                            */
/*                     int   nr                                             */
/*                     )                                                    */
/*            x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           */
/*            h[nh]:      Pointer to Coefficient array of size nh.          */
/*                        (in reverse order).                               */
/*            r[nr]:      Pointer to Output array od size nr.               */
/*            nh:         Number of coefficients                            */
/*            nr:         Number of output samples.                         */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       Computes a real FIR filter (direct-form) using coefficients        */
/*       stored in vector h[]. The real data input is stored in vector      */
/*       x[]. The filter output result is stored in vector r[]. The         */
/*       filter calculates nr output samples using nh coefficients.         */
/*       The coefficients are expected to be in reverse order.              */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       The outer loop is unrolled four times and inner loop is            */
/*       unrolled twice.                                                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nr is a multiple of 2 and greater than or equal to 2.           */
/*       2. nh is a multiple of 2 and greater than or equal to 8.           */
/*       3. x and h are double word aligned.                                */
/*       4. Coefficients in array h are expected to be in revrse order.     */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef SP_fir_r2_ASM_H_
#define SP_fir_r2_ASM_H_ 1

void DSPF_sp_fir_r2(const     float *restrict x, const float *restrict h, float *restrict r, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_fir_r2_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_fir_r2./1117057346  1610  0     0       1784      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fir_r2 -- Single Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_fir_r2

* ======================================================================== *
*  End of file: DSPF_sp_fir_r2_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_fircirc/1117057348  1630  0     0       11470     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has following C prototype                              */
/*                                                                          */
/*      void DSPF_sp_fircirc                                                     */
/*      (                                                                   */
/*          float *x,       // Pointer to input samples                     */
/*          float *h,       // Pointer to impulse response samples          */
/*          float *r,       // Pointer to output samples                    */
/*          int index,      // Offset by which to start reading from        */
/*                          // input array                                  */
/*          int csize,      // Size of circular buffer for input is         */
/*                          // 2^(csize+1) bytes                            */
/*          int nh,         // Number of impulse response samples           */
/*          int nr          // Number of output samples                     */
/*       );                                                                 */
/*                                                                          */
/*      x[]     : Input array (circular buffer of 2^(csize+1) bytes)        */
/*                Must be aligned at 2^(csize+1) byte boundary              */
/*      h[nh]   : Filter coefficients array                                 */
/*                Must be double-word aligned                               */
/*      r[nr]   : Output array                                              */
/*      index   : Offset by which to start reading from the input array     */
/*                Must be multiple of 2                                     */
/*      csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         */
/*                Must be 2 <= csize <= 31.                                 */
/*      nh      : Number of filter coefficients                             */
/*                Must be multiple of 2 and >= 4                            */
/*      nr      : Size of output array                                      */
/*                Must be multiple of 4                                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine implements a circularly addressed FIR filter.          */
/*      'nh' is the number of filter coefficients. 'nr' is the number       */
/*      of the output samples.                                              */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. LDDW instructions are used to load two SP floating point         */
/*         values simultaneously for the x and h arrays.                    */
/*      2. The outer loop is unrolled 4 times.                              */
/*      3. The inner loop is unrolled 2 times.                              */
/*      4. The variables prod1, prod3, prod5 and prod7 share A9.            */
/*         The variables prod0, prod2, prod4 and prod6 share B6.            */
/*         The variables sum1, sum3, sum5 and sum7 share A7.                */
/*         The variables sum0, sum2, sum4 and sum6 share B8.                */
/*         This multiple assignment is possible since the variables         */
/*         are always read just once on the first cycle that they are       */
/*         avaliable.                                                       */
/*      6. A load counter is used so that an epilog is not needed.  No      */
/*         extraneous loads are performed.                                  */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The circular input buffer x[] must be aligned at a 2^(csize+1)   */
/*         byte boundary. csize must lie in the range 2 <= csize <= 31.     */
/*      2. The number of coefficients  (nh) must be a multiple of 2         */
/*         and greater than or equal to 4.                                  */
/*      3. The number of outputs (nr) must be a multiple of 4 and           */
/*         greater than or equal to 4.                                      */
/*      4. The 'index' (offset to start reading input array) must be        */
/*         mutiple of 2 and less than or equal to (2^(csize-1) - 6)         */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_fircirc                                                     */
/*      (                                                                   */
/*          float *x,       // Pointer to input samples                     */
/*          float *h,       // Pointer to impulse response samples          */
/*          float *r,       // Pointer to output samples                    */
/*          int index,      // Offset by which to start reading from        */
/*                          // input array                                  */
/*          int csize,      // Size of circular buffer for input is         */
/*                          // 2^(csize+1) bytes                            */
/*          int nh,         // Number of impulse response samples           */
/*          int nr          // Number of output samples                     */
/*       )                                                                  */
/*      {                                                                   */
/*          int i, j;                                                       */
/*          //Circular Buffer block size = ((2^(csize + 1)) / 4)            */
/*          //floating point numbers                                        */
/*          int mod = (1 << (csize - 1));                                   */
/*          float r0;                                                       */
/*                                                                          */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              r0 = 0;                                                     */
/*              for (j = 0; j < nh; j++)                                    */
/*              {                                                           */
/*                  //Operation "% mod" is equivalent to "& (mod -1)"       */
/*                  //r0 += x[(i + j + index) % mod] * h[j];                */
/*                  r0 += x[(i + j + index) & (mod - 1)] * h[j];            */
/*              }                                                           */
/*          r[i] = r0;                                                      */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. This code is LITLLE ENDIAN.                                      */
/*      2. This routine disables interupts for its entire duration.         */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      (2*nh + 10) nr/4 + 18                                               */
/*      eg. for nh = 30, nr=100                                             */
/*      cycles = 1768                                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      512 bytes                                                           */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_FIRCIRC_ASM_H_
#define DSPF_SP_FIRCIRC_ASM_H_ 1

void DSPF_sp_fircirc(float     * x, float * h, float * r, int index, int csize, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_fircirc.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_sp_fircirc/1117057347  1649  0     0       11503     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_fircirc -- Single Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has following C prototype                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        );                                                                 *
*                                                                           *
*       x[]     : Input array (circular buffer of 2^(csize+1) bytes)        *
*                 Must be aligned at 2^(csize+1) byte boundary              *
*       h[nh]   : Filter coefficients array                                 *
*                 Must be double-word aligned                               *
*       r[nr]   : Output array                                              *
*       index   : Offset by which to start reading from the input array     *
*                 Must be multiple of 2                                     *
*       csize   : Size of circular buffer x[] is 2^(csize+1) bytes.         *
*                 Must be 2 <= csize <= 31.                                 *
*       nh      : Number of filter coefficients                             *
*                 Must be multiple of 2 and >= 4                            *
*       nr      : Size of output array                                      *
*                 Must be multiple of 4                                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine implements a circularly addressed FIR filter.          *
*       'nh' is the number of filter coefficients. 'nr' is the number       *
*       of the output samples.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. LDDW instructions are used to load two SP floating point         *
*          values simultaneously for the x and h arrays.                    *
*       2. The outer loop is unrolled 4 times.                              *
*       3. The inner loop is unrolled 2 times.                              *
*       4. The variables prod1, prod3, prod5 and prod7 share A9.            *
*          The variables prod0, prod2, prod4 and prod6 share B6.            *
*          The variables sum1, sum3, sum5 and sum7 share A7.                *
*          The variables sum0, sum2, sum4 and sum6 share B8.                *
*          This multiple assignment is possible since the variables         *
*          are always read just once on the first cycle that they are       *
*          avaliable.                                                       *
*       6. A load counter is used so that an epilog is not needed.  No      *
*          extraneous loads are performed.                                  *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The circular input buffer x[] must be aligned at a 2^(csize+1)   *
*          byte boundary. csize must lie in the range 2 <= csize <= 31.     *
*       2. The number of coefficients  (nh) must be a multiple of 2         *
*          and greater than or equal to 4.                                  *
*       3. The number of outputs (nr) must be a multiple of 4 and           *
*          greater than or equal to 4.                                      *
*       4. The 'index' (offset to start reading input array) must be        *
*          mutiple of 2 and less than or equal to (2^(csize-1) - 6)         *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_sp_fircirc                                                     *
*       (                                                                   *
*           float *x,       // Pointer to input samples                     *
*           float *h,       // Pointer to impulse response samples          *
*           float *r,       // Pointer to output samples                    *
*           int index,      // Offset by which to start reading from        *
*                           // input array                                  *
*           int csize,      // Size of circular buffer for input is         *
*                           // 2^(csize+1) bytes                            *
*           int nh,         // Number of impulse response samples           *
*           int nr          // Number of output samples                     *
*        )                                                                  *
*       {                                                                   *
*           int i, j;                                                       *
*           //Circular Buffer block size = ((2^(csize + 1)) / 4)            *
*           //floating point numbers                                        *
*           int mod = (1 << (csize - 1));                                   *
*           float r0;                                                       *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               r0 = 0;                                                     *
*               for (j = 0; j < nh; j++)                                    *
*               {                                                           *
*                   //Operation "% mod" is equivalent to "& (mod -1)"       *
*                   //r0 += x[(i + j + index) % mod] * h[j];                *
*                   r0 += x[(i + j + index) & (mod - 1)] * h[j];            *
*               }                                                           *
*           r[i] = r0;                                                      *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. This code is LITLLE ENDIAN.                                      *
*       2. This routine disables interupts for its entire duration.         *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (2*nh + 10) nr/4 + 18                                               *
*       eg. for nh = 30, nr=100                                             *
*       cycles = 1768                                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       512 bytes                                                           *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_sp_fircirc

*  ======================================================================== *
*   End of file:  DSPF_sp_fircirc.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2003 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_sp_biquad./1117057348  1670  0     0       3961      `
/* ============================================================================*/
/*                                                                             */
/*  TEXAS INSTRUMENTS, INC.                                                    */
/*                                                                             */
/*  NAME                                                                       */
/*      DSPF_sp_biquad: Biquad filter (IIR filter of 2nd order)                     */
/*                                                                             */
/*  USAGE                                                                      */
/*      This routine has following C prototype:                                */
/*                                                                             */
/*           void DSPF_sp_biquad (                                                  */
/*                         float x[],    Pointer to input samples              */
/*                         float b[],    Pointer to Nr coefs b0, b1, b2        */
/*                         float a[],    Pointer to Dr coefs a1, a2            */
/*                         float delay[] Pointer to filter delays              */
/*                         float r[],    Pointer to output samples             */
/*                         int   nx      Number of input/output samples        */
/*                         )                                                   */
/*                                                                             */
/*                                                                             */
/*                                                                             */
/*  DESCRIPTION                                                                */
/*      This routine implements a DF 2 transposed structure of the biquad      */
/*      filter. The transfer function of a biquad can be written               */ 
/*      as:                                                                    */
/*                                                                             */
/*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)            */
/*                       H(Z) =     _________________________________          */
/*                                    1 + a(1)z^(-1) + a(2)z^(-2)              */
/*                                                                             */
/* ============================================================================*/
/*            Copyright (c) 2002 Texas Instruments, Incorporated.              */
/*                           All Rights Reserved.                              */
/* ============================================================================*/

#ifndef DSPF_SP_BIQUAD_ASM
#define DSPF_SP_BIQUAD_ASM 1

void DSPF_sp_biquad     (
                float x[],         //Pointer to input samples
                float b[],         //Pointer to numerator coefficients b[0], b[1] and b[2]
                float a[],         //Pointer to denominator coefficients a[1] and a[2]
                float delay[],     //Pointer to filter delays delay[0] and delay[1]
                float r[],         //Pointer to output samples
                int      nx         //Number of input/output samples
               );
#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_biquad.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */





DSPF_sp_biquad./1117057348  1688  0     0       1680      `
 ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_biquad -- Single Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_biquad

* ======================================================================== *
*  End of file: DSPF_sp_biquad_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_iir.h/  1117057349  0     0     0       6054      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_iir -- Single Precision IIR filter (used in the VSELP vocoder)   */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*   This routine is C callable, and has the following C prototype:         */
/*                                                                          */
/*      void DSPF_sp_iir    (float* restrict r1,                                 */
/*                      const float*    x,                                  */
/*                      float* restrict r2,                                 */
/*                      const float*    h2,                                 */
/*                      const float*    h1,                                 */
/*                      int nr                                              */
/*                     );                                                   */
/*                                                                          */
/*           r1   :  Delay element values (i/p and o/p)                     */
/*           x    :  Pointer to the input array                             */
/*           r2   :  Pointer to the output array                            */
/*           h2   :  Auto-regressive filter coefficients                    */
/*           h1   :  Moving average filter coefficients                     */
/*           nr   :  Number of output samples                               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    The IIR performs an auto-regressive moving-average (ARMA)             */
/*    filter with 4 auto-regressive filter coefficients and 5               */
/*    moving-average filter coefficients for nr output samples.             */
/*    The output vector is stored in two locations. This routine            */
/*    is used as a high pass filter in the VSELP vocoder.                   */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the Assembly Code without                   */
/*  restrictions.                                                           */
/*                                                                          */
/*  Note that the assembly code is hand optimized and restrictions          */
/*  may apply.                                                              */
/*                                                                          */
/*  void DSPF_sp_iir (float* restrict r1,                                        */
/*                   const float*    x,                                     */
/*                   float* restrict r2,                                    */
/*                   const float*    h2,                                    */
/*                   const float*    h1,                                    */
/*                   int nr                                                 */
/*                  )                                                       */
/*      {                                                                   */
/*         int i, j;                                                        */
/*         float sum;                                                       */
/*                                                                          */
/*         for (i = 0; i < nr; i++)                                         */
/*         {                                                                */
/*             sum = h2[0] * x[4+i];                                        */
/*                                                                          */
/*             for (j = 1; j <= 4; j++)                                     */
/*                 sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];             */
/*                                                                          */
/*             r1[4+i] = sum;                                               */
/*             r2[i] = r1[4+i];                                             */
/*         }                                                                */
/*     }                                                                    */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_IIR_ASM_H_
#define DSPF_SP_IIR_ASM_H_ 1

void DSPF_sp_iir(float     *restrict r1, const float * x, float *restrict r2, const float * h2, const float * h1, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_iir_h.asm                                               */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_iir.h67/1117057349  0     0     0       1680      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iir -- Single Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_iir

* ======================================================================== *
*  End of file: DSPF_sp_iir_h.asm                                               *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_iirlat./1117057350  1708  0     0       7263      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           */
/*                                                                          */
/*    USAGE                                                                  */ 
/*        This routine has following C prototype:                            */
/*                                                                           */ 
/*             void DSPF_sp_iirlat(                                               */ 
/*                           float *x,                                       */ 
/*                           int nx,                                         */ 
/*                           const float * restrict k,                       */ 
/*                           int nk,                                         */ 
/*                           float * restrict b,                             */ 
/*                           float * r                                       */ 
/*                           )                                               */ 
/*          x[nx]   : Input vector                                           */ 
/*          nx      : Length of input vector.                                */ 
/*          k[nk]   : Reflection coefficients                                */ 
/*          nk      : Number of reflection coefficients/lattice stages       */ 
/*                    Must be multiple of 2 and >=6.                         */ 
/*          b[nk+1] : Delay line elements from previous call. Should be      */ 
/*                    initialized to all zeros prior to the first call.      */ 
/*          r[nx]   : Output vector                                          */ 
/*                                                                           */ 
/*      DESCRIPTION                                                          */ 
/*          This routine implements a real all-pole IIR filter in lattice    */ 
/*          structure (AR lattice). The filter consists of nk lattice stages */ 
/*          Each stage requires one reflection coefficient k and one delay   */ 
/*          element b. The routine takes an input vector x[] and returns the */ 
/*          filter output in r[]. Prior to the first call of the routine the */ 
/*          delay elements in b[] should be set to zero. The input data may  */ 
/*          have to be pre-scaled to avoid overflow or achieve better SNR. T */ 
/*          reflections coefficients lie in the range -1.0 < k < 1.0. The    */ 
/*          order of the coefficients is such that k[nk-1] corresponds to th */ 
/*          first lattice stage after the input and k[0] corresponds to the  */ 
/*          last stage.                                                      */ 
/*                                                                           */
/*     TECHNIQUES                                                            */ 
/*          1.  The loop has been unrolled by 4 times.                       */ 
/*                                                                           */ 
/*          2.  Register sharing has been used to optimize on the use of regs*/
/*                                                                           */ 
/*                                                                           */ 
/*     ASSUMPTIONS                                                           */
/*                                                                           */ 
/*         1. nk is a multiple of 2 and >=6.                                 */
/*         2. Extraneous loads are allowed (80 bytes) before the start of    */
/*            array.                                                         */ 
/*                                                                           */ 
/*     C CODE                                                                */
/*                                                                           */ 
/*        void DSPF_sp_iirlat(float * x, int nx, const float * restrict k, int nk,*/ 
/*                       float * restrict b, float * r)                      */
/*        {                                                                  */
/*                                                                           */ 
/*       float rt;     // output       //                                    */
/*       int i, j;                                                           */
/*                                                                           */
/*       for (j = 0; j < nx; j++)                                            */
/*       {                                                                    */
/*           rt = x[j];                                                         */
/*                                                                            */
/*           for (i = nk - 1; i >= 0; i--)                                    */
/*           {                                                                 */
/*               rt = rt - b[i] * k[i];                                         */
/*               b[i + 1] = b[i] + rt * k[i];                                 */
/*           }                                                                 */
/*                                                                            */
/*           b[0] = rt;                                                      */                                
/*           r[j] = rt;                                                         */
/*       }                                                                    */
/*                                                                             */ 
/*      }                                                                     */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_IIRLAT_ASM_H_
#define DSPF_SP_IIRLAT_ASM_H_ 1

void DSPF_sp_iirlat(float     * x, int nx, const float * restrict k, int nk, float * restrict b, float * r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_iirlat_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_iirlat./1117057350  1726  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_iirlat -- Single Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_iirlat

* ======================================================================== *
*  End of file: DSPF_sp_iirlat_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_convol./1117057351  1746  0     0       5887      `
/* =======================================================================      */
/*                                                                              */     
/*  TEXAS INSTRUMENTS, INC.                                                     */
/*                                                                              */
/*  NAME                                                                         */
/*      DSPF_sp_convol: Convolution(Floating Point Version)                          */ 
/*                                                                              */
/*  USAGE                                                                       */
/*      This routine is C callable, and has the following C prototype:          */
/*                                                                              */
/*      void DSPF_sp_convol                                                          */  
/*             (                                                                */
/*                       float *x, //x: Pointer to input samples//              */          
/*                       float *h, //h: Pointer to impulse response samples//   */
/*                       float *r, //r: Pointer to output samples//             */
/*                       int   nh, //nh: Number of impulse response samples//   */
/*                       int   nr  //nr: Number of output samples//             */
/*             )                                                                */
/*                                                                              */
/*              x = pointer to real input vector of size = nr+nh-1              */
/*                  a typically contains input data (x) padded with             */
/*                  consecutive nh - 1  zeros at the beginning and end.         */
/*              h = pointer to real input vector of size nh in forward order.   */
/*                  h typically contains the filter coefs.                      */
/*              r = pointer to real output vector of size nr                    */
/*              nh= number of elements in vector b. NOTE: nh <= nr  nh is       */
/*                  typically noted as m in convol formulas. nh must be a       */
/*                  MULTIPLE of 2                                               */
/*              nr= number of elements in vector r. nr must be a MULTIPLE of 4  */
/*                                                                              */
/*              If routine is not to be used as a C callable function then      */
/*              you need to initialize values for all of the values passed      */
/*              as these are assumed to be in registers as defined by the       */
/*              calling convention of the compiler, (refer to the C compiler    */
/*              reference guide).                                               */
/*                                                                              */
/*  DESCRIPTION                                                                 */
/*              This fucntion calculates the full-lenght convolution of real    */
/*              vectors x and h using time-domain techniques. The result is     */
/*              placed in real vector r.                                        */
/*                                                                              */
/*              It is assumed that input vector x is padded with nh-1 no of     */
/*              zeros in the beginning and end.                                 */
/*                                                                              */
/*              It is assumed that the length of the input vector h, nh, is a   */
/*              multiple of 2 and the length of the output vector r, nr, is a   */    
/*              multiple of 4. nh is greater thanor equal to 4 and nr is greater*/
/*              than or equal to nh. The routine computes 4 output              */
/*              samples at a time.                                              */
/*                                                                              */
/*              x and h are assumed to be aligned on a double word boundary     */
/*                                                                              */
/* -----------------------------------------------------------------------      */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.               */
/*                           All Rights Reserved.                               */
/* =======================================================================      */

#ifndef DSPF_SP_CONVOL_ASM
#define DSPF_SP_CONVOL_ASM 1

void DSPF_sp_convol
        (                                                                   
             float *x, /*x: Pointer to input samples*/                                   
             float *h, /*h: Pointer to impulse response samples*/           
             float *r, /*r: Pointer to output samples*/                       
             int   nh, /*nh: Number of impulse response samples*/            
             int   nr  /*nr: Number of output samples*/                     
        );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_sp_convol.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_sp_convol./1117057351  1764  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_convol -- Single Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_convol

* ======================================================================== *
*  End of file: DSPF_sp_convol_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_dotp_sq/1117057352  1784  0     0       4412      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_dotp_sqr(                                                  */
/*                       float G,                                           */
/*                       const float * x,                                   */
/*                       const float * y,                                   */
/*                       float *  restrict r,                               */
/*                       int   nx                                           */
/*                       )                                                  */
/*            G:      Sum of y-squared initial value.                       */
/*            x[nx]:  Pointer to First input array.                         */
/*            y[nx]:  Pointer to Second input array.                        */
/*            r:      Pointer to Output for Accumulation of x[]*y[].        */
/*            nx:     Length of input vectors.                              */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This routine computes the dot product of x[] and y[] arrays,adding */
/*       it to the value in the location pointed to by r. Additionally, it  */
/*       computes the sum of the squares of the terms in the y array,adding */
/*       it to the argument G. The final value of G is given as the return  */
/*       value of the function.                                             */
/*                                                                          */
/*       x and y should be aligned on a double word boundary.               */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The loop is unrolled four times.                                    */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*      1. nx is a multiple of 4.                                           */
/*      2. x and y should be double word aligned.                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_DOTP_SQR_ASM_H_
#define DSPF_SP_DOTP_SQR_ASM_H_ 1

float DSPF_sp_dotp_sqr(float     G, const float * x, const float * y, float *restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_dotp_sqr_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_dotp_sq/1117057352  1804  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_sqr -- Single Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotp_sqr

* ======================================================================== *
*  End of file: DSPF_sp_dotp_sqr_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_dotprod/1117057353  1826  0     0       4089      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      float DSPF_sp_dotprod(const float *x, const float *y, const int nx);     */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      nx    : Number of values in the x & y vectors                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 single precision       */
/*  float vectors.                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      float dotp(const float *x, const float *y, const int nx)            */
/*      {                                                                   */
/*         int i;                                                           */
/*         float sum = 0;                                                   */
/*                                                                          */
/*         for (i=0; i < nx; i++)                                           */
/*         {                                                                */
/*            sum += x[i] * y[i];                                           */
/*         }                                                                */
/*         return sum;                                                      */
/*      }                                                                   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_DOTPROD_ASM_H_
#define DSPF_SP_DOTPROD_ASM_H_ 1

float DSPF_sp_dotprod(const     float * x, const float * y, const int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_dotprod_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_dotprod/1117057353  1845  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotprod -- Dot Product of 2 Single Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotprod

* ======================================================================== *
*  End of file: DSPF_sp_dotprod_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_dotp_cp/1117057354  1866  0     0       6614      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_dotp_cplx -- Complex single precision floating point dot         */
/*      product                                                             */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      void DSPF_sp_dotp_cplx(const float *x, const float *y, int n, float *    */
/*                        restrict re, float * restrict im);                */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      n     : Number of values in the x & y vectors                       */
/*      re    : Pointer to the location storing the real part of the result */
/*      im    : Pointer to the location storing the imaginary part of       */
/*          the result                                                      */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 single precision       */
/*  complex float vectors. The even numbered locations hold the real parts  */
/*  of the complex numbers while the odd numbered locations contain the     */
/*  imaginary portions.                                                     */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1.  The loop is unrolled 4 times because the loop carried           */
/*      dependency bound is 4.                                              */
/*                                                                          */
/*      2.  LDDW instructions are used to load two SP floating point        */
/*          values at a time for the x and y arrays.                        */
/*                                                                          */
/*      3.  A load counter avoids all extraneous loads.                     */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1.  Little Endian is assumed for LDDW instructions.                 */
/*      2.  Since single assignment of registers is not used,               */
/*          interrupts should be disabled before this function is           */
/*          called.                                                         */
/*      3.  Loop counter must be > 0.                                       */
/*  4.  The x and y arrays must be double word aligned.                     */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_sp_dotp_cplx(const    float* x, const float* y,                */
/*                       int n, float* restrict re,                         */
/*               float* restrict im)                                        */
/*      {                                                                   */
/*                                                                          */
/*          float real=0, imag=0;                                           */
/*          int i=0;                                                        */
/*                                                                          */
/*          for(i=0; i<n; i++)                                              */
/*          {                                                               */
/*              real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  */
/*              imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  */
/*          }                                                               */
/*                                                                          */
/*          *re=real;                                                       */
/*          *im=imag;                                                       */
/*     }                                                                    */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_DOTP_CPLX_ASM_H_
#define DSPF_SP_DOTP_CPLX_ASM_H_ 1

void DSPF_sp_dotp_cplx(const     float * x, const float * y, int n, float * restrict re, float * restrict im);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_dotp_cplx_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_dotp_cp/1117057354  1887  0     0       1764      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_dotp_cplx -- Complex single precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_dotp_cplx

* ======================================================================== *
*  End of file: DSPF_sp_dotp_cplx_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_maxval./1117057355  1910  0     0       3716      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       float DSPF_sp_maxval(                                                   */
/*                       const float* x,                                    */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*            Returns float: Maximum value in the input array               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       This routine Finds out the maximum number in the input array.      */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The loop is unrolled Six times.                                     */
/*      Six maximums are maintained in each iteration.                      */ 
/*      One of the maximums are calculated using SUBSP in place of CMPGTSP  */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      nx should be multiple of 2 and >= 2.                                */ 
/*      x should be double word aligned.                                    */ 
/*      NAN( Not a Number in Single Precision format) in the input are      */ 
/*      disregarded.                                                        */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAXVAL_ASM_H_
#define DSPF_SP_MAXVAL_ASM_H_ 1

float DSPF_sp_maxval(const     float* x, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_maxval_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_maxval./1117057355  1928  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxval -- Maximum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_maxval

* ======================================================================== *
*  End of file: DSPF_sp_maxval_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_maxidx./1117057356  1948  0     0       3580      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       int DSPF_sp_maxidx(                                                     */
/*                      const float* x,                                     */
/*                      int nx                                              */
/*                    )                                                     */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*            Returns int: Index of Maximum value                           */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       This routine Finds out the index of maximum number in the input    */
/*       array.                                                             */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The loop is unrolled three times.                                   */
/*      Three maximums are maintained in each iteration.                    */
/*      MPY indtructions are  used for move.                                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      nx is a multiple of 3                                               */
/*      nx >= 3, and nx <= 2^16-1.                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAXIDX_ASM_H_
#define DSPF_SP_MAXIDX_ASM_H_ 1

int DSPF_sp_maxidx(const     float* x, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_maxidx_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_maxidx./1117057356  1966  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_maxidx -- Index of Maximum Element of Single Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_maxidx

* ======================================================================== *
*  End of file: DSPF_sp_maxidx_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_minval./1117057357  1986  0     0       3881      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             */
/*                                                                          */
/*     USAGE                                                                */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       float DSPF_sp_minval(                                                   */
/*                       const float* x,                                    */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*            Returns float: Minimum value in the input array               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       This routine Finds out the minimum number in the input array.      */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       The loop is unrolled Six times.                                    */ 
/*       Six minimums are maintained in each iteration.                     */ 
/*       One of the minimums are calculated using SUBSP in place of CMPGTSP */ 
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       nx should be multiple of 2 and >= 2.                               */ 
/*       x should be double word aligned.                                   */ 
/*       NAN( Not a Number in Single Precision format) in the input are     */ 
/*       disregarded.                                                       */ 
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MINVAL_ASM_H_
#define DSPF_SP_MINVAL_ASM_H_ 1

float DSPF_sp_minval(const     float* x, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_minval_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_minval./1117057356  2004  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minval -- Minimum Element of Single Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_minval

* ======================================================================== *
*  End of file: DSPF_sp_minval_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecreci/1117057359  2024  0     0       5137      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_vecrecip(const float *x,                                   */
/*                        float * restrict r,                               */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_sp_vecrecip module calculates the reciprocal of each element in */
/*      array x and returns the output in array r. It uses 2 iterations     */
/*      of the Newton-Raphson method to improve the accuracy of the output  */
/*      generated by the RCPSP instruction of the C67x. Each iteration      */
/*      doubles the accuracy. The initial output generated by RCPSP is 8 bi */
/*      So after the first iteration it is 16 bits and after the second it  */
/*      the full 23 bits. The formula used is:                              */
/*                                                                          */
/*               r[n+1] = r[n](2 - v*r[n])                                  */
/*                                                                          */
/*      where v = the number whose reciprocal is to be found.               */
/*      x[0], the seed value for the algorithm, is given by RCPSP.          */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*      1. The inner loop is unrolled four times to allow calculation of    */
/*         four reciprocals in the kernel.                                  */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*                                                                          */
/*    C CODE                                                                */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*  void DSPF_sp_vecrecip(const    float* x, float* restrict r, int n)           */
/*      {                                                                   */
/*          int i;                                                          */
/*          for(i = 0; i < n; i++)                                          */
/*              r[i] = 1 / x[i];                                            */
/*      }                                                                   */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECRECIP_ASM_H_
#define DSPF_SP_VECRECIP_ASM_H_ 1

void DSPF_sp_vecrecip(const     float * x, float * restrict r, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecrecip_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_vecreci/1117057359  2044  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecrecip -- Single Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecrecip

* ======================================================================== *
*  End of file: DSPF_sp_vecrecip_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_vecsum_/1117057360  2066  0     0       3996      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      float DSPF_sp_vecsum_sq(const float *x,                                  */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs a sum of squares of the elements of the      */
/*   array x and returns the sum.                                           */
/*                                                                          */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     float DSPF_sp_vecsum_sq(const    float *x,int n)                          */
/*     {                                                                    */
/*         int i;                                                           */
/*         float sum=0;                                                     */
/*                                                                          */
/*         for(i=0; i<n; i++)                                               */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECSUM_SQ_ASM_H_
#define DSPF_SP_VECSUM_SQ_ASM_H_ 1

float DSPF_sp_vecsum_sq(const     float * x, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecsum_sq_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_vecsum_/1117057360  2087  0     0       1686      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecsum_sq -- Single Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecsum_sq

* ======================================================================== *
*  End of file: DSPF_sp_vecsum_sq_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_w_vec.h/1117057361  0     0     0       4750      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void DSPF_sp_w_vec(const float* x,                                     */
/*                      const float * y,                                    */
/*                      float m,                                            */
/*                      float * restrict r,                                 */
/*                      int     nr                                          */
/*                     )                                                    */
/*                                                                          */
/*             x    :  Pointer to first input array                         */
/*             y    :  Pointer to second input array                        */
/*             m    :  Weight factor                                        */
/*             r    :  Output array pointer                                 */
/*             nr   :  Number of elements in arrays                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine is used to obtain the weighted vector sum.              */
/*     Both the inputs and output are single precision floating             */
/*     point numbers.                                                       */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_sp_w_vec(    const float *    x,                                */
/*                       const float *    y,                                */
/*                       float         m,                                   */
/*                       float *        restrict r,                         */
/*                       int         nr                                     */
/*                    )                                                     */
/*                                                                          */
/*    {                                                                     */
/*        int i;                                                            */
/*        for (i = 0; i < nr; i++)                                          */
/*            r[i] = (m * x[i]) + y[i];                                     */
/*    }                                                                     */
/*                                                                          */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_W_VEC_ASM_H_
#define DSPF_SP_W_VEC_ASM_H_ 1

void DSPF_sp_w_vec(const     float * x, const float * y, float m, float * restrict r, int nr);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_w_vec_h.asm                                             */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_w_vec.h/1117057361  2110  0     0       1682      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_w_vec -- Single Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_w_vec

* ======================================================================== *
*  End of file: DSPF_sp_w_vec_h.asm                                             *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_vecmul./1117057362  2129  0     0       4338      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_vecmul -- Single Precision vector multiplication                 */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void DSPF_sp_vecmul   (const float *x,                                   */
/*                        const float *x,                                   */
/*                        float * restrict r,                               */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             y        :  Pointer to second input array                    */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs an element by element floating point         */
/*   multiply of the vectors x[] and y[] and returns the values in r[].     */
/*                                                                          */
/*    C CODE                                                                */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     float sp_vecsum_sq(const    float *x,int n)                         */
/*     {                                                                    */
/*         int i;                                                           */
/*         float sum=0;                                                     */
/*                                                                          */
/*         for(i=0; i<n; i++)                                               */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_VECMUL_ASM_H_
#define DSPF_SP_VECMUL_ASM_H_ 1

void DSPF_sp_vecmul(const     float * x, const float * y, float * restrict r, int n);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_vecmul_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_vecmul./1117057362  2147  0     0       1683      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_vecmul -- Single Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_vecmul

* ======================================================================== *
*  End of file: DSPF_sp_vecmul_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_mat_mul/1117057363  2167  0     0       3828      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                */
/*                                                                          */
/* USAGE                                                                    */
/*     This routine has following C prototype                               */
/*                                                                          */
/*         void DSPF_sp_mat_mul                                                  */
/*         (                                                                */
/*             float *x, int r1, int c1,                                    */
/*             float *y,         int c2,                                    */
/*             float *r,                                                    */
/*         );                                                               */
/*                                                                          */
/*     x[]  : Pointer to r1 by c1 input matrix.                             */
/*     r1   : Number of rows in x.                                          */
/*     c1   : Number of columns in x.  Also number of rows in y.            */
/*     y[]  : Pointer to c1 by c2 input matrix.                             */
/*     c2   : Number of columns in y.                                       */
/*     r[]  : Pointer to r1 by c2 output matrix.                            */
/*                                                                          */
/* DESCRIPTION                                                              */
/*     This function computes the expression "r = x * y" for the matrices   */
/*     x and y.  The column dimension of x must match the row dimension     */
/*     of y.  The resulting matrix has the same number of rows as x and     */
/*     the same number of columns as y.                                     */
/*                                                                          */
/*     The values stored in the matrices are assumed to be single precision */
/*     floating point values.                                               */
/*                                                                          */
/*     This code is suitable for dense matrices.  No optimizations are      */
/*     made for sparse matrices.                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAT_MUL_ASM_H_
#define DSPF_SP_MAT_MUL_ASM_H_ 1

void DSPF_sp_mat_mul(float     * x, int r1, int c1, float * y, int c2, float * r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_mat_mul_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_mat_mul/1117057363  2186  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul -- Single Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      14-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_mul

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_mat_tra/1117057364  2207  0     0       3790      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_mat_trans -- Single Precision matrix transpose                   */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_mat_trans(                                                 */
/*                            const float *restrict x,                      */
/*                            int rows,                                     */
/*                            int cols,                                     */
/*                            float *restrict r)                            */
/*                                                                          */
/*          x[r1*c1]:  Input matrix containing r1*c1 floating point         */
/*                     numbers having r1 rows and c1 columns.               */
/*          rows    :  Number of rows in Matrix x.                          */
/*                     Also Number of columns in matrix y                   */
/*          cols    :  No. of columns in Matrx x.                           */
/*                     Also no. of rows in Matrix y.                        */
/*          y[c1*c2]:  Output matrix containing c1*r1 floating point        */
/*                     numbers having c1 rows and r1 columns.               */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    This function transposes the input matrix x[] and writes the          */
/*    result to matrix r[].                                                 */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*    The loop is unrolled twice.                                           */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    rows > 0 and cols > 0                                                 */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAT_TRANS_ASM_H_
#define DSPF_SP_MAT_TRANS_ASM_H_ 1

void DSPF_sp_mat_trans(const     float *restrict x, int rows, int cols, float *restrict r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_mat_trans_h.asm                                         */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_mat_tra/1117057364  2228  0     0       1686      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_trans -- Single Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_trans

* ======================================================================== *
*  End of file: DSPF_sp_mat_trans_h.asm                                         *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_sp_mat_mul/1117057365  2251  0     0       5724      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_mat_mul_cplx -- complex matrix multiplication                    */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_mat_mul_cplx(                                              */
/*                              const float* x,                             */
/*                              int r1,                                     */
/*                              int c1,                                     */
/*                              const float* y,                             */
/*                              int c2,                                     */
/*                              float* restrict r                           */
/*                           )                                              */
/*                                                                          */
/*            x[2*r1*c1]:   Input matrix containing r1*c1 complex           */
/*                          floating point numbers having r1 rows and c1    */
/*                          columns of complex numbers.                     */
/*            r1        :   Number of rows in Matrix x.                     */
/*            c1        :   No. of columns in Matrx x.                      */
/*                          Also no. of rows in Matrix y.                   */
/*            y[2*c1*c2]:   Input matrix containing c1*c2 complex           */
/*                          floating point numbers having c1 rows and c2    */
/*                          columns of complex numbers.                     */
/*            c2        :   No. of columns in Matrix y.                     */
/*            r[2*r1*c2]:   Output matrix of c1*c2 complex floating         */
/*                          point numbers having c1 rows and c2 columns of  */
/*                          complex numbers.                                */
/*                                                                          */
/*                          Complex numbers are stored consecutively with   */
/*                          Real values are stored in even word positions   */
/*                          and imaginary values in odd positions.          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*        This function computes the expression "r = x * y" for the         */
/*        matrices x and y. The columnar dimension of x must match the row  */
/*        dimension of y. The resulting matrix has the same number of rows  */
/*        as x and the same number of columns as y.                         */
/*                                                                          */
/*        Each element of Matrices are assumed to be complex numbers with   */
/*        Real values are stored in even word positions and imaginary       */
/*        values in odd positions.                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*        Innermost loop is Unrolled twice.                                 */
/*        Two inner loops are collapsed into one loop.                      */
/*        Outermost loop is executed in parallel with innner loops.         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*        c1 >= 4, and r1,r2>=1                                             */
/*        x should be padded with 6 words                                   */
/*        x and y should be double word aligned                             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MAT_MUL_CPLX_ASM_H_
#define DSPF_SP_MAT_MUL_CPLX_ASM_H_ 1

void DSPF_sp_mat_mul_cplx(const     float* x, int r1, int c1, const float* y, int c2, float* restrict r);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_mat_mul_cplx_h.asm                                      */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_sp_mat_mul/1117057365  2275  0     0       1689      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_mat_mul_cplx -- complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_mat_mul_cplx

* ======================================================================== *
*  End of file: DSPF_sp_mat_mul_cplx_h.asm                                      *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_blk_mov/1117057366  2301  0     0       3207      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_blk_move -- Single Precision Block Move                          */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_sp_blk_move                                                   */
/*                     (                                                    */
/*                         const float    *r,                               */
/*                         const float *  restrict r,                       */
/*                         int            nx,                               */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data to be moved.                       */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:        Number of floats to move.                               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*       This routine moves nx floats from memory location pointed to by x  */
/*       to a separate memory location pointed to by r.                     */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_BLK_MOVE_ASM_H_
#define DSPF_SP_BLK_MOVE_ASM_H_ 1

void DSPF_sp_blk_move(const     float * x, float *restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_blk_move_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_blk_mov/1117057366  2321  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_blk_move -- Single Precision Block Move                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_blk_move

* ======================================================================== *
*  End of file: DSPF_sp_blk_move_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap1/1117057367  2343  0     0       3931      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap16                                                   */
/*                     (                                                    */
/*                         void * restrict x,                               */
/*                         void * restrict r,                               */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of shorts (16-bit values) to endian-swap.          */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*         The date in the x array is endian swapped, meaning that the      */
/*      byte-order of the bytest within wach half-word (short) of x is      */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP16_ASM_H_
#define DSPF_BLK_ESWAP16_ASM_H_ 1

void DSPF_blk_eswap16(short     * restrict x, short * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap16_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap1/1117057367  2363  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap16 -- C67x Endian-swap of a block of 16-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap16

* ======================================================================== *
*  End of file: DSPF_blk_eswap16_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap3/1117057368  2385  0     0       3931      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap32                                                   */
/*                     (                                                    */
/*                         float * restrict x,                              */
/*                         float * restrict r,                              */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of words (32-bit values) to endian-swap.           */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      The date in the x array is endian swapped, meaning that the         */
/*      byte-order of the bytest within wach word of x is                   */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP32_ASM_H_
#define DSPF_BLK_ESWAP32_ASM_H_ 1

void DSPF_blk_eswap32(float     * restrict x, float * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap32_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap3/1117057367  2405  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap32 -- C67x Endian-swap of a block of 32-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap32

* ======================================================================== *
*  End of file: DSPF_blk_eswap32_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_blk_eswap6/1117057368  2427  0     0       3933      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         */
/*                                                                          */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_blk_eswap64                                                   */
/*                     (                                                    */
/*                         double * restrict x,                             */
/*                         double * restrict r,                             */
/*                         int             nx,                              */
/*                     )                                                    */
/*                                                                          */
/*       x[nx]:   Pointer to source data.                                   */
/*       r[nx]:   Pointer to destination array.                             */
/*       nx:      Number of double words (64-bit values) to endian-swap.    */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      The date in the x array is endian swapped, meaning that the         */
/*      byte-order of the bytes within each double word of x is             */
/*      reversed in the array r. This routine is used to facilitate moving  */
/*      big-endian data to a little-endian system or vice-versa.            */
/*                                                                          */
/*      When the r pointer is non-NULL, the endian-swap occurs              */
/*      out-of-place, similar to a block move. When the r pointer is NULL,  */
/*      the endian-swap occurs in-place, allowing the swap to occure        */
/*      without using any additional memory.                                */
/*                                                                          */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_BLK_ESWAP64_ASM_H_
#define DSPF_BLK_ESWAP64_ASM_H_ 1

void DSPF_blk_eswap64(double     * restrict x, double * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_blk_eswap64_h.asm                                          */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_blk_eswap6/1117057368  2447  0     0       1685      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_blk_eswap64 -- C67x Endian-swap of a block of 64-bit values         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      21-Oct-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_blk_eswap64

* ======================================================================== *
*  End of file: DSPF_blk_eswap64_h.asm                                          *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_fltoq15.h/ 1117057369  0     0     0       4801      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       */
/*                                                                          */
/*  USAGE                                                                   */
/*     This routine is C-callable and can be called as:                     */
/*                                                                          */
/*     void DSPF_fltoq15                                                         */
/*     (                                                                    */
/*         const float* restrict x,                                         */
/*         short*       restrict r,                                         */
/*         int         nx                                                   */
/*     );                                                                   */
/*                                                                          */
/*     x[nx] :  Input array contaning values of type float                  */
/*     r[nx] :  Output array contains Q15 equivalents of x[nx]              */
/*     nx    :  Number of elements in both arrays                           */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*     Convert the IEEE floating point numbers stored in vector x[] into    */
/*     Q.15 format numbers stored in vector r[]. Results will be rounded    */
/*     towards negative infinity. All values that exceed the size limit     */
/*     will be saturated to 0x7fff if value is positive and 0x8000 if       */
/*     value is negative.                                                   */
/*                                                                          */
/*  C CODE                                                                  */
/*     void DSPF_fltoq15                                                         */
/*     (                                                                    */
/*         const float* restrict x,                                         */
/*         short*       restrict r,                                         */
/*         int         nx                                                   */
/*     )                                                                    */
/*     {                                                                    */
/*         int i, a;                                                        */
/*                                                                          */
/*         for(i = 0; i < nx; i++)                                          */
/*         {                                                                */
/*             a = floor(32768 * x[i]);                                     */
/*                                                                          */
/*             // saturate to 16-bit //                                     */
/*             if (a>32767)  a =  32767;                                    */
/*             if (a<-32768) a = -32768;                                    */
/*                                                                          */
/*             r[i] = (short) a;                                            */
/*         }                                                                */
/*     }                                                                    */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_FLTOQ15_ASM_H_
#define DSPF_FLTOQ15_ASM_H_ 1

void DSPF_fltoq15(const     float * x, short * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_fltoq15_h.asm                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_fltoq15.h6/1117057369  2469  0     0       1681      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_fltoq15 -- IEEE Single Precision floating point to Q15 format       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_fltoq15

* ======================================================================== *
*  End of file: DSPF_fltoq15_h.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_sp_minerr./1117057370  2487  0     0       4111      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_sp_minerr -- Searching for a pair of numbers producing maximum      */
/*      dot product                                                         */
/*                                                                          */
/*  USAGE                                                                   */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       float DSPF_sp_minerr(const float* GSP0_TABLE, const float* errCoefs,    */
/*                                              int *restrict max_index)    */
/*                                                                          */
/*          GSP0_TABLE[256*9]: GSP0 terms array.                            */
/*          errCoefs[9]:       Array of error coefficients.                 */
/*                             Must be Double word aligned.                 */
/*          max_index:         Index to GSP0_TABLE[max_index], the first    */
/*                             element of the 9-element vector that         */
/*                             resulted in the maximum dot product.         */
/*          return float       Maximum dot product result.                  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*       Performs a dot product on 256 pairs of 9 element vectors and       */
/*       searches for the pair of vectors which produces the maximum dot    */
/*       product result. This is a large part of the VSELP vocoder          */
/*       codebook search.                                                   */
/*                                                                          */
/*       The function stores the index to the first element of the          */
/*       9-element vector that resulted in the maximum dot product in the   */
/*       memory loaction Pointed by max_index. The maximum dot product      */
/*       value is returned by the function.                                 */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      The inner loop is totally unrolled.                                 */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      errCoefs must be Double word aligned.                               */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_SP_MINERR_ASM_H_
#define DSPF_SP_MINERR_ASM_H_ 1

float DSPF_sp_minerr(const     float* GSP0_TABLE, const float* errCoefs, int *restrict max_index);

#endif
/* ======================================================================== */
/*  End of file: DSPF_sp_minerr_h.asm                                            */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_sp_minerr./1117057370  2505  0     0       1761      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_sp_minerr -- Searching for a pair of numbers producing maximum      *
*      dot product                                                         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      31-Dec-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_sp_minerr

* ======================================================================== *
*  End of file: DSPF_sp_minerr_h.asm                                            *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_q15tofl.h/ 1117057371  0     0     0       3921      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       */
/*      format                                                              */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      float DSPF_q15tofl(short *x, float *r, int nx);                          */
/*                                                                          */
/*      x     : Input array containing shorts in Q15 format                 */
/*      r     : Output array containing equivalent floats                   */
/*      nx    : Number of values in the x vector                            */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine converts data in the Q15 format into IEEE Single Preci */
/*      floating point.                                                     */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*  void DSPF_q15tofl(short    *x, float *r, int nx)                             */
/*     {                                                                    */
/*      int i;                                                              */
/*      for (i=0;i<nx;i++)                                                  */
/*           r[i]=(float)x[i]/0x8000;                                       */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2002 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_Q15TOFL_ASM_H_
#define DSPF_Q15TOFL_ASM_H_ 1

void DSPF_q15tofl(const     short * x, float * restrict r, int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_q15tofl_h.asm                                              */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2002 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_q15tofl.h6/1117057371  2525  0     0       1759      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_q15tofl -- Q15 format to Single Precision IEEE floating point       *
*      format                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Nov-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_q15tofl

* ======================================================================== *
*  End of file: DSPF_q15tofl_h.asm                                              *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2002 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *

DSPF_dp_lms.h/  1117057372  0     0     0       9134      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_lms -- Double Precision floating point LMS algorithm             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine is C callable, and has the following C prototype:       */
/*                                                                          */
/*     double DSPF_dp_lms (double *x,                                            */
/*                    double *h,                                             */
/*                    double *desired,                                      */
/*                    double *r,                                            */
/*                    double adaptrate,                                     */
/*                    double error,                                         */
/*                    int nh,                                               */
/*                    int nr                                                */
/*                    )                                                     */
/*                                                                          */
/*      x        :  Pointer to input samples                                */
/*      h        :  Pointer to the coefficient array                        */
/*      desired  :  Pointer to the desired output array                     */
/*      r        :  Pointer to filtered output array                        */
/*      adaptrate:  Adaptation rate                                         */
/*      error    :  Initial error                                           */
/*      nh       :  Number of coefficients                                  */
/*      nr       :  Number of output samples                                */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*     The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  */
/*     signal and a desired input signal, the filter produces an output     */
/*     signal, the final coefficient values and returns the final output    */
/*     error signal.                                                        */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*   1. The inner loop is unrolled Two times to allow update of             */
/*      two coefficients in the kernel.                                     */
/*                                                                          */
/*   2. The 'error' term needs to be computed in the outer loop             */
/*      before a new iteration of the inner loop can start. As a            */
/*      result the prolog cannot be placed in parallel with epilog          */
/*      (after the loop kernel).                                            */
/*                                                                          */
/*  3. Register sharing is used to make optimal use of available            */
/*      registers.                                                          */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*   1. The inner loop counter must be a multiple of 2 and >=2.             */
/*   2. Little endianness is assumed.                                       */
/*   3. Extraneous loads are allowed in the program.                        */
/*   4. The coefficient array is assumed to be in reverse order,            */
/*      i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*   This is the C equivalent of the Assembly Code without                  */
/*   restrictions.                                                          */
/*                                                                          */
/*   Note that the assembly code is hand optimized and restrictions         */
/*   may apply.                                                             */
/*                                                                          */
/*   double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou *e
/*        int nr, double error)                                             */
/*   {                                                                      */
/*       int i,j;                                                           */
/*       double sum;                                                        */
/*                                                                          */
/*       for (i = 0; i < nr; i++)                                           */
/*       {                                                                  */
/*        for (j = 0; j < nh; j++)                                          */
/*        {                                                                 */
/*           h[j] = h[j] + (ar*error*x[i+j-1]);                             */
/*        }                                                                 */
/*                                                                          */
/*       sum = 0.0f;                                                        */
/*        for (j = 0; j < nh; j++)                                          */
/*        {                                                                 */
/*          sum += h[j] * x[i+j];                                           */
/*        }                                                                 */
/*       y[i] = sum;                                                        */
/*       error = d[i] - sum;                                                */
/*      }                                                                   */
/*      return error;                                                       */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt-tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*    (4*nh + 47) nr + 27                                                   */
/*    eg. for nh = 24 and nr = 36                                           */
/*    cycles = 5175                                                         */
/*                                                                          */
/* CODESIZE                                                                 */
/*     640 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_LMS_H_
#define DSPF_DP_LMS_H_ 1

double DSPF_dp_lms     (double *x,
              double *h,
               double *desired,
               double *r,
               double adaptrate,
               double error,
               int nh,
               int nr
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_lms.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_lms.h67/1117057372  0     0     0       9057      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_lms -- Double Precision floating point LMS algorithm             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C callable, and has the following C prototype:       *
*                                                                           *
*      double DSPF_dp_lms (double *x,                                            *
*                     double *h,                                             *
*                     double *desired,                                      *
*                     double *r,                                            *
*                     double adaptrate,                                     *
*                     double error,                                         *
*                     int nh,                                               *
*                     int nr                                                *
*                     )                                                     *
*                                                                           *
*       x        :  Pointer to input samples                                *
*       h        :  Pointer to the coefficient array                        *
*       desired  :  Pointer to the desired output array                     *
*       r        :  Pointer to filtered output array                        *
*       adaptrate:  Adaptation rate                                         *
*       error    :  Initial error                                           *
*       nh       :  Number of coefficients                                  *
*       nr       :  Number of output samples                                *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      The DSPF_dp_lms implements an LMS adaptive filter. Given an actual input  *
*      signal and a desired input signal, the filter produces an output     *
*      signal, the final coefficient values and returns the final output    *
*      error signal.                                                        *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*    1. The inner loop is unrolled Two times to allow update of             *
*       two coefficients in the kernel.                                     *
*                                                                           *
*    2. The 'error' term needs to be computed in the outer loop             *
*       before a new iteration of the inner loop can start. As a            *
*       result the prolog cannot be placed in parallel with epilog          *
*       (after the loop kernel).                                            *
*                                                                           *
*   3. Register sharing is used to make optimal use of available            *
*       registers.                                                          *
*                                                                           *
*    ASSUMPTIONS                                                            *
*    1. The inner loop counter must be a multiple of 2 and >=2.             *
*    2. Little endianness is assumed.                                       *
*    3. Extraneous loads are allowed in the program.                        *
*    4. The coefficient array is assumed to be in reverse order,            *
*       i.e. h(nh-1) to h(0) hold coeffs. h0,h1,h2 etc.                     *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    This is the C equivalent of the Assembly Code without                  *
*    restrictions.                                                          *
*                                                                           *
*    Note that the assembly code is hand optimized and restrictions         *
*    may apply.                                                             *
*                                                                           *
*    double DSPF_dp_lms(double *x, double *h, double *y, int nh, double *d,  dou *e
*         int nr, double error)                                             *
*    {                                                                      *
*        int i,j;                                                           *
*        double sum;                                                        *
*                                                                           *
*        for (i = 0; i < nr; i++)                                           *
*        {                                                                  *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*            h[j] = h[j] + (ar*error*x[i+j-1]);                             *
*         }                                                                 *
*                                                                           *
*        sum = 0.0f;                                                        *
*         for (j = 0; j < nh; j++)                                          *
*         {                                                                 *
*           sum += h[j] * x[i+j];                                           *
*         }                                                                 *
*        y[i] = sum;                                                        *
*        error = d[i] - sum;                                                *
*       }                                                                   *
*       return error;                                                       *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
*  CYCLES                                                                   *
*     (4*nh + 47) nr + 27                                                   *
*     eg. for nh = 24 and nr = 36                                           *
*     cycles = 5175                                                         *
*                                                                           *
*  CODESIZE                                                                 *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_lms

*  ======================================================================== *
*   End of file:  DSPF_dp_lms.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_autocor/1117057373  2543  0     0       8210      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_autocor -- double Precision autocorrelation                      */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine has the following C prototype:                         */
/*                                                                          */
/*      void DSPF_dp_autocor                                                     */
/*      (                                                                   */
/*          double    *  restrict r,                                        */
/*          double    *  restrict x,                                        */
/*          int       nx,                                                   */
/*          int       nr                                                    */
/*      )                                                                   */
/*                                                                          */
/*      r  = Pointer to output array of autocorrelation of length nr        */
/*      x  = Pointer to input array of length nx+nr. Input data must        */
/*           be padded with nr consecutive zeros at the beginning.          */
/*      nx = Length of autocorrelation vector.                              */
/*      nr = Length of lags.                                                */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine performs the autocorrelation of the input array x.     */
/*      is assumed that the length of the input array, x, is a              */
/*      multiple of 2 and the length of the output array, r, is a           */
/*      multiple of 4. The assembly routine computes 4 output samples       */
/*      at a time. It is assumed that input vector x is padded with nr      */
/*      no of zeros in the beginning.                                       */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled twice and the outer loop is unrolled  */
/*      four times.                                                         */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx is a multiple of 2 and greater than or equal to 4.            */
/*      2. nr is a multiple of 4 and greater than or equal to 4.            */
/*      3. nx is greater than or equal to nr                                */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      void DSPF_dp_autocor                                                     */
/*      (                                                                   */
/*          double    *  restrict r,                                        */
/*          double    *  restrict x,                                        */
/*          int       nx,                                                   */
/*          int       nr                                                    */
/*      )                                                                   */
/*      {                                                                   */
/*          int i,k;                                                        */
/*          double sum;                                                     */
/*          for (i = 0; i < nr; i++)                                        */
/*          {                                                               */
/*              sum = 0;                                                    */
/*              for (k = nr; k < nx+nr; k++)                                */
/*                  sum += x[k] * x[k-i];                                   */
/*              r[i] = sum ;                                                */
/*          }                                                               */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*      interruptible.                                                      */
/*                                                                          */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      2*nx*nr + 5/2*nr + 32                                               */
/*      For nx=32 and nr=64, cycles=4258                                    */
/*      For nx=24 and nr=32, cycles=1648                                    */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      576 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_AUTOCOR_H_
#define DSPF_DP_AUTOCOR_H_ 1

void DSPF_dp_autocor
(
    double    *  restrict r,
    double    *  restrict x,
    int       nx,
    int       nr
);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_autocor.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_autocor/1117057373  2562  0     0       8264      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_autocor -- double Precision autocorrelation                      *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      25-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*                                                                           *
*       r  = Pointer to output array of autocorrelation of length nr        *
*       x  = Pointer to input array of length nx+nr. Input data must        *
*            be padded with nr consecutive zeros at the beginning.          *
*       nx = Length of autocorrelation vector.                              *
*       nr = Length of lags.                                                *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine performs the autocorrelation of the input array x.     *
*       is assumed that the length of the input array, x, is a              *
*       multiple of 2 and the length of the output array, r, is a           *
*       multiple of 4. The assembly routine computes 4 output samples       *
*       at a time. It is assumed that input vector x is padded with nr      *
*       no of zeros in the beginning.                                       *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice and the outer loop is unrolled  *
*       four times.                                                         *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 2 and greater than or equal to 4.            *
*       2. nr is a multiple of 4 and greater than or equal to 4.            *
*       3. nx is greater than or equal to nr                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       void DSPF_dp_autocor                                                     *
*       (                                                                   *
*           double    *  restrict r,                                        *
*           double    *  restrict x,                                        *
*           int       nx,                                                   *
*           int       nr                                                    *
*       )                                                                   *
*       {                                                                   *
*           int i,k;                                                        *
*           double sum;                                                     *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (k = nr; k < nx+nr; k++)                                *
*                   sum += x[k] * x[k-i];                                   *
*               r[i] = sum ;                                                *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*       interruptible.                                                      *
*                                                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       2*nx*nr + 5/2*nr + 32                                               *
*       For nx=32 and nr=64, cycles=4258                                    *
*       For nx=24 and nr=32, cycles=1648                                    *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       576 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_autocor

*  ======================================================================== *
*   End of file:  DSPF_dp_autocor.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_bitrev_/1117057374  2583  0     0       15918     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         */
/*     numbers                                                             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine is C Callable and can be called as:                     */
/*                                                                          */
/*     void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                */
/*                                                                          */
/*     x      : Complex input array to be bit-reversed.                     */
/*              Contains 2*nx doubles                                       */
/*     index  : Array of size ~sqrt(nx) created by the routine              */
/*              bitrev_index to allow the fast implementation of the        */
/*              bit-reversal.                                               */
/*     nx     : Number of elements in array x[]. Must be power of 2.        */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine performs the bit-reversal of the input array x[],       */
/*     where x[] is a double array of length 2*nx containing Double         */
/*     precision floating point complex pairs of data. This routine         */
/*     requires the index array provided by the program below.              */
/*     This index should be generated at compile time not by the DSP.       */
/*                                                                          */
/*     authorizes the use of the bit-reversal code and related table        */
/*     generation code with TMS320-family DSPs manufactured by TI.          */
/*                                                                          */
/*     // ----------------------------------------------------------- //    */
/*     //  This routine calculates the index for bit reversal of      //    */
/*     //  an array of length nx.  The length of the index table is   //    */
/*     //  2^(2*ceil(k/2)) where nx = 2^k.                            //    */
/*     //                                                             //    */
/*     //  In other words, the length of the index table is:          //    */
/*     //      - for even power of radix: sqrt(nx)                    //    */
/*     //      - for odd  power of radix: sqrt(2*nx)                  //    */
/*     // ----------------------------------------------------------- //    */
/*     void bitrev_index(short *index, int nx)                              */
/*     {                                                                    */
/*         int   i, j, k, radix = 2;                                        */
/*         short nbits, nbot, ntop, ndiff, n2, raddiv2;                     */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*             i = i >> 1;                                                  */
/*             nbits++;                                                     */
/*         }                                                                */
/*                                                                          */
/*         raddiv2 = radix >> 1;                                            */
/*         nbot    = nbits >> raddiv2;                                      */
/*         nbot    = nbot << raddiv2 - 1;                                   */
/*         ndiff   = nbits & raddiv2;                                       */
/*         ntop    = nbot + ndiff;                                          */
/*         n2      = 1 << ntop;                                             */
/*                                                                          */
/*         index[0] = 0;                                                    */
/*         for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  */
/*         {                                                                */
/*             index[i] = j - 1;                                            */
/*                                                                          */
/*             for (k = n2/radix; k*(radix-1) < j; k /= radix)              */
/*                 j -= k*(radix-1);                                        */
/*                                                                          */
/*             j += k;                                                      */
/*         }                                                                */
/*         index[n2 - 1] = n2 - 1;                                          */
/*     }                                                                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*     1. nx must be a power of 2.                                          */
/*     2. The table from bitrev_index is already created.                   */
/*     3. The array x is actually an array of 2*nx doubles.                 */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                */
/*      {                                                                   */
/*         int    i;                                                        */
/*         short  i0, i1, i2;                                               */
/*         short  j0, j1, j2;                                               */
/*         double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       */
/*         double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       */
/*         short  t;                                                        */
/*         int    a, b, ia, ib, ibs;                                        */
/*         int    mask;                                                     */
/*         int    nbits, nbot, ntop, ndiff, n2, halfn;                      */
/*                                                                          */
/*         nbits = 0;                                                       */
/*         i = nx;                                                          */
/*         while (i > 1)                                                    */
/*         {                                                                */
/*            i = i >> 1;                                                   */
/*            nbits++;                                                      */
/*         }                                                                */
/*                                                                          */
/*         nbot    = nbits >> 1;                                            */
/*         ndiff   = nbits & 1;                                             */
/*         ntop    = nbot + ndiff;                                          */
/*         n2       = 1 << ntop;                                            */
/*         mask    = n2 - 1;                                                */
/*         halfn   = nx >> 1;                                               */
/*                                                                          */
/*         for (i0 = 0; i0 < halfn; i0 += 2)                                */
/*         {                                                                */
/*             b       = i0 & mask;                                         */
/*             a       = i0 >> nbot;                                        */
/*             if (!b) ia = index[a];                                       */
/*             ib      = index[b];                                          */
/*             ibs     = ib << nbot;                                        */
/*                                                                          */
/*             j0      = ibs + ia;                                          */
/*             t       = i0 < j0;                                           */
/*             xi0r     = x[2*i0];                                          */
/*             xi0i     = x[2*i0+1];                                        */
/*             xj0r     = x[2*j0];                                          */
/*             xj0i     = x[2*j0+1];                                           */
/*             if (t)                                                       */
/*             {                                                            */
/*                x[2*i0]   = xj0r;                                         */
/*                x[2*i0+1] = xj0i;                                         */
/*                x[2*j0]   = xi0r;                                         */
/*                x[2*j0+1] = xi0i;                                         */
/*              }                                                           */
/*                                                                          */
/*             i1      = i0 + 1;                                            */
/*             j1      = j0 + halfn;                                        */
/*             xi1r    = x[2*i1];                                           */
/*             xi1i    = x[2*i1+1];                                         */
/*             xj1r    = x[2*j1];                                           */
/*             xj1i    = x[2*j1+1];                                         */
/*                                                                          */
/*             x[2*i1]   = xj1r;                                            */
/*             x[2*i1+1] = xj1i;                                            */
/*             x[2*j1]   = xi1r;                                            */
/*             x[2*j1+1] = xi1i;                                            */
/*                                                                          */
/*             i2      = i1 + halfn;                                        */
/*             j2      = j1 + 1;                                            */
/*                                                                          */
/*             xi2r    = x[2*i2];                                           */
/*             xi2i    = x[2*i2+1];                                         */
/*             xj2r    = x[2*j2];                                           */
/*             xj2i    = x[2*j2+1];                                         */
/*             if (t)                                                       */
/*             {                                                            */
/*             x[2*i2]   = xj2r;                                            */
/*             x[2*i2+1] = xj2i;                                            */
/*             x[2*j2]   = xi2r;                                            */
/*             x[2*j2+1] = xi2i;                                            */
/*             }                                                            */
/*           }                                                              */
/*                                                                          */
/*         }                                                                */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*     1. The index table can be generated using the bitrev_index           */
/*        function provided in the dsplib\support\fft directory.            */
/*     2. If nx <= 4K one can use the char (8-bit) data type for            */
/*        the "index" variable. This would require changing the LDH when    */
/*        loading index values in the assembly routine to LDB. This would   */
/*        further reduce the size of the Index Table by half its size.      */
/*                                                                          */
/*     3. Endian: LITTLE ENDIAN configuration used.                         */
/*                                                                          */
/*     4. Interruptibility: This code is interrupt tolerant, but not        */
/*        interruptible.                                                    */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*     5*nx + 33                                                            */
/*     e.g. nx = 128, cycles = 673                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     736 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BITREV_CPLX_H_
#define DSPF_DP_BITREV_CPLX_H_ 1

void DSPF_dp_bitrev_cplx(double     *x, short *index, int nx);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_bitrev_cplx.h                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_bitrev_/1117057374  2606  0     0       15933     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_bitrev_cplx -- Bit reversal for Double Precision Complex         *
*      numbers                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      29-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine is C Callable and can be called as:                     *
*                                                                           *
*      void DSPF_dp_bitrev_cplx(double *x, short *index, int nx);                *
*                                                                           *
*      x      : Complex input array to be bit-reversed.                     *
*               Contains 2*nx doubles                                       *
*      index  : Array of size ~sqrt(nx) created by the routine              *
*               bitrev_index to allow the fast implementation of the        *
*               bit-reversal.                                               *
*      nx     : Number of elements in array x[]. Must be power of 2.        *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine performs the bit-reversal of the input array x[],       *
*      where x[] is a double array of length 2*nx containing Double         *
*      precision floating point complex pairs of data. This routine         *
*      requires the index array provided by the program below.              *
*      This index should be generated at compile time not by the DSP.       *
*                                                                           *
*      authorizes the use of the bit-reversal code and related table        *
*      generation code with TMS320-family DSPs manufactured by TI.          *
*                                                                           *
*      /* ----------------------------------------------------------- */    *
*      /*  This routine calculates the index for bit reversal of      */    *
*      /*  an array of length nx.  The length of the index table is   */    *
*      /*  2^(2*ceil(k/2)) where nx = 2^k.                            */    *
*      /*                                                             */    *
*      /*  In other words, the length of the index table is:          */    *
*      /*      - for even power of radix: sqrt(nx)                    */    *
*      /*      - for odd  power of radix: sqrt(2*nx)                  */    *
*      /* ----------------------------------------------------------- */    *
*      void bitrev_index(short *index, int nx)                              *
*      {                                                                    *
*          int   i, j, k, radix = 2;                                        *
*          short nbits, nbot, ntop, ndiff, n2, raddiv2;                     *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*              i = i >> 1;                                                  *
*              nbits++;                                                     *
*          }                                                                *
*                                                                           *
*          raddiv2 = radix >> 1;                                            *
*          nbot    = nbits >> raddiv2;                                      *
*          nbot    = nbot << raddiv2 - 1;                                   *
*          ndiff   = nbits & raddiv2;                                       *
*          ntop    = nbot + ndiff;                                          *
*          n2      = 1 << ntop;                                             *
*                                                                           *
*          index[0] = 0;                                                    *
*          for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                  *
*          {                                                                *
*              index[i] = j - 1;                                            *
*                                                                           *
*              for (k = n2/radix; k*(radix-1) < j; k /= radix)              *
*                  j -= k*(radix-1);                                        *
*                                                                           *
*              j += k;                                                      *
*          }                                                                *
*          index[n2 - 1] = n2 - 1;                                          *
*      }                                                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*      1. nx must be a power of 2.                                          *
*      2. The table from bitrev_index is already created.                   *
*      3. The array x is actually an array of 2*nx doubles.                 *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_bitrev_cplx(double* x, short* index, int nx)                *
*       {                                                                   *
*          int    i;                                                        *
*          short  i0, i1, i2;                                               *
*          short  j0, j1, j2;                                               *
*          double xi0r, xi0i, xi1r, xi1i, xi2r, xi2i;                       *
*          double xj0r, xj0i, xj1r, xj1i, xj2r, xj2i;                       *
*          short  t;                                                        *
*          int    a, b, ia, ib, ibs;                                        *
*          int    mask;                                                     *
*          int    nbits, nbot, ntop, ndiff, n2, halfn;                      *
*                                                                           *
*          nbits = 0;                                                       *
*          i = nx;                                                          *
*          while (i > 1)                                                    *
*          {                                                                *
*             i = i >> 1;                                                   *
*             nbits++;                                                      *
*          }                                                                *
*                                                                           *
*          nbot    = nbits >> 1;                                            *
*          ndiff   = nbits & 1;                                             *
*          ntop    = nbot + ndiff;                                          *
*          n2       = 1 << ntop;                                            *
*          mask    = n2 - 1;                                                *
*          halfn   = nx >> 1;                                               *
*                                                                           *
*          for (i0 = 0; i0 < halfn; i0 += 2)                                *
*          {                                                                *
*              b       = i0 & mask;                                         *
*              a       = i0 >> nbot;                                        *
*              if (!b) ia = index[a];                                       *
*              ib      = index[b];                                          *
*              ibs     = ib << nbot;                                        *
*                                                                           *
*              j0      = ibs + ia;                                          *
*              t       = i0 < j0;                                           *
*              xi0r     = x[2*i0];                                          *
*              xi0i     = x[2*i0+1];                                        *
*              xj0r     = x[2*j0];                                          *
*              xj0i     = x[2*j0+1];                                           *
*              if (t)                                                       *
*              {                                                            *
*                 x[2*i0]   = xj0r;                                         *
*                 x[2*i0+1] = xj0i;                                         *
*                 x[2*j0]   = xi0r;                                         *
*                 x[2*j0+1] = xi0i;                                         *
*               }                                                           *
*                                                                           *
*              i1      = i0 + 1;                                            *
*              j1      = j0 + halfn;                                        *
*              xi1r    = x[2*i1];                                           *
*              xi1i    = x[2*i1+1];                                         *
*              xj1r    = x[2*j1];                                           *
*              xj1i    = x[2*j1+1];                                         *
*                                                                           *
*              x[2*i1]   = xj1r;                                            *
*              x[2*i1+1] = xj1i;                                            *
*              x[2*j1]   = xi1r;                                            *
*              x[2*j1+1] = xi1i;                                            *
*                                                                           *
*              i2      = i1 + halfn;                                        *
*              j2      = j1 + 1;                                            *
*                                                                           *
*              xi2r    = x[2*i2];                                           *
*              xi2i    = x[2*i2+1];                                         *
*              xj2r    = x[2*j2];                                           *
*              xj2i    = x[2*j2+1];                                         *
*              if (t)                                                       *
*              {                                                            *
*              x[2*i2]   = xj2r;                                            *
*              x[2*i2+1] = xj2i;                                            *
*              x[2*j2]   = xi2r;                                            *
*              x[2*j2+1] = xi2i;                                            *
*              }                                                            *
*            }                                                              *
*                                                                           *
*          }                                                                *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1. The index table can be generated using the bitrev_index           *
*         function provided in the dsplib\support\fft directory.            *
*      2. If nx <= 4K one can use the char (8-bit) data type for            *
*         the "index" variable. This would require changing the LDH when    *
*         loading index values in the assembly routine to LDB. This would   *
*         further reduce the size of the Index Table by half its size.      *
*                                                                           *
*      3. Endian: LITTLE ENDIAN configuration used.                         *
*                                                                           *
*      4. Interruptibility: This code is interrupt tolerant, but not        *
*         interruptible.                                                    *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      5*nx + 33                                                            *
*      e.g. nx = 128, cycles = 673                                          *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      736 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_bitrev_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_bitrev_cplx.h67                                        *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_cfftr4_/1117057375  2631  0     0       14391     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      */
/*     Frequency radix-4 FFT with complex input                            */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*  This routine is C Callable and can be called as:                        */
/*                                                                          */
/*  void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       */
/*                                                                          */
/*  x : Pointer to an array holding the input and output floating           */
/*      point array which contains 'n' complex points                       */
/*  w : Pointer to an array holding the coefficient floating point          */
/*      array which contains 3*n/4 complex numbers                          */
/*  n : Number of complex points in x                                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*  This routine implements the DIF (decimation in frequency)               */
/*  complex radix 4 FFT with digit-reversed output and normal               */
/*  order input.  The number of points, 'n', must be a power                */
/*  of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   */
/*  in-place routine in the sense that the output is written                */
/*  over the input.  It is not an in-place routine in the                   */
/*  sense that the input is in normal order and the output is               */
/*  in digit-reversed order.                                                */
/*                                                                          */
/*  There must be n complex points (2*n values), and 3*n/4 complex          */
/*  coefficients (3*n/2 values).                                            */
/*                                                                          */
/*  Each real and imaginary input value is interleaved in the               */
/*  'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             */
/*  are in normal order.  Each real and imaginary output value              */
/*  is interleaved in the 'x' array and the complex numbers are             */
/*  in digit-reversed  order {rx0, ix0, ...}.  The real and                 */
/*  imaginary values of the coefficients are interleaved in the             */
/*  'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           */
/*  are in normal order.                                                    */
/*                                                                          */
/*  Note that the imaginary coefficients are negated                        */
/*  {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           */
/*  {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       */
/*  where d = 2*PI/n.  The value of w(n,k) is usually written               */
/*  w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                */
/*                                                                          */
/*  The routine can be used to implement an inverse FFT by                  */
/*  performing the complex conjugate on the input complex numbers           */
/*  (negating the imaginary value), and dividing the result by n.           */
/*  Another method to use the FFT to perform an inverse FFT, is to          */
/*  swap the real and imaginary values of the input and the result,         */
/*  and divide the result by n.  In either case, the input is still         */
/*  in normal order and the output is still in digit-reversed order.        */
/*                                                                          */
/*  Note that you can not make the radix 4 FFT into an inverse              */
/*  FFT by using the complex conjugate of the coefficients as               */
/*  you can do with the complex radix 2 FFT.                                */
/*                                                                          */
/*  If you label the input locations from 0 to (n-1) (normal order),        */
/*  the digit-reversed locations can be calculated by reversing the         */
/*  order of the bit pairs of the labels.  For example, for a 1024          */
/*  point FFT, the digit reversed location for                              */
/*  617d = 1001101001b = 10 01 10 10 01  is                                 */
/*  422d = 0110100110b = 01 10 10 01 10  and visa versa.                    */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*  1.  All the three loops are executed as one loop with                   */
/*      conditional instructions.                                           */
/*  2.  The outer loop counter is used as load counterto prevent            */
/*      extraneous loads.                                                   */
/*  3.  If more registers were available, the inner loop could              */
/*      probably be as small as 28 cycles,but the loop was extended         */
/*      to 56 cycles to allow more variables to share registers.            */
/*  4.  The pointer for X and W are maintianed  on both register sides      */
/*      to avoid crosspath Conflicts.                                       */
/*  5.  Variable tctr is used as innerloop Counter.                          */
/*  6.  The variable, K, is used as the outer loop counter.We are           */
/*      finished when n2b = 0.                                              */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*  1.  There are no special alignment requirements.                        */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent for the assembly code.  Note that              */
/*  the assembly code is hand optimized and restrictions may                */
/*  apply.                                                                  */
/*                                                                          */
/*  void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       */
/*  {                                                                       */
/*      short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              */
/*      double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               */
/*      double si1, si2, si3;                                               */
/*      n2 = n;                                                             */
/*      ie = 1;                                                             */
/*      for(k=n; k>1; k>>=2)                                                */
/*      {                                                                   */
/*         n1 = n2;                                                         */
/*         n2 >>= 2;                                                        */
/*         ia1 = 0;                                                         */
/*         for(j=0; j<n2; j++)                                              */
/*         {                                                                */
/*             ia2 = ia1 + ia1;                                             */
/*             ia3 = ia1 + ia2;                                             */
/*             co1 = w[ia1*2];                                              */
/*             si1 = w[ia1*2 + 1];                                          */
/*             co2 = w[ia2*2];                                              */
/*             si2 = w[ia2*2 + 1];                                          */
/*             co3 = w[ia3*2];                                              */
/*             si3 = w[ia3*2 + 1];                                          */
/*             ia1 += ie;                                                   */
/*             for(i0=j; i0<n; i0+=n1)                                      */
/*             {                                                            */
/*                 i1 = i0 + n2;                                            */
/*                 i2 = i1 + n2;                                            */
/*                 i3 = i2 + n2;                                            */
/*                 r1 = x[i0*2]   + x[i2*2];                                */
/*                 r3 = x[i0*2]   - x[i2*2];                                */
/*                 s1 = x[i0*2+1] + x[i2*2+1];                              */
/*                 s3 = x[i0*2+1] - x[i2*2+1];                              */
/*                 r2 = x[i1*2]   + x[i3*2];                                */
/*                 r4 = x[i1*2]   - x[i3*2];                                */
/*                 s2 = x[i1*2+1] + x[i3*2+1];                              */
/*                 s4 = x[i1*2+1] - x[i3*2+1];                              */
/*                 x[i0*2]   = r1 + r2;                                     */
/*                 r2        = r1 - r2;                                     */
/*                 r1        = r3 - s4;                                     */
/*                 r3        = r3 + s4;                                     */
/*                 x[i0*2+1] = s1 + s2;                                     */
/*                 s2        = s1 - s2;                                     */
/*                 s1        = s3 + r4;                                     */
/*                 s3        = s3 - r4;                                     */
/*                 x[i1*2]   = co1*r3 + si1*s3;                             */
/*                 x[i1*2+1] = co1*s3 - si1*r3;                             */
/*                 x[i2*2]   = co2*r2 + si2*s2;                             */
/*                 x[i2*2+1] = co2*s2 - si2*r2;                             */
/*                 x[i3*2]   = co3*r1 + si3*s1;                             */
/*                 x[i3*2+1] = co3*s1 - si3*r1;                             */
/*            }                                                             */
/*         }                                                                */
/*         ie <<= 2;                                                        */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. The twiddle factor array w can be generated by the tw_r4fft       */
/*        function provided in dsplib\support\fft\tw_r4fft.c. The exe       */
/*        file for this function, dsplib\bin\tw_r4fft.exe, can be           */
/*        used dump the twiddle factor array into a file.                   */
/*     2. The function bit_rev in dsplib\support\fft can be used to         */
/*        bit-reverse the output array to convert it into normal order.     */
/*     3. Endian: This code is LITTLE  ENDIAN.                              */
/*     4. Interruptibility: This code is interrupt tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*    14*n*log4(n) + 46                                                     */
/*    eg. if n = 256, cycles = 14382.                                       */
/*                                                                          */
/*  CODESIZE                                                                */
/*      1344 bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CFFTR4_DIF_H_
#define DSPF_DP_CFFTR4_DIF_H_ 1

void DSPF_dp_cfftr4_dif(double*     x, double* w, short n);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_cfftr4_dif.h                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_cfftr4_/1117057375  2653  0     0       14429     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr4_dif -- Double Precision floating point Decimation in      *
*      Frequency radix-4 FFT with complex input                            *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Oct-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*   This routine is C Callable and can be called as:                        *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*                                                                           *
*   x : Pointer to an array holding the input and output floating           *
*       point array which contains 'n' complex points                       *
*   w : Pointer to an array holding the coefficient floating point          *
*       array which contains 3*n/4 complex numbers                          *
*   n : Number of complex points in x                                       *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*   This routine implements the DIF (decimation in frequency)               *
*   complex radix 4 FFT with digit-reversed output and normal               *
*   order input.  The number of points, 'n', must be a power                *
*   of 4 {4, 16, 64, 256, 1024, ...}.  This routine is an                   *
*   in-place routine in the sense that the output is written                *
*   over the input.  It is not an in-place routine in the                   *
*   sense that the input is in normal order and the output is               *
*   in digit-reversed order.                                                *
*                                                                           *
*   There must be n complex points (2*n values), and 3*n/4 complex          *
*   coefficients (3*n/2 values).                                            *
*                                                                           *
*   Each real and imaginary input value is interleaved in the               *
*   'x' array {rx0, ix0, rx1, ix2, ...} and the complex numbers             *
*   are in normal order.  Each real and imaginary output value              *
*   is interleaved in the 'x' array and the complex numbers are             *
*   in digit-reversed  order {rx0, ix0, ...}.  The real and                 *
*   imaginary values of the coefficients are interleaved in the             *
*   'w' array {rw0, -iw0, rw1, -iw1, ...} and the complex numbers           *
*   are in normal order.                                                    *
*                                                                           *
*   Note that the imaginary coefficients are negated                        *
*   {cos(d*0),  sin(d*0),  cos(d*1),   sin(d*1), ...} rather than           *
*   {cos(d*0), -sin(d*0),  cos(d*1),  -sin(d*1), ...}                       *
*   where d = 2*PI/n.  The value of w(n,k) is usually written               *
*   w(n,k) = e^-j(2*PI*k/n) = cos(2*PI*k/n) - sin(2*PI*k/n).                *
*                                                                           *
*   The routine can be used to implement an inverse FFT by                  *
*   performing the complex conjugate on the input complex numbers           *
*   (negating the imaginary value), and dividing the result by n.           *
*   Another method to use the FFT to perform an inverse FFT, is to          *
*   swap the real and imaginary values of the input and the result,         *
*   and divide the result by n.  In either case, the input is still         *
*   in normal order and the output is still in digit-reversed order.        *
*                                                                           *
*   Note that you can not make the radix 4 FFT into an inverse              *
*   FFT by using the complex conjugate of the coefficients as               *
*   you can do with the complex radix 2 FFT.                                *
*                                                                           *
*   If you label the input locations from 0 to (n-1) (normal order),        *
*   the digit-reversed locations can be calculated by reversing the         *
*   order of the bit pairs of the labels.  For example, for a 1024          *
*   point FFT, the digit reversed location for                              *
*   617d = 1001101001b = 10 01 10 10 01  is                                 *
*   422d = 0110100110b = 01 10 10 01 10  and visa versa.                    *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*   1.  All the three loops are executed as one loop with                   *
*       conditional instructions.                                           *
*   2.  The outer loop counter is used as load counterto prevent            *
*       extraneous loads.                                                   *
*   3.  If more registers were available, the inner loop could              *
*       probably be as small as 28 cycles,but the loop was extended         *
*       to 56 cycles to allow more variables to share registers.            *
*   4.  The pointer for X and W are maintianed  on both register sides      *
*       to avoid crosspath Conflicts.                                       *
*   5.  Variable tctr is used as innerloop Counter.                          *
*   6.  The variable, K, is used as the outer loop counter.We are           *
*       finished when n2b = 0.                                              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*   1.  There are no special alignment requirements.                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent for the assembly code.  Note that              *
*   the assembly code is hand optimized and restrictions may                *
*   apply.                                                                  *
*                                                                           *
*   void DSPF_dp_cfftr4_dif(double* x, double* w, short n)                       *
*   {                                                                       *
*       short n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;              *
*       double r1, r2, r3, r4, s1, s2, s3, s4, co1, co2, co3;               *
*       double si1, si2, si3;                                               *
*       n2 = n;                                                             *
*       ie = 1;                                                             *
*       for(k=n; k>1; k>>=2)                                                *
*       {                                                                   *
*          n1 = n2;                                                         *
*          n2 >>= 2;                                                        *
*          ia1 = 0;                                                         *
*          for(j=0; j<n2; j++)                                              *
*          {                                                                *
*              ia2 = ia1 + ia1;                                             *
*              ia3 = ia1 + ia2;                                             *
*              co1 = w[ia1*2];                                              *
*              si1 = w[ia1*2 + 1];                                          *
*              co2 = w[ia2*2];                                              *
*              si2 = w[ia2*2 + 1];                                          *
*              co3 = w[ia3*2];                                              *
*              si3 = w[ia3*2 + 1];                                          *
*              ia1 += ie;                                                   *
*              for(i0=j; i0<n; i0+=n1)                                      *
*              {                                                            *
*                  i1 = i0 + n2;                                            *
*                  i2 = i1 + n2;                                            *
*                  i3 = i2 + n2;                                            *
*                  r1 = x[i0*2]   + x[i2*2];                                *
*                  r3 = x[i0*2]   - x[i2*2];                                *
*                  s1 = x[i0*2+1] + x[i2*2+1];                              *
*                  s3 = x[i0*2+1] - x[i2*2+1];                              *
*                  r2 = x[i1*2]   + x[i3*2];                                *
*                  r4 = x[i1*2]   - x[i3*2];                                *
*                  s2 = x[i1*2+1] + x[i3*2+1];                              *
*                  s4 = x[i1*2+1] - x[i3*2+1];                              *
*                  x[i0*2]   = r1 + r2;                                     *
*                  r2        = r1 - r2;                                     *
*                  r1        = r3 - s4;                                     *
*                  r3        = r3 + s4;                                     *
*                  x[i0*2+1] = s1 + s2;                                     *
*                  s2        = s1 - s2;                                     *
*                  s1        = s3 + r4;                                     *
*                  s3        = s3 - r4;                                     *
*                  x[i1*2]   = co1*r3 + si1*s3;                             *
*                  x[i1*2+1] = co1*s3 - si1*r3;                             *
*                  x[i2*2]   = co2*r2 + si2*s2;                             *
*                  x[i2*2+1] = co2*s2 - si2*r2;                             *
*                  x[i3*2]   = co3*r1 + si3*s1;                             *
*                  x[i3*2+1] = co3*s1 - si3*r1;                             *
*             }                                                             *
*          }                                                                *
*          ie <<= 2;                                                        *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. The twiddle factor array w can be generated by the tw_r4fft       *
*         function provided in dsplib\support\fft\tw_r4fft.c. The exe       *
*         file for this function, dsplib\bin\tw_r4fft.exe, can be           *
*         used dump the twiddle factor array into a file.                   *
*      2. The function bit_rev in dsplib\support\fft can be used to         *
*         bit-reverse the output array to convert it into normal order.     *
*      3. Endian: This code is LITTLE  ENDIAN.                              *
*      4. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     14*n*log4(n) + 46                                                     *
*     eg. if n = 256, cycles = 14382.                                       *
*                                                                           *
*   CODESIZE                                                                *
*       1344 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_cfftr4_dif

*  ======================================================================== *
*   End of file:  DSPF_dp_cfftr4_dif.h67                                         *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_cfftr2./1117057376  2677  0     0       19475     `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_cfftr2 -- Double Precision Cache Optimized radix 2 forward FFT    */
/*     with complex input                                                  */
/*                                                                         */
/* USAGE                                                                    */
/*        This routine is C-callable and can be called as:                  */
/*                                                                          */
/*        void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          */
/*                                                                          */
/*        x : input and output sequences (dim-n)      (input/output)        */
/*            x has n complex numbers (2*n DP values).                      */
/*            The real and imaginary values are interleaved in memory.      */
/*            The input is in normal order and output is in bit-reversed    */
/*            Order.                                                        */
/*        w : FFT coefficients (dim-n)                (input)               */
/*            w has n complex numbers (n DP values).                        */
/*            FFT coeficients are in a special sequence so that FFT can     */
/*            be called on smaller input sets multiple times to avoid       */
/*            cache thrashing.                                              */
/*            The real and imaginary values are interleaved in memory.      */
/*        n : FFT size which is a power of 2 and > 4  (input)               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*      This routine is used to compute the Complex, Radix-2, Fast          */
/*      Fourier Transform of a double precision complex sequence of size    */
/*      n, and a power of 2 in a Cache-friendly way. The routine requires   */
/*      normal order input and normal order coefficents (twiddle factors)   */
/*      in a special sequence and produces results that are in              */
/*      bit-reversed order.                                                 */
/*                                                                          */
/*      The input can be broken into smaller parts and called multiple      */
/*      times to avoid cache thrashing.                                     */
/*                                                                          */
/*      How to use                                                          */
/*                                                                          */
/*      void main(void)                                                     */
/*      {                                                                   */
/*         gen_w_r2(w, N);         // Generate coefficient table            */
/*                                 // in normal order                       */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in      */
/*                                 // order bit-reversed                    */
/*                                                                          */
/*        bit_rev(x, N)           // Bit reverse the output if              */
/*                                 // normal order output is needed         */
/*                                 // Function is given in C-CODE section   */
/*      }                                                                   */
/*                                                                          */
/*      main fft of size N can be divided into several steps (where         */
/*      number of steps is a power of 2), allowing as much data             */
/*      reuse as possible.                                                  */
/*                                                                          */
/*      For example the following function                                  */
/*      DSPF_dp_cfftr2(N, x, w, 1);                                              */
/*                                                                          */
/*      is equivalent to:                                                   */
/*                                                                          */
/*      DSPF_dp_cfftr2(N, x, w, N/4);                                            */
/*                                                                          */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                  */
/*      DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                  */
/*                                                                          */
/*      Notice how the 1st fft function is called on the entire data set.   */
/*      It covers the 1st pass of the fft until the butterfly size is       */
/*      N/4. The following 4 ffts do N/4 point ffts, 25% of the original    */
/*      size. These continue down to the end when the buttly is of size     */
/*      2. We use an index of 2* 3/4 *N to the main twiddle factor array    */
/*      for the last 4 calls. This is because the twiddle factor array      */
/*      is composed of successively decimated versions of the main array.   */
/*                                                                          */
/*      The twiddle factor array is composed of log2(N) sets of twiddle     */
/*      factors of size N, N/2, N/4, N/8 etc. The index into this array     */
/*      for each stage of the fft can be calculated by summing these        */
/*      indices up appropriately. For example, if we are dividing the       */
/*      input into 2 parts then index into this array should be N, if we    */
/*      are dividing into 4 parts then index into this array should be      */
/*      N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   */
/*                                                                          */
/*      For multiple ffts they can share the same table by calling the      */
/*      small ffts from further down in the twiddle factor array, in the    */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      The functions for creating this special sequence of twiddle         */
/*      factors and bit-reversal are provided in the C CODE section.        */
/*                                                                          */
/*      In general if divide the input into NO_OF_DIV parts we can call     */
/*      the function as follows:                                            */
/*                                                                          */
/*      // Divide the input into NO_OF_DIV parts                            */
/*      DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                    */
/*                                                                          */
/*                                                                          */
/*      // Find out the index into twiddle factor array                     */
/*      for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       */
/*      {                                                                   */
/*         w_index += j;                                                    */
/*      }                                                                   */
/*      w_index = N * w_index / NO_OF_DIV;                                  */
/*                                                                          */
/*      // Call the Function a subset of inputs                             */
/*      for(i=0; i<NO_OF_DIV; i++)                                          */
/*      {                                                                   */
/*         DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);   */
/*      }                                                                   */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*      1. Outer loop instructions are executed in parallel with the        */
/*         inner loop epilog.                                               */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*      1. Both input x and coefficient w should be aligned on double       */
/*         word boundary.                                                   */
/*      2. n should be greater than 4 and a power of 2.                     */
/*                                                                          */
/* C CODE                                                                   */
/*        This is the C equivalent of the assembly code without             */
/*        restrictions. Note that the assembly code is hand optimized       */
/*        and restrictions may apply.                                       */
/*                                                                          */
/*        void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          */
/*        {                                                                 */
/*             int n2, ie, ia, i, j, k, m;                                  */
/*             double rtemp, itemp, c, s;                                   */
/*                                                                          */
/*             n2 = n;                                                      */
/*             ie = 1;                                                      */
/*                                                                          */
/*             for(k = n; k > n_min; k >>= 1)                               */
/*              {                                                           */
/*                n2 >>= 1;                                                 */
/*                ia = 0;                                                   */
/*                for(j=0; j < ie; j++)                                     */
/*                {                                                         */
/*                 for(i=0; i < n2; i++)                                    */
/*                   {                                                      */
/*                      c = w[2*i];                                         */
/*                      s = w[2*i+1];                                       */
/*                      m = ia + n2;                                        */
/*                      rtemp     = x[2*ia]   - x[2*m];                     */
/*                      x[2*ia]   = x[2*ia]   + x[2*m];                     */
/*                      itemp     = x[2*ia+1] - x[2*m+1];                   */
/*                      x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   */
/*                      x[2*m]    = c*rtemp   - s*itemp;                    */
/*                      x[2*m+1]  = c*itemp   + s*rtemp;                    */
/*                      ia++;                                               */
/*                     }                                                    */
/*                  ia += n2;                                               */
/*                 }                                                        */
/*                ie <<= 1;                                                 */
/*                w = w + k;                                                */
/*             }                                                            */
/*         }                                                                */
/*                                                                          */
/*         The follwoing C code is used to generate the coefficient table.  */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*          //  table of size n complex numbers (or 2*n numbers)            */
/*                                                                          */
/*          void gen_w_r2(double* w, int n)                                 */
/*          {                                                               */
/*               int i, j=1;                                                */
/*               double pi = 4.0*atan(1.0);                                 */
/*               double e = pi*2.0/n;                                       */
/*               for(j=1; j < n; j <<= 1)                                   */
/*               {                                                          */
/*               for(i=0; i < ( n>>1 ); i += j)                             */
/*                  {                                                       */
/*                  *w++   = cos(i*e);                                      */
/*                  *w++   = -sin(i*e);                                     */
/*                  }                                                       */
/*               }                                                          */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*          The follwoing C code is used to bit-reverse the output.         */
/*                                                                          */
/*          bit_rev(double* x, int n)                                       */
/*          {                                                               */
/*            int i, j, k;                                                  */
/*            double rtemp, itemp;                                          */
/*                                                                          */
/*            j = 0;                                                        */
/*            for(i=1; i < (n-1); i++)                                      */
/*            {                                                             */
/*              k = n >> 1;                                                 */
/*               while(k <= j)                                              */
/*               {                                                          */
/*                  j -= k;                                                 */
/*                  k >>= 1;                                                */
/*               }                                                          */
/*               j += k;                                                    */
/*               if(i < j)                                                  */
/*               {                                                          */
/*                  rtemp    = x[j*2];                                      */
/*                  x[j*2]   = x[i*2];                                      */
/*                  x[i*2]   = rtemp;                                       */
/*                  itemp    = x[j*2+1];                                    */
/*                  x[j*2+1] = x[i*2+1];                                    */
/*                  x[i*2+1] = itemp;                                       */
/*               }                                                          */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. The special sequence of twiddle factor array w can be generated  */
/*        using the gen_w_r2 function provided in the previous section.     */
/*                                                                          */
/*      2. Endian:This code is LITTLE ENDIAN.                               */
/*                                                                          */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       4 * n * lg(n) + 16 * lg(n) + 34                                    */
/*       eg. IF n = 64,  cycles = 1666                                      */
/*       eg. IF n = 32,  cycles = 754                                       */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       1408 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CFFTR2_H_
#define DSPF_DP_CFFTR2_H_ 1

void DSPF_dp_cfftr2(int     n, double * x, double * w, int n_min);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_cfftr2.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_cfftr2./1117057376  2695  0     0       19447     `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_cfftr2 -- Double Precision Cache Optimized radix 2 forward FFT    *
*      with complex input                                                  *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      27-Feb-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*         This routine is C-callable and can be called as:                  *
*                                                                           *
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          *
*                                                                           *
*         x : input and output sequences (dim-n)      (input/output)        *
*             x has n complex numbers (2*n DP values).                      *
*             The real and imaginary values are interleaved in memory.      *
*             The input is in normal order and output is in bit-reversed    *
*             Order.                                                        *
*         w : FFT coefficients (dim-n)                (input)               *
*             w has n complex numbers (n DP values).                        *
*             FFT coeficients are in a special sequence so that FFT can     *
*             be called on smaller input sets multiple times to avoid       *
*             cache thrashing.                                              *
*             The real and imaginary values are interleaved in memory.      *
*         n : FFT size which is a power of 2 and > 4  (input)               *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*       This routine is used to compute the Complex, Radix-2, Fast          *
*       Fourier Transform of a double precision complex sequence of size    *
*       n, and a power of 2 in a Cache-friendly way. The routine requires   *
*       normal order input and normal order coefficents (twiddle factors)   *
*       in a special sequence and produces results that are in              *
*       bit-reversed order.                                                 *
*                                                                           *
*       The input can be broken into smaller parts and called multiple      *
*       times to avoid cache thrashing.                                     *
*                                                                           *
*       How to use                                                          *
*                                                                           *
*       void main(void)                                                     *
*       {                                                                   *
*          gen_w_r2(w, N);         // Generate coefficient table            *
*                                  // in normal order                       *
*                                  // Function is given in C-CODE section   *
*                                                                           *
*         DSPF_dp_cfftr2(N, x, w, 1);   // input in normal order, output in      *
*                                  // order bit-reversed                    *
*                                                                           *
*         bit_rev(x, N)           // Bit reverse the output if              *
*                                  // normal order output is needed         *
*                                  // Function is given in C-CODE section   *
*       }                                                                   *
*                                                                           *
*       main fft of size N can be divided into several steps (where         *
*       number of steps is a power of 2), allowing as much data             *
*       reuse as possible.                                                  *
*                                                                           *
*       For example the following function                                  *
*       DSPF_dp_cfftr2(N, x, w, 1);                                              *
*                                                                           *
*       is equivalent to:                                                   *
*                                                                           *
*       DSPF_dp_cfftr2(N, x, w, N/4);                                            *
*                                                                           *
*       DSPF_dp_cfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                  *
*       DSPF_dp_cfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                  *
*                                                                           *
*       Notice how the 1st fft function is called on the entire data set.   *
*       It covers the 1st pass of the fft until the butterfly size is       *
*       N/4. The following 4 ffts do N/4 point ffts, 25% of the original    *
*       size. These continue down to the end when the buttly is of size     *
*       2. We use an index of 2* 3/4 *N to the main twiddle factor array    *
*       for the last 4 calls. This is because the twiddle factor array      *
*       is composed of successively decimated versions of the main array.   *
*                                                                           *
*       The twiddle factor array is composed of log2(N) sets of twiddle     *
*       factors of size N, N/2, N/4, N/8 etc. The index into this array     *
*       for each stage of the fft can be calculated by summing these        *
*       indices up appropriately. For example, if we are dividing the       *
*       input into 2 parts then index into this array should be N, if we    *
*       are dividing into 4 parts then index into this array should be      *
*       N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   *
*                                                                           *
*       For multiple ffts they can share the same table by calling the      *
*       small ffts from further down in the twiddle factor array, in the    *
*       same way as the decomposition works for more data reuse.            *
*                                                                           *
*       The functions for creating this special sequence of twiddle         *
*       factors and bit-reversal are provided in the C CODE section.        *
*                                                                           *
*       In general if divide the input into NO_OF_DIV parts we can call     *
*       the function as follows:                                            *
*                                                                           *
*       // Divide the input into NO_OF_DIV parts                            *
*       DSPF_dp_cfftr2(N, x, w, N/NO_OF_DIV);                                    *
*                                                                           *
*                                                                           *
*       // Find out the index into twiddle factor array                     *
*       for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       *
*       {                                                                   *
*          w_index += j;                                                    *
*       }                                                                   *
*       w_index = N * w_index / NO_OF_DIV;                                  *
*                                                                           *
*       // Call the Function a subset of inputs                             *
*       for(i=0; i<NO_OF_DIV; i++)                                          *
*       {                                                                   *
*          DSPF_dp_cfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);   *
*       }                                                                   *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*       1. Outer loop instructions are executed in parallel with the        *
*          inner loop epilog.                                               *
*                                                                           *
*  ASSUMPTIONS                                                              *
*       1. Both input x and coefficient w should be aligned on double       *
*          word boundary.                                                   *
*       2. n should be greater than 4 and a power of 2.                     *
*                                                                           *
*  C CODE                                                                   *
*         This is the C equivalent of the assembly code without             *
*         restrictions. Note that the assembly code is hand optimized       *
*         and restrictions may apply.                                       *
*                                                                           *
*         void DSPF_dp_cfftr2(int n, double * x, double * w, int n_min)          *
*         {                                                                 *
*              int n2, ie, ia, i, j, k, m;                                  *
*              double rtemp, itemp, c, s;                                   *
*                                                                           *
*              n2 = n;                                                      *
*              ie = 1;                                                      *
*                                                                           *
*              for(k = n; k > n_min; k >>= 1)                               *
*               {                                                           *
*                 n2 >>= 1;                                                 *
*                 ia = 0;                                                   *
*                 for(j=0; j < ie; j++)                                     *
*                 {                                                         *
*                  for(i=0; i < n2; i++)                                    *
*                    {                                                      *
*                       c = w[2*i];                                         *
*                       s = w[2*i+1];                                       *
*                       m = ia + n2;                                        *
*                       rtemp     = x[2*ia]   - x[2*m];                     *
*                       x[2*ia]   = x[2*ia]   + x[2*m];                     *
*                       itemp     = x[2*ia+1] - x[2*m+1];                   *
*                       x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   *
*                       x[2*m]    = c*rtemp   - s*itemp;                    *
*                       x[2*m+1]  = c*itemp   + s*rtemp;                    *
*                       ia++;                                               *
*                      }                                                    *
*                   ia += n2;                                               *
*                  }                                                        *
*                 ie <<= 1;                                                 *
*                 w = w + k;                                                *
*              }                                                            *
*          }                                                                *
*                                                                           *
*          The follwoing C code is used to generate the coefficient table.  *
*                                                                           *
*           #include <math.h>                                               *
*           // generate real and imaginary twiddle                          *
*           //  table of size n complex numbers (or 2*n numbers)            *
*                                                                           *
*           void gen_w_r2(double* w, int n)                                 *
*           {                                                               *
*                int i, j=1;                                                *
*                double pi = 4.0*atan(1.0);                                 *
*                double e = pi*2.0/n;                                       *
*                for(j=1; j < n; j <<= 1)                                   *
*                {                                                          *
*                for(i=0; i < ( n>>1 ); i += j)                             *
*                   {                                                       *
*                   *w++   = cos(i*e);                                      *
*                   *w++   = -sin(i*e);                                     *
*                   }                                                       *
*                }                                                          *
*           }                                                               *
*                                                                           *
*                                                                           *
*           The follwoing C code is used to bit-reverse the output.         *
*                                                                           *
*           bit_rev(double* x, int n)                                       *
*           {                                                               *
*             int i, j, k;                                                  *
*             double rtemp, itemp;                                          *
*                                                                           *
*             j = 0;                                                        *
*             for(i=1; i < (n-1); i++)                                      *
*             {                                                             *
*               k = n >> 1;                                                 *
*                while(k <= j)                                              *
*                {                                                          *
*                   j -= k;                                                 *
*                   k >>= 1;                                                *
*                }                                                          *
*                j += k;                                                    *
*                if(i < j)                                                  *
*                {                                                          *
*                   rtemp    = x[j*2];                                      *
*                   x[j*2]   = x[i*2];                                      *
*                   x[i*2]   = rtemp;                                       *
*                   itemp    = x[j*2+1];                                    *
*                   x[j*2+1] = x[i*2+1];                                    *
*                   x[i*2+1] = itemp;                                       *
*                }                                                          *
*             }                                                             *
*           }                                                               *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. The special sequence of twiddle factor array w can be generated  *
*         using the gen_w_r2 function provided in the previous section.     *
*                                                                           *
*       2. Endian:This code is LITTLE ENDIAN.                               *
*                                                                           *
*       3. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*        4 * n * lg(n) + 16 * lg(n) + 34                                    *
*        eg. IF n = 64,  cycles = 1666                                      *
*        eg. IF n = 32,  cycles = 754                                       *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*        1408 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_cfftr2

*  ======================================================================== *
*   End of file:  DSPF_dp_cfftr2.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_icfftr2/1117057378  2715  0     0       21572     `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      */
/*      FFT with complex input                                              */
/*                                                                          */
/* USAGE                                                                    */
/*                                                                          */
/*        This routine is C-callable and can be called as:                  */
/*                                                                          */
/*        void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)         */
/*                                                                          */
/*        x : input and output sequences (dim-n)      (input/output)        */
/*            x has n complex numbers (2*n DP values).                      */
/*            The real and imaginary values are interleaved in memory.      */
/*            The input is in normal order and output is in bit-reversed    */
/*            Order.                                                        */
/*        w : FFT coefficients (dim-n)                (input)               */
/*            w has n complex numbers (n DP values).                        */
/*            FFT coeficients are in a special sequence so that FFT can     */
/*            be called on smaller input sets multiple times to avoid       */
/*            cache thrashing.                                              */
/*            The real and imaginary values are interleaved in memory.      */
/*        n : FFT size which is a power of 2 and > 4  (input)               */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine is used to compute the Inverse Complex, Radix-2, Fast  */
/*      Fourier Transform of a double precision complex sequence of size    */
/*      n, and a power of 2 in a Cache-friendly way. The routine requires   */
/*      normal order input and normal order coefficents (twiddle factors)   */
/*      in a special sequence and produces results that are in              */
/*      bit-reversed order.                                                 */
/*                                                                          */
/*      The input can be broken into smaller parts and called multiple      */
/*      times to avoid cache thrashing.                                     */
/*                                                                          */
/*      How to use                                                          */
/*                                                                          */
/*      void main(void)                                                     */
/*      {                                                                   */
/*         gen_w_r2(w, N);         // Generate coefficient table            */
/*                                 // in normal order                       */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        DSPF_dp_icfftr2(N, x, w, 1);  // input in normal order, output in      */
/*                                 // order bit-reversed                    */
/*                                                                          */
/*        bit_rev(x, N)            // Bit reverse the output if             */
/*                                 // normal order output is needed         */
/*                                 // Function is given in C-CODE section   */
/*                                                                          */
/*        divide(x, N);            // scale inverse FFT output              */
/*                                 // result is the same as original        */
/*                                 // input                                 */
/*                                                                          */
/*     }                                                                    */
/*                                                                          */
/*      main Inverse fft of size N can be divided into several steps (where */
/*      number of steps is a power of 2), allowing as much data             */
/*      reuse as possible.                                                  */
/*                                                                          */
/*      For example the following function                                  */
/*      DSPF_dp_icfftr2(N, x, w, 1);                                             */
/*                                                                          */
/*      is equivalent to:                                                   */
/*                                                                          */
/*      DSPF_dp_icfftr2(N, x, w, N/4);                                           */
/*                                                                          */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 0 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 1 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 2 * (N/4)], &w[N + N/2], 1);                 */
/*      DSPF_dp_icfftr2(N/4, &x[2 * 3 * (N/4)], &w[N + N/2], 1);                 */
/*                                                                          */
/*      Notice how the 1st icfft function is called on the entire data set. */
/*      It covers the 1st pass of the fft until the butterfly size is       */
/*      N/4. The following 4 ffts do N/4 point ffts, 25% of the original    */
/*      size. These continue down to the end when the buttly is of size     */
/*      2. We use an index of 2* 3/4 *N to the main twiddle factor array    */
/*      for the last 4 calls. This is because the twiddle factor array      */
/*      is composed of successively decimated versions of the main array.   */
/*                                                                          */
/*      The twiddle factor array is composed of log2(N) sets of twiddle     */
/*      factors of size N, N/2, N/4, N/8 etc. The index into this array     */
/*      for each stage of the fft can be calculated by summing these        */
/*      indices up appropriately. For example, if we are dividing the       */
/*      input into 2 parts then index into this array should be N, if we    */
/*      are dividing into 4 parts then index into this array should be      */
/*      N+N/2, if we are dividing into 8 parts index should be N+N/2+N/4.   */
/*                                                                          */
/*      For multiple iffts they can share the same table by calling the     */
/*      small iffts from further down in the twiddle factor array, in the   */
/*      same way as the decomposition works for more data reuse.            */
/*                                                                          */
/*      The functions for creating this special sequence of twiddle         */
/*      factors and bit-reversal are provided in the C CODE section.        */
/*                                                                          */
/*      In general if divide the input into NO_OF_DIV parts we can call     */
/*      the function as follows:                                            */
/*                                                                          */
/*      // Divide the input into NO_OF_DIV parts                            */
/*      DSPF_dp_icfftr2(N, x, w, N/NO_OF_DIV);                                   */
/*                                                                          */
/*                                                                          */
/*      // Find out the index into twiddle factor array                     */
/*      for(w_index=0,j = NO_OF_DIV; j > 1 ; j >>= 1)                       */
/*      {                                                                   */
/*         w_index += j;                                                    */
/*      }                                                                   */
/*      w_index = N * w_index / NO_OF_DIV;                                  */
/*                                                                          */
/*      // Call the Function a subset of inputs                             */
/*      for(i=0; i<NO_OF_DIV; i++)                                          */
/*      {                                                                   */
/*         DSPF_dp_icfftr2(N/NO_OF_DIV, &x[2*i*(N/NO_OF_DIV)], &w[w_index], 1);  */
/*      }                                                                   */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*      1. Outer loop instructions are executed in parallel with the        */
/*         inner loop epilog.                                               */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*      1. Both input x and coefficient w should be aligned on double       */
/*         word boundary.                                                   */
/*      2. n should be greater than 4 and a power of 2.                     */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*        This is the C equivalent of the assembly code without             */
/*        restrictions. Note that the assembly code is hand optimized       */
/*        and restrictions may apply.                                       */
/*                                                                          */
/*        void DSPF_dp_icfftr2(int n, double * x, double * w, int n_min)         */
/*        {                                                                 */
/*             int n2, ie, ia, i, j, k, m;                                  */
/*             double rtemp, itemp, c, s;                                   */
/*                                                                          */
/*             n2 = n;                                                      */
/*             ie = 1;                                                      */
/*                                                                          */
/*             for(k = n; k > n_min; k >>= 1)                               */
/*              {                                                           */
/*                n2 >>= 1;                                                 */
/*                ia = 0;                                                   */
/*                for(j=0; j < ie; j++)                                     */
/*                {                                                         */
/*                 for(i=0; i < n2; i++)                                    */
/*                   {                                                      */
/*                      c = w[2*i];                                         */
/*                      s = w[2*i+1];                                       */
/*                      m = ia + n2;                                        */
/*                      rtemp     = x[2*ia]   - x[2*m];                     */
/*                      x[2*ia]   = x[2*ia]   + x[2*m];                     */
/*                      itemp     = x[2*ia+1] - x[2*m+1];                   */
/*                      x[2*ia+1] = x[2*ia+1] + x[2*m+1];                   */
/*                      x[2*m]    = c*rtemp   + s*itemp;                    */
/*                      x[2*m+1]  = c*itemp   - s*rtemp;                    */
/*                      ia++;                                               */
/*                     }                                                    */
/*                  ia += n2;                                               */
/*                 }                                                        */
/*                ie <<= 1;                                                 */
/*                w = w + k;                                                */
/*             }                                                            */
/*         }                                                                */
/*                                                                          */
/*         The follwoing C code is used to generate the coefficient table.  */
/*                                                                          */
/*          #include <math.h>                                               */
/*          // generate real and imaginary twiddle                          */
/*          // table of size n complex numbers (or 2*n numbers)             */
/*                                                                          */
/*          void gen_w_r2(double* w, int n)                                 */
/*          {                                                               */
/*               int i, j=1;                                                */
/*               double pi = 4.0*atan(1.0);                                 */
/*               double e = pi*2.0/n;                                       */
/*               for(j=1; j < n; j <<= 1)                                   */
/*               {                                                          */
/*               for(i=0; i < ( n>>1 ); i += j)                             */
/*                  {                                                       */
/*                  *w++   = cos(i*e);                                      */
/*                  *w++   = -sin(i*e);                                     */
/*                  }                                                       */
/*               }                                                          */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/*          The follwoing C code is used to bit-reverse the output.         */
/*                                                                          */
/*          bit_rev(double* x, int n)                                       */
/*          {                                                               */
/*            int i, j, k;                                                  */
/*            double rtemp, itemp;                                          */
/*                                                                          */
/*            j = 0;                                                        */
/*            for(i=1; i < (n-1); i++)                                      */
/*            {                                                             */
/*              k = n >> 1;                                                 */
/*               while(k <= j)                                              */
/*               {                                                          */
/*                  j -= k;                                                 */
/*                  k >>= 1;                                                */
/*               }                                                          */
/*               j += k;                                                    */
/*               if(i < j)                                                  */
/*               {                                                          */
/*                  rtemp    = x[j*2];                                      */
/*                  x[j*2]   = x[i*2];                                      */
/*                  x[i*2]   = rtemp;                                       */
/*                  itemp    = x[j*2+1];                                    */
/*                  x[j*2+1] = x[i*2+1];                                    */
/*                  x[i*2+1] = itemp;                                       */
/*               }                                                          */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/*      The follwoing C code is used to perform the final scaling           */
/*      of the IFFT:                                                        */
/*                                                                          */
/*      // divide each element of x by n                                    */
/*                                                                          */
/*      divide(double* x, int n)                                            */
/*      {                                                                   */
/*        int i;                                                            */
/*        double inv = 1.0 / n;                                             */
/*                                                                          */
/*         for(i=0; i < n; i++)                                             */
/*          {                                                               */
/*              x[2*i] = inv * x[2*i];                                      */
/*              x[2*i+1] = inv * x[2*i+1];                                  */
/*            }                                                             */
/*       }                                                                  */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. The special sequence of twiddle factor array w can be generated  */
/*        using the gen_w_r2 function provided in the previous section.     */
/*                                                                          */
/*      2. Endian:This code is LITTLE ENDIAN.                               */
/*                                                                          */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       4 * n * lg(n) + 16 * lg(n) + 34                                    */
/*       eg. IF n = 64,  cycles = 1666                                      */
/*       eg. IF n = 32,  cycles = 754                                       */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       1408 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_ICFFTR2_ASM_H_
#define DSPF_DP_ICFFTR2_ASM_H_ 1

void DSPF_dp_icfftr2(int     n, double * x, double * w, int n_min);

#endif
/* ======================================================================== */
/*  End of file: DSPF_dp_icfftr2_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2004 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */
DSPF_dp_icfftr2/1117057377  2734  0     0       1762      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_icfftr2 -- Double Precision Cache optimised radix-2 inverse      *
*      FFT with complex input                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      12-Feb-2004                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_dp_icfftr2

* ======================================================================== *
*  End of file: DSPF_dp_icfftr2_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2004 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_fir_cpl/1117057379  2755  0     0       8398      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     */
/*     Filter                                                              */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_fir_cplx(                                                  */
/*                        const double * restrict x,                        */
/*                        const double * restrict h,                        */
/*                        double *       restrict r,                        */
/*                        int   nh,                                         */
/*                        int   nr                                          */
/*                       )                                                  */
/*                                                                          */
/*            x[2*(nr+nh-1)]: Pointer to complex input array.               */
/*                            The input data pointer x must point to the    */
/*                           (nh)th complex element, i.e. element 2*(nh-1). */
/*            h[2*nh]       : Pointer to complex coefficient array          */
/*                            (in normal order).                            */
/*            r[2*nr]       : Pointer to complex output array.              */
/*            nh            : Number of complex coefficients in vector h.   */
/*            nr            : Number of complex output samples to           */
/*                           calculate.                                     */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*       This function implements the FIR filter for complex input data.    */
/*       The filter has nr output samples and nh coefficients. Each array   */
/*       consists of an even and odd term with even terms representing the  */
/*       real part and the odd terms the imaginary part of the element.     */
/*       The coefficients are expected in normal order.                     */
/*                                                                          */
/*                                                                          */
/*     TECHNIQUES                                                           */
/*                                                                          */
/*    1. The outer loop is unrolled twice.                                  */
/*    2. Outer loop instructions are executed in parallel with inner loop.  */
/*    3. Register Sharing is used to make optimal use of available register *
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    1. nr is a multiple of 2 and greater than or equal to 2.              */
/*    2. nh is greater than or equal to 4.                                  */
/*    3. x points to 2*(nh-1)th input element.                              */
/*                                                                          */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*  void DSPF_dp_fir_cplx(const double * x, const double * h,                    */
/*                   double * restrict r, int nh, int nr)                   */
/*  {                                                                       */
/*       int i,j;                                                           */
/*       double imag, real;                                                 */
/*       for (i = 0; i < 2*nr; i += 2)                                      */
/*       {                                                                  */
/*           imag = 0;                                                      */
/*           real = 0;                                                      */
/*           for (j = 0; j < 2*nh; j += 2)                                  */
/*           {                                                              */
/*               real += h[j] * x[i-j] - h[j+1] * x[i+1-j];                 */
/*               imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];                 */
/*           }                                                              */
/*           r[i] = real;                                                   */
/*           r[i+1] = imag;                                                 */
/*       }                                                                  */
/*  }                                                                       */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt-tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*  8*nh*nr + 5*nr + 30                                                     */
/*  For nh=24 and nr=48, cycles=9486                                        */
/*  For nh=16 and nr=36, cycles=4818                                        */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*  608 bytes                                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_CPLX_H_
#define DSPF_DP_FIR_CPLX_H_ 1

void DSPF_dp_fir_cplx(
                 const double * restrict x,
                 const double * restrict h,
                 double *       restrict r,
                 int   nh,
                 int   nr
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_cplx.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_fir_cpl/1117057378  2775  0     0       8343      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_cplx -- Double Precision complex Finite Impulse Response     *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      26-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_cplx(                                                  *
*                         const double * restrict x,                        *
*                         const double * restrict h,                        *
*                         double *       restrict r,                        *
*                         int   nh,                                         *
*                         int   nr                                          *
*                        )                                                  *
*                                                                           *
*             x[2*(nr+nh-1)]: Pointer to complex input array.               *
*                             The input data pointer x must point to the    *
*                            (nh)th complex element, i.e. element 2*(nh-1). *
*             h[2*nh]       : Pointer to complex coefficient array          *
*                             (in normal order).                            *
*             r[2*nr]       : Pointer to complex output array.              *
*             nh            : Number of complex coefficients in vector h.   *
*             nr            : Number of complex output samples to           *
*                            calculate.                                     *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        This function implements the FIR filter for complex input data.    *
*        The filter has nr output samples and nh coefficients. Each array   *
*        consists of an even and odd term with even terms representing the  *
*        real part and the odd terms the imaginary part of the element.     *
*        The coefficients are expected in normal order.                     *
*                                                                           *
*                                                                           *
*      TECHNIQUES                                                           *
*                                                                           *
*     1. The outer loop is unrolled twice.                                  *
*     2. Outer loop instructions are executed in parallel with inner loop.  *
*     3. Register Sharing is used to make optimal use of available register *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. nr is a multiple of 2 and greater than or equal to 2.              *
*     2. nh is greater than or equal to 4.                                  *
*     3. x points to 2*(nh-1)th input element.                              *
*                                                                           *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_cplx(const double * x, const double * h,                    *
*                    double * restrict r, int nh, int nr)                   *
*   {                                                                       *
*        int i,j;                                                           *
*        double imag, real;                                                 *
*        for (i = 0; i < 2*nr; i += 2)                                      *
*        {                                                                  *
*            imag = 0;                                                      *
*            real = 0;                                                      *
*            for (j = 0; j < 2*nh; j += 2)                                  *
*            {                                                              *
*                real += h[j] * x[i-j] - h[j+1] * x[i+1-j];                 *
*                imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];                 *
*            }                                                              *
*            r[i] = real;                                                   *
*            r[i+1] = imag;                                                 *
*        }                                                                  *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt-tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*   8*nh*nr + 5*nr + 30                                                     *
*   For nh=24 and nr=48, cycles=9486                                        *
*   For nh=16 and nr=36, cycles=4818                                        *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   608 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_cplx.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fir_gen/1117057379  2797  0     0       8125      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*   This routine is C Callable and can be called as:                       */
/*                                                                          */
/*       void DSPF_dp_fir_gen(const double *x, const double *h,                  */
/*                              double * restrict r,int nh, int nr);        */
/*                                                                          */
/*       x : Pointer to array holding the input floating point array        */
/*       h : Pointer to array holding the coefficient floating point        */
/*           array                                                          */
/*       r : Pointer to output array                                        */
/*       nh: Number of coefficents                                          */
/*       nr: Number of output values                                        */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine implements a block FIR filter.  There are "nh"        */
/*       filter coefficients, "nr" output samples, and "nh+nr-1"            */
/*       input samples.    The coefficients need to be placed in the "h"    */
/*       array in reverse order {h(nh-1), ... , h(1), h(0)} and the         */
/*       array "x" starts at x(-nh+1) and ends at x(nr-1).  The             */
/*       routine calculates y(0) through y(nr-1) using the following        */
/*       formula:                                                           */
/*                                                                          */
/*       r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           */
/*                                                                          */
/*       where n = {0, 1, ... , nr-1}.                                      */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*       1.  The outer loop is unrolled 4 times.                            */
/*       2.  The inner loop is unrolled 2 times and software pipelined.     */
/*       3.  Register sharing is used to make optimum utilisation of        */
/*           available registers                                            */
/*       4.  Outerlop instructions and Prolog for next stage are scheduled  */
/*           in parallel with last iteration of kernel                      */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*       1.  Little Endian is assumed for LDDW instructions.                */
/*       2.  The number of coefficients must be greater than                */
/*           or equal to 4.                                                 */
/*       3.  The number of outputs must be greater than or equal to 4       */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*       This is the C equivalent for the assembly code.  Note that         */
/*       the assembly code is hand optimized and restrictions may           */
/*       apply.                                                             */
/*                                                                          */
/*       void DSPF_dp_fir_gen(const double *x, const double *h,                  */
/*                   double * restrict r, int nh, int nr)                   */
/*       {                                                                  */
/*          int i, j;                                                       */
/*          double sum;                                                     */
/*                                                                          */
/*          for(i=0; i < nr; i++)                                           */
/*          {                                                               */
/*             sum = 0;                                                     */
/*             for(j=0; j < nh; j++)                                        */
/*             {                                                            */
/*                 sum += x[i+j] * h[j];                                    */
/*             }                                                            */
/*             r[i] = sum;                                                  */
/*          }                                                               */
/*       }                                                                  */
/*                                                                          */
/*                                                                          */
/*   NOTES                                                                  */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/*   CYCLES                                                                 */
/*                                                                          */
/*   (16*floor((nh+1)/2)+10)*(ceil(nr/4)) + 32                              */
/*    for nh=26, nr=42, cycles=2430 cycles.                                 */
/*                                                                          */
/*   CODESIZE                                                               */
/*                                                                          */
/*    672 bytes                                                             */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_GEN_H_
#define DSPF_DP_FIR_GEN_H_ 1

void DSPF_dp_fir_gen(const     double *x, const double *h,
                       double * restrict r,int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_gen.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fir_gen/1117057379  2816  0     0       8185      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_gen -- Double Precision Generic FIR filter                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*    This routine is C Callable and can be called as:                       *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                               double * restrict r,int nh, int nr);        *
*                                                                           *
*        x : Pointer to array holding the input floating point array        *
*        h : Pointer to array holding the coefficient floating point        *
*            array                                                          *
*        r : Pointer to output array                                        *
*        nh: Number of coefficents                                          *
*        nr: Number of output values                                        *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine implements a block FIR filter.  There are "nh"        *
*        filter coefficients, "nr" output samples, and "nh+nr-1"            *
*        input samples.    The coefficients need to be placed in the "h"    *
*        array in reverse order {h(nh-1), ... , h(1), h(0)} and the         *
*        array "x" starts at x(-nh+1) and ends at x(nr-1).  The             *
*        routine calculates y(0) through y(nr-1) using the following        *
*        formula:                                                           *
*                                                                           *
*        r(n) = h(0)*x(n) + h(1)*x(n-1) + ... + h(nh-1)*x(n-nh+1)           *
*                                                                           *
*        where n = {0, 1, ... , nr-1}.                                      *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*        1.  The outer loop is unrolled 4 times.                            *
*        2.  The inner loop is unrolled 2 times and software pipelined.     *
*        3.  Register sharing is used to make optimum utilisation of        *
*            available registers                                            *
*        4.  Outerlop instructions and Prolog for next stage are scheduled  *
*            in parallel with last iteration of kernel                      *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*        1.  Little Endian is assumed for LDDW instructions.                *
*        2.  The number of coefficients must be greater than                *
*            or equal to 4.                                                 *
*        3.  The number of outputs must be greater than or equal to 4       *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*        This is the C equivalent for the assembly code.  Note that         *
*        the assembly code is hand optimized and restrictions may           *
*        apply.                                                             *
*                                                                           *
*        void DSPF_dp_fir_gen(const double *x, const double *h,                  *
*                    double * restrict r, int nh, int nr)                   *
*        {                                                                  *
*           int i, j;                                                       *
*           double sum;                                                     *
*                                                                           *
*           for(i=0; i < nr; i++)                                           *
*           {                                                               *
*              sum = 0;                                                     *
*              for(j=0; j < nh; j++)                                        *
*              {                                                            *
*                  sum += x[i+j] * h[j];                                    *
*              }                                                            *
*              r[i] = sum;                                                  *
*           }                                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*    NOTES                                                                  *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*    CYCLES                                                                 *
*                                                                           *
*    (16*floor((nh+1)/2)+10)*(ceil(nr/4)) + 32                              *
*     for nh=26, nr=42, cycles=2430 cycles.                                 *
*                                                                           *
*    CODESIZE                                                               *
*                                                                           *
*     672 bytes                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_gen

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_gen.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fir_r2./1117057380  2837  0     0       7895      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       */
/*     Filter                                                              */
/*                                                                         */
/* USAGE                                                                    */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_fir_r2(                                                    */
/*                     const double * restrict x,                           */
/*                     const double * restrict h,                           */
/*                     double      * restrict r,                            */
/*                     int   nh,                                            */
/*                     int   nr                                             */
/*                     )                                                    */
/*            x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           */
/*            h[nh]     : Pointer to coefficient array of size nh.          */
/*                        (in reverse order).                               */
/*            r[nr]     : Pointer to output array of size nr.               */
/*            nh        : Number of coefficients                            */
/*            nr        : Number of output samples.                         */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*       Computes a real FIR filter (direct-form) using coefficients        */
/*       stored in vector h[]. The real data input is stored in vector      */
/*       x[]. The filter output result is stored in vector r[]. The         */
/*       filter calculates nr output samples using nh coefficients.         */
/*       The coefficients are expected to be in reverse order.              */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*       1. The outer loop is unrolled four times and inner loop is         */
/*          unrolled twice.                                                 */
/*       2. Register sharing is used to make optimum utilisation of         */
/*          available Registers                                             */
/*       3. Outer loop instructions are executed in parallel with           */
/*          inner loop.                                                     */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*       1. nr is a multiple of 2 and greater than or equal to 2.           */
/*       2. nh is a multiple of 2 and greater than or equal to 8.           */
/*       3. Coefficients in array h are expected to be in reverse order.    */
/*       4. x and h should be padded with 4 words at the end.               */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*  void DSPF_dp_fir_r2(const double * x, const double * h,                      */
/*                     double *restrict r, int nh, int nr)                  */
/*  {                                                                       */
/*      int i, j;                                                           */
/*      double sum;                                                         */
/*                                                                          */
/*      for (i = 0; i < nr; i++)                                            */
/*      {                                                                   */
/*          sum = 0;                                                        */
/*                                                                          */
/*          for (j = 0; j < nh; j++)                                        */
/*             sum += x[i + j] * h[j];                                      */
/*             r[i] = sum;                                                  */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*   1. Endian: This code is LITTLE ENDIAN.                                 */
/*   2. Interruptibility: This code is interrupt tolerant but not           */
/*      interruptible.                                                      */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*   (8*nh + 10)*ceil(nr/4) + 32                                            */
/*    For nh=24 and nr=62, cycles=3264                                      */
/*                                                                          */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*  672 bytes                                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIR_R2_H_
#define DSPF_DP_FIR_R2_H_ 1

void DSPF_dp_fir_r2(
              const double * restrict x,
              const double * restrict h,
              double      * restrict r,
              int   nh,
              int   nr
              );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fir_r2.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fir_r2./1117057380  2855  0     0       7867      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fir_r2 -- Double Precision complex Finite Impulse Response       *
*      Filter                                                              *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      28-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_fir_r2(                                                    *
*                      const double * restrict x,                           *
*                      const double * restrict h,                           *
*                      double      * restrict r,                            *
*                      int   nh,                                            *
*                      int   nr                                             *
*                      )                                                    *
*             x[nr+nh-1]: Pointer to Input array of size nr+nh-1.           *
*             h[nh]     : Pointer to coefficient array of size nh.          *
*                         (in reverse order).                               *
*             r[nr]     : Pointer to output array of size nr.               *
*             nh        : Number of coefficients                            *
*             nr        : Number of output samples.                         *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*        Computes a real FIR filter (direct-form) using coefficients        *
*        stored in vector h[]. The real data input is stored in vector      *
*        x[]. The filter output result is stored in vector r[]. The         *
*        filter calculates nr output samples using nh coefficients.         *
*        The coefficients are expected to be in reverse order.              *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*        1. The outer loop is unrolled four times and inner loop is         *
*           unrolled twice.                                                 *
*        2. Register sharing is used to make optimum utilisation of         *
*           available Registers                                             *
*        3. Outer loop instructions are executed in parallel with           *
*           inner loop.                                                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*        1. nr is a multiple of 2 and greater than or equal to 2.           *
*        2. nh is a multiple of 2 and greater than or equal to 8.           *
*        3. Coefficients in array h are expected to be in reverse order.    *
*        4. x and h should be padded with 4 words at the end.               *
*                                                                           *
* C CODE                                                                    *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*   void DSPF_dp_fir_r2(const double * x, const double * h,                      *
*                      double *restrict r, int nh, int nr)                  *
*   {                                                                       *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*           sum = 0;                                                        *
*                                                                           *
*           for (j = 0; j < nh; j++)                                        *
*              sum += x[i + j] * h[j];                                      *
*              r[i] = sum;                                                  *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*                                                                           *
* NOTES                                                                     *
*                                                                           *
*    1. Endian: This code is LITTLE ENDIAN.                                 *
*    2. Interruptibility: This code is interrupt tolerant but not           *
*       interruptible.                                                      *
*                                                                           *
* CYCLES                                                                    *
*                                                                           *
*    (8*nh + 10)*ceil(nr/4) + 32                                            *
*     For nh=24 and nr=62, cycles=3264                                      *
*                                                                           *
*                                                                           *
* CODESIZE                                                                  *
*                                                                           *
*   672 bytes                                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fir_r2

*  ======================================================================== *
*   End of file:  DSPF_dp_fir_r2.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_fircirc/1117057381  2875  0     0       9001      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine has following C prototype:                               */
/*                                                                          */
/*    void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          */
/*                     int csize, int nh, int nr)                           */
/*                                                                          */
/*            x[]     :     Input array (circular buffer of 2^(csize+1)     */
/*                          bytes)                                          */
/*                          Must be aligned at 2^(csize+1) byte boundary    */
/*            h[nh]   :     Filter coefficients array                       */
/*                          Must be double-word aligned                     */
/*            r[nr]   :     Output array                                    */
/*            index   :     Offset by which to start reading from the       */
/*                          input array. Must be multiple of 2              */
/*            csize   :     Size of circular buffer x[] is 2^(csize+1)      */
/*                          bytes. Must be 2 <= csize <= 31.                */
/*            nh      :     Number of filter coefficients                   */
/*                          Must be multiple of 2 and >= 4                  */
/*            nr      :     Size of output array                            */
/*                          Must be multiple of 4                           */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*    This routine implements a circularly addressed FIR filter.            */
/*    'nh' is the number of filter coefficients. 'nr' is the number         */
/*    of the output samples.                                                */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*    1. The outer loop is unrolled 4 times.                                */
/*    2. The inner loop is unrolled 2 times.                                */
/*    3. Regiter sharing is udes to make optimal utilisation of the         */
/*       available registers.                                               */
/*    4. Outerloop instructions and Prolog for next stage are               */
/*       scheduled in the last cycle of Kernel.                             */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*    1. The circular input buffer x[] must be aligned at a 2^(csize+1)     */
/*       byte boundary. csize must lie in the range 2 <= csize <= 31.       */
/*    2. The number of coefficients  (nh) must be a multiple of 2           */
/*       and greater than or equal to 4.                                    */
/*    3. The number of outputs (nr) must be a multiple of 4 and             */
/*       greater than or equal to 4.                                        */
/*    4. The 'index' (offset to start reading input array) must be          */
/*       mutiple of 2 and less than or equal to (2^(csize-2) - 6)           */
/*    5. The coefficient array is assumed to be in reverse order,           */
/*       i.e. h(nh-1) to h(0) hold coeffs. h0, h1, h2 etc.                  */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*    This is the C equivalent for the assembly code.  Note that            */
/*    the assembly code is hand optimized and restrictions may              */
/*    apply.                                                                */
/*                                                                          */
/*    void DSPF_dp_fircirc  (double x[], double h[], double r[], int index,      */
/*                                  int csize, int nh, int nr)              */
/*      {                                                                   */
/*        int i, j;                                                         */
/*        //Circular Buffer block size = ((2^(csize + 1)) / 8)              */
/*        //floating point numbers                                          */
/*        int mod = (1 << (csize - 2));                                     */
/*        double r0;                                                        */
/*                                                                          */
/*        for (i = 0; i < nr; i++)                                          */
/*        {                                                                 */
/*            r0 = 0;                                                       */
/*            for (j = 0; j < nh; j++)                                      */
/*            {                                                             */
/*             //Operation "% mod" is equivalent to "& (mod -1)"            */
/*             //r0 += x[(i + j + index) % mod] * h[j];                     */
/*                                                                          */
/*               r0 += x[(i + j + index) & (mod - 1)] * h[j];               */
/*            }                                                             */
/*            r[i] = r0;                                                    */
/*        }                                                                 */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt-tolerant but not          */
/*       interruptible.                                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*    (2*nh + 2) nr + 38                                                    */
/*     For nh = 36 & nr=64, cycles = 4774                                   */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*     640 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_FIRCIRC_H_
#define DSPF_DP_FIRCIRC_H_ 1

void DSPF_dp_fircirc     (double *x, double *h, double *r, int index,
                 int csize, int nh, int nr);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_fircirc.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_fircirc/1117057381  2894  0     0       9054      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_fircirc -- Double Precision Circular FIR algorithm               *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      30-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_fircirc (double *x, double *h, double *r, int index,          *
*                      int csize, int nh, int nr)                           *
*                                                                           *
*             x[]     :     Input array (circular buffer of 2^(csize+1)     *
*                           bytes)                                          *
*                           Must be aligned at 2^(csize+1) byte boundary    *
*             h[nh]   :     Filter coefficients array                       *
*                           Must be double-word aligned                     *
*             r[nr]   :     Output array                                    *
*             index   :     Offset by which to start reading from the       *
*                           input array. Must be multiple of 2              *
*             csize   :     Size of circular buffer x[] is 2^(csize+1)      *
*                           bytes. Must be 2 <= csize <= 31.                *
*             nh      :     Number of filter coefficients                   *
*                           Must be multiple of 2 and >= 4                  *
*             nr      :     Size of output array                            *
*                           Must be multiple of 4                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This routine implements a circularly addressed FIR filter.            *
*     'nh' is the number of filter coefficients. 'nr' is the number         *
*     of the output samples.                                                *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*     1. The outer loop is unrolled 4 times.                                *
*     2. The inner loop is unrolled 2 times.                                *
*     3. Regiter sharing is udes to make optimal utilisation of the         *
*        available registers.                                               *
*     4. Outerloop instructions and Prolog for next stage are               *
*        scheduled in the last cycle of Kernel.                             *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The circular input buffer x[] must be aligned at a 2^(csize+1)     *
*        byte boundary. csize must lie in the range 2 <= csize <= 31.       *
*     2. The number of coefficients  (nh) must be a multiple of 2           *
*        and greater than or equal to 4.                                    *
*     3. The number of outputs (nr) must be a multiple of 4 and             *
*        greater than or equal to 4.                                        *
*     4. The 'index' (offset to start reading input array) must be          *
*        mutiple of 2 and less than or equal to (2^(csize-2) - 6)           *
*     5. The coefficient array is assumed to be in reverse order,           *
*        i.e. h(nh-1) to h(0) hold coeffs. h0, h1, h2 etc.                  *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*     This is the C equivalent for the assembly code.  Note that            *
*     the assembly code is hand optimized and restrictions may              *
*     apply.                                                                *
*                                                                           *
*     void DSPF_dp_fircirc  (double x[], double h[], double r[], int index,      *
*                                   int csize, int nh, int nr)              *
*       {                                                                   *
*         int i, j;                                                         *
*         //Circular Buffer block size = ((2^(csize + 1)) / 8)              *
*         //floating point numbers                                          *
*         int mod = (1 << (csize - 2));                                     *
*         double r0;                                                        *
*                                                                           *
*         for (i = 0; i < nr; i++)                                          *
*         {                                                                 *
*             r0 = 0;                                                       *
*             for (j = 0; j < nh; j++)                                      *
*             {                                                             *
*              //Operation "% mod" is equivalent to "& (mod -1)"            *
*              //r0 += x[(i + j + index) % mod] * h[j];                     *
*                                                                           *
*                r0 += x[(i + j + index) & (mod - 1)] * h[j];               *
*             }                                                             *
*             r[i] = r0;                                                    *
*         }                                                                 *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*     (2*nh + 2) nr + 38                                                    *
*      For nh = 36 & nr=64, cycles = 4774                                   *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*      640 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_fircirc

*  ======================================================================== *
*   End of file:  DSPF_dp_fircirc.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_biquad./1117057382  2915  0     0       7714      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine has following C prototype:                               */
/*                                                                          */
/*    void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        */
/*                   double *r, int nx)                                     */
/*                                                                          */
/*           x       :  Pointer to input samples                            */
/*           b       :  Pointer to Nr coefs b0, b1, b2                      */
/*           a       :  Pointer to Dr coefs a1, a2                          */
/*           delay   :  Pointer to filter delays                            */
/*           r       :  Pointer to output samples                           */
/*           nx      :  Number of input/output samples                      */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine implements a DF 2 transposed structure of the biquad   */
/*      filter. The transfer function of a biquad can be written            */
/*      as:                                                                 */
/*                                                                          */
/*                                   b(0) + b(1)z^(-1) + b(2)z^(-2)         */
/*                       H(Z) =     _________________________________       */
/*                                    1 + a(1)z^(-1) + a(2)z^(-2)           */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*        1.  Register sharing has been used to optimize on the use of      */
/*            registers.                                                    */
/*        2.  x[i] is loaded on both sides to avoid crosspath conflict         */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*        1. The value of nx is >=4.                                        */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*   void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,         */
/*                                                double *r,  int nx)       */
/*      {                                                                   */
/*       int i;                                                             */
/*       double a1, a2, b0, b1, b2, d0, d1, x_i;                            */
/*                                                                          */
/*       a1 = a[0];                                                         */
/*       a2 = a[1];                                                         */
/*                                                                          */
/*       b0 = b[0];                                                         */
/*       b1 = b[1];                                                         */
/*       b2 = b[2];                                                         */
/*                                                                          */
/*       d0 = delay[0];                                                     */
/*       d1 = delay[1];                                                     */
/*                                                                          */
/*       for (i = 0; i < nx; i++)                                           */
/*       {                                                                  */
/*           x_i = x[i];                                                    */
/*           r[i] = b0 * x_i + d0;                                          */
/*           d0 = b1 * x_i - a1 * r[i] + d1;                                */
/*           d1 = b2 * x_i - a2 * r[i];                                     */
/*       }                                                                  */
/*       delay[0] = d0;                                                     */
/*       delay[1] = d1;                                                     */
/*  }                                                                       */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*       16 * nx + 49                                                       */
/*       For nx = 64,  cycles = 1073                                        */
/*       For nx = 48,  cycles = 817.                                        */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*       576 bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BIQUAD_H_
#define DSPF_DP_BIQUAD_H_ 1

void DSPF_dp_biquad(double     *x, double *b, double *a, double *delay,
               double *r, int nx);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_biquad.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_biquad./1117057382  2933  0     0       7792      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_biquad -- Double Precision 2nd order IIR (Biquad) Filter         *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      03-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine has following C prototype:                               *
*                                                                           *
*     void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,        *
*                    double *r, int nx)                                     *
*                                                                           *
*            x       :  Pointer to input samples                            *
*            b       :  Pointer to Nr coefs b0, b1, b2                      *
*            a       :  Pointer to Dr coefs a1, a2                          *
*            delay   :  Pointer to filter delays                            *
*            r       :  Pointer to output samples                           *
*            nx      :  Number of input/output samples                      *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*       This routine implements a DF 2 transposed structure of the biquad   *
*       filter. The transfer function of a biquad can be written            *
*       as:                                                                 *
*                                                                           *
*                                    b(0) + b(1)z^(-1) + b(2)z^(-2)         *
*                        H(Z) =     _________________________________       *
*                                     1 + a(1)z^(-1) + a(2)z^(-2)           *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*         1.  Register sharing has been used to optimize on the use of      *
*             registers.                                                    *
*         2.  x[i] is loaded on both sides to avoid crosspath conflict         *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*         1. The value of nx is >=4.                                        *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*    void DSPF_dp_biquad(double *x, double *b, double *a, double *delay,         *
*                                                 double *r,  int nx)       *
*       {                                                                   *
*        int i;                                                             *
*        double a1, a2, b0, b1, b2, d0, d1, x_i;                            *
*                                                                           *
*        a1 = a[0];                                                         *
*        a2 = a[1];                                                         *
*                                                                           *
*        b0 = b[0];                                                         *
*        b1 = b[1];                                                         *
*        b2 = b[2];                                                         *
*                                                                           *
*        d0 = delay[0];                                                     *
*        d1 = delay[1];                                                     *
*                                                                           *
*        for (i = 0; i < nx; i++)                                           *
*        {                                                                  *
*            x_i = x[i];                                                    *
*            r[i] = b0 * x_i + d0;                                          *
*            d0 = b1 * x_i - a1 * r[i] + d1;                                *
*            d1 = b2 * x_i - a2 * r[i];                                     *
*        }                                                                  *
*        delay[0] = d0;                                                     *
*        delay[1] = d1;                                                     *
*   }                                                                       *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*        16 * nx + 49                                                       *
*        For nx = 64,  cycles = 1073                                        *
*        For nx = 48,  cycles = 817.                                        *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*        576 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_biquad

*  ======================================================================== *
*   End of file:  DSPF_dp_biquad.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_iir.h/  1117057383  0     0     0       8557      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*   This routine is C callable, and has the following C prototype:         */
/*                                                                          */
/*      void DSPF_dp_iir    (double* restrict r1,                                */
/*                      const double*    x,                                 */
/*                      double* restrict r2,                                */
/*                      const double*    h2,                                */
/*                      const double*    h1,                                */
/*                      int nr                                              */
/*                     );                                                   */
/*                                                                          */
/*           r1[nr+4]   :  Delay element values (i/p and o/p)               */
/*           x[nr]      :  Pointer to the input array                       */
/*           r2[nr+4]   :  Pointer to the output array                      */
/*           h2[5]      :  Auto-regressive filter coefficients              */
/*           h1[5]      :  Moving average filter coefficients               */
/*           nr         :  Number of output samples                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*    The IIR performs an auto-regressive moving-average (ARMA)             */
/*    filter with 4 auto-regressive filter coefficients and 5               */
/*    moving-average filter coefficients for nr output samples.             */
/*    The output vector is stored in two locations. This routine            */
/*    is used as a high pass filter in the VSELP vocoder. The               */
/*    4 values in the r1 vector store the initial values of the             */
/*    delays.                                                               */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*    1. The inner loop is completely unrolled so that two loops            */
/*       become one loop.                                                   */
/*    2. Register Sharing is used to make Optimum Utilisation of            */
/*       available registers.                                               */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*    1. The value of 'nr' must be > 0.                                     */
/*    2. Extraneous loads are allowed in the program.                       */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the Assembly Code without                   */
/*  restrictions.                                                           */
/*                                                                          */
/*  Note that the assembly code is hand optimized and restrictions          */
/*  may apply.                                                              */
/*                                                                          */
/*  void DSPF_dp_iir (double* restrict r1,                                       */
/*               const double*    x,                                        */
/*               double* restrict r2,                                       */
/*               const double*    h2,                                       */
/*               const double*    h1,                                       */
/*               int nr                                                     */
/*               )                                                          */
/*   {                                                                      */
/*      int i, j;                                                           */
/*      double sum;                                                         */
/*                                                                          */
/*      for (i = 0; i < nr; i++)                                            */
/*      {                                                                   */
/*         sum = h2[0] * x[4+i];                                            */
/*         for (j = 1; j <= 4; j++)                                         */
/*            sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];                  */
/*                                                                          */
/*         r1[4+i] = sum;                                                   */
/*         r2[i] = r1[4+i];                                                 */
/*      }                                                                   */
/*  }                                                                       */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. Endian: The code is LITTLE ENDIAN.                                */
/*     2. Interruptibility: This code is interrupt-tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     24*nr + 48                                                           */
/*     eg. for nr = 32, cycles = 816.                                       */
/*                                                                          */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     608 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_IIR_H_
#define DSPF_DP_IIR_H_ 1

void DSPF_dp_iir        (double* restrict r1,
                const double*    x,
                double* restrict r2,
                const double*    h2,
                const double*    h1,
                int nr
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_iir.h                                                  */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_iir.h67/1117057383  0     0     0       8497      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iir -- Double Precision IIR filter (used in the VSELP vocoder)   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*    This routine is C callable, and has the following C prototype:         *
*                                                                           *
*       void DSPF_dp_iir    (double* restrict r1,                                *
*                       const double*    x,                                 *
*                       double* restrict r2,                                *
*                       const double*    h2,                                *
*                       const double*    h1,                                *
*                       int nr                                              *
*                      );                                                   *
*                                                                           *
*            r1[nr+4]   :  Delay element values (i/p and o/p)               *
*            x[nr]      :  Pointer to the input array                       *
*            r2[nr+4]   :  Pointer to the output array                      *
*            h2[5]      :  Auto-regressive filter coefficients              *
*            h1[5]      :  Moving average filter coefficients               *
*            nr         :  Number of output samples                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*     The IIR performs an auto-regressive moving-average (ARMA)             *
*     filter with 4 auto-regressive filter coefficients and 5               *
*     moving-average filter coefficients for nr output samples.             *
*     The output vector is stored in two locations. This routine            *
*     is used as a high pass filter in the VSELP vocoder. The               *
*     4 values in the r1 vector store the initial values of the             *
*     delays.                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*     1. The inner loop is completely unrolled so that two loops            *
*        become one loop.                                                   *
*     2. Register Sharing is used to make Optimum Utilisation of            *
*        available registers.                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*     1. The value of 'nr' must be > 0.                                     *
*     2. Extraneous loads are allowed in the program.                       *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the Assembly Code without                   *
*   restrictions.                                                           *
*                                                                           *
*   Note that the assembly code is hand optimized and restrictions          *
*   may apply.                                                              *
*                                                                           *
*   void DSPF_dp_iir (double* restrict r1,                                       *
*                const double*    x,                                        *
*                double* restrict r2,                                       *
*                const double*    h2,                                       *
*                const double*    h1,                                       *
*                int nr                                                     *
*                )                                                          *
*    {                                                                      *
*       int i, j;                                                           *
*       double sum;                                                         *
*                                                                           *
*       for (i = 0; i < nr; i++)                                            *
*       {                                                                   *
*          sum = h2[0] * x[4+i];                                            *
*          for (j = 1; j <= 4; j++)                                         *
*             sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];                  *
*                                                                           *
*          r1[4+i] = sum;                                                   *
*          r2[i] = r1[4+i];                                                 *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. Endian: The code is LITTLE ENDIAN.                                *
*      2. Interruptibility: This code is interrupt-tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      24*nr + 48                                                           *
*      eg. for nr = 32, cycles = 816.                                       *
*                                                                           *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      608 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_iir

*  ======================================================================== *
*   End of file:  DSPF_dp_iir.h67                                                *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_iirlat./1117057384  2953  0     0       8538      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*        This routine has following C prototype:                           */
/*                                                                          */
/*            void DSPF_dp_iirlat(                                               */
/*                          double *x,                                      */
/*                          int nx,                                         */
/*                          const double * restrict k,                      */
/*                          int nk,                                         */
/*                          double * restrict b,                            */
/*                          double * r                                      */
/*                          )                                               */
/*         x[nx]   : Input vector                                           */
/*         nx      : Length of input vector.                                */
/*         k[nk]   : Reflection coefficients                                */
/*         nk      : Number of reflection coefficients/lattice stages       */
/*                   Must be multiple of 2 and >=6.                         */
/*         b[nk+1] : Delay line elements from previous call. Should be      */
/*                   initialized to all zeros prior to the first call.      */
/*         r[nx]   : Output vector                                          */
/*                                                                          */
/*     DESCRIPTION                                                          */
/*                                                                          */
/*         This routine implements a real all-pole IIR filter in lattice    */
/*     structure (AR lattice). The filter consists of nk lattice stages.    */
/*     Each  stage  requires one  reflection coefficient  k and one delay   */
/*     element b. The routine takes an input vector x[] and returns the     */
/*     filter output in r[]. Prior to the first call of the outine the      */
/*     delay elements in b[]  should be set to zero. The input data may     */
/*     have to be pre-scaled to avoid overflow or achieve better SNR. The   */
/*     reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     */
/*     order of the coefficients is such that k[nk-1] corresponds to the    */
/*     first lattice stage after the input and k[0] Corresponds to the      */
/*     last stage.                                                          */
/*                                                                          */
/*    TECHNIQUES                                                            */
/*                                                                          */
/*         1.  The loop has been unrolled by 4 times.                       */
/*                                                                          */
/*         2.  Register sharing has been used to optimize on the            */
/*             use of registers.                                            */
/*                                                                          */
/*    ASSUMPTIONS                                                           */
/*                                                                          */
/*        1. nk is a multiple of 2 and >=6.                                 */
/*        2. Extraneous loads are allowed (80 bytes) before the start of    */
/*           array.                                                         */
/*                                                                          */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*   void DSPF_dp_iirlat(double * x, int nx, const double * restrict k, int nk,  */
/*                   double * restrict b, double * r)                       */
/*   {                                                                      */
/*                                                                          */
/*      double rt;     // output       //                                   */
/*      int i, j;                                                           */
/*                                                                          */
/*      for (j = 0; j < nx; j++)                                            */
/*      {                                                                   */
/*         rt = x[j];                                                       */
/*                                                                          */
/*         for (i = nk - 1; i >= 0; i--)                                    */
/*         {                                                                */
/*             rt = rt - b[i] * k[i];                                       */
/*             b[i + 1] = b[i] + rt * k[i];                                 */
/*         }                                                                */
/*                                                                          */
/*         b[0] = rt;                                                       */
/*         r[j] = rt;                                                       */
/*      }                                                                   */
/*    }                                                                     */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*         interruptible.                                                   */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      (24*Ceil(nk/4) + 19)* nx + 33                                       */
/*       For nk = 14, nx = 64 cycles = 7393                                 */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*        832 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_IIRLAT_H_
#define DSPF_DP_IIRLAT_H_ 1

void DSPF_dp_iirlat(
              double *x,
              int nx,
              const double * restrict k,
              int nk,
              double * restrict b,
              double * r
              );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_iirlat.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_iirlat./1117057384  2971  0     0       8500      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_iirlat -- Double Precision All-Pole IIR lattice filter           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*         This routine has following C prototype:                           *
*                                                                           *
*             void DSPF_dp_iirlat(                                               *
*                           double *x,                                      *
*                           int nx,                                         *
*                           const double * restrict k,                      *
*                           int nk,                                         *
*                           double * restrict b,                            *
*                           double * r                                      *
*                           )                                               *
*          x[nx]   : Input vector                                           *
*          nx      : Length of input vector.                                *
*          k[nk]   : Reflection coefficients                                *
*          nk      : Number of reflection coefficients/lattice stages       *
*                    Must be multiple of 2 and >=6.                         *
*          b[nk+1] : Delay line elements from previous call. Should be      *
*                    initialized to all zeros prior to the first call.      *
*          r[nx]   : Output vector                                          *
*                                                                           *
*      DESCRIPTION                                                          *
*                                                                           *
*          This routine implements a real all-pole IIR filter in lattice    *
*      structure (AR lattice). The filter consists of nk lattice stages.    *
*      Each  stage  requires one  reflection coefficient  k and one delay   *
*      element b. The routine takes an input vector x[] and returns the     *
*      filter output in r[]. Prior to the first call of the outine the      *
*      delay elements in b[]  should be set to zero. The input data may     *
*      have to be pre-scaled to avoid overflow or achieve better SNR. The   *
*      reflections  coefficients lie  in  the range -1.0 < k < 1.0. The     *
*      order of the coefficients is such that k[nk-1] corresponds to the    *
*      first lattice stage after the input and k[0] Corresponds to the      *
*      last stage.                                                          *
*                                                                           *
*     TECHNIQUES                                                            *
*                                                                           *
*          1.  The loop has been unrolled by 4 times.                       *
*                                                                           *
*          2.  Register sharing has been used to optimize on the            *
*              use of registers.                                            *
*                                                                           *
*     ASSUMPTIONS                                                           *
*                                                                           *
*         1. nk is a multiple of 2 and >=6.                                 *
*         2. Extraneous loads are allowed (80 bytes) before the start of    *
*            array.                                                         *
*                                                                           *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*    void DSPF_dp_iirlat(double * x, int nx, const double * restrict k, int nk,  *
*                    double * restrict b, double * r)                       *
*    {                                                                      *
*                                                                           *
*       double rt;     // output       //                                   *
*       int i, j;                                                           *
*                                                                           *
*       for (j = 0; j < nx; j++)                                            *
*       {                                                                   *
*          rt = x[j];                                                       *
*                                                                           *
*          for (i = nk - 1; i >= 0; i--)                                    *
*          {                                                                *
*              rt = rt - b[i] * k[i];                                       *
*              b[i + 1] = b[i] + rt * k[i];                                 *
*          }                                                                *
*                                                                           *
*          b[0] = rt;                                                       *
*          r[j] = rt;                                                       *
*       }                                                                   *
*     }                                                                     *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*          interruptible.                                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       (24*Ceil(nk/4) + 19)* nx + 33                                       *
*        For nk = 14, nx = 64 cycles = 7393                                 *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_iirlat

*  ======================================================================== *
*   End of file:  DSPF_dp_iirlat.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_convol./1117057385  2991  0     0       8817      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_convol -- Double Precision convolution                           */
/*                                                                         */
/* USAGE                                                                    */
/*    This routine has the following C prototype:                           */
/*                                                                          */
/*    void DSPF_dp_convol                                                        */
/*         (                                                                */
/*               double *x, //x: Pointer to input samples//                 */
/*               double *h, //h: Pointer to impulse response samples//      */
/*               double *r, //r: Pointer to output samples//                */
/*               int   nh, //nh: Number of impulse response samples//       */
/*               int   nr  //nr: Number of output samples//                 */
/*         )                                                                */
/*                                                                          */
/*          x = pointer to real input vector of size = nr+nh-1              */
/*          a typically contains input data (x) padded with                 */
/*          consecutive nh - 1  zeros at the beginning and end.             */
/*          h = pointer to real input vector of size nh in forward order.   */
/*          h typically contains the filter coefs.                          */
/*          r = Pointer to real output vector of size nr                    */
/*          nh= Number of elements in vector b. NOTE: nh <= nr  nh is       */
/*          typically noted as m in convol formulas. nh must be a           */
/*          MULTIPLE of 2                                                   */
/*          nr= Number of elements in vector r. nr must be a MULTIPLE of 4  */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*          This function calculates the full-length convolution of real    */
/*          vectors x and h using time-domain techniques. The result is     */
/*          placed in real vector r.                                        */
/*                                                                          */
/*          It is assumed that input vector x is padded with nh-1 no of     */
/*          zeros in the beginning and end.                                 */
/*                                                                          */
/*          It is assumed that the length of the input vector h, nh, is a   */
/*          multiple of 2 and the length of the output vector r, nr, is a   */
/*          multiple of 4. nh is greater than or equal to 4 and nr is       */
/*          greater than or equal to nh. The routine computes 4 output      */
/*          samples at a time.                                              */
/*                                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*          1. The inner loop is unrolled twice and the outer loop is       */
/*             unrolled four times.                                         */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*          1. nh is a multiple of 2 and greater than or equal to 4         */
/*          2. nr is a multiple of 4                                        */
/*                                                                          */
/*  C CODE                                                                  */
/*          This is the C equivalent of the assembly code.  Note that       */
/*          the assembly code is hand optimized and restrictions may        */
/*          apply.                                                          */
/*                                                                          */
/*                                                                          */
/*          void DSPF_dp_convol(double *x, double *h, double *r, short nh,       */
/*                         short nr)                                        */
/*          {                                                               */
/*            short   octr, ictr;                                           */
/*            double  acc ;                                                 */
/*                                                                          */
/*            for (octr = nr ; octr > 0 ; octr--)                           */
/*            {                                                             */
/*              acc = 0 ;                                                   */
/*                                                                          */
/*              for (ictr = nh ; ictr > 0 ; ictr--)                         */
/*              {                                                           */
/*             acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       */
/*              }                                                           */
/*              r[nr-octr] = acc;                                           */
/*            }                                                             */
/*          }                                                               */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*          1. Endian: This code is LITTLE ENDIAN.                          */
/*          2. Interruptibility: This code is interrupt tolerant but not    */
/*                       interruptible.                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*          2*(nh*nr) + 5/2*nr + 32                                         */
/*          For nh=24 and nr=48, cycles=2456                                */
/*          For nh=20 and nr=32, cycles=1392                                */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*          544 bytes                                                       */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_CONVOL_H_
#define DSPF_DP_CONVOL_H_ 1

void DSPF_dp_convol
     (
           double *x, //x: Pointer to input samples//
           double *h, //h: Pointer to impulse response samples//
           double *r, //r: Pointer to output samples//
           int   nh, //nh: Number of impulse response samples//
           int   nr  //nr: Number of output samples//
     );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_convol.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_convol./1117057385  3009  0     0       8658      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_convol -- Double Precision convolution                           *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      24-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*     This routine has the following C prototype:                           *
*                                                                           *
*     void DSPF_dp_convol                                                        *
*          (                                                                *
*                double *x, //x: Pointer to input samples//                 *
*                double *h, //h: Pointer to impulse response samples//      *
*                double *r, //r: Pointer to output samples//                *
*                int   nh, //nh: Number of impulse response samples//       *
*                int   nr  //nr: Number of output samples//                 *
*          )                                                                *
*                                                                           *
*           x = pointer to real input vector of size = nr+nh-1              *
*           a typically contains input data (x) padded with                 *
*           consecutive nh - 1  zeros at the beginning and end.             *
*           h = pointer to real input vector of size nh in forward order.   *
*           h typically contains the filter coefs.                          *
*           r = Pointer to real output vector of size nr                    *
*           nh= Number of elements in vector b. NOTE: nh <= nr  nh is       *
*           typically noted as m in convol formulas. nh must be a           *
*           MULTIPLE of 2                                                   *
*           nr= Number of elements in vector r. nr must be a MULTIPLE of 4  *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*           This function calculates the full-length convolution of real    *
*           vectors x and h using time-domain techniques. The result is     *
*           placed in real vector r.                                        *
*                                                                           *
*           It is assumed that input vector x is padded with nh-1 no of     *
*           zeros in the beginning and end.                                 *
*                                                                           *
*           It is assumed that the length of the input vector h, nh, is a   *
*           multiple of 2 and the length of the output vector r, nr, is a   *
*           multiple of 4. nh is greater than or equal to 4 and nr is       *
*           greater than or equal to nh. The routine computes 4 output      *
*           samples at a time.                                              *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*           1. The inner loop is unrolled twice and the outer loop is       *
*              unrolled four times.                                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*           1. nh is a multiple of 2 and greater than or equal to 4         *
*           2. nr is a multiple of 4                                        *
*                                                                           *
*   C CODE                                                                  *
*           This is the C equivalent of the assembly code.  Note that       *
*           the assembly code is hand optimized and restrictions may        *
*           apply.                                                          *
*                                                                           *
*                                                                           *
*           void DSPF_dp_convol(double *x, double *h, double *r, short nh,       *
*                          short nr)                                        *
*           {                                                               *
*             short   octr, ictr;                                           *
*             double  acc ;                                                 *
*                                                                           *
*             for (octr = nr ; octr > 0 ; octr--)                           *
*             {                                                             *
*               acc = 0 ;                                                   *
*                                                                           *
*               for (ictr = nh ; ictr > 0 ; ictr--)                         *
*               {                                                           *
*              acc += x[nr-octr+nh-ictr]*h[(ictr-1)];                       *
*               }                                                           *
*               r[nr-octr] = acc;                                           *
*             }                                                             *
*           }                                                               *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*           1. Endian: This code is LITTLE ENDIAN.                          *
*           2. Interruptibility: This code is interrupt tolerant but not    *
*                        interruptible.                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*           2*(nh*nr) + 5/2*nr + 32                                         *
*           For nh=24 and nr=48, cycles=2456                                *
*           For nh=20 and nr=32, cycles=1392                                *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*           544 bytes                                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_convol

*  ======================================================================== *
*   End of file:  DSPF_dp_convol.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_dotp_sq/1117057386  3029  0     0       7174      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       */
/*                                                                         */
/*   USAGE                                                                  */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_dotp_sqr(                                                */
/*                       double G,                                          */
/*                       const double * x,                                  */
/*                       const double * y,                                  */
/*                       double *  restrict r,                              */
/*                       int   nx                                           */
/*                       )                                                  */
/*            G:      Sum of y-squared initial value.                       */
/*            x[nx]:  Pointer to First input array.                         */
/*            y[nx]:  Pointer to Second input array.                        */
/*            r:      Pointer to Output for Accumulation of x[]*y[].        */
/*            nx:     Length of input vectors.                              */
/*                                                                          */
/*   DESCRIPTION                                                            */
/*                                                                          */
/*       This routine computes the dot product of x[] and y[] arrays,       */
/*   adding it to the value in the location pointed to by r.                */
/*   Additionally, it computes the sum of the squares of the terms          */
/*   in the y array,adding it to the argument G. The final value of         */
/*   G is given as the return value of the function.                        */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*     1. Multiple Assignment was used to reduce loop carry path.           */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*     1. There are no special alignment requirements.                      */
/*                                                                          */
/*   C CODE                                                                 */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    */
/*                        double *restrict r, int nx)                       */
/*      {                                                                   */
/*                                                                          */
/*         int i;                                                           */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         {                                                                */
/*               *r += x[i] * y[i];     // Compute Dot Product //           */
/*               G += y[i] * y[i];      // Compute Square  //               */
/*         }                                                                */
/*                                                                          */
/*         return G;                                                        */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*    NOTES                                                                 */
/*                                                                          */
/*        1. Endian : This code is LITTLE ENDIAN .                          */
/*        2. Interruptibility: This code is interrupt-tolerant but not      */
/*                             interruptible.                               */
/*                                                                          */
/*    CYCLES                                                                */
/*                                                                          */
/*      4*nx + 26                                                           */
/*                                                                          */
/*       For nx=64, cycles=282.                                             */
/*       For nx=30, cycles=146.                                             */
/*                                                                          */
/*    CODESIZE                                                              */
/*                                                                          */
/*      244 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTP_SQR_H_
#define DSPF_DP_DOTP_SQR_H_ 1

double DSPF_dp_dotp_sqr(
                double G,
                const double * x,
                const double * y,
                double *  restrict r,
                int   nx
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_dotp_sqr.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_dotp_sq/1117057386  3049  0     0       7159      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_sqr -- Double Precision dot product and sum of square       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      10-Sep-2003                                                         *
*                                                                          *
*    USAGE                                                                  *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_dotp_sqr(                                                *
*                        double G,                                          *
*                        const double * x,                                  *
*                        const double * y,                                  *
*                        double *  restrict r,                              *
*                        int   nx                                           *
*                        )                                                  *
*             G:      Sum of y-squared initial value.                       *
*             x[nx]:  Pointer to First input array.                         *
*             y[nx]:  Pointer to Second input array.                        *
*             r:      Pointer to Output for Accumulation of x[]*y[].        *
*             nx:     Length of input vectors.                              *
*                                                                           *
*    DESCRIPTION                                                            *
*                                                                           *
*        This routine computes the dot product of x[] and y[] arrays,       *
*    adding it to the value in the location pointed to by r.                *
*    Additionally, it computes the sum of the squares of the terms          *
*    in the y array,adding it to the argument G. The final value of         *
*    G is given as the return value of the function.                        *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*      1. Multiple Assignment was used to reduce loop carry path.           *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*      1. There are no special alignment requirements.                      *
*                                                                           *
*    C CODE                                                                 *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       double DSPF_dp_dotp_sqr(double G, const double * x, const double * y,    *
*                         double *restrict r, int nx)                       *
*       {                                                                   *
*                                                                           *
*          int i;                                                           *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          {                                                                *
*                *r += x[i] * y[i];     /* Compute Dot Product */           *
*                G += y[i] * y[i];      /* Compute Square  */               *
*          }                                                                *
*                                                                           *
*          return G;                                                        *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*         1. Endian : This code is LITTLE ENDIAN .                          *
*         2. Interruptibility: This code is interrupt-tolerant but not      *
*                              interruptible.                               *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*       4*nx + 26                                                           *
*                                                                           *
*        For nx=64, cycles=282.                                             *
*        For nx=30, cycles=146.                                             *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*       244 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_dotp_sqr

*  ======================================================================== *
*   End of file:  DSPF_dp_dotp_sqr.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_dotprod/1117057387  3071  0     0       4097      `
/* ======================================================================== */
/*  TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                          */
/*  NAME                                                                    */
/*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       */
/*                                                                          */
/*  USAGE                                                                   */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      double DSPF_dp_dotprod(const double *x, const double *y, const int nx);  */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      nx    : Number of values in the x & y vectors                       */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      This routine calculates the dot product of 2 Double precision       */
/*  float vectors.                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      double DSPF_dp_dotprod(const double *x, const double *y, const int nx)   */
/*      {                                                                   */
/*         int i;                                                           */
/*         double sum = 0;                                                  */
/*                                                                          */
/*         for (i=0; i < nx; i++)                                           */
/*         {                                                                */
/*            sum += x[i] * y[i];                                           */
/*         }                                                                */
/*         return sum;                                                      */
/*      }                                                                   */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2003 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTPROD_ASM_H_
#define DSPF_DP_DOTPROD_ASM_H_ 1

double DSPF_dp_dotprod(const     double * x, const double * y, const int nx);

#endif
/* ======================================================================== */
/*  End of file: DSPF_dp_dotprod_h.asm                                           */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2003 Texas Instruments, Incorporated.             */
/*                          All Rights Reserved.                            */
/* ======================================================================== */

DSPF_dp_dotprod/1117057387  3090  0     0       1684      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotprod -- Dot Product of 2 Double Precision float vectors       *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                   *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
        .global _DSPF_dp_dotprod

* ======================================================================== *
*  End of file: DSPF_dp_dotprod_h.asm                                           *
* ------------------------------------------------------------------------ *
*          Copyright (C) 2003 Texas Instruments, Incorporated.             *
*                          All Rights Reserved.                            *
* ======================================================================== *
DSPF_dp_dotp_cp/1117057388  3111  0     0       6940      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         */
/*     product                                                             */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*    This routine is C Callable and can be called as:                      */
/*                                                                          */
/*      void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double * */
/*                        restrict re, double * restrict im);               */
/*                                                                          */
/*      x     : Pointer to array holding the first floating point vector    */
/*      y     : Pointer to array holding the second floating point vector   */
/*      n     : Number of values in the x & y vectors                       */
/*      re    : Pointer to the location storing the real                    */
/*              part of the result.                                         */
/*      im    : Pointer to the location storing the imaginary part of       */
/*              the result                                                  */
/*                                                                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*      This routine calculates the dot product of 2 Double   precision     */
/*  complex float vectors. The even numbered locations hold the real parts  */
/*  of the complex numbers while the odd numbered locations contain the     */
/*  imaginary portions.                                                     */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*      1.  The value of nx must be  > 0.                                   */
/*                                                                          */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*      This is the C equivalent for the assembly code.  Note that          */
/*      the assembly code is hand optimized and restrictions may            */
/*      apply.                                                              */
/*                                                                          */
/*      void DSPF_dp_dotp_cplx(const double* x, const double* y, int n,          */
/*                    double* restrict re, double* restrict im)             */
/*      {                                                                   */
/*                                                                          */
/*          double real=0, imag=0;                                          */
/*          int i=0;                                                        */
/*                                                                          */
/*          for(i=0; i<n; i++)                                              */
/*          {                                                               */
/*              real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  */
/*              imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  */
/*          }                                                               */
/*                                                                          */
/*          *re=real;                                                       */
/*          *im=imag;                                                       */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*  1. Endian: This code is LITTLE ENDIAN.                                  */
/*  2. Interruptibility: This code is interrupt tolerant but not            */
/*     interruptible.                                                       */
/*                                                                          */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*     8*N + 29                                                             */
/*     eg. for N = 128, cycles = 1053.                                      */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*     352 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_DOTP_CPLX_H_
#define DSPF_DP_DOTP_CPLX_H_ 1

void DSPF_dp_dotp_cplx(const     double *x, const double *y, int n, double *
                  restrict re, double * restrict im);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_dotp_cplx.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_dotp_cp/1117057388  3132  0     0       7001      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_dotp_cplx -- Complex Double precision floating point dot         *
*      product                                                             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      11-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*     This routine is C Callable and can be called as:                      *
*                                                                           *
*       void DSPF_dp_dotp_cplx(const double *x, const double *y, int n, double * *
*                         restrict re, double * restrict im);               *
*                                                                           *
*       x     : Pointer to array holding the first floating point vector    *
*       y     : Pointer to array holding the second floating point vector   *
*       n     : Number of values in the x & y vectors                       *
*       re    : Pointer to the location storing the real                    *
*               part of the result.                                         *
*       im    : Pointer to the location storing the imaginary part of       *
*               the result                                                  *
*                                                                           *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*       This routine calculates the dot product of 2 Double   precision     *
*   complex float vectors. The even numbered locations hold the real parts  *
*   of the complex numbers while the odd numbered locations contain the     *
*   imaginary portions.                                                     *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*       1.  The value of nx must be  > 0.                                   *
*                                                                           *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       This is the C equivalent for the assembly code.  Note that          *
*       the assembly code is hand optimized and restrictions may            *
*       apply.                                                              *
*                                                                           *
*       void DSPF_dp_dotp_cplx(const double* x, const double* y, int n,          *
*                     double* restrict re, double* restrict im)             *
*       {                                                                   *
*                                                                           *
*           double real=0, imag=0;                                          *
*           int i=0;                                                        *
*                                                                           *
*           for(i=0; i<n; i++)                                              *
*           {                                                               *
*               real+=(x[2*i]*y[2*i] - x[2*i+1]*y[2*i+1]);                  *
*               imag+=(x[2*i]*y[2*i+1] + x[2*i+1]*y[2*i]);                  *
*           }                                                               *
*                                                                           *
*           *re=real;                                                       *
*           *im=imag;                                                       *
*      }                                                                    *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*   1. Endian: This code is LITTLE ENDIAN.                                  *
*   2. Interruptibility: This code is interrupt tolerant but not            *
*      interruptible.                                                       *
*                                                                           *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*      8*N + 29                                                             *
*      eg. for N = 128, cycles = 1053.                                      *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*      352 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_dotp_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_dotp_cplx.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_maxval./1117057389  3155  0     0       6903      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_maxval -- Maximum Element of Double Precision Vector             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_maxval(                                                  */
/*                       const double* x,                                   */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out the maximum number in the                   */
/*   input array.This code returns the maximum value                        */
/*   in the array.                                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*     1. The loop is unrolled six times.                                   */
/*     2. Six maximums are maintained in each iteration.                    */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx should be multiple of 2 and >= 2.                             */
/*      2. NAN( Not a Number in Double Precision format) in the input is    */
/*         disregarded.                                                     */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the assembly code.  Note that           */
/*      the assembly code is hand optimized and restrictions may apply.     */
/*                                                                          */
/*      double DSPF_dp_maxval(const double* x, int nx)                           */
/*      {                                                                   */
/*         int i;                                                           */
/*         double max;                                                      */
/*         *((int *)&max) = 0x00000000;                                     */
/*         *((int *)&max+1) = 0xfff00000;                                   */
/*                                                                          */
/*          for (i = 0; i < nx; i++)                                        */
/*          if (x[i] > max)                                                 */
/*           {                                                              */
/*            max = x[i];                                                   */
/*           }                                                              */
/*                                                                          */
/*          return max;                                                     */
/*       }                                                                  */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. NAN( Not a Number in Double Precision format) in the input are   */
/*         disregarded.                                                     */
/*      2. Endian: This code is LITTLE ENDIAN.                              */
/*      3. Interruptibility: This code is interrupt-tolerant but not        */
/*                           interruptible.                                 */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      7*ceil(nx/6) + 31                                                   */
/*      For nx=60, cycles=101.                                              */
/*      For nx=34, cycles=73.                                               */
/*                                                                          */
/*  CODESIZE                                                                */
/*      672 bytes                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAXVAL_H_
#define DSPF_DP_MAXVAL_H_ 1

double DSPF_dp_maxval(
                const double* x,
                int nx
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_maxval.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_maxval./1117057389  3173  0     0       6999      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxval -- Maximum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_maxval(                                                  *
*                        const double* x,                                   *
*                        int nx                                             *
*                       )                                                   *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the maximum number in the                   *
*    input array.This code returns the maximum value                        *
*    in the array.                                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*      1. The loop is unrolled six times.                                   *
*      2. Six maximums are maintained in each iteration.                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx should be multiple of 2 and >= 2.                             *
*       2. NAN( Not a Number in Double Precision format) in the input is    *
*          disregarded.                                                     *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the assembly code.  Note that           *
*       the assembly code is hand optimized and restrictions may apply.     *
*                                                                           *
*       double DSPF_dp_maxval(const double* x, int nx)                           *
*       {                                                                   *
*          int i;                                                           *
*          double max;                                                      *
*          *((int *)&max) = 0x00000000;                                     *
*          *((int *)&max+1) = 0xfff00000;                                   *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           if (x[i] > max)                                                 *
*            {                                                              *
*             max = x[i];                                                   *
*            }                                                              *
*                                                                           *
*           return max;                                                     *
*        }                                                                  *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. NAN( Not a Number in Double Precision format) in the input are   *
*          disregarded.                                                     *
*       2. Endian: This code is LITTLE ENDIAN.                              *
*       3. Interruptibility: This code is interrupt-tolerant but not        *
*                            interruptible.                                 *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       7*ceil(nx/6) + 31                                                   *
*       For nx=60, cycles=101.                                              *
*       For nx=34, cycles=73.                                               *
*                                                                           *
*   CODESIZE                                                                *
*       672 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_maxval

*  ======================================================================== *
*   End of file:  DSPF_dp_maxval.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_maxidx./1117057390  3193  0     0       6496      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       int DSPF_dp_maxidx(                                                     */
/*                      const double* x,                                    */
/*                      int nx                                              */
/*                    )                                                     */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out the index of maximum number in the input    */
/*       array. This function returns the index of the greatest value.      */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The loop is unrolled three times.                                */
/*      2. Three maximums are maintained in each iteration.                 */
/*      3. MPY instructions are  used for move.                             */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx is a multiple of 3.                                           */
/*      2. nx >= 3, and nx <= 2^16-1.                                       */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      int DSPF_dp_maxidx(const double* x, int nx)                              */
/*      {                                                                   */
/*         int index, i;                                                    */
/*         double max;                                                      */
/*                                                                          */
/*         *((int *)&max) = 0x00000000;                                     */
/*         *((int *)&max+1) = 0xfff00000;                                   */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         if (x[i] > max)                                                  */
/*         {                                                                */
/*            max = x[i];                                                   */
/*            index = i;                                                    */
/*         }                                                                */
/*         return index;                                                    */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*     1. Endian: This code is LITTLE ENDIAN.                               */
/*     2. Interruptibility: This code is interrupt tolerant but not         */
/*        interruptible.                                                    */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      4*nx/3 + 22                                                         */
/*      For nx=60, cycles=102.                                              */
/*      For nx=30, cycles=62.                                               */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      448 bytes                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAXIDX_H_
#define DSPF_DP_MAXIDX_H_ 1

int DSPF_dp_maxidx(
               const double* x,
               int nx
             );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_maxidx.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_maxidx./1117057390  3211  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_maxidx -- Index of Maximum Element of Double Precision Vector    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      16-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        int DSPF_dp_maxidx(                                                     *
*                       const double* x,                                    *
*                       int nx                                              *
*                     )                                                     *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out the index of maximum number in the input    *
*        array. This function returns the index of the greatest value.      *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled three times.                                *
*       2. Three maximums are maintained in each iteration.                 *
*       3. MPY instructions are  used for move.                             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx is a multiple of 3.                                           *
*       2. nx >= 3, and nx <= 2^16-1.                                       *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       int DSPF_dp_maxidx(const double* x, int nx)                              *
*       {                                                                   *
*          int index, i;                                                    *
*          double max;                                                      *
*                                                                           *
*          *((int *)&max) = 0x00000000;                                     *
*          *((int *)&max+1) = 0xfff00000;                                   *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] > max)                                                  *
*          {                                                                *
*             max = x[i];                                                   *
*             index = i;                                                    *
*          }                                                                *
*          return index;                                                    *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*      1. Endian: This code is LITTLE ENDIAN.                               *
*      2. Interruptibility: This code is interrupt tolerant but not         *
*         interruptible.                                                    *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       4*nx/3 + 22                                                         *
*       For nx=60, cycles=102.                                              *
*       For nx=30, cycles=62.                                               *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       448 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_maxidx

*  ======================================================================== *
*   End of file:  DSPF_dp_maxidx.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_minval./1117057391  3231  0     0       6503      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_minval -- Minimum Element of Double Precision Vector             */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       double DSPF_dp_minval(                                                  */
/*                       const double* x,                                   */
/*                       int nx                                             */
/*                      )                                                   */
/*                                                                          */
/*            x :  Pointer to Input array.                                  */
/*            nx:  Number of Inputs in the input Array.                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine finds out and returns the minimum number              */
/*   in the input array.                                                    */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The loop is unrolled six times.                                  */
/*      2. Six minimums are maintained in each iteration.                   */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. nx should be multiple of 2 and >= 2.                             */
/*      2. NAN( Not a Number in Double Precision format) in the input are   */
/*         disregarded.                                                     */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*      double DSPF_dp_minval(const double* x, int nx)                           */
/*      {                                                                   */
/*         int i;                                                           */
/*         double min;                                                      */
/*         *((int *)&min) = 0x00000000;                                     */
/*         *((int *)&min+1) = 0x7ff00000;                                   */
/*                                                                          */
/*         for (i = 0; i < nx; i++)                                         */
/*         if (x[i] < min)                                                  */
/*         {                                                                */
/*            min = x[i];                                                   */
/*           }                                                              */
/*                                                                          */
/*         return min;                                                      */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*  1. NAN( Not a Number in Double Precision format) in the input are       */
/*     disregarded.                                                         */
/*  2. Endian: This code is LITTLE ENDIAN.                                  */
/*  3. Interruptibility: This code is interrupt tolerant but not            */
/*     interruptible.                                                       */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*      7*ceil(nx/6) + 31                                                   */
/*      For nx=60 cycles=101                                                */
/*      For nx=34 cycles=73                                                 */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*      640 bytes                                                           */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MINVAL_H_
#define DSPF_DP_MINVAL_H_ 1

double DSPF_dp_minval(
                const double* x,
                int nx
               );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_minval.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_minval./1117057391  3249  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_minval -- Minimum Element of Double Precision Vector             *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      15-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        double DSPF_dp_minval(                                                  *
*                        const double* x,                                   *
*                        int nx                                             *
*                       )                                                   *
*                                                                           *
*             x :  Pointer to Input array.                                  *
*             nx:  Number of Inputs in the input Array.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine finds out and returns the minimum number              *
*    in the input array.                                                    *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The loop is unrolled six times.                                  *
*       2. Six minimums are maintained in each iteration.                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. nx should be multiple of 2 and >= 2.                             *
*       2. NAN( Not a Number in Double Precision format) in the input are   *
*          disregarded.                                                     *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*       double DSPF_dp_minval(const double* x, int nx)                           *
*       {                                                                   *
*          int i;                                                           *
*          double min;                                                      *
*          *((int *)&min) = 0x00000000;                                     *
*          *((int *)&min+1) = 0x7ff00000;                                   *
*                                                                           *
*          for (i = 0; i < nx; i++)                                         *
*          if (x[i] < min)                                                  *
*          {                                                                *
*             min = x[i];                                                   *
*            }                                                              *
*                                                                           *
*          return min;                                                      *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*   1. NAN( Not a Number in Double Precision format) in the input are       *
*      disregarded.                                                         *
*   2. Endian: This code is LITTLE ENDIAN.                                  *
*   3. Interruptibility: This code is interrupt tolerant but not            *
*      interruptible.                                                       *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*       7*ceil(nx/6) + 31                                                   *
*       For nx=60 cycles=101                                                *
*       For nx=34 cycles=73                                                 *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*       640 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_minval

*  ======================================================================== *
*   End of file:  DSPF_dp_minval.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_vecreci/1117057392  3269  0     0       6942      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecrecip -- Double Precision vector reciprocal                   */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void  DSPF_dp_vecrecip(const double *x,                                  */
/*                        double * restrict r,                              */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*      The DSPF_dp_vecrecip module calculates the reciprocal of each element    */
/*  in the array x and returns the output in array r. It uses 3             */
/*  iterations of the Newton-Raphson method to improve the accuracy         */
/*  of the output generated by the RCPDP instruction of the C67x.           */
/*  Each iteration doubles the accuracy. The initial output generated       */
/*  by RCPDP is 8 bits.So after the first iteration it is 16 bits and       */
/*  after the second it is the  23 bits and after third it is full 52 bits. */
/*  The formula used is:                                                    */
/*                                                                          */
/*               r[n+1] = r[n](2 - v*r[n])                                  */
/*                                                                          */
/*      where v = the number whose reciprocal is to be found.               */
/*      x[0], the seed value for the algorithm, is given by RCPDP.          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled four times to allow calculation of    */
/*         four reciprocals in the kernel. However the stores are executed  */
/*         conditionally to allow 'n' to be any number > 0.                 */
/*                                                                          */
/*      2. Register sharing is used to make optimal use of available        */
/*         registers.                                                       */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. There are no alignment requirements.                             */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*      This is the C equivalent of the Assembly Code without               */
/*      restrictions.                                                       */
/*                                                                          */
/*    void DSPF_dp_vecrecip(const double* x, double* restrict r, int n)          */
/*    {                                                                     */
/*     int i;                                                               */
/*     for(i = 0; i < n; i++)                                               */
/*        r[i] = 1 / x[i];                                                  */
/*      }                                                                   */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*      1. Endian: This code is LITTLE ENDIAN.                              */
/*      2. Interruptibility: This code is interrupt tolerant                */
/*         but not interruptible.                                           */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     78*ceil(n/4) + 24                                                    */
/*     eg. for n = 54, cycles = 1116                                        */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*     448 bytes                                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECRECIP_H_
#define DSPF_DP_VECRECIP_H_ 1

void  DSPF_dp_vecrecip(const     double *x,
                  double * restrict r,
                  int n
                 );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecrecip.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_vecreci/1117057392  3289  0     0       7006      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecrecip -- Double Precision vector reciprocal                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void  DSPF_dp_vecrecip(const double *x,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       The DSPF_dp_vecrecip module calculates the reciprocal of each element    *
*   in the array x and returns the output in array r. It uses 3             *
*   iterations of the Newton-Raphson method to improve the accuracy         *
*   of the output generated by the RCPDP instruction of the C67x.           *
*   Each iteration doubles the accuracy. The initial output generated       *
*   by RCPDP is 8 bits.So after the first iteration it is 16 bits and       *
*   after the second it is the  23 bits and after third it is full 52 bits. *
*   The formula used is:                                                    *
*                                                                           *
*                r[n+1] = r[n](2 - v*r[n])                                  *
*                                                                           *
*       where v = the number whose reciprocal is to be found.               *
*       x[0], the seed value for the algorithm, is given by RCPDP.          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled four times to allow calculation of    *
*          four reciprocals in the kernel. However the stores are executed  *
*          conditionally to allow 'n' to be any number > 0.                 *
*                                                                           *
*       2. Register sharing is used to make optimal use of available        *
*          registers.                                                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. There are no alignment requirements.                             *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without               *
*       restrictions.                                                       *
*                                                                           *
*     void DSPF_dp_vecrecip(const double* x, double* restrict r, int n)          *
*     {                                                                     *
*      int i;                                                               *
*      for(i = 0; i < n; i++)                                               *
*         r[i] = 1 / x[i];                                                  *
*       }                                                                   *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*       1. Endian: This code is LITTLE ENDIAN.                              *
*       2. Interruptibility: This code is interrupt tolerant                *
*          but not interruptible.                                           *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      78*ceil(n/4) + 24                                                    *
*      eg. for n = 54, cycles = 1116                                        *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*      448 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecrecip

*  ======================================================================== *
*   End of file:  DSPF_dp_vecrecip.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_vecsum_/1117057393  3311  0     0       6101      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecsum_sq -- Double Precision sum of squares                     */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      double DSPF_dp_vecsum_sq(const double *x,                                */
/*                        int n                                             */
/*                       )                                                  */
/*                                                                          */
/*             x        :  Pointer to input array                           */
/*             n        :  Number of elements in array                      */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs a sum of squares of the elements of the      */
/*       array x and returns the sum.                                       */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*      1. The inner loop is unrolled twice. Hence, 2 registers are used    */
/*         to hold the sum of squares. ADDDPs are staggered.                */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. Since loads of 4 doubles beyond the array occur,                 */
/*         a pad must be provided.                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions. Note that the assembly code is hand optimized          */
/*     and restrictions may apply.                                          */
/*                                                                          */
/*     double DSPF_dp_vecsum_sq(const double *x,int n)                           */
/*     {                                                                    */
/*         int i;                                                           */
/*         double sum=0;                                                    */
/*                                                                          */
/*         for(i = 0;  i < n; i++ )                                         */
/*             sum += x[i]*x[i];                                            */
/*                                                                          */
/*         return sum;                                                      */
/*     }                                                                    */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*    1. Endian: This code is ENDIAN NEUTRAL.                               */
/*    2. Interruptibility: This code is interrupt tolerant                  */
/*                            but not interruptible.                        */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*    4*Ceil(n/2) + 33                                                      */
/*    eg. for n = 100, cycles = 233                                         */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*    288 bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECSUM_SQ_H_
#define DSPF_DP_VECSUM_SQ_H_ 1

double DSPF_dp_vecsum_sq(const     double *x,
                  int n
                 );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecsum_sq.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_vecsum_/1117057392  3332  0     0       6212      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecsum_sq -- Double Precision sum of squares                     *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      17-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       double DSPF_dp_vecsum_sq(const double *x,                                *
*                         int n                                             *
*                        )                                                  *
*                                                                           *
*              x        :  Pointer to input array                           *
*              n        :  Number of elements in array                      *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs a sum of squares of the elements of the      *
*        array x and returns the sum.                                       *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*       1. The inner loop is unrolled twice. Hence, 2 registers are used    *
*          to hold the sum of squares. ADDDPs are staggered.                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. Since loads of 4 doubles beyond the array occur,                 *
*          a pad must be provided.                                          *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions. Note that the assembly code is hand optimized          *
*      and restrictions may apply.                                          *
*                                                                           *
*      double DSPF_dp_vecsum_sq(const double *x,int n)                           *
*      {                                                                    *
*          int i;                                                           *
*          double sum=0;                                                    *
*                                                                           *
*          for(i = 0;  i < n; i++ )                                         *
*              sum += x[i]*x[i];                                            *
*                                                                           *
*          return sum;                                                      *
*      }                                                                    *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*     1. Endian: This code is ENDIAN NEUTRAL.                               *
*     2. Interruptibility: This code is interrupt tolerant                  *
*                             but not interruptible.                        *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*     4*Ceil(n/2) + 33                                                      *
*     eg. for n = 100, cycles = 233                                         *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     288 bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecsum_sq

*  ======================================================================== *
*   End of file:  DSPF_dp_vecsum_sq.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_w_vec.h/1117057394  0     0     0       6417      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_w_vec -- Double Precision weighted sum of vectors                */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*        void DSPF_dp_w_vec(const double* x,                                    */
/*                      const double* y,                                    */
/*                      double m,                                           */
/*                      double * restrict r,                                */
/*                      int     nr                                          */
/*                     )                                                    */
/*                                                                          */
/*             x    :  Pointer to first input array                         */
/*             y    :  Pointer to second input array                        */
/*             m    :  Weight factor                                        */
/*             r    :  Output array pointer                                 */
/*             nr   :  Number of elements in arrays                         */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*     This routine is used to obtain the weighted vector sum.              */
/*     Both the inputs and output are Double precision floating             */
/*     point numbers.                                                       */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*     1. The inner loop is unrolled twice.                                 */
/*                                                                          */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*      1. The value of nr must be > 0.                                     */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_dp_w_vec( const double * x,const double * y, double  m,         */
/*                    double * restrict r,int nr)                           */
/*                                                                          */
/*    {                                                                     */
/*        int i;                                                            */
/*        for (i = 0; i < nr; i++)                                          */
/*            r[i] = (m * x[i]) + y[i];                                     */
/*    }                                                                     */
/*                                                                          */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt tolerant but not          */
/*                         interruptible.                                   */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*     4*Ceil(n/2) + 32                                                     */
/*     eg. for n = 100, cycles = 232.                                       */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*    352 bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_W_VEC_H_
#define DSPF_DP_W_VEC_H_ 1

void DSPF_dp_w_vec(const     double* x,
              const double* y,
              double m,
              double * restrict r,
              int     nr
             );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_w_vec.h                                                */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_w_vec.h/1117057393  3355  0     0       6445      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_w_vec -- Double Precision weighted sum of vectors                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*         void DSPF_dp_w_vec(const double* x,                                    *
*                       const double* y,                                    *
*                       double m,                                           *
*                       double * restrict r,                                *
*                       int     nr                                          *
*                      )                                                    *
*                                                                           *
*              x    :  Pointer to first input array                         *
*              y    :  Pointer to second input array                        *
*              m    :  Weight factor                                        *
*              r    :  Output array pointer                                 *
*              nr   :  Number of elements in arrays                         *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*      This routine is used to obtain the weighted vector sum.              *
*      Both the inputs and output are Double precision floating             *
*      point numbers.                                                       *
*   TECHNIQUES                                                              *
*                                                                           *
*      1. The inner loop is unrolled twice.                                 *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*       1. The value of nr must be > 0.                                     *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_w_vec( const double * x,const double * y, double  m,         *
*                     double * restrict r,int nr)                           *
*                                                                           *
*     {                                                                     *
*         int i;                                                            *
*         for (i = 0; i < nr; i++)                                          *
*             r[i] = (m * x[i]) + y[i];                                     *
*     }                                                                     *
*                                                                           *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt tolerant but not          *
*                          interruptible.                                   *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*      4*Ceil(n/2) + 32                                                     *
*      eg. for n = 100, cycles = 232.                                       *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*     352 bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_w_vec

*  ======================================================================== *
*   End of file:  DSPF_dp_w_vec.h67                                              *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_vecmul./1117057395  3374  0     0       6570      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_vecmul -- Double Precision vector multiplication                 */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*      This routine is C callable, and has the following C prototype:      */
/*                                                                          */
/*      void DSPF_dp_vecmul   (const double *x,                                  */
/*                        const double *y,                                  */
/*                        double * restrict r,                              */
/*                        int n                                             */
/*                        )                                                 */
/*                                                                          */
/*             x        :  Pointer to first input array                     */
/*             y        :  Pointer to second input array                    */
/*             r        :  Pointer to output array                          */
/*             n        :  Number of elements in arrays                     */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*       This routine performs an element by element Double Precision       */
/*       floating point  multiplication of the vectors x[] and y[] and      */
/*       returns the values in r[].                                         */
/*                                                                          */
/*   TECHNIQUES                                                             */
/*                                                                          */
/*      1. The inner loop is unrolled twice to allow calculation of         */
/*         2 outputs in the kernel. However the stores are executed         */
/*         conditionally to allow 'n' to be any number > 0.                 */
/*                                                                          */
/*   ASSUMPTIONS                                                            */
/*                                                                          */
/*      1. The value of n > 0.                                              */
/*                                                                          */
/*                                                                          */
/*    C CODE                                                                */
/*                                                                          */
/*     This is the C equivalent of the Assembly Code without                */
/*     restrictions.                                                        */
/*                                                                          */
/*     void DSPF_dp_vecmul(const double * x, const double * y,                   */
/*                           double * restrict r, int n)                    */
/*      {                                                                   */
/*        int i;                                                            */
/*                                                                          */
/*        for(i = 0; i < n; i++)                                            */
/*             r[i] = x[i] * y[i];                                          */
/*                                                                          */
/*      }                                                                   */
/*                                                                          */
/*                                                                          */
/*    NOTES                                                                 */
/*                                                                          */
/*       1. Endian: This code is LITTLE ENDIAN.                             */
/*       2. Interruptibility: The code is interrupt tolerant but not        */
/*          interruptible.                                                  */
/*                                                                          */
/*    CYCLES                                                                */
/*                                                                          */
/*         4*Ceil(n/2) + 13                                                 */
/*         eg. for n = 100, cycles = 213                                    */
/*                                                                          */
/*    CODESIZE                                                              */
/*                                                                          */
/*         256 bytes                                                        */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_VECMUL_H_
#define DSPF_DP_VECMUL_H_ 1

void DSPF_dp_vecmul       (const double *x,
                  const double *y,
                  double * restrict r,
                  int n
                  );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_vecmul.h                                               */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_vecmul./1117057394  3392  0     0       6604      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_vecmul -- Double Precision vector multiplication                 *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       void DSPF_dp_vecmul   (const double *x,                                  *
*                         const double *y,                                  *
*                         double * restrict r,                              *
*                         int n                                             *
*                         )                                                 *
*                                                                           *
*              x        :  Pointer to first input array                     *
*              y        :  Pointer to second input array                    *
*              r        :  Pointer to output array                          *
*              n        :  Number of elements in arrays                     *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*        This routine performs an element by element Double Precision       *
*        floating point  multiplication of the vectors x[] and y[] and      *
*        returns the values in r[].                                         *
*                                                                           *
*    TECHNIQUES                                                             *
*                                                                           *
*       1. The inner loop is unrolled twice to allow calculation of         *
*          2 outputs in the kernel. However the stores are executed         *
*          conditionally to allow 'n' to be any number > 0.                 *
*                                                                           *
*    ASSUMPTIONS                                                            *
*                                                                           *
*       1. The value of n > 0.                                              *
*                                                                           *
*                                                                           *
*     C CODE                                                                *
*                                                                           *
*      This is the C equivalent of the Assembly Code without                *
*      restrictions.                                                        *
*                                                                           *
*      void DSPF_dp_vecmul(const double * x, const double * y,                   *
*                            double * restrict r, int n)                    *
*       {                                                                   *
*         int i;                                                            *
*                                                                           *
*         for(i = 0; i < n; i++)                                            *
*              r[i] = x[i] * y[i];                                          *
*                                                                           *
*       }                                                                   *
*                                                                           *
*                                                                           *
*     NOTES                                                                 *
*                                                                           *
*        1. Endian: This code is LITTLE ENDIAN.                             *
*        2. Interruptibility: The code is interrupt tolerant but not        *
*           interruptible.                                                  *
*                                                                           *
*     CYCLES                                                                *
*                                                                           *
*          4*Ceil(n/2) + 13                                                 *
*          eg. for n = 100, cycles = 213                                    *
*                                                                           *
*     CODESIZE                                                              *
*                                                                           *
*          256 bytes                                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_vecmul

*  ======================================================================== *
*   End of file:  DSPF_dp_vecmul.h67                                             *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_mul/1117057395  3412  0     0       8271      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*     This routine has following C prototype:                              */
/*     void DSPF_dp_mat_mul(double *x, int r1, int c1,                           */
/*                     double *y, int c2, double *r)                        */
/*                                                                          */
/*     x      : Pointer to r1 by c1 input matrix.                           */
/*     r1     : Number of rows in x.                                        */
/*     c1     : Number of columns in x.  Also number of rows in y.          */
/*     y      : Pointer to c1 by c2 input matrix.                           */
/*     c2     : Number of columns in y.                                     */
/*     r      : Pointer to r1 by c2 output matrix.                          */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*     This function computes the expression "r = x * y" for the matrices   */
/*     x and y.  The column dimension of x must match the row dimension     */
/*     of y.  The resulting matrix has the same number of rows as x and     */
/*     the same number of columns as y.                                     */
/*                                                                          */
/*     The values stored in the matrices are assumed to be Double           */
/*     precision floating point values.                                     */
/*                                                                          */
/*     This code is suitable for dense matrices.  No optimizations are      */
/*     made for sparse matrices.                                            */
/*                                                                          */
/* TECHNIQUES                                                               */
/*                                                                          */
/*     1.    All three loops are unrolled two times                         */
/*     2.    All the prolog stages of the innermost loop (kLoop) are        */
/*           Scheduled in Parallel with outer loop.                         */
/*     3.    Extraneous Loads are allowed in Program                        */
/*     4.    Outer most Loop Instructions are scheduled in Parallel with In *r
/*           Loop Instructions.                                                   */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*     1.    The arrays 'x', 'y', and 'r' are stored in distinct arrays.    */
/*           That is, in-place processing is not allowed.                   */
/*     2.    All r1, c1, c2 are assumed to be > 1                           */
/*     3.   If r1 is odd, one extra row of x[] matrix is loaded             */
/*     4.   If c2 is odd, one extra col of y[] matrix is loaded.            */
/*     5.   If c1 is odd, one extra col of x[] and  one extra row of        */
/*          y[] array is loaded                                             */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*    void DSPF_dp_mat_mul(double *x, int r1, int c1,                            */
/*                    double *y, int c2, double *r)                         */
/*    {                                                                     */
/*        int i, j, k;                                                      */
/*        double sum;                                                       */
/*                                                                          */
/*     //  Multiply each row in x by each column in y.                      */
/*     //  The product of row m in x and column n in y is placed            */
/*     //  in position (m,n) in the result.                                 */
/*                                                                          */
/*        for (i = 0; i < r1; i++)                                          */
/*            for (j = 0; j < c2; j++)                                      */
/*            {                                                             */
/*                sum = 0;                                                  */
/*                for (k = 0; k < c1; k++)                                  */
/*                    sum += x[k + i*c1] * y[j + k*c2];                     */
/*                                                                          */
/*                r[j + i*c2] = sum;                                        */
/*            }                                                             */
/*    }                                                                     */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*     1.   Endian: This code is LITTLE ENDIAN .                            */
/*     2.   Interruptibility: This code is interrupt-tolerant but not       */
/*          interruptible.                                                  */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*    (2 * r1' * c1 * c2') + 18*( c2'/2 * r1'/2) + 40                       */
/*    where                                                                 */
/*           r1' = r1 + (r1&1)                                              */
/*           c2' = c2 + (c2&1)                                              */
/*    For r1 = 12, c1 = 14 and c2 = 12,     cycles = 4720                   */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*    960 Bytes                                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_MUL_H_
#define DSPF_DP_MAT_MUL_H_ 1

void DSPF_dp_mat_mul(double     *x, int r1, int c1,
                double *y, int c2, double *r);

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_mul.h                                              */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_mat_mul/1117057395  3431  0     0       8350      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul -- Double Precision Matrix Multiplication                *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      18-Aug-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*      This routine has following C prototype:                              *
*      void DSPF_dp_mat_mul(double *x, int r1, int c1,                           *
*                      double *y, int c2, double *r)                        *
*                                                                           *
*      x      : Pointer to r1 by c1 input matrix.                           *
*      r1     : Number of rows in x.                                        *
*      c1     : Number of columns in x.  Also number of rows in y.          *
*      y      : Pointer to c1 by c2 input matrix.                           *
*      c2     : Number of columns in y.                                     *
*      r      : Pointer to r1 by c2 output matrix.                          *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*      This function computes the expression "r = x * y" for the matrices   *
*      x and y.  The column dimension of x must match the row dimension     *
*      of y.  The resulting matrix has the same number of rows as x and     *
*      the same number of columns as y.                                     *
*                                                                           *
*      The values stored in the matrices are assumed to be Double           *
*      precision floating point values.                                     *
*                                                                           *
*      This code is suitable for dense matrices.  No optimizations are      *
*      made for sparse matrices.                                            *
*                                                                           *
*  TECHNIQUES                                                               *
*                                                                           *
*      1.    All three loops are unrolled two times                         *
*      2.    All the prolog stages of the innermost loop (kLoop) are        *
*            Scheduled in Parallel with outer loop.                         *
*      3.    Extraneous Loads are allowed in Program                        *
*      4.    Outer most Loop Instructions are scheduled in Parallel with In *r
*            Loop Instructions.                                                   *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*      1.    The arrays 'x', 'y', and 'r' are stored in distinct arrays.    *
*            That is, in-place processing is not allowed.                   *
*      2.    All r1, c1, c2 are assumed to be > 1                           *
*      3.   If r1 is odd, one extra row of x[] matrix is loaded             *
*      4.   If c2 is odd, one extra col of y[] matrix is loaded.            *
*      5.   If c1 is odd, one extra col of x[] and  one extra row of        *
*           y[] array is loaded                                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*     void DSPF_dp_mat_mul(double *x, int r1, int c1,                            *
*                     double *y, int c2, double *r)                         *
*     {                                                                     *
*         int i, j, k;                                                      *
*         double sum;                                                       *
*                                                                           *
*      //  Multiply each row in x by each column in y.                      *
*      //  The product of row m in x and column n in y is placed            *
*      //  in position (m,n) in the result.                                 *
*                                                                           *
*         for (i = 0; i < r1; i++)                                          *
*             for (j = 0; j < c2; j++)                                      *
*             {                                                             *
*                 sum = 0;                                                  *
*                 for (k = 0; k < c1; k++)                                  *
*                     sum += x[k + i*c1] * y[j + k*c2];                     *
*                                                                           *
*                 r[j + i*c2] = sum;                                        *
*             }                                                             *
*     }                                                                     *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*      1.   Endian: This code is LITTLE ENDIAN .                            *
*      2.   Interruptibility: This code is interrupt-tolerant but not       *
*           interruptible.                                                  *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*     (2 * r1' * c1 * c2') + 18*( c2'/2 * r1'/2) + 40                       *
*     where                                                                 *
*            r1' = r1 + (r1&1)                                              *
*            c2' = c2 + (c2&1)                                              *
*     For r1 = 12, c1 = 14 and c2 = 12,     cycles = 4720                   *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*     960 Bytes                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_mul

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_mul.h67                                            *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_tra/1117057396  3452  0     0       6180      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_trans -- Double Precision matrix transpose                   */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_mat_trans(const double *restrict x,                        */
/*                         int rows,                                        */
/*                         int cols,                                        */
/*                         double *restrict r                               */
/*                         )                                                */
/*                                                                          */
/*          x       :  Input matrix containing rows*cols Double Precision   */
/*                     floating point numbers.                              */
/*          rows    :  No. of rows in matrix x.                             */
/*                     Also no. of columns in matrix r                      */
/*          cols    :  No. of columns in matrix x.                          */
/*                     Also no. of rows in matrix r.                        */
/*          r       :  Output matrix containing cols*rows Double Precision  */
/*                     floating point numbers.                              */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*    This function transposes the input matrix x[] and writes the          */
/*    result to matrix r[].                                                 */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*    1. The number of rows and columns is > 0.                             */
/*                                                                          */
/* C CODE                                                                   */
/*                                                                          */
/*       This is the C equivalent of the assembly code.  Note that          */
/*       the assembly code is hand optimized and restrictions may apply.    */
/*                                                                          */
/*       void DSPF_dp_mat_trans(const double *restrict x, int rows,              */
/*       int cols, double *restrict r)                                      */
/*       {                                                                  */
/*          int i,j;                                                        */
/*                                                                          */
/*          for(i=0; i<cols; i++)                                           */
/*             for(j=0; j<rows; j++)                                        */
/*                r[i * rows + j] = x[i + cols * j];                        */
/*       }                                                                  */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*    1. Endian: This code is LITTLE ENDIAN.                                */
/*    2. Interruptibility: This code is interrupt-tolerant but not          */
/*       interruptible.                                                     */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*      2 * rows * cols + 15                                                */
/*      For rows=10 and cols=20, cycles=415                                 */
/*      For rows=15 and cols=20, cycles=615                                 */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*      256  bytes                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_TRANS_H_
#define DSPF_DP_MAT_TRANS_H_ 1

void DSPF_dp_mat_trans(const     double *restrict x,
                  int rows,
                  int cols,
                  double *restrict r
                  );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_trans.h                                            */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_mat_tra/1117057396  3473  0     0       6212      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_trans -- Double Precision matrix transpose                   *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      22-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x,                        *
*                          int rows,                                        *
*                          int cols,                                        *
*                          double *restrict r                               *
*                          )                                                *
*                                                                           *
*           x       :  Input matrix containing rows*cols Double Precision   *
*                      floating point numbers.                              *
*           rows    :  No. of rows in matrix x.                             *
*                      Also no. of columns in matrix r                      *
*           cols    :  No. of columns in matrix x.                          *
*                      Also no. of rows in matrix r.                        *
*           r       :  Output matrix containing cols*rows Double Precision  *
*                      floating point numbers.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*     This function transposes the input matrix x[] and writes the          *
*     result to matrix r[].                                                 *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*     1. The number of rows and columns is > 0.                             *
*                                                                           *
*  C CODE                                                                   *
*                                                                           *
*        This is the C equivalent of the assembly code.  Note that          *
*        the assembly code is hand optimized and restrictions may apply.    *
*                                                                           *
*        void DSPF_dp_mat_trans(const double *restrict x, int rows,              *
*        int cols, double *restrict r)                                      *
*        {                                                                  *
*           int i,j;                                                        *
*                                                                           *
*           for(i=0; i<cols; i++)                                           *
*              for(j=0; j<rows; j++)                                        *
*                 r[i * rows + j] = x[i + cols * j];                        *
*        }                                                                  *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*     1. Endian: This code is LITTLE ENDIAN.                                *
*     2. Interruptibility: This code is interrupt-tolerant but not          *
*        interruptible.                                                     *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2 * rows * cols + 15                                                *
*       For rows=10 and cols=20, cycles=415                                 *
*       For rows=15 and cols=20, cycles=615                                 *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       256  bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_trans

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_trans.h67                                          *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *
DSPF_dp_mat_mul/1117057397  3496  0     0       9807      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    */
/*                                                                         */
/*  USAGE                                                                   */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_mat_mul_cplx(                                              */
/*                              const double* x,                            */
/*                              int r1,                                     */
/*                              int c1,                                     */
/*                              const double* y,                            */
/*                              int c2,                                     */
/*                              double* restrict r                          */
/*                           )                                              */
/*                                                                          */
/*            x[2*r1*c1]:   Input matrix containing r1*c1 complex           */
/*                          floating point numbers having r1 rows and c1    */
/*                          columns of complex numbers.                     */
/*            r1        :   No. of rows in matrix x.                        */
/*            c1        :   No. of columns in matrix x.                     */
/*                          Also no. of rows in matrix y.                   */
/*            y[2*c1*c2]:   Input matrix containing c1*c2 complex           */
/*                          floating point numbers having c1 rows and c2    */
/*                          columns of complex numbers.                     */
/*            c2        :   No. of columns in matrix y.                     */
/*            r[2*r1*c2]:   Output matrix of c1*c2 complex floating         */
/*                          point numbers having c1 rows and c2 columns of  */
/*                          complex numbers.                                */
/*                                                                          */
/*                          Complex numbers are stored consecutively with   */
/*                          real values stored in even positions and        */
/*                          imaginary values in odd positions.              */
/*                                                                          */
/*  DESCRIPTION                                                             */
/*                                                                          */
/*        This function computes the expression "r = x * y" for the         */
/*        matrices x and y. The columnar dimension of x must match the row  */
/*        dimension of y. The resulting matrix has the same number of rows  */
/*        as x and the same number of columns as y.                         */
/*                                                                          */
/*        Each element of the matrix is assumed to be complex numbers with  */
/*        Real values are stored in even positions and imaginary            */
/*        values in odd positions.                                          */
/*                                                                          */
/*  TECHNIQUES                                                              */
/*                                                                          */
/*        1. Innermost loop is unrolled twice.                              */
/*        2. Outermost loop is executed in parallel with innner loops.      */
/*                                                                          */
/*  ASSUMPTIONS                                                             */
/*                                                                          */
/*        1. r1,r2>=1,c1 should be a multiple of 2 and >=2.                 */
/*        2. x should be padded with 6 words                                */
/*                                                                          */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*   the assembly code is hand optimized and restrictions may apply.        */
/*                                                                          */
/*        void DSPF_dp_mat_mul_cplx(const double* x, int r1, int c1,             */
/*          const double* y, int c2, double* restrict r)                    */
/*        {                                                                 */
/*            double real, imag;                                            */
/*            int i, j, k;                                                  */
/*                                                                          */
/*            for(i = 0; i < r1; i++)                                       */
/*            {                                                             */
/*              for(j = 0; j < c2; j++)                                     */
/*              {                                                           */
/*                real=0;                                                   */
/*                imag=0;                                                   */
/*                                                                          */
/*                for(k = 0; k < c1; k++)                                   */
/*                {                                                         */
/*                real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j]                  */
/*                -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);              */
/*                                                                          */
/*                imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1]              */
/*                   + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);              */
/*                }                                                         */
/*                r[i*2*c2 + 2*j] = real;                                   */
/*                r[i*2*c2 + 2*j + 1] = imag;                               */
/*              }                                                           */
/*            }                                                             */
/*        }                                                                 */
/*                                                                          */
/*  NOTES                                                                   */
/*                                                                          */
/*        1. Real values are stored in even word positions and imaginary    */
/*           values in odd positions.                                       */
/*        2. Endian: This code is LITTLE ENDIAN.                            */
/*        3. Interruptibility: This code is interrupt tolerant but not      */
/*           interruptible.                                                 */
/*                                                                          */
/*  CYCLES                                                                  */
/*                                                                          */
/*        8*r1*c1*c2'+ 18*(r1*c2)+40 WHERE c2'=2*ceil(c2/2)                 */
/*        When r1=3, c1=4, c2=4, cycles = 640                               */
/*        When r1=4, c1=4, c2=5, cycles = 1040                              */
/*                                                                          */
/*  CODESIZE                                                                */
/*                                                                          */
/*        832 bytes                                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_MAT_MUL_CPLX_H_
#define DSPF_DP_MAT_MUL_CPLX_H_ 1

void DSPF_dp_mat_mul_cplx(
                       const double* x,
                       int r1,
                       int c1,
                       const double* y,
                       int c2,
                       double* restrict r
                    );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_mat_mul_cplx.h                                         */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */

DSPF_dp_mat_mul/1117057397  3520  0     0       9691      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_mat_mul_cplx -- Complex matrix multiplication                    *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      19-Sep-2003                                                         *
*                                                                          *
*   USAGE                                                                   *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_mat_mul_cplx(                                              *
*                               const double* x,                            *
*                               int r1,                                     *
*                               int c1,                                     *
*                               const double* y,                            *
*                               int c2,                                     *
*                               double* restrict r                          *
*                            )                                              *
*                                                                           *
*             x[2*r1*c1]:   Input matrix containing r1*c1 complex           *
*                           floating point numbers having r1 rows and c1    *
*                           columns of complex numbers.                     *
*             r1        :   No. of rows in matrix x.                        *
*             c1        :   No. of columns in matrix x.                     *
*                           Also no. of rows in matrix y.                   *
*             y[2*c1*c2]:   Input matrix containing c1*c2 complex           *
*                           floating point numbers having c1 rows and c2    *
*                           columns of complex numbers.                     *
*             c2        :   No. of columns in matrix y.                     *
*             r[2*r1*c2]:   Output matrix of c1*c2 complex floating         *
*                           point numbers having c1 rows and c2 columns of  *
*                           complex numbers.                                *
*                                                                           *
*                           Complex numbers are stored consecutively with   *
*                           real values stored in even positions and        *
*                           imaginary values in odd positions.              *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*         This function computes the expression "r = x * y" for the         *
*         matrices x and y. The columnar dimension of x must match the row  *
*         dimension of y. The resulting matrix has the same number of rows  *
*         as x and the same number of columns as y.                         *
*                                                                           *
*         Each element of the matrix is assumed to be complex numbers with  *
*         Real values are stored in even positions and imaginary            *
*         values in odd positions.                                          *
*                                                                           *
*   TECHNIQUES                                                              *
*                                                                           *
*         1. Innermost loop is unrolled twice.                              *
*         2. Outermost loop is executed in parallel with innner loops.      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*                                                                           *
*         1. r1,r2>=1,c1 should be a multiple of 2 and >=2.                 *
*         2. x should be padded with 6 words                                *
*                                                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*    the assembly code is hand optimized and restrictions may apply.        *
*                                                                           *
*         void DSPF_dp_mat_mul_cplx(const double* x, int r1, int c1,             *
*           const double* y, int c2, double* restrict r)                    *
*         {                                                                 *
*             double real, imag;                                            *
*             int i, j, k;                                                  *
*                                                                           *
*             for(i = 0; i < r1; i++)                                       *
*             {                                                             *
*               for(j = 0; j < c2; j++)                                     *
*               {                                                           *
*                 real=0;                                                   *
*                 imag=0;                                                   *
*                                                                           *
*                 for(k = 0; k < c1; k++)                                   *
*                 {                                                         *
*                 real += (x[i*2*c1 + 2*k]*y[k*2*c2 + 2*j]                  *
*                 -x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j + 1]);              *
*                                                                           *
*                 imag+=(x[i*2*c1 + 2*k] * y[k*2*c2 + 2*j + 1]              *
*                    + x[i*2*c1 + 2*k + 1] * y[k*2*c2 + 2*j]);              *
*                 }                                                         *
*                 r[i*2*c2 + 2*j] = real;                                   *
*                 r[i*2*c2 + 2*j + 1] = imag;                               *
*               }                                                           *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*   NOTES                                                                   *
*                                                                           *
*         1. Real values are stored in even word positions and imaginary    *
*            values in odd positions.                                       *
*         2. Endian: This code is LITTLE ENDIAN.                            *
*         3. Interruptibility: This code is interrupt tolerant but not      *
*            interruptible.                                                 *
*                                                                           *
*   CYCLES                                                                  *
*                                                                           *
*         8*r1*c1*c2'+ 18*(r1*c2)+40 WHERE c2'=2*ceil(c2/2)                 *
*         When r1=3, c1=4, c2=4, cycles = 640                               *
*         When r1=4, c1=4, c2=5, cycles = 1040                              *
*                                                                           *
*   CODESIZE                                                                *
*                                                                           *
*         832 bytes                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_mat_mul_cplx

*  ======================================================================== *
*   End of file:  DSPF_dp_mat_mul_cplx.h67                                       *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

DSPF_dp_blk_mov/1117057398  3546  0     0       5756      `
/* ======================================================================= */
/* TEXAS INSTRUMENTS, INC.                                                 */
/*                                                                         */
/* NAME                                                                    */
/*     DSPF_dp_blk_move -- DSPF_dp_blk_move                                          */
/*                                                                         */
/* USAGE                                                                    */
/*                                                                          */
/*       This routine has the following C prototype:                        */
/*                                                                          */
/*       void DSPF_dp_blk_move(                                                  */
/*                        const double *   x,                               */
/*                        double *restrict r,                               */
/*                        int nx                                            */
/*                       )                                                  */
/*                                                                          */
/*            x[nx]: Pointer to source data to be moved.                    */
/*            r[nx]: Pointer to destination array.                          */
/*            nx:    Number of floats to move.                              */
/*                                                                          */
/* DESCRIPTION                                                              */
/*                                                                          */
/*   This routine moves nx doubles from one memory location                 */
/*       pointed to by x to another pointed to by r.                        */
/*                                                                          */
/*                                                                          */
/* ASSUMPTIONS                                                              */
/*                                                                          */
/*       1. nx is greater than 0.                                           */
/*                                                                          */
/*  C CODE                                                                  */
/*                                                                          */
/*  This is the C equivalent of the assembly code.  Note that               */
/*  the assembly code is hand optimized and restrictions may apply.         */
/*                                                                          */
/*       void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     */
/*       {                                                                  */
/*           int i;                                                         */
/*           for (i = 0 ; i < nx; i++)                                      */
/*               r[i] = x[i];                                               */
/*       }                                                                  */
/*                                                                          */
/*                                                                          */
/* NOTES                                                                    */
/*                                                                          */
/*      1. Endian: This implementation is Little-Endian.                    */
/*      2. Interruptibility: This code is interrupt-tolerant but not        */
/*                           interruptible.                                 */
/*                                                                          */
/* CYCLES                                                                   */
/*                                                                          */
/*      2*nx+ 8                                                             */
/*      For nx=64, cycles=136.                                              */
/*      For nx=25, cycles=58.                                               */
/*                                                                          */
/* CODESIZE                                                                 */
/*                                                                          */
/*      96 bytes                                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
#ifndef DSPF_DP_BLK_MOVE_H_
#define DSPF_DP_BLK_MOVE_H_ 1

void DSPF_dp_blk_move(
                 const double *   x,
                 double *restrict r,
                 int nx
                );

#endif
/* ======================================================================== */
/*  End of file:  DSPF_dp_blk_move.h                                             */
/* ------------------------------------------------------------------------ */
/*            Copyright (c) 2004 Texas Instruments, Incorporated.           */
/*                           All Rights Reserved.                           */
/* ======================================================================== */
DSPF_dp_blk_mov/1117057398  3566  0     0       5821      `
* ======================================================================== *
*  TEXAS INSTRUMENTS, INC.                                                 *
*                                                                          *
*  NAME                                                                    *
*      DSPF_dp_blk_move -- DSPF_dp_blk_move                                          *
*                                                                          *
*                                                                          *
*  REVISION DATE                                                           *
*      23-Sep-2003                                                         *
*                                                                          *
*  USAGE                                                                    *
*                                                                           *
*        This routine has the following C prototype:                        *
*                                                                           *
*        void DSPF_dp_blk_move(                                                  *
*                         const double *   x,                               *
*                         double *restrict r,                               *
*                         int nx                                            *
*                        )                                                  *
*                                                                           *
*             x[nx]: Pointer to source data to be moved.                    *
*             r[nx]: Pointer to destination array.                          *
*             nx:    Number of floats to move.                              *
*                                                                           *
*  DESCRIPTION                                                              *
*                                                                           *
*    This routine moves nx doubles from one memory location                 *
*        pointed to by x to another pointed to by r.                        *
*                                                                           *
*                                                                           *
*  ASSUMPTIONS                                                              *
*                                                                           *
*        1. nx is greater than 0.                                           *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*   This is the C equivalent of the assembly code.  Note that               *
*   the assembly code is hand optimized and restrictions may apply.         *
*                                                                           *
*        void DSPF_dp_blk_move(const double * x, double *restrict r, int nx)     *
*        {                                                                  *
*            int i;                                                         *
*            for (i = 0 ; i < nx; i++)                                      *
*                r[i] = x[i];                                               *
*        }                                                                  *
*                                                                           *
*                                                                           *
*  NOTES                                                                    *
*                                                                           *
*       1. Endian: This implementation is Little-Endian.                    *
*       2. Interruptibility: This code is interrupt-tolerant but not        *
*                            interruptible.                                 *
*                                                                           *
*  CYCLES                                                                   *
*                                                                           *
*       2*nx+ 8                                                             *
*       For nx=64, cycles=136.                                              *
*       For nx=25, cycles=58.                                               *
*                                                                           *
*  CODESIZE                                                                 *
*                                                                           *
*       96 bytes                                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .global _DSPF_dp_blk_move

*  ======================================================================== *
*   End of file:  DSPF_dp_blk_move.h67                                           *
*  ------------------------------------------------------------------------ *
*             Copyright (c) 2004 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*  ======================================================================== *

